<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="调试与反调试"><meta name="keywords" content="frida"><meta name="author" content="J"><meta name="copyright" content="J"><title>调试与反调试 | 万物皆可逆向</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?a345f534c85363668f09d4d5c6a9ee81";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-111479568-4","auto"),ga("send","pageview")</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer="defer"></script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},hexoVersion:"4.2.1"}</script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#篇幅有限"><span class="toc-number">1.</span> <span class="toc-text">篇幅有限</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ANDROID调试检测技术汇总"><span class="toc-number">2.</span> <span class="toc-text">ANDROID调试检测技术汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-IDA调试端口检测"><span class="toc-number">2.0.1.</span> <span class="toc-text">1. IDA调试端口检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-调试器进程名检测"><span class="toc-number">2.0.2.</span> <span class="toc-text">2. 调试器进程名检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-父进程名检测"><span class="toc-number">2.0.3.</span> <span class="toc-text">3 父进程名检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-自身进程名检测"><span class="toc-number">2.0.4.</span> <span class="toc-text">4 自身进程名检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-apk线程检测"><span class="toc-number">2.0.5.</span> <span class="toc-text">5 apk线程检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-apk进程fd文件检测"><span class="toc-number">2.0.6.</span> <span class="toc-text">6 apk进程fd文件检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-安卓系统自带调试检测函数"><span class="toc-number">2.0.7.</span> <span class="toc-text">7 安卓系统自带调试检测函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ptrace检测"><span class="toc-number">2.0.8.</span> <span class="toc-text">8 ptrace检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-函数hash值检测"><span class="toc-number">2.0.9.</span> <span class="toc-text">9 函数hash值检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-断点指令检测"><span class="toc-number">2.0.10.</span> <span class="toc-text">10 断点指令检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-系统源码修改检测"><span class="toc-number">2.0.11.</span> <span class="toc-text">11 系统源码修改检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-单步调试陷阱"><span class="toc-number">2.0.12.</span> <span class="toc-text">12 单步调试陷阱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-利用IDA先截获信号特性的检测"><span class="toc-number">2.0.13.</span> <span class="toc-text">13 利用IDA先截获信号特性的检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-利用IDA解析缺陷反调试"><span class="toc-number">2.0.14.</span> <span class="toc-text">14 利用IDA解析缺陷反调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-五种代码执行时间检测"><span class="toc-number">2.0.15.</span> <span class="toc-text">15 五种代码执行时间检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-三种进程信息结构检测"><span class="toc-number">2.0.16.</span> <span class="toc-text">16 三种进程信息结构检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Inotify事件监控dump"><span class="toc-number">2.0.17.</span> <span class="toc-text">17 Inotify事件监控dump</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#Frida反反调试"><span class="toc-number">3.</span> <span class="toc-text">Frida反反调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#应用崩溃退出"><span class="toc-number">3.1.</span> <span class="toc-text">应用崩溃退出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#检测是否被调试"><span class="toc-number">3.2.</span> <span class="toc-text">检测是否被调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#frida检测"><span class="toc-number">3.3.</span> <span class="toc-text">frida检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#环境检测"><span class="toc-number">3.4.</span> <span class="toc-text">环境检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#端口检测"><span class="toc-number">3.5.</span> <span class="toc-text">端口检测</span></a></li></ol></li></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://onejane.gitee.io/picture/avatar.jpg"></div><div class="author-info__name text-center">J</div><div class="author-info__description text-center">逆向,爬虫</div><div class="follow-button"><a href="https://github.com/OneJane/" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">84</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">66</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://blog.csdn.net/welggy" target="_blank" rel="noopener">OneJane</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(http://onejane.gitee.io/picture/kali.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">万物皆可逆向</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i> <span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a></span></div><div id="post-info"><div id="post-title">调试与反调试</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-10-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/">安卓逆向</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">7.3k</span><span class="post-meta__separator">|</span><span>阅读时长: 37 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><div id="vip-container"><h1 id="篇幅有限"><a href="#篇幅有限" class="headerlink" title="篇幅有限"></a>篇幅有限</h1><p>完整内容及源码关注公众号：ReverseCode，发送 <strong>冲</strong></p><h1 id="ANDROID调试检测技术汇总"><a href="#ANDROID调试检测技术汇总" class="headerlink" title="ANDROID调试检测技术汇总"></a><strong>ANDROID调试检测技术汇总</strong></h1><h3 id="1-IDA调试端口检测"><a href="#1-IDA调试端口检测" class="headerlink" title="1. IDA调试端口检测"></a>1. IDA调试端口检测</h3><p>原理： 调试器远程调试时，会占用一些固定的端口号。</p><p>做法： 读取/proc/net/tcp，查找IDA远程调试所用的23946端口，若发现说明进程正在被IDA调试。 （也可以运行netstat -apn结果中搜索23946端口）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void CheckPort23946ByTcp()&#123; </span><br><span class="line">    FILE* pfile&#x3D;NULL; </span><br><span class="line">    char buf[0x1000]&#x3D;&#123;0&#125;; </span><br><span class="line">    &#x2F;&#x2F; 执行命令 </span><br><span class="line">    char* strCatTcp&#x3D; &quot;cat &#x2F;proc&#x2F;net&#x2F;tcp |grep :5D8A&quot;; </span><br><span class="line">    &#x2F;&#x2F;char* strNetstat&#x3D;&quot;netstat |grep :23946&quot;; </span><br><span class="line">    pfile&#x3D;popen(strCatTcp,&quot;r&quot;); </span><br><span class="line">    if(NULL&#x3D;&#x3D;pfile) &#123; </span><br><span class="line">        LOGA(&quot;CheckPort23946ByTcp popen打开命令失败!\n&quot;); </span><br><span class="line">        return; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取结果 </span><br><span class="line">    while(fgets(buf,sizeof(buf),pfile))  &#123; </span><br><span class="line">        &#x2F;&#x2F; 执行到这里，判定为调试状态 </span><br><span class="line">        LOGA(&quot;执行cat &#x2F;proc&#x2F;net&#x2F;tcp |grep :5D8A的结果:\n&quot;);         </span><br><span class="line">        LOGB(&quot;%s&quot;,buf); </span><br><span class="line">    &#125;&#x2F;&#x2F;while </span><br><span class="line">    pclose(pfile); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-调试器进程名检测"><a href="#2-调试器进程名检测" class="headerlink" title="2. 调试器进程名检测"></a>2. 调试器进程名检测</h3><p>原理：远程调试要在手机中运行android_server gdbserver gdb等进程。</p><p>做法： 遍历进程，查找固定的进程名，找到说明调试器在运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void SearchObjProcess() &#123; </span><br><span class="line">    FILE* pfile&#x3D;NULL; </span><br><span class="line">    char buf[0x1000]&#x3D;&#123;0&#125;; </span><br><span class="line">    &#x2F;&#x2F; 执行命令 </span><br><span class="line">    &#x2F;&#x2F;pfile&#x3D;popen(&quot;ps | awk &#39;&#123;print $9&#125;&#39;&quot;,&quot;r&quot;); &#x2F;&#x2F; 部分不支持awk命令     </span><br><span class="line">    pfile&#x3D;popen(&quot;ps&quot;,&quot;r&quot;); </span><br><span class="line">    if(NULL&#x3D;&#x3D;pfile) &#123; </span><br><span class="line">        LOGA(&quot;SearchObjProcess popen打开命令失败!\n&quot;); </span><br><span class="line">        return; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取结果 </span><br><span class="line">    LOGA(&quot;popen方案:\n&quot;); </span><br><span class="line">    while(fgets(buf,sizeof(buf),pfile)) &#123; </span><br><span class="line">        &#x2F;&#x2F; 打印进程 </span><br><span class="line">        LOGB(&quot;遍历进程:%s\n&quot;,buf); </span><br><span class="line">        &#x2F;&#x2F; 查找子串 </span><br><span class="line">        char* strA&#x3D;NULL,strB&#x3D;NULL,strC&#x3D;NULL,strD&#x3D;NULL; </span><br><span class="line">        strA&#x3D;strstr(buf,&quot;android_server&quot;); </span><br><span class="line">        strB&#x3D;strstr(buf,&quot;gdbserver&quot;); </span><br><span class="line">        strC&#x3D;strstr(buf,&quot;gdb&quot;); </span><br><span class="line">        strD&#x3D;strstr(buf,&quot;fuwu&quot;); </span><br><span class="line">        if(strA || strB ||strC || strD)  &#123; </span><br><span class="line">            &#x2F;&#x2F; 执行到这里，判定为调试状态 </span><br><span class="line">            LOGB(&quot;发现目标进程:%s\n&quot;,buf); </span><br><span class="line">        &#125;&#x2F;&#x2F;if </span><br><span class="line">    &#125;&#x2F;&#x2F;while </span><br><span class="line">    pclose(pfile); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-父进程名检测"><a href="#3-父进程名检测" class="headerlink" title="3 父进程名检测"></a>3 父进程名检测</h3><p>原理： 有的时候不使用apk附加调试的方法进行逆向，而是写一个.out可执行文件直接加载so进行 调试，这样程序的父进程名和正常启动apk的父进程名是不一样的。</p><p>测试发现：</p><p>（1）正常启动的apk程序：父进程是zygote</p><p>（2）调试启动的apk程序：在AS中用LLDB调试发现父进程还是zygote</p><p>（3）附加调试的apk程序：父进程是zygote</p><p>（4）vs远程调试 用可执行文件加载so:父进程名为gdbserver 结论：父进程名非zygote的，判定为调试状态。</p><p>读取/proc/pid/cmdline，查看内容是否为zygote</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void CheckParents() </span><br><span class="line">&#123; </span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; </span><br><span class="line">    &#x2F;&#x2F; 设置buf </span><br><span class="line">    char strPpidCmdline[0x100]&#x3D;&#123;0&#125;; </span><br><span class="line">    snprintf(strPpidCmdline, sizeof(strPpidCmdline), &quot;&#x2F;proc&#x2F;%d&#x2F;cmdl ine&quot;, getppid()); </span><br><span class="line">    &#x2F;&#x2F; 打开文件 </span><br><span class="line">    int file&#x3D;open(strPpidCmdline,O_RDONLY); </span><br><span class="line">    if(file&lt;0) &#123; </span><br><span class="line">        LOGA(&quot;CheckParents open错误!\n&quot;); </span><br><span class="line">        return; </span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;&#x2F; 文件内容读入内存 </span><br><span class="line">    memset(strPpidCmdline,0,sizeof(strPpidCmdline)); </span><br><span class="line">    ssize_t ret&#x3D;read(file,strPpidCmdline,sizeof(strPpidCmdline));     </span><br><span class="line">    if(-1&#x3D;&#x3D;ret) &#123; </span><br><span class="line">        LOGA(&quot;CheckParents read错误!\n&quot;); </span><br><span class="line">        return; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 没找到返回0 </span><br><span class="line">    char sRet&#x3D;strstr(strPpidCmdline,&quot;zygote&quot;); </span><br><span class="line">    if(NULL&#x3D;&#x3D;sRet)  &#123; </span><br><span class="line">        &#x2F;&#x2F; 执行到这里，判定为调试状态 </span><br><span class="line">        LOGA(&quot;父进程cmdline没有zygote子串!\n&quot;); </span><br><span class="line">        return; </span><br><span class="line">    &#125; </span><br><span class="line">    int i&#x3D;0; </span><br><span class="line">    return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-自身进程名检测"><a href="#4-自身进程名检测" class="headerlink" title="4 自身进程名检测"></a>4 自身进程名检测</h3><p>原理： 和上条一样，也是写个.out加载so来脱壳的场景， 正常进程名一般是apk的com.xxx这样的格式。</p><p>代码： 略</p><h3 id="5-apk线程检测"><a href="#5-apk线程检测" class="headerlink" title="5 apk线程检测"></a>5 apk线程检测</h3><p>原理：</p><p>同样.out加载so来脱壳的场景， 正常apk进程一般会有十几个线程在运行(比如会有jdwp线程)， 自己写可执行文件加载so一般只有一个线程， 可以根据这个差异来进行调试环境检测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void CheckTaskCount()</span><br><span class="line">&#123; </span><br><span class="line">    char  buf[0x100]&#x3D;&#123;0&#125;; </span><br><span class="line">    char* str&#x3D;&quot;&#x2F;proc&#x2F;%d&#x2F;task&quot;; </span><br><span class="line">    snprintf(buf,sizeof(buf),str,getpid()); </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 打开目录: </span><br><span class="line">    DIR* pdir &#x3D; opendir(buf); </span><br><span class="line">    if (!pdir)  &#123; </span><br><span class="line">        perror(&quot;CheckTaskCount open() fail.\n&quot;); </span><br><span class="line">        return; </span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;&#x2F; 查看目录下文件个数: </span><br><span class="line">    struct dirent* pde&#x3D;NULL; </span><br><span class="line">    int Count&#x3D;0; </span><br><span class="line">    while ((pde &#x3D; readdir(pdir))) &#123; </span><br><span class="line">        &#x2F;&#x2F; 字符过滤 </span><br><span class="line">        if ((pde-&gt;d_name[0] &lt;&#x3D; &#39;9&#39;) &amp;&amp; (pde-&gt;d_name[0] &gt;&#x3D; &#39;0&#39;))  &#123; </span><br><span class="line">            ++Count; </span><br><span class="line">            LOGB(&quot;%d 线程名称:%s\n&quot;,Count,pde-&gt;d_name); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    LOGB(&quot;线程个数为：%d&quot;,Count); </span><br><span class="line">    if(1&gt;&#x3D;Count)  &#123; </span><br><span class="line">        &#x2F;&#x2F; 此处判定为调试状态. </span><br><span class="line">        LOGA(&quot;调试状态!\n&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">    int i&#x3D;0; </span><br><span class="line">    return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-apk进程fd文件检测"><a href="#6-apk进程fd文件检测" class="headerlink" title="6 apk进程fd文件检测"></a>6 apk进程fd文件检测</h3><p>原理： 根据/proc/pid/fd/路径下文件的个数差异，判断进程状态。 （apk启动的进程和非apk启动的进程fd数量不一样） （apk的debug启动和正常启动，进程fd数量也不一样）</p><p>代码： 略</p><h3 id="7-安卓系统自带调试检测函数"><a href="#7-安卓系统自带调试检测函数" class="headerlink" title="7 安卓系统自带调试检测函数"></a>7 安卓系统自带调试检测函数</h3><p>// android.os.Debug.isDebuggerConnected();</p><p>原理： 分析android自带调试检测函数isDebuggerConnected()在native的实现， 尝试在native使用。</p><p>做法：</p><p>（1）dalvik模式下: 找到进程中libdvm.so中的dvmDbgIsDebuggerConnected()函数， 调用他就能得知程序是否被调试。</p><p>dlopen(/system/lib/libdvm.so) dlsym(_Z25dvmDbgIsDebuggerConnectedv)</p><p>（2）art模式下： art模式下，结果存放在libart.so中的全局变量gDebuggerActive中， 符号名为_ZN3art3Dbg15gDebuggerActiveE。 但是貌似新版本android不允许使用非ndk原生库，dlopen(libart.so)会失败。 所以无法用dalvik那样的方法了。 有一种麻烦的方法，手动在内存中搜索libart模块，然后手工寻找该全局变量符号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 只写了dalvik的代码，art的就不写了 </span><br><span class="line">typedef unsigned char wbool; </span><br><span class="line">typedef  wbool (*PPP)(); </span><br><span class="line"></span><br><span class="line">void NativeIsDBGConnected() </span><br><span class="line">&#123; </span><br><span class="line">    void* Handle&#x3D;NULL; </span><br><span class="line">    Handle&#x3D;dlopen(&quot;&#x2F;system&#x2F;lib&#x2F;libdvm.so&quot;, RTLD_LAZY); </span><br><span class="line">    if(NULL&#x3D;&#x3D;Handle) &#123; </span><br><span class="line">        LOGA(&quot;dlopen打开libdvm.so失败!\n&quot;); </span><br><span class="line">        return; </span><br><span class="line">    &#125; </span><br><span class="line">    PPP Fun &#x3D; (PPP)dlsym(Handle, &quot;_Z25dvmDbgIsDebuggerConnectedv&quot;);   </span><br><span class="line">    if(NULL&#x3D;&#x3D;Fun)  &#123; </span><br><span class="line">        LOGA(&quot;dlsym获取_Z25dvmDbgIsDebuggerConnectedv失败!\n&quot;); </span><br><span class="line">        return; </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        wbool ret &#x3D; Fun(); </span><br><span class="line">        if(1&#x3D;&#x3D;ret) &#123; </span><br><span class="line">            &#x2F;&#x2F; 此处判定为调试模式 </span><br><span class="line">            LOGA(&quot;dalvikm模式，调试状态!\n&quot;); </span><br><span class="line">            return; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-ptrace检测"><a href="#8-ptrace检测" class="headerlink" title="8 ptrace检测"></a>8 ptrace检测</h3><p>原理： 每个进程同时刻只能被1个调试进程ptrace，再次p自己会失败。</p><p>做法：</p><p>1 主动ptrace自己,根据返回值判断自己是否被调试了。</p><p>2 或者多进程ptrace。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单线程ptrace </span><br><span class="line">void ptraceCheck() </span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; ptrace如果被调试返回值为-1，如果正常运行，返回值为0     int iRet&#x3D;ptrace(PTRACE_TRACEME, 0, 0, 0); </span><br><span class="line">    if(-1 &#x3D;&#x3D; iRet)  &#123; </span><br><span class="line">        LOGA(&quot;ptrace失败，进程正在被调试\n&quot;); </span><br><span class="line">        return; </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        LOGB(&quot;ptrace的返回值为:%d\n&quot;,iRet);</span><br><span class="line">        return; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-函数hash值检测"><a href="#9-函数hash值检测" class="headerlink" title="9 函数hash值检测"></a>9 函数hash值检测</h3><p>原理： so文件中函数的指令是固定，但是如果被下了软件断点，指令就会发生改变(断点地址被改 写为bkpt断点指令)，可以计算内存中一段指令的hash值进行校验，检测函数是否被修改或 被下断点。</p><p>代码： 略</p><h3 id="10-断点指令检测"><a href="#10-断点指令检测" class="headerlink" title="10 断点指令检测"></a>10 断点指令检测</h3><p>原理： 上面说了，如果函数被下软件断点，则断点地址会被改写为bkpt指令， 可以在函数体中搜索bkpt指令来检测软件断点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; IDA 6.8 断点扫描 </span><br><span class="line">&#x2F;&#x2F; 参数1：函数首地址 参数2：函数size </span><br><span class="line">typedef uint8_t u8; </span><br><span class="line">typedef uint32_t u32; </span><br><span class="line"></span><br><span class="line">void checkbkpt(u8* addr,u32 size)&#123; </span><br><span class="line">    &#x2F;&#x2F; 结果 </span><br><span class="line">    u32 uRet&#x3D;0; </span><br><span class="line">    &#x2F;&#x2F; 断点指令 </span><br><span class="line">&#x2F;&#x2F;    u8 armBkpt[4]&#x3D;&#123;0xf0,0x01,0xf0,0xe7&#125;; </span><br><span class="line">&#x2F;&#x2F;    u8 thumbBkpt[2]&#x3D;&#123;0x10,0xde&#125;; </span><br><span class="line">    u8 armBkpt[4]&#x3D;&#123;0&#125;; </span><br><span class="line">    armBkpt[0]&#x3D;0xf0; </span><br><span class="line">    armBkpt[1]&#x3D;0x01; </span><br><span class="line">    armBkpt[2]&#x3D;0xf0; </span><br><span class="line">    armBkpt[3]&#x3D;0xe7; </span><br><span class="line">    u8 thumbBkpt[2]&#x3D;&#123;0&#125;; </span><br><span class="line">    thumbBkpt[0]&#x3D;0x10; </span><br><span class="line">    thumbBkpt[1]&#x3D;0xde; </span><br><span class="line">    &#x2F;&#x2F; 判断模式 </span><br><span class="line">    int mode&#x3D;(u32)addr%2; </span><br><span class="line">    if(1&#x3D;&#x3D;mode) &#123; </span><br><span class="line">        LOGA(&quot;checkbkpt:(thumb mode)该地址为thumb模式\n&quot;); </span><br><span class="line">        u8* start&#x3D;(u8*)((u32)addr-1); </span><br><span class="line">        u8* end&#x3D;(u8*)((u32)start+size); </span><br><span class="line">        &#x2F;&#x2F; 遍历对比 </span><br><span class="line">        while(1)  &#123; </span><br><span class="line">            if(start &gt;&#x3D; end) &#123; </span><br><span class="line">                uRet&#x3D;0; </span><br><span class="line">                LOGA(&quot;checkbkpt:(no find bkpt)没有发现断点.\n&quot;);                 </span><br><span class="line">                break; </span><br><span class="line">            &#125; </span><br><span class="line">            if( 0&#x3D;&#x3D;memcmp(start,thumbBkpt,2) ) &#123; </span><br><span class="line">                uRet&#x3D;1; </span><br><span class="line">                LOGA(&quot;checkbkpt:(find it)发现断点.\n&quot;); </span><br><span class="line">                break; </span><br><span class="line">            &#125; </span><br><span class="line">            start&#x3D;start+2; </span><br><span class="line">        &#125;&#x2F;&#x2F;while </span><br><span class="line">    &#125;&#x2F;&#x2F;if </span><br><span class="line">    else  &#123; </span><br><span class="line">        LOGA(&quot;checkbkpt:(arm mode)该地址为arm模式\n&quot;); </span><br><span class="line">        u8* start&#x3D;(u8*)addr; </span><br><span class="line">        u8* end&#x3D;(u8*)((u32)start+size); </span><br><span class="line">        &#x2F;&#x2F; 遍历对比 </span><br><span class="line">        while(1)   &#123; </span><br><span class="line">            if (start &gt;&#x3D; end) &#123; </span><br><span class="line">                uRet &#x3D; 0; </span><br><span class="line">                LOGA(&quot;checkbkpt:(no find)没有发现断点.\n&quot;);                 </span><br><span class="line">                break; </span><br><span class="line">            &#125; </span><br><span class="line">            if (0 &#x3D;&#x3D; memcmp(start,armBkpt , 4))&#123; </span><br><span class="line">                uRet &#x3D; 1; </span><br><span class="line">                LOGA(&quot;checkbkpt:(find it)发现断点.\n&quot;); </span><br><span class="line">                break; </span><br><span class="line">            &#125; </span><br><span class="line">            start &#x3D; start + 4; </span><br><span class="line">        &#125;&#x2F;&#x2F;while </span><br><span class="line">    &#125;&#x2F;&#x2F;else </span><br><span class="line">    return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-系统源码修改检测"><a href="#11-系统源码修改检测" class="headerlink" title="11 系统源码修改检测"></a>11 系统源码修改检测</h3><p>原理： 安卓native下最流行的反调试方案是读取进程的status或stat来检测tracepid，原理是调试状 态下的进程tracepid不为0。</p><p>对于这种调试检测手段，最彻底的绕过方式是修改系统源码后重新编译，让tracepid永远为 0。</p><p>对抗这种bypass手段，我们可以创建一个子进程，让子进程主动ptrace自身设为调试状态， 此时正常情况下，子进程的tracepid应该不为0。此时我们检测子进程的tracepid是否为0， 如果为0说明源码被修改了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">bool checkSystem() </span><br><span class="line">&#123; </span><br><span class="line">    &#x2F;&#x2F; 建立管道 </span><br><span class="line">    int pipefd[2]; </span><br><span class="line">    if (-1 &#x3D;&#x3D; pipe(pipefd)) &#123; </span><br><span class="line">        LOGA(&quot;pipe() error.\n&quot;); </span><br><span class="line">        return false; </span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;&#x2F; 创建子进程 </span><br><span class="line">    pid_t pid &#x3D; fork(); </span><br><span class="line">    LOGB(&quot;father pid is: %d\n&quot;,getpid()); </span><br><span class="line">    LOGB(&quot;child  pid is: %d\n&quot;,pid); </span><br><span class="line">    &#x2F;&#x2F; for失败 </span><br><span class="line">    if(0 &gt; pid) &#123; </span><br><span class="line">        LOGA(&quot;fork() error.\n&quot;); </span><br><span class="line">        return false; </span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;&#x2F; 子进程程序 </span><br><span class="line">    int childTracePid&#x3D;0; </span><br><span class="line">    if ( 0 &#x3D;&#x3D; pid ) &#123; </span><br><span class="line">        int iRet &#x3D; ptrace(PTRACE_TRACEME, 0, 0, 0); </span><br><span class="line">        if (-1 &#x3D;&#x3D; iRet) &#123; </span><br><span class="line">            LOGA(&quot;child ptrace failed.\n&quot;); </span><br><span class="line">            exit(0); </span><br><span class="line">        &#125; </span><br><span class="line">        LOGA(&quot;%s ptrace succeed.\n&quot;); </span><br><span class="line">        &#x2F;&#x2F; 获取tracepid </span><br><span class="line">        char pathbuf[0x100] &#x3D; &#123;0&#125;; </span><br><span class="line">        char readbuf[100] &#x3D; &#123;0&#125;; </span><br><span class="line">        sprintf(pathbuf, &quot;&#x2F;proc&#x2F;%d&#x2F;status&quot;, getpid()); </span><br><span class="line">        int fd &#x3D; openat(NULL, pathbuf, O_RDONLY); </span><br><span class="line">        if (-1 &#x3D;&#x3D; fd) &#123; </span><br><span class="line">            LOGA(&quot;openat failed.\n&quot;); </span><br><span class="line">        &#125; </span><br><span class="line">        read(fd, readbuf, 100); </span><br><span class="line">        close(fd); </span><br><span class="line">        uint8_t *start &#x3D; (uint8_t *) readbuf; </span><br><span class="line">        uint8_t des[100] &#x3D; &#123;0x54, 0x72, 0x61, 0x63, 0x65, 0x72, 0x5 0, 0x69, 0x64, 0x3A,0x09&#125;; </span><br><span class="line">        int i   &#x3D; 100; </span><br><span class="line">        bool flag&#x3D; false; </span><br><span class="line">        while (--i) &#123; </span><br><span class="line">            if( 0&#x3D;&#x3D;memcmp(start,des,10)) &#123; </span><br><span class="line">                start&#x3D;start+11; </span><br><span class="line">                childTracePid&#x3D;atoi((char*)start); </span><br><span class="line">                flag&#x3D; true; </span><br><span class="line">                break; </span><br><span class="line">            &#125;else &#123; </span><br><span class="line">                start&#x3D;start+1; </span><br><span class="line">                flag&#x3D; false; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;&#x2F;&#x2F;while </span><br><span class="line">        if(false&#x3D;&#x3D;flag) &#123; </span><br><span class="line">            LOGA(&quot;get tracepid failed.\n&quot;); </span><br><span class="line">            return false; </span><br><span class="line">        &#125; </span><br><span class="line">        &#x2F;&#x2F; 向管道写入数据 </span><br><span class="line">        close(pipefd[0]);                           &#x2F;&#x2F; 关闭管道读端 </span><br><span class="line">        write(pipefd[1], (void*)&amp;childTracePid,4);  &#x2F;&#x2F; 向管道写端写入 数据 </span><br><span class="line">        close(pipefd[1]);                           &#x2F;&#x2F; 写完关闭管道写 端 </span><br><span class="line">        LOGA(&quot;child succeed, Finish.\n&quot;); </span><br><span class="line">        exit(0); </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        &#x2F;&#x2F; 父进程程序 </span><br><span class="line">        LOGA(&quot;开始等待子进程.\n&quot;); </span><br><span class="line">        waitpid(pid,NULL,NULL);                         &#x2F;&#x2F; 等待子进程 结束 </span><br><span class="line">        int buf2 &#x3D; 0; </span><br><span class="line">        close(pipefd[1]);                               &#x2F;&#x2F; 关闭写端 </span><br><span class="line">        read(pipefd[0], (void*)&amp;buf2, 4);               &#x2F;&#x2F; 从读端读取 数据到buf </span><br><span class="line">        close(pipefd[0]);                               &#x2F;&#x2F; 关闭读端 </span><br><span class="line">        LOGB(&quot;子进程传递的内容为:%d\n&quot;, buf2);               &#x2F;&#x2F; 输出内容         &#x2F;&#x2F; 判断子进程ptarce后的tracepid </span><br><span class="line">        if(0 &#x3D;&#x3D; buf2) &#123; </span><br><span class="line">            LOGA(&quot;源码被修改了.\n&quot;); </span><br><span class="line">        &#125;else&#123; </span><br><span class="line">            LOGA(&quot;源码没有被修改.\n&quot;); </span><br><span class="line">        &#125; </span><br><span class="line">        return true; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void smain() </span><br><span class="line">&#123; </span><br><span class="line">    bool bRet&#x3D;checkSystem(); </span><br><span class="line">    if(true&#x3D;&#x3D;bRet) </span><br><span class="line">        LOGA(&quot;check succeed.\n&quot;); </span><br><span class="line">    else </span><br><span class="line">        LOGA(&quot;check failed.\n&quot;); </span><br><span class="line">    LOGB(&quot;main Finish pid:%d\n&quot;,getpid());     return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-单步调试陷阱"><a href="#12-单步调试陷阱" class="headerlink" title="12 单步调试陷阱"></a>12 单步调试陷阱</h3><p>原理：调试器从下断点到执行断点的过程分析：</p><ul><li>1 保存：保存目标处指令</li><li>2 替换：目标处指令替换为断点指令</li><li>3 命中断点：命中断点指令(引发中断 或者说发出信号)</li><li>4 收到信号：调试器收到信号后，执行调试器注册的信号处理函数。 5 恢复：调试器处理函数恢复保存的指令</li><li>6 回退：回退PC寄存器</li><li>7 控制权回归程序.</li></ul><p>主动设置断点指令/注册信号处理函数的反调试方案:</p><ul><li>1 在函数中写入断点指令</li><li>2 在代码中注册断点信号处理函数</li><li>3 程序执行到断点指令，发出信号</li></ul><p>分两种情况：</p><p>(1)非调试状态 进入自己注册的函数，NOP指令替换断点指令，回退PC后正常指令。 (执行断点发出信号—进入处理信号函数—NOP替换断点—退回PC)</p><p>(2)调试状态 进入调试器的断点处理流程，他会恢复目标处指令失败，然后回退PC，进入死循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#!cpp </span><br><span class="line"></span><br><span class="line">char dynamic_ccode[] &#x3D; &#123;0x1f,0xb4, &#x2F;&#x2F;push &#123;r0-r4&#125;                         </span><br><span class="line">                        0x01,0xde, &#x2F;&#x2F;breakpoint </span><br><span class="line">                        0x1f,0xbc, &#x2F;&#x2F;pop &#123;r0-r4&#125;                         </span><br><span class="line">                        0xf7,0x46&#125;;&#x2F;&#x2F;mov pc,lr </span><br><span class="line"></span><br><span class="line">char *g_addr &#x3D; 0; </span><br><span class="line"></span><br><span class="line">void my_sigtrap(int sig)&#123; </span><br><span class="line">    char change_bkp[] &#x3D; &#123;0x00,0x46&#125;; &#x2F;&#x2F;mov r0,r0 </span><br><span class="line">    memcpy(g_addr+2,change_bkp,2); </span><br><span class="line">    __clear_cache((void*)g_addr,(void*)(g_addr+8)); &#x2F;&#x2F; need to clea r cache </span><br><span class="line">    LOGI(&quot;chang bpk to nop\n&quot;); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void anti4()&#123;&#x2F;&#x2F;SIGTRAP </span><br><span class="line">    int ret,size; </span><br><span class="line">    char *addr,*tmpaddr; </span><br><span class="line">    signal(SIGTRAP,my_sigtrap); </span><br><span class="line">    addr &#x3D; (char*)malloc(PAGESIZE*2); </span><br><span class="line">    memset(addr,0,PAGESIZE*2); </span><br><span class="line">    g_addr &#x3D; (char *)(((int) addr + PAGESIZE-1) &amp; ~(PAGESIZE-1)); </span><br><span class="line">    LOGI(&quot;addr: %p ,g_addr : %p\n&quot;,addr,g_addr); </span><br><span class="line">    ret &#x3D; mprotect(g_addr,PAGESIZE,PROT_READ|PROT_WRITE|PROT_EXEC);     </span><br><span class="line">    if(ret!&#x3D;0) &#123; </span><br><span class="line">        LOGI(&quot;mprotect error\n&quot;); </span><br><span class="line">        return ; </span><br><span class="line">    &#125; </span><br><span class="line">    size &#x3D; 8;</span><br><span class="line">    memcpy(g_addr,dynamic_ccode,size); </span><br><span class="line">    __clear_cache((void*)g_addr,(void*)(g_addr+size)); &#x2F;&#x2F; need to c lear cache </span><br><span class="line">    __asm__(&quot;push &#123;r0-r4,lr&#125;\n\t&quot; </span><br><span class="line">            &quot;mov r0,pc\n\t&quot;  &#x2F;&#x2F;此时pc指向后两条指令 </span><br><span class="line">            &quot;add r0,r0,#4\n\t&quot;&#x2F;&#x2F;+4 是的lr 地址为 pop&#123;r0-r5&#125; </span><br><span class="line">            &quot;mov lr,r0\n\t&quot; </span><br><span class="line">            &quot;mov pc,%0\n\t&quot; </span><br><span class="line">            &quot;pop &#123;r0-r5&#125;\n\t&quot; </span><br><span class="line">            &quot;mov lr,r5\n\t&quot; &#x2F;&#x2F;恢复lr    </span><br><span class="line">            : </span><br><span class="line">            :&quot;r&quot;(g_addr) </span><br><span class="line">            :); </span><br><span class="line"></span><br><span class="line">    LOGI(&quot;hi, i&#39;m here\n&quot;); free(addr); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-利用IDA先截获信号特性的检测"><a href="#13-利用IDA先截获信号特性的检测" class="headerlink" title="13 利用IDA先截获信号特性的检测"></a>13 利用IDA先截获信号特性的检测</h3><p>原理： IDA会首先截获信号，导致进程无法接收到信号，导致不会执行信号处理函数。将关键流程 放在信号处理函数中，如果没有执行，就是被调试状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;signal.h&gt; </span><br><span class="line">#include &lt;unistd.h&gt; </span><br><span class="line">void myhandler(int sig) &#123; </span><br><span class="line">    &#x2F;&#x2F;signal(5, myhandler); </span><br><span class="line">    printf(&quot;myhandler.\n&quot;); </span><br><span class="line">    return; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int g_ret &#x3D; 0; </span><br><span class="line">int main(int argc, char **argv) &#123; </span><br><span class="line">    &#x2F;&#x2F; 设置SIGTRAP信号的处理函数为myhandler() </span><br><span class="line">    g_ret &#x3D; (int)signal(SIGTRAP, myhandler); </span><br><span class="line">    if ( (int)SIG_ERR &#x3D;&#x3D; g_ret ) &#123;</span><br><span class="line">        printf(&quot;signal ret value is SIG_ERR.\n&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    &#x2F;&#x2F; 打印signal的返回值(原处理函数地址) </span><br><span class="line">    printf(&quot;signal ret value is %x\n&quot;,(unsigned char*)g_ret); </span><br><span class="line">    &#x2F;&#x2F; 主动给自己进程发送SIGTRAP信号 raise(SIGTRAP); raise(SIGTRAP); raise(SIGTRAP); </span><br><span class="line">    kill(getpid(), SIGTRAP); </span><br><span class="line">    printf(&quot;main.\n&quot;);     </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-利用IDA解析缺陷反调试"><a href="#14-利用IDA解析缺陷反调试" class="headerlink" title="14 利用IDA解析缺陷反调试"></a>14 利用IDA解析缺陷反调试</h3><p>原理： IDA采用递归下降算法来反汇编指令，而该算法最大的缺点在于它无法处理间接代码路径， 无法识别动态算出来的跳转。而arm架构下由于存在arm和thumb指令集，就涉及到指令集 切换，IDA在某些情况下无法智能识别arm和thumb指令，进一步导致无法进行伪代码还原。</p><p>在IDA动态调试时，仍然存在该问题，若在指令识别错误的地点写入断点，有可能使得调试 器崩溃。（ 可能写断点 ,不知道写ARM还是THUMB ,造成的崩溃）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#if(JUDGE_THUMB) </span><br><span class="line"></span><br><span class="line">#define GETPC_KILL_IDAF5_SKATEBOARD     \</span><br><span class="line">__asm __volatile(                       \</span><br><span class="line">&quot;mov   r0,pc        \n\t&quot;               \</span><br><span class="line">&quot;adds  r0,0x9       \n\t&quot;               \</span><br><span class="line">&quot;push  &#123;r0&#125;         \n\t&quot;               \</span><br><span class="line">&quot;pop   &#123;r0&#125;         \n\t&quot;               \</span><br><span class="line">&quot;bx    r0           \n\t&quot;               \</span><br><span class="line">\</span><br><span class="line">&quot;.byte 0x00         \n\t&quot;               \</span><br><span class="line">&quot;.byte 0xBF         \n\t&quot;               \ </span><br><span class="line">\ </span><br><span class="line"></span><br><span class="line">&quot;.byte 0x00         \n\t&quot;               \ </span><br><span class="line">&quot;.byte 0xBF         \n\t&quot;               \ </span><br><span class="line">\ </span><br><span class="line"></span><br><span class="line">&quot;.byte 0x00         \n\t&quot;               \ </span><br><span class="line">&quot;.byte 0xBF         \n\t&quot;               \ </span><br><span class="line">:::&quot;r0&quot;                                 \ ); </span><br><span class="line"></span><br><span class="line">#else </span><br><span class="line">#define GETPC_KILL_IDAF5_SKATEBOARD     \</span><br><span class="line">__asm __volatile(                       \ </span><br><span class="line">&quot;mov   r0,pc        \n\t&quot;               \ </span><br><span class="line">&quot;add   r0,0x10      \n\t&quot;               \ </span><br><span class="line">&quot;push  &#123;r0&#125;         \n\t&quot;               \ </span><br><span class="line">&quot;pop   &#123;r0&#125;         \n\t&quot;               \</span><br><span class="line">&quot;bx    r0           \n\t&quot;               \</span><br><span class="line">&quot;.int 0xE1A00000    \n\t&quot;               \ </span><br><span class="line">&quot;.int 0xE1A00000    \n\t&quot;               \ </span><br><span class="line">&quot;.int 0xE1A00000    \n\t&quot;               \ </span><br><span class="line">&quot;.int 0xE1A00000    \n\t&quot;               \ </span><br><span class="line">:::&quot;r0&quot;                                 \ ); </span><br><span class="line"></span><br><span class="line">#endif </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 常量标签版本 </span><br><span class="line"></span><br><span class="line">#if(JUDGE_THUMB) </span><br><span class="line"></span><br><span class="line">#define IDAF5_CONST_1_2                     \ </span><br><span class="line">__asm __volatile(                           \ </span><br><span class="line">&quot;b      T1              \n\t&quot;               \</span><br><span class="line">&quot;T2:                    \n\t&quot;               \ </span><br><span class="line">&quot;adds   r0,1            \n\t&quot;               \ </span><br><span class="line">&quot;bx     r0              \n\t&quot;               \ </span><br><span class="line">&quot;T1:                    \n\t&quot;               \ </span><br><span class="line">&quot;mov    r0,pc           \n\t&quot;               \ </span><br><span class="line">&quot;b      T2              \n\t&quot;               \ </span><br><span class="line">:::&quot;r0&quot;                                     \ </span><br><span class="line"></span><br><span class="line">); </span><br><span class="line"></span><br><span class="line">#else </span><br><span class="line"></span><br><span class="line">#define IDAF5_CONST_1_2                     \ </span><br><span class="line">__asm __volatile(                           \ </span><br><span class="line">&quot;b      T1              \n\t&quot;               \ </span><br><span class="line">&quot;T2:                    \n\t&quot;               \ </span><br><span class="line">&quot;bx     r0              \n\t&quot;               \ </span><br><span class="line"></span><br><span class="line">&quot;T1:                    \n\t&quot;               \ </span><br><span class="line">&quot;mov    r0,pc           \n\t&quot;               \ </span><br><span class="line"></span><br><span class="line">&quot;b      T2              \n\t&quot;               \ </span><br><span class="line">:::&quot;r0&quot;                                     \ ); </span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="15-五种代码执行时间检测"><a href="#15-五种代码执行时间检测" class="headerlink" title="15 五种代码执行时间检测"></a>15 五种代码执行时间检测</h3><p>第一类：</p><p>原理： 一段代码，在a处获取一下时间，运行一段后，再在b处获取下时间， 然后通过(b时间­a时间)求时间差,正常情况下这个时间差会非常小， 如果这个时间差比较大，说明正在被单步调试。</p><p>做法： 五个能获取时间的api：</p><p>time()函数 time_t结构体<br>clock()函数 clock_t结构体<br>gettimeofday()函数 timeval结构 timezone结构<br>clock_gettime()函数 timespec结构<br>getrusage()函数 rusage结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;time.h&gt; </span><br><span class="line">#include &lt;sys&#x2F;types.h&gt; </span><br><span class="line">#include &lt;sys&#x2F;resource.h&gt; </span><br><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;stdlib.h&gt; </span><br><span class="line">#include &lt;unistd.h&gt; </span><br><span class="line">#include &lt;time.h&gt; </span><br><span class="line"></span><br><span class="line">static int _getrusage();   &#x2F;&#x2F;Invalid </span><br><span class="line">static int _clock();       &#x2F;&#x2F;Invalid </span><br><span class="line">static int _time(); </span><br><span class="line">static int _gettimeofday(); </span><br><span class="line">static int _clock_gettime(); </span><br><span class="line"></span><br><span class="line">int main () &#123; </span><br><span class="line">    _getrusage(); </span><br><span class="line">    _clock(); </span><br><span class="line">    _time(); </span><br><span class="line">    _gettimeofday();    </span><br><span class="line">    _clock_gettime(); </span><br><span class="line">    return 0; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int _getrusage() &#123; </span><br><span class="line">    struct rusage t1; </span><br><span class="line"></span><br><span class="line">    &#x2F;* breakpoint *&#x2F; </span><br><span class="line">    getrusage (RUSAGE_SELF, &amp;t1); </span><br><span class="line">    long used &#x3D; t1.ru_utime.tv_sec + t1.ru_stime.tv_sec;     </span><br><span class="line">    if (used &gt; 2) &#123; </span><br><span class="line">        puts(&quot;debugged&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">    return 0;    </span><br><span class="line">&#125; </span><br><span class="line">int _clock()&#123; </span><br><span class="line">    clock_t t1, t2; </span><br><span class="line">    t1 &#x3D; clock (); </span><br><span class="line"></span><br><span class="line">    &#x2F;* breakpoint *&#x2F; </span><br><span class="line">    t2 &#x3D; clock (); </span><br><span class="line">    double used &#x3D; (double)(t2 - t1) &#x2F; CLOCKS_PER_SEC; </span><br><span class="line">    if (used &gt; 2) &#123; </span><br><span class="line">        puts(&quot;debugged&quot;);     </span><br><span class="line">    &#125; </span><br><span class="line">    return 0;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int _time() &#123; </span><br><span class="line">    time_t t1, t2; </span><br><span class="line">    time (&amp;t1); </span><br><span class="line">    </span><br><span class="line">    &#x2F;* breakpoint *&#x2F; </span><br><span class="line">    time (&amp;t2); </span><br><span class="line">    if (t2 - t1 &gt; 2) &#123; </span><br><span class="line">        puts(&quot;debugged&quot;);    </span><br><span class="line">    &#125; </span><br><span class="line">    return 0;   </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int _gettimeofday() &#123; </span><br><span class="line">    struct timeval t1, t2;     </span><br><span class="line">    struct timezone t; </span><br><span class="line">    gettimeofday (&amp;t1, &amp;t); </span><br><span class="line">    </span><br><span class="line">    &#x2F;* breakpoint *&#x2F; </span><br><span class="line">    gettimeofday (&amp;t2, &amp;t); </span><br><span class="line">    if (t2.tv_sec - t1.tv_sec &gt;2 )&#123;</span><br><span class="line">        puts(&quot;debugged&quot;); </span><br><span class="line">    &#125;    </span><br><span class="line">    return 0;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int _clock_gettime()&#123;</span><br><span class="line">    struct timespec t1, t2; </span><br><span class="line">    clock_gettime (CLOCK_REALTIME, &amp;t1); </span><br><span class="line">    &#x2F;* breakpoint *&#x2F; </span><br><span class="line">    clock_gettime (CLOCK_REALTIME, &amp;t2); </span><br><span class="line">    if (t2.tv_sec - t1.tv_sec &gt; 2) &#123;         </span><br><span class="line">        puts(&quot;debugged&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-三种进程信息结构检测"><a href="#16-三种进程信息结构检测" class="headerlink" title="16 三种进程信息结构检测"></a>16 三种进程信息结构检测</h3><p>原理： 一些进程文件中存储了进程信息，可以读取这些信息得知是否为调试状态。</p><p>做法：</p><p>第一种：/proc/pid/status /proc/pid/task/pid/status TracerPid非0 statue字段中写入t（tracing stop）</p><p>第二种：/proc/pid/stat /proc/pid/task/pid/stat 第二个字段是t（T）</p><p>第三种：/proc/pid/wchan /proc/pid/task/pid/wchan ptrace_stop</p><p>代码： 略。</p><h3 id="17-Inotify事件监控dump"><a href="#17-Inotify事件监控dump" class="headerlink" title="17 Inotify事件监控dump"></a>17 Inotify事件监控dump</h3><p>原理： 通常壳会在程序运行前完成对text的解密，所以脱壳可以通过dd与gdb_gcore来dump /proc/pid/mem或/proc/pid/pagemap，获取到解密后的代码内容。</p><p>可以通过Inotify系列api来监控mem或pagemap的打开或访问事件， 一旦发生时间就结束进程来阻止dump。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">void thread_watchDumpPagemap() &#123; </span><br><span class="line">    LOGA(&quot;-------------------watchDump:Pagemap------------------ - \n&quot;); </span><br><span class="line">    char dirName[NAME_MAX]&#x3D;&#123;0&#125;; </span><br><span class="line">    snprintf(dirName,NAME_MAX,&quot;&#x2F;proc&#x2F;%d&#x2F;pagemap&quot;,getpid()); </span><br><span class="line">    int fd &#x3D; inotify_init(); </span><br><span class="line">    if (fd &lt; 0) &#123; </span><br><span class="line">        LOGA(&quot;inotify_init err.\n&quot;); </span><br><span class="line">        return; </span><br><span class="line">    &#125; </span><br><span class="line">    int wd &#x3D; inotify_add_watch(fd,dirName,IN_ALL_EVENTS); </span><br><span class="line">    if (wd &lt; 0)  &#123; </span><br><span class="line">        LOGA(&quot;inotify_add_watch err.\n&quot;); </span><br><span class="line">        close(fd); </span><br><span class="line">        return; </span><br><span class="line">    &#125; </span><br><span class="line">    const int   buflen&#x3D;sizeof(struct inotify_event) * 0x100; </span><br><span class="line">    char        buf[buflen]&#x3D;&#123;0&#125;; </span><br><span class="line">    fd_set      readfds; </span><br><span class="line">    while(1) &#123; </span><br><span class="line">        FD_ZERO(&amp;readfds); </span><br><span class="line">        FD_SET(fd, &amp;readfds); </span><br><span class="line">        int iRet &#x3D; select(fd+1,&amp;readfds,0,0,0); &#x2F;&#x2F; 此处阻塞 </span><br><span class="line">        LOGB(&quot;iRet的返回值:%d\n&quot;,iRet); </span><br><span class="line">        if(-1&#x3D;&#x3D;iRet) </span><br><span class="line">            break; </span><br><span class="line">        if (iRet) &#123; </span><br><span class="line">            memset(buf,0,buflen);</span><br><span class="line">            int len &#x3D; read(fd,buf,buflen); </span><br><span class="line">            int i&#x3D;0; </span><br><span class="line">            while(i &lt; len)  &#123; </span><br><span class="line">                struct inotify_event *event &#x3D; (struct inotify_even t*)&amp;buf[i]; </span><br><span class="line">                LOGB(&quot;1 event mask的数值为:%d\n&quot;,event-&gt;mask); </span><br><span class="line">                if( (event-&gt;mask&#x3D;&#x3D;IN_OPEN)  )  &#123; </span><br><span class="line">                    &#x2F;&#x2F; 此处判定为有true,执行崩溃. </span><br><span class="line">                    LOGB(&quot;2 有人打开pagemap,第%d次.\n\n&quot;,i); </span><br><span class="line">                    &#x2F;&#x2F;__asm __volatile(&quot;.int 0x8c89fa98&quot;); </span><br><span class="line">                &#125; </span><br><span class="line">                i +&#x3D; sizeof (struct inotify_event) + event-&gt;len;             &#125; </span><br><span class="line">            LOGA(&quot;-----3 退出小循环-----\n&quot;); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    inotify_rm_watch(fd,wd); </span><br><span class="line">    close(fd); </span><br><span class="line">    LOGA(&quot;-----4 退出大循环,关闭监视-----\n&quot;); </span><br><span class="line">    return; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void smain() &#123; </span><br><span class="line">    &#x2F;&#x2F; 监控&#x2F;proc&#x2F;pid&#x2F;mem </span><br><span class="line">    pthread_t ptMem,t,ptPageMap; </span><br><span class="line">    int iRet&#x3D;0; </span><br><span class="line">    &#x2F;&#x2F; 监控&#x2F;proc&#x2F;pid&#x2F;pagemap </span><br><span class="line">    iRet&#x3D;pthread_create(&amp;ptPageMap,NULL,(PPP)thread_watchDumpPagema p,NULL); </span><br><span class="line">    if (0!&#x3D;iRet)  &#123; </span><br><span class="line">        LOGA(&quot;Create,thread_watchDumpPagemap,error!\n&quot;);                  return; </span><br><span class="line">    &#125; </span><br><span class="line">    iRet&#x3D;pthread_detach(ptPageMap); </span><br><span class="line">    if (0!&#x3D;iRet)   &#123; </span><br><span class="line">        LOGA(&quot;pthread_detach,thread_watchDumpPagemap,error!\n&quot;);          return; </span><br><span class="line">    &#125; </span><br><span class="line">    LOGA(&quot;-------------------smain-------------------\n&quot;); </span><br><span class="line">    LOGB(&quot;pid:%d\n&quot;,getpid()); </span><br><span class="line">    return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Frida反反调试"><a href="#Frida反反调试" class="headerlink" title="Frida反反调试"></a>Frida反反调试</h1><h2 id="应用崩溃退出"><a href="#应用崩溃退出" class="headerlink" title="应用崩溃退出"></a>应用崩溃退出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function show_native_stacks(flag)&#123; </span><br><span class="line">    console.log(&#96;$&#123;flag&#125; \tBacktrace:\n\t&#96; + Thread.backtrace(this.context,Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&#39;\n\t&#39;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function anti_exit() &#123;</span><br><span class="line">    const exit_ptr &#x3D; Module.findExportByName(null, &#39;exit&#39;);</span><br><span class="line">    console.log(&#39;anti_exit: &#39;,  exit_ptr);</span><br><span class="line">    if (null &#x3D;&#x3D; exit_ptr) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Interceptor.replace(exit_ptr, new NativeCallback(function (flag) &#123;</span><br><span class="line">        if (null &#x3D;&#x3D; this) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&#39;anti_exit lr: &#39;,this.context.lr);</span><br><span class="line">        show_native_stacks(&#39;anti_exit&#39;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;, &#39;int&#39;, [&#39;int&#39;, &#39;int&#39;]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function anti_kill() &#123;</span><br><span class="line">    const kill_ptr &#x3D; Module.findExportByName(null, &#39;kill&#39;);</span><br><span class="line">    console.log(&#39;anti_kill: &#39;, kill_ptr);</span><br><span class="line">    if (null &#x3D;&#x3D; kill_ptr) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Interceptor.replace(kill_ptr, new NativeCallback(function (pid, flag) &#123;</span><br><span class="line">        if (null &#x3D;&#x3D; this) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&#96;anti_kill: lr&#x3D;$&#123;this.context.lr&#125; pid&#x3D;$&#123;pid&#125; flag&#x3D;$&#123;flag&#125;&#96;);</span><br><span class="line">        show_native_stacks(&#39;anti_kill&#39;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;, &#39;int&#39;, [&#39;int&#39;, &#39;int&#39;]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检测是否被调试"><a href="#检测是否被调试" class="headerlink" title="检测是否被调试"></a>检测是否被调试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">function anti_isDebuggerConnected()&#123;</span><br><span class="line">  Java.perform(function() &#123;</span><br><span class="line">      var Debug &#x3D; Java.use(&#39;android.os.Debug&#39;);</span><br><span class="line">      Debug.isDebuggerConnected.implementation &#x3D; function() &#123;</span><br><span class="line">          console.log(&#39;isDebuggerConnected Bypassed !&#39;);</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;开发者模式</span><br><span class="line">function anti_developer_mod()&#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        var SSecure &#x3D; Java.use(&quot;android.provider.Settings$Secure&quot;);</span><br><span class="line">        SSecure.getStringForUser.overload(&#39;android.content.ContentResolver&#39;, &#39;java.lang.String&#39;, &#39;int&#39;).implementation &#x3D; function (contentResolver, name, flag) &#123;</span><br><span class="line">            if (name.indexOf(&quot;development_settings_enabled&quot;) &gt;&#x3D; 0) &#123;</span><br><span class="line">              console.log(name);</span><br><span class="line">              return this.getStringForUser.call(this, contentResolver, &#39;fuckyou&#39;, flag);</span><br><span class="line">            &#125;</span><br><span class="line">            return this.getStringForUser(contentResolver, name, flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);</span><br><span class="line">function anti_ptrace() &#123;</span><br><span class="line">    var ptrace_ptr &#x3D; Module.findExportByName(null, &quot;ptrace&quot;);</span><br><span class="line">    console.log(&#39;ptrace_ptr: &#39;, ptrace_ptr);</span><br><span class="line">    if (null !&#x3D; ptrace_ptr) &#123;</span><br><span class="line">        Interceptor.replace(ptrace_ptr.or(1), new NativeCallback(function (request, pid, addr, data) &#123;</span><br><span class="line">            console.log(&#39;anti_ptrace entry&#39;);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;, &#39;long&#39;, [&#39;int&#39;, &quot;int&quot;, &#39;pointer&#39;, &#39;pointer&#39;]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每日优鲜</span><br><span class="line">function anti_fork() &#123;</span><br><span class="line">    var fork_ptr &#x3D; Module.findExportByName(null, &quot;fork&quot;);</span><br><span class="line">    console.log(&#39;fork_ptr: &#39;,  fork_ptr);</span><br><span class="line">    if (null !&#x3D; fork_ptr) &#123;</span><br><span class="line">        Interceptor.replace(fork_ptr, new NativeCallback(function () &#123;</span><br><span class="line">            console.log(&#39;fork_ptr&#39;, &#39;entry&#39;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;, &#39;int&#39;, []));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function getModuleByAddr(addr) &#123;</span><br><span class="line">    var result &#x3D; null;</span><br><span class="line">    Process.enumerateModules().forEach(function (module) &#123;</span><br><span class="line">        if (module.base &lt;&#x3D; addr &amp;&amp; addr &lt;&#x3D; (module.base.add(module.size))) &#123;</span><br><span class="line">            result &#x3D; JSON.stringify(module);</span><br><span class="line">            return false; &#x2F;&#x2F; 跳出循环</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;char *fgets(char *str, int n, FILE *stream)</span><br><span class="line">function anti_fgets() &#123;</span><br><span class="line">    const tag &#x3D; &#39;anti_fgets&#39;;</span><br><span class="line">    const fgets_ptr &#x3D; Module.findExportByName(null, &#39;fgets&#39;);</span><br><span class="line">    console.log(&#39;fgets_ptr: &#39;, fgets_ptr);</span><br><span class="line">    if (!fgets_ptr) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    var fgets &#x3D; new NativeFunction(fgets_ptr, &#39;pointer&#39;, [&#39;pointer&#39;, &#39;int&#39;, &#39;pointer&#39;]);</span><br><span class="line">    Interceptor.replace(fgets_ptr, new NativeCallback(function (buffer, size, fp) &#123;</span><br><span class="line">        if (null &#x3D;&#x3D; this) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        var logTag &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 进入时先记录现场</span><br><span class="line">        const lr &#x3D; this.context.lr</span><br><span class="line">        &#x2F;&#x2F; 读取原 buffer</span><br><span class="line">        var retval &#x3D; fgets(buffer, size, fp);</span><br><span class="line">        var bufstr &#x3D; Memory.readUtf8String(buffer);</span><br><span class="line">        if (null !&#x3D; bufstr) &#123;</span><br><span class="line">            if (bufstr.indexOf(&quot;TracerPid:&quot;) &gt; -1) &#123;</span><br><span class="line">                buffer.writeUtf8String(&quot;TracerPid:\t0&quot;);</span><br><span class="line">                logTag &#x3D; &#39;TracerPid&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;State:    S (sleeping)</span><br><span class="line">            else if (bufstr.indexOf(&quot;State:\tt (tracing stop)&quot;) &gt; -1) &#123;</span><br><span class="line">                buffer.writeUtf8String(&quot;State:\tS (sleeping)&quot;);</span><br><span class="line">                logTag &#x3D; &#39;State&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; ptrace_stop</span><br><span class="line">            else if (bufstr.indexOf(&quot;ptrace_stop&quot;) &gt; -1) &#123;</span><br><span class="line">                buffer.writeUtf8String(&quot;sys_epoll_wait&quot;);</span><br><span class="line">                logTag &#x3D; &#39;ptrace_stop&#39;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;(sankuai.meituan) t</span><br><span class="line">            else if (bufstr.indexOf(&quot;) t&quot;) &gt; -1) &#123;</span><br><span class="line">                buffer.writeUtf8String(bufstr.replace(&quot;) t&quot;, &quot;) S&quot;));</span><br><span class="line">                logTag &#x3D; &#39;stat_t&#39;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; SigBlk</span><br><span class="line">            else if (bufstr.indexOf(&#39;SigBlk:&#39;) &gt; -1) &#123;</span><br><span class="line">                buffer.writeUtf8String(&#39;SigBlk:\t0000000000001204&#39;);</span><br><span class="line">                logTag &#x3D; &#39;SigBlk&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (logTag) &#123;</span><br><span class="line">                console.log(tag + &quot; &quot; + logTag, bufstr + &quot; -&gt; &quot; + buffer.readCString() + &#39; lr: &#39; + lr +</span><br><span class="line">                    &quot;(&quot; + getModuleByAddr(lr) + &quot;)&quot;);</span><br><span class="line">                show_native_stacks(tag)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return retval;</span><br><span class="line">    &#125;, &#39;pointer&#39;, [&#39;pointer&#39;, &#39;int&#39;, &#39;pointer&#39;]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="frida检测"><a href="#frida检测" class="headerlink" title="frida检测"></a>frida检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;梆梆检测点</span><br><span class="line">&#x2F;&#x2F;int  readlink(const  char *path,  char *buf, size_t  bufsiz);</span><br><span class="line">function anti_readlink()&#123;</span><br><span class="line">    const readlink_ptr &#x3D; Module.findExportByName(null, &quot;readlink&quot;);</span><br><span class="line">    console.log(&#39;readlink_ptr: &#39;,  readlink_ptr);</span><br><span class="line">    if(!readlink_ptr)&#123;</span><br><span class="line">        return </span><br><span class="line">    &#125;</span><br><span class="line">    const readlink &#x3D; new NativeFunction(readlink_ptr, &#39;int&#39;, [&#39;pointer&#39;, &#39;pointer&#39;, &#39;pointer&#39;])</span><br><span class="line">    Interceptor.replace(readlink_ptr, new NativeCallback(function(path, buf, size)&#123;</span><br><span class="line">        var retval &#x3D; readlink(path, buf, size);</span><br><span class="line">        var bufstr &#x3D; buf.readCString(); </span><br><span class="line">        if (bufstr.indexOf(&#39;frida&#39;)!&#x3D;&#x3D;-1 ||</span><br><span class="line">            bufstr.indexOf(&#39;gum-js-loop&#39;)!&#x3D;&#x3D;-1 ||</span><br><span class="line">            bufstr.indexOf(&#39;gmain&#39;)!&#x3D;&#x3D;-1 ||</span><br><span class="line">            bufstr.indexOf(&#39;linjector&#39;)!&#x3D;&#x3D;-1)&#123;</span><br><span class="line">            console.log(&#96;\nreadlink(path&#x3D;$&#123;path.readCstring()&#125;, buf&#x3D;$&#123;bufstr&#125;, size&#x3D;$&#123;size&#125;&#96;);</span><br><span class="line">            this.buf.writeUtf8String(&quot;&#x2F;system&#x2F;framework&#x2F;boot.art&quot;)</span><br><span class="line">            console.log(&quot;replce with: &quot;+ this.buf.readCString())</span><br><span class="line">            return 0x1A;</span><br><span class="line">        &#125;</span><br><span class="line">        return retval;</span><br><span class="line">    &#125;, &#39;int&#39;, [&#39;pointer&#39;, &#39;pointer&#39;, &#39;pointer&#39;]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;char *strstr(const char *haystack, const char *needle)</span><br><span class="line">function anti_strstr()&#123;</span><br><span class="line">    const strstr_ptr &#x3D; Module.findExportByName(null, &quot;strstr&quot;);</span><br><span class="line">    console.log(&#39;strstr_ptr: &#39;,  strstr_ptr);</span><br><span class="line">    if(!strstr_ptr)&#123;</span><br><span class="line">        return </span><br><span class="line">    &#125;</span><br><span class="line">    const strstr &#x3D; new NativeFunction(strstr_ptr, &#39;pointer&#39;, [&#39;pointer&#39;, &#39;pointer&#39;])</span><br><span class="line">    Interceptor.replace(strstr_ptr, new NativeCallback(function(haystack, needle)&#123;</span><br><span class="line">        var retval &#x3D; strstr(haystack, needle);</span><br><span class="line">        var haystackstr &#x3D; haystack.readCString(); </span><br><span class="line">        var needle_content &#x3D; haystack.readCString(); </span><br><span class="line">        if (haystackstr.indexOf(&#39;frida&#39;)!&#x3D;&#x3D;-1 ||</span><br><span class="line">            needle_content.indexOf(&#39;frida&#39;)!&#x3D;&#x3D;-1 ||</span><br><span class="line">            haystackstr.indexOf(&#39;gum-js-loop&#39;)!&#x3D;&#x3D;-1 ||</span><br><span class="line">            needle_content.indexOf(&#39;gum-js-loop&#39;)!&#x3D;&#x3D;-1 ||</span><br><span class="line">            haystackstr.indexOf(&#39;gmain&#39;)!&#x3D;&#x3D;-1 ||</span><br><span class="line">            needle_content.indexOf(&#39;gmain&#39;)!&#x3D;&#x3D;-1 ||</span><br><span class="line">            haystackstr.indexOf(&#39;linjector&#39;)!&#x3D;&#x3D;-1 ||</span><br><span class="line">            needle_content.indexOf(&#39;linjector&#39;)!&#x3D;&#x3D;-1)&#123;</span><br><span class="line">            console.log(&#96;\nstrstr(haystack&#x3D;$&#123;haystackstr&#125;, needle&#x3D;$&#123;needle_content&#125;&#96;);</span><br><span class="line">            this.buf.writeUtf8String(&quot;&#x2F;system&#x2F;framework&#x2F;boot.art&quot;)</span><br><span class="line">            console.log(&quot;replce with: &quot;+ this.buf.readCString())</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return retval;</span><br><span class="line">    &#125;, &#39;pointer&#39;, [&#39;pointer&#39;, &#39;pointer&#39;]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程检测</span><br><span class="line">&#x2F;&#x2F;int pthread_create(pthread_t* thread_out, pthread_attr_t const* attr, </span><br><span class="line">&#x2F;&#x2F;void* (*start_routine)(void*), void* arg)</span><br><span class="line">function anti_pthread_create_detect_frida_loop()&#123;</span><br><span class="line">    const pthread_create_ptr &#x3D; Module.findExportByName(null, &quot;pthread_create&quot;);</span><br><span class="line">    console.log(&#39;pthread_create_ptr: &#39;,  pthread_create_ptr);</span><br><span class="line">    if(!strstr_ptr)&#123;</span><br><span class="line">        return </span><br><span class="line">    &#125;</span><br><span class="line">    const pthread_create &#x3D; new NativeFunction(pthread_create_ptr, &#39;int&#39;, [&#39;pointer&#39;, &#39;pointer&#39;,&#39;pointer&#39;,&#39;pointer&#39;]);</span><br><span class="line">    Interceptor.replace(pthread_create_ptr, new NativeCallback(function (thread_out, attr, start_routine, arg) &#123;</span><br><span class="line">        var retval;</span><br><span class="line">        var detect_frida_loop &#x3D; Module.findExportByName(null, &quot;_Z17detect_frida_loopPv&quot;);</span><br><span class="line">        if (String(detect_frida_loop) &#x3D;&#x3D;&#x3D; String(start_routine))&#123;</span><br><span class="line">            retval &#x3D; 0;</span><br><span class="line">            console.log(&#39;Prevent detect_frida_loop Thread start&#39;)</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            retval &#x3D; pthread_create(thread_out, attr, start_routine, arg);</span><br><span class="line">        &#125;</span><br><span class="line">        return retval</span><br><span class="line">    &#125;,&#39;int&#39;, [&#39;pointer&#39;, &#39;pointer&#39;,&#39;pointer&#39;,&#39;pointer&#39;]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环境检测"><a href="#环境检测" class="headerlink" title="环境检测"></a>环境检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">const openPtr &#x3D; Module.getExportByName(&#39;libc.so&#39;, &#39;open&#39;);</span><br><span class="line">const open &#x3D; new NativeFunction(openPtr, &#39;int&#39;, [&#39;pointer&#39;, &#39;int&#39;]);</span><br><span class="line"></span><br><span class="line">var readPtr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;read&quot;);</span><br><span class="line">var read &#x3D; new NativeFunction(readPtr, &#39;int&#39;, [&#39;int&#39;, &#39;pointer&#39;, &quot;int&quot;]);</span><br><span class="line">var fakePath &#x3D; &quot;&#x2F;data&#x2F;data&#x2F;com.xingin.xhs&#x2F;maps&quot;;&#x2F;&#x2F;这里要改包名</span><br><span class="line">var file &#x3D; new File(fakePath, &quot;w&quot;);</span><br><span class="line">var buffer &#x3D; Memory.alloc(512);</span><br><span class="line"></span><br><span class="line">var fakePath2 &#x3D; &quot;&#x2F;data&#x2F;data&#x2F;com.xingin.xhs&#x2F;task&quot;;</span><br><span class="line">var file2 &#x3D; new File(fakePath2, &quot;w&quot;);</span><br><span class="line">var buffer2 &#x3D; Memory.alloc(512);</span><br><span class="line"></span><br><span class="line">Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123;</span><br><span class="line">    var pathname &#x3D; Memory.readUtf8String(pathnameptr);</span><br><span class="line">    var realFd &#x3D; open(pathnameptr, flag);</span><br><span class="line">    console.log(&quot;open:&quot;, pathname)</span><br><span class="line">    &#x2F;&#x2F;路径是否包含maps 和task</span><br><span class="line">    if (pathname.indexOf(&quot;maps&quot;) &gt;&#x3D; 0 || pathname.indexOf(&quot;status&quot;) &gt;&#x3D; 0 || pathname.indexOf(&quot;cmdline&quot;) &gt;&#x3D; 0) &#123;</span><br><span class="line">        var temp &#x3D; pathname.indexOf(&quot;maps&quot;) &gt;&#x3D; 0 ? 1:2;</span><br><span class="line">        &#x2F;&#x2F;包含maps则map为1 task为2</span><br><span class="line">        switch (temp) &#123;</span><br><span class="line">            case 1:&#x2F;&#x2F;maps</span><br><span class="line">            &#123;</span><br><span class="line">               &#x2F;&#x2F; console.log(&quot;open maps:&quot;, pathname);</span><br><span class="line">                while (parseInt(read(realFd, buffer, 512)) !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    var oneLine &#x3D; Memory.readCString(buffer);</span><br><span class="line">                &#x2F;&#x2F;   if(pathname&#x3D;&#x3D;&quot;&#x2F;proc&#x2F;self&#x2F;maps&quot;)&#123;</span><br><span class="line">                &#x2F;&#x2F;     console.log(&quot;maps 打印 oneLine: &quot;,oneLine);</span><br><span class="line">                &#x2F;&#x2F;   &#125;</span><br><span class="line">            </span><br><span class="line">                    if (oneLine.indexOf(&quot;tmp&quot;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">                        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D; 比&#x3D;&#x3D; 更加严格 &#x3D;&#x3D;类型不匹配再转化匹配值 &#x3D;&#x3D;&#x3D;类型不匹配就是false</span><br><span class="line">                        &#x2F;&#x2F; 就是online 不包含tmp 则写入&#x2F;data&#x2F;data&#x2F;com.wujie.chengxin&#x2F;maps中</span><br><span class="line">                        &#x2F;&#x2F; 因为Frida在运行时会先确定&#x2F;data&#x2F;local&#x2F;tmp路径下是否有re.frida.server文件夹，</span><br><span class="line">                        &#x2F;&#x2F; 若没有则创建该文件夹并存放fridaagent.so等文件</span><br><span class="line">                        &#x2F;&#x2F; console.log(&quot;write :&quot;,oneLine);</span><br><span class="line">                        file.write(oneLine);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(&quot;外打印 maps oneLine: &quot;,oneLine)</span><br><span class="line">                var filename &#x3D; Memory.allocUtf8String(fakePath);</span><br><span class="line">                return open(filename, flag);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case 2:&#x2F;&#x2F;task</span><br><span class="line">            &#123;</span><br><span class="line">                console.log(&quot;open task:&quot;, pathname);</span><br><span class="line">                while(parseInt(read(realFd, buffer2, 512)) !&#x3D;&#x3D; 0)&#123;</span><br><span class="line">                    var oneLine &#x3D; Memory.readCString(buffer2);</span><br><span class="line">                    console.log(&quot;打印 oneLine: &quot;,oneLine)</span><br><span class="line"></span><br><span class="line">                    if(oneLine.indexOf(&quot;gum-js-loop&quot;)!&#x3D;-1)&#123;</span><br><span class="line">                        var replaceStr &#x3D; &quot;AAAAAAAAAA&quot;</span><br><span class="line">                        oneLine &#x3D; oneLine.replace(&quot;gum-js-loop&quot;, replaceStr)</span><br><span class="line">                        &#x2F;&#x2F;console.log(oneLine)</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(oneLine.indexOf(&quot;pool-frida&quot;)!&#x3D;-1)&#123;</span><br><span class="line">                         var replaceStr &#x3D; &quot;BBBBBBB&quot;</span><br><span class="line">                        oneLine &#x3D; oneLine.replace(&quot;pool-frida&quot;, replaceStr)</span><br><span class="line">                        &#x2F;&#x2F;console.log(oneLine)</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(oneLine.indexOf(&quot;gmain&quot;)!&#x3D;-1)&#123;</span><br><span class="line">                         var replaceStr &#x3D; &quot;CCCCCCC&quot;  &#x2F;&#x2F;最终只有这里匹配上了</span><br><span class="line">                        oneLine &#x3D; oneLine.replace(&quot;gmain&quot;, replaceStr)</span><br><span class="line">                        &#x2F;&#x2F;console.log(oneLine)</span><br><span class="line">                    &#125;</span><br><span class="line">                    file2.write(oneLine);</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(&quot;外打印 oneLine: &quot;,oneLine)</span><br><span class="line">                var filename &#x3D; Memory.allocUtf8String(fakePath2);</span><br><span class="line">                return open(filename, flag);&#x2F;&#x2F;把伪造的路径打开返回</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var fd &#x3D; open(pathnameptr, flag);</span><br><span class="line">    &#x2F;&#x2F; Thread.sleep(1)</span><br><span class="line">    return fd; </span><br><span class="line">&#125;, &#39;int&#39;, [&#39;pointer&#39;, &#39;int&#39;]));</span><br><span class="line"></span><br><span class="line">function get_self_process_name() &#123;</span><br><span class="line">    var openPtr &#x3D; Module.getExportByName(&#39;libc.so&#39;, &#39;open&#39;);</span><br><span class="line">    var open &#x3D; new NativeFunction(openPtr, &#39;int&#39;, [&#39;pointer&#39;, &#39;int&#39;]);</span><br><span class="line"></span><br><span class="line">    var readPtr &#x3D; Module.getExportByName(&quot;libc.so&quot;, &quot;read&quot;);</span><br><span class="line">    var read &#x3D; new NativeFunction(readPtr, &quot;int&quot;, [&quot;int&quot;, &quot;pointer&quot;, &quot;int&quot;]);</span><br><span class="line"></span><br><span class="line">    var closePtr &#x3D; Module.getExportByName(&#39;libc.so&#39;, &#39;close&#39;);</span><br><span class="line">    var close &#x3D; new NativeFunction(closePtr, &#39;int&#39;, [&#39;int&#39;]);</span><br><span class="line"></span><br><span class="line">    var path &#x3D; Memory.allocUtf8String(&quot;&#x2F;proc&#x2F;self&#x2F;cmdline&quot;);</span><br><span class="line">    var fd &#x3D; open(path, 0);</span><br><span class="line">    if (fd !&#x3D; -1) &#123;</span><br><span class="line">        var buffer &#x3D; Memory.alloc(0x1000);</span><br><span class="line"></span><br><span class="line">        var result &#x3D; read(fd, buffer, 0x1000);</span><br><span class="line">        close(fd);</span><br><span class="line">        result &#x3D; ptr(buffer).readCString();</span><br><span class="line">        console.log(&quot;进程的名字是:&quot;+result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &quot;-1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;int __system_property_get(const char *name, char *value);</span><br><span class="line">function anti_system_property_get()&#123;</span><br><span class="line">    const system_property_get_ptr &#x3D; Module.getExportByName(&#39;libc.so&#39;, &#39;__system_property_get&#39;);</span><br><span class="line">    if (!system_property_get_ptr)&#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var system_property_get &#x3D; new NativeFunction(system_property_get_ptr, &#39;int&#39;, [&#39;pointer&#39;, &#39;pointer&#39;])</span><br><span class="line">    Interceptor.replace(system_property_get, new NativeCallback(function (name, value) &#123;</span><br><span class="line">        console.log(&#96;\n__system_property_get(name&#x3D;$&#123;name.readCString()&#125;, value&#x3D;$&#123;value.readCString()&#125;&#96;);</span><br><span class="line">        var retval &#x3D; system_property_get(name, value);</span><br><span class="line">        return retval;</span><br><span class="line">    &#125;, &#39;int&#39;, [&#39;pointer&#39;, &#39;pointer&#39;]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="端口检测"><a href="#端口检测" class="headerlink" title="端口检测"></a>端口检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.attach(Module.findExportByName(&quot;libc.so&quot;, &quot;connect&quot;), &#123;</span><br><span class="line">    onEnter: function (args) &#123;</span><br><span class="line">        var memory &#x3D; Memory.readByteArray(args[1], 64);</span><br><span class="line">        var b &#x3D; new Uint8Array(memory);</span><br><span class="line">        if (b[2] &#x3D;&#x3D; 0x69 &amp;&amp; b[3] &#x3D;&#x3D; 0xa2 &amp;&amp; b[4] &#x3D;&#x3D; 0x7f &amp;&amp; b[5] &#x3D;&#x3D; 0x00 &amp;&amp; b[6] &#x3D;&#x3D; 0x00 &amp;&amp; b[7] &#x3D;&#x3D; 0x01) &#123;</span><br><span class="line">            this.frida_detection &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave: function (retval) &#123;</span><br><span class="line">        if (this.frida_detection) &#123;</span><br><span class="line">            console.log(&quot;Frida Bypassed&quot;);</span><br><span class="line">            retval.replace(-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Interceptor.attach(Module.findExportByName(null, &quot;connect&quot;), &#123;</span><br><span class="line">    onEnter: function (args) &#123;</span><br><span class="line">        var family &#x3D; Memory.readU16(args[1]);</span><br><span class="line">        if (family !&#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        var port &#x3D; Memory.readU16(args[1].add(2));</span><br><span class="line">        port &#x3D; ((port &amp; 0xff) &lt;&lt; 8) | (port &gt;&gt; 8);</span><br><span class="line">        if (port &#x3D;&#x3D;&#x3D; 27042) &#123;</span><br><span class="line">            console.log(&#39;Frida port check&#39;);</span><br><span class="line">            Memory.writeU16(args[1].add(2), 0x0101);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if(!isMobile){var btw=new BTWPlugin;btw.init({id:"vip-container",blogId:"25827-1638538754631-918",name:"万物皆可逆向",qrcode:"https://onejane.github.io/gzh.jpg",keyword:"密码"})}</script></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">J</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="http://onejane.github.io/2022/10/19/调试与反调试/">http://onejane.github.io/2022/10/19/调试与反调试/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://onejane.github.io">万物皆可逆向</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/frida/">frida</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://onejane.gitee.io/picture/alipay.png"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://onejane.gitee.io/picture/wx.png"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/2022/10/15/SO%E9%80%86%E5%90%91%E4%B9%8B%E7%88%B1%E5%BA%93%E5%AD%98sig/"><span>SO逆向之爱库存sig</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify=!1,verify=!1,record_ip=!1,GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)});guest_info=0==guest_info.length?GUEST_INFO:guest_info,window.valine=new Valine({el:"#vcomment",notify:notify,verify:verify,recordIP:record_ip,appId:"cWLsquGr5PNi33OWXNhzerep-gzGzoHsz",appKey:"S35phfCSbm8dAG9LpOc5rjm3",placeholder:"一起来吹牛逼好吗！",avatar:"mm",guest_info:guest_info,pageSize:"10",lang:"zh-cn"})</script></div></div><footer class="footer-bg" style="background-image:url(http://onejane.gitee.io/picture/kali.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By J</div><div class="framework-info"><span>驱动 -</span> <a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"),$("#top-container").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>