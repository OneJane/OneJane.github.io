{"meta":{"title":"J","subtitle":"朝花夕拾","description":"逆向,爬虫","author":"J","url":"http://onejane.github.io","root":"/"},"pages":[{"title":"404","date":"2021-01-30T10:32:36.000Z","updated":"2021-01-30T10:33:01.911Z","comments":true,"path":"/404.html","permalink":"http://onejane.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-30T07:34:23.000Z","updated":"2021-01-30T08:30:40.321Z","comments":true,"path":"categories/index.html","permalink":"http://onejane.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-01-30T07:34:05.000Z","updated":"2021-01-30T08:00:59.817Z","comments":true,"path":"tags/index.html","permalink":"http://onejane.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"自制路由器抓包","slug":"自制路由器抓包","date":"2021-07-03T01:07:14.000Z","updated":"2021-07-03T15:11:07.170Z","comments":true,"path":"2021/07/03/自制路由器抓包/","link":"","permalink":"http://onejane.github.io/2021/07/03/%E8%87%AA%E5%88%B6%E8%B7%AF%E7%94%B1%E5%99%A8%E6%8A%93%E5%8C%85/","excerpt":"","text":"京东搜索从实践中学习系列丛书 网络工具集：netwox 网络层：MAC/IP/ARP/DHCP 传输层：IP/TCP/UDP/ICMP(ping,traceroute) 应用层：DNS/Telnet/NC/FTP ARM设备武器化指南·破·Kali.Nethunter.2020a.上手实操 配合有线，无线网卡，手机wifi，4g该手机将会有4个ip地址。 网卡NDS Lookup 给指定网卡配置路由器给kali插入一块Ralink 802.11n网卡 nm-connection-editor 保存后ifconfig查看wlan0的ip，移动端就可以收到wifi信号了，jnettop结合wireshark抓包经过该网卡的全部流量。 123456789101112131415161718192021222324252627282930313233343536ifconfig wlan0 downifconfig wlan0 upssh root@192.168.0.107 连接kali nethunternethogs，jnettop 和 kali linux中抓的结果一致apt install netwox 创造任意tcp,udp数据报文，网络欺骗，自行发包netwox 55 -i 192.168.0.107 判断内网主机是否存活netwox 171 充当客户端请求dhcpnetwox 179 根据自己ip获取dhcp服务器信息netwox 3 -a www.163.comnetwox 3 -a 192.168.0.0&#x2F;24netwox 38 -l 192.168.0.8 -m 192.168.0.9netwox 34nentwox 74 -i &quot;192.168.0.107&quot; 洪水攻击netwox 94 -i 192.168.0.7 -p 8888 -c &quot;&#x2F;bin&#x2F;sh -c ifconfig&quot; 远程调用指令netwox 93 -P 8888netwox 87 -i 192.168.0.7 -p 80 发送消息netwox 89 -P 80 接受消息netwox 95 -i 192.168.0.7 -p 8888 &quot;nohup.out&quot; 获取目标机的文件netwox 95 --helpnetwox 93 -P 8888netwox 96 -i 192.168.0.7 -p 8888 -f get-pip.py -F get-pip.py 传输文件netwox 93 -P 8888netwox 51 -i 220.181.38.148netwox 67 -i 192.168.0.7 -p 1-100netwox 59 -i 192.168.0.7 洪水共计netwox 88 -i 192.168.0.7 -p 80 发送udp的包netwox 90 -P 80nc -l 8888 &gt; get-pip.py nc 118.126.66.192 8888 &lt; get-pip.py arp缓存表，路由表 树莓派刷安卓10 4G代理pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip 在kali nethunter下载shadowsocks-3.0.0 ssserver –version ssserver -k “123456” -m rc4-md5 pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip 在kali linux下载shadowsocks-3.0.0 sslocal –version ssserver –version sslocal -s 192.168.0.4 -p 8388 -k “123456” -m rc4-md5 vim /etc/proxychains4.conf socks5 127.0.0.1 1080 proxychains curl ip.sb =&gt; proxychains =&gt; sslocal =&gt; nps =&gt; 内网穿透 -&gt; npc -&gt; sserver -&gt; 4G 搭建NPS服务器 =&gt; 新增客户端 下载linux_arm64_client.tar.gz 执行新增客户端后生成的npc命令 建立隧道 sslocal -s 118.126.66.193 -p 58388 -k “123456” -m rc4-md5 112.65.48.132 是手机的ip，在手机端curl ip.sb pip install pysocks 1234567import requestsr &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;ip&#39;)print(r.text)proxy &#x3D; &#123;&quot;http&quot;:&quot;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;,&quot;https&quot;:&quot;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;&#125;r2 &#x3D;requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;ip&#39;,proxies &#x3D;proxy)print(r2.text) 美团点评移动网络优化实践 TCP协议详解 UDP协议的详细解析","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"加壳与脱壳之FART脱壳","slug":"加壳与脱壳之FART脱壳","date":"2021-06-03T05:25:02.000Z","updated":"2021-06-07T14:48:07.206Z","comments":true,"path":"2021/06/03/加壳与脱壳之FART脱壳/","link":"","permalink":"http://onejane.github.io/2021/06/03/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8BFART%E8%84%B1%E5%A3%B3/","excerpt":"","text":"在对于整体保护来说，Dalvik和Art通用的解决方案都是寻找一个合适的时机点去dump内存中完整的dex。整体加固存在致命的弱点，就是在内存中是连续的。由此进入函数抽取的时代，即二代壳的开始，而FART的出现要解决的问题就是函数抽取的方案。","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"FART","slug":"FART","permalink":"http://onejane.github.io/tags/FART/"}]},{"title":"克拉恋人会员制取证分析","slug":"克拉恋人会员制取证分析","date":"2021-05-30T16:21:13.000Z","updated":"2021-06-26T02:34:15.804Z","comments":true,"path":"2021/05/31/克拉恋人会员制取证分析/","link":"","permalink":"http://onejane.github.io/2021/05/31/%E5%85%8B%E6%8B%89%E6%81%8B%E4%BA%BA%E4%BC%9A%E5%91%98%E5%88%B6%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/","excerpt":"","text":"绕过强制会员adb install com.caratlover.apk 安装后强制支付会员费才可进主页 脱壳jadx打开发现代码很少，目测被加固，脱个衣服先。 12345678910git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;FRIDA-DEXDump.git.&#x2F;fs1426arm64pyenv local 3.9.0python main.py app保持最前端,开始脱壳git clone https:&#x2F;&#x2F;github.com&#x2F;hanbinglengyue&#x2F;FART.gitadb push frida_fart&#x2F;lib&#x2F;fart* &#x2F;data&#x2F;local&#x2F;tmpadb shell &amp;&amp; cp fart* &#x2F;data&#x2F;app &amp;&amp; chmod 777frida -U -f com.caratlover -l frida_fart_hook.js --no-pause 使用安卓8和安卓8.1进行脱壳mv ..&#x2F;*.dex carat &amp;&amp; adb pull &#x2F;sdcard&#x2F;carat file * 查看文件格式是Dalvik dex file，但是脱完的部分dex文件用010 Editor打开时，报错，说明文件并不标准。 123objection -g com.caratlover exploreandroid hooking list activitiesandroid intent launch_activity com.chanson.business.MainActivity 直接绕过强制会员购买页面 使用jadx1.2.0中同时打开多个dex，查找com.chanson.business.MainActivity 用12.8.0的frida混淆的爹妈都不认识了，还是用14.2.16版本。 绕过强制会员页面后，编辑资料填写个人详细信息。 搭讪通过点击发送时，调用hookEvent.js查看触发的类frida -UF -l hookEvent.js 1[Pixel::克拉恋人]-&gt; [WatchEvent] onClick: com.tencent.qcloud.tim.uikit.modules.chat.layout.input.InputLayout 查看InputLayout该类的用例，该UI基本都在com.chanson.business.message.activity.ChatActivity中调用 其中com.chanson.business.message.activity.ChatActivity有一段代码，判断是否vip 12345678910111213141516171819202122232425262728293031private final void ja() &#123; BasicUserInfoBean col1; BasicUserInfoBean col12; if (Ib.f9521i.m()) &#123; MyInfoBean k &#x3D; Ib.f9521i.k(); if (k &#x3D;&#x3D; null || (col12 &#x3D; k.getCol1()) &#x3D;&#x3D; null || !col12.isVip()) &#123; CheckTalkBean checkTalkBean &#x3D; this.f10545d; if ((checkTalkBean !&#x3D; null ? checkTalkBean.getUnlockTime() : 0) &gt; 0) &#123; da(); &#125; else &#123; l(0); &#125; &#125; else &#123; da(); &#125; &#125; else &#123; MyInfoBean k2 &#x3D; Ib.f9521i.k(); if (k2 &#x3D;&#x3D; null || (col1 &#x3D; k2.getCol1()) &#x3D;&#x3D; null || !col1.isReal()) &#123; ConfirmDialogFragment.a aVar &#x3D; ConfirmDialogFragment.Companion; String string &#x3D; getString(R$string.you_can_chat_after_you_have_certified); i.a((Object) string, &quot;getString(R.string.you_c…after_you_have_certified)&quot;); String string2 &#x3D; getString(R$string.authentication_now_in_ten_seconds); i.a((Object) string2, &quot;getString(R.string.authe…ation_now_in_ten_seconds)&quot;); FragmentManager supportFragmentManager &#x3D; getSupportFragmentManager(); i.a((Object) supportFragmentManager, &quot;supportFragmentManager&quot;); ConfirmDialogFragment.a.a(aVar, &quot;&quot;, string, &quot;&quot;, string2, true, supportFragmentManager, true, (kotlin.jvm.a.a) null, false, (kotlin.jvm.a.b) null, (String) null, 0.0f, (kotlin.jvm.a.b) null, 8064, (Object) null).a(new I(this)); return; &#125; da(); &#125;&#125; 其中的isVip方法来自于com.chanson.business.model.BasicUserInfoBean,我们尝试trace下该类，并打印类的每个域的值。 tracefrida -UF -l trace.js -o traceVip.txt 对指定类的所有动静态方法及构造函数进行trace 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196function inspectObject(obj) &#123; Java.perform(function () &#123; const obj_class &#x3D; obj.class; &#x2F;&#x2F; var objClass &#x3D; Java.use(&quot;java.lang.Object&quot;).getClass.apply(object); &#x2F;&#x2F; obj_class &#x3D;Java.use(&quot;java.lang.Class&quot;).getName.apply(objClass); const fields &#x3D; obj_class.getDeclaredFields(); const methods &#x3D; obj_class.getMethods(); &#x2F;&#x2F; console.log(&quot;Inspecting &quot; + obj.getClass().toString()); &#x2F;&#x2F; console.log(&quot;Inspecting &quot; + obj.class.toString()); console.log(&quot;\\tFields:&quot;); for (var i in fields) &#123; console.log(&quot;\\t\\t&quot; + fields[i].toString()); var className &#x3D; obj_class.toString().trim().split(&quot; &quot;)[1]; &#x2F;&#x2F; console.log(&quot;className is &#x3D;&gt; &quot;,className); var fieldName &#x3D; fields[i].toString().split(className.concat(&quot;.&quot;)).pop(); console.log(fieldName + &quot; &#x3D;&gt; &quot;, obj[fieldName].value); &#125; &#x2F;&#x2F; console.log(&quot;\\tMethods:&quot;); &#x2F;&#x2F; for (var i in methods) &#x2F;&#x2F; console.log(&quot;\\t\\t&quot; + methods[i].toString()); &#125;)&#125;function uniqBy(array, key)&#123; var seen &#x3D; &#123;&#125;; return array.filter(function(item) &#123; var k &#x3D; key(item); return seen.hasOwnProperty(k) ? false : (seen[k] &#x3D; true); &#125;);&#125;&#x2F;&#x2F; trace a specific Java Methodfunction traceMethod(targetClassMethod)&#123; var delim &#x3D; targetClassMethod.lastIndexOf(&quot;.&quot;); if (delim &#x3D;&#x3D;&#x3D; -1) return; var targetClass &#x3D; targetClassMethod.slice(0, delim) var targetMethod &#x3D; targetClassMethod.slice(delim + 1, targetClassMethod.length) var hook &#x3D; Java.use(targetClass); var overloadCount &#x3D; hook[targetMethod].overloads.length; console.log(&quot;Tracing &quot; + targetClassMethod + &quot; [&quot; + overloadCount + &quot; overload(s)]&quot;); for (var i &#x3D; 0; i &lt; overloadCount; i++) &#123; hook[targetMethod].overloads[i].implementation &#x3D; function() &#123; inspectObject(this) console.warn(&quot;\\n*** entered &quot; + targetClassMethod); &#x2F;&#x2F; print backtrace &#x2F;&#x2F; Java.perform(function() &#123; &#x2F;&#x2F; var bt &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()); &#x2F;&#x2F; console.log(&quot;\\nBacktrace:\\n&quot; + bt); &#x2F;&#x2F; &#125;); &#x2F;&#x2F; print args if (arguments.length) console.log(); for (var j &#x3D; 0; j &lt; arguments.length; j++) &#123; console.log(&quot;arg[&quot; + j + &quot;]: &quot; + arguments[j]); &#125; &#x2F;&#x2F; print retval var retval &#x3D; this[targetMethod].apply(this, arguments); &#x2F;&#x2F; rare crash (Frida bug?) console.log(&quot;\\nretval: &quot; + retval); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.warn(&quot;\\n*** exiting &quot; + targetClassMethod); return retval; &#125; &#125; &#125;function traceClass(targetClass)&#123; &#x2F;&#x2F;Java.use是新建一个对象哈，大家还记得么？ var hook &#x3D; Java.use(targetClass); &#x2F;&#x2F;利用反射的方式，拿到当前类的所有方法 var methods &#x3D; hook.class.getDeclaredMethods(); &#x2F;&#x2F; var methods &#x3D; hook.class.getMethods(); console.log(&quot;methods &#x3D;&gt; &quot;,methods) &#x2F;&#x2F;建完对象之后记得将对象释放掉哈 hook.$dispose; &#x2F;&#x2F;将方法名保存到数组中 var parsedMethods &#x3D; []; methods.forEach(function(method) &#123; parsedMethods.push(method.toString().replace(targetClass + &quot;.&quot;, &quot;TOKEN&quot;).match(&#x2F;\\sTOKEN(.*)\\(&#x2F;)[1]); &#125;); &#x2F;&#x2F;去掉一些重复的值 var targets &#x3D; uniqBy(parsedMethods, JSON.stringify); &#x2F;&#x2F; 只hook构造函数 &#x2F;&#x2F;targets &#x3D; []; targets &#x3D; targets.concat(&quot;$init&quot;) console.log(&quot;targets&#x3D;&gt;&quot;,targets) &#x2F;&#x2F;对数组中所有的方法进行hook，traceMethod也就是第一小节的内容 targets.forEach(function(targetMethod) &#123; traceMethod(targetClass + &quot;.&quot; + targetMethod); &#125;);&#125;function hook() &#123; Java.perform(function () &#123; console.log(&quot;start&quot;) Java.enumerateClassLoaders(&#123; onMatch: function (loader) &#123; try &#123; if(loader.findClass(&quot;com.ceco.nougat.gravitybox.ModStatusbarColor$1&quot;))&#123; &#x2F;&#x2F; if(loader.findClass(&quot;de.robv.android.xposed.XC_MethodHook&quot;))&#123; &#x2F;&#x2F; if(loader.findClass(&quot;de.robv.android.xposed.XposedBridge&quot;))&#123; &#x2F;&#x2F;if(loader.findClass(&quot;com.android.internal.statusbar.StatusBarIcon&quot;))&#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); Java.classFactory.loader &#x3D; loader ; &#125; &#125; catch(error)&#123; console.log(&quot;find error:&quot; + error) &#125; &#125;, onComplete: function () &#123; console.log(&quot;end1&quot;) &#125; &#125;) &#x2F;&#x2F; Java.use(&quot;de.robv.android.xposed.XposedBridge&quot;).log.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (str) &#123; &#x2F;&#x2F; console.log(&quot;entering Xposedbridge.log &quot;,str.toString()) &#x2F;&#x2F; return true &#x2F;&#x2F; &#125; &#x2F;&#x2F;traceClass(&quot;com.ceco.nougat.gravitybox.ModStatusbarColor&quot;) &#x2F;&#x2F; Java.use(&quot;com.roysue.xposed1.HookTest$1&quot;).afterHookedMethod.implementation &#x3D; function (param)&#123; &#x2F;&#x2F; console.log(&quot;entering afterHookedMethod param is &#x3D;&gt; &quot;,param); &#x2F;&#x2F; return this.afterHookedMethod(param); &#x2F;&#x2F; &#125; &#x2F;&#x2F; traceClass(&quot;de.robv.android.xposed.XC_MethodHook&quot;) &#x2F;&#x2F; Java.use(&quot;de.robv.android.xposed.XC_MethodHook$MethodHookParam&quot;).setResult.implementation &#x3D; function(str)&#123; &#x2F;&#x2F; console.log(&quot;entersing de.robv.android.xposed.XC_MethodHook$MethodHookParam setResult &#x3D;&gt; &quot;,str) &#x2F;&#x2F; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); &#x2F;&#x2F; return this.setResult(str); &#x2F;&#x2F; &#125; Java.enumerateLoadedClasses (&#123; onMatch:function(className)&#123; if(className.toString().indexOf(&quot;gravitybox&quot;)&gt;0 &amp;&amp; className.toString().indexOf(&quot;$&quot;)&gt;0 )&#123; console.log(&quot;found &#x3D;&gt; &quot;,className) &#x2F;&#x2F; var interFaces &#x3D; Java.use(className).class.getInterfaces(); &#x2F;&#x2F; if(interFaces.length&gt;0)&#123; &#x2F;&#x2F; console.log(&quot;interface is &#x3D;&gt; &quot;); &#x2F;&#x2F; for(var i in interFaces)&#123; &#x2F;&#x2F; console.log(&quot;\\t&quot;,interFaces[i].toString()) &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; if(Java.use(className).class.getSuperclass())&#123; var superClass &#x3D; Java.use(className).class.getSuperclass().getName(); &#x2F;&#x2F; console.log(&quot;superClass is &#x3D;&gt; &quot;,superClass); if (superClass.indexOf(&quot;XC_MethodHook&quot;)&gt;0)&#123; console.log(&quot;found class is &#x3D;&gt; &quot;,className.toString()) traceClass(className); &#125; &#125; &#125; &#125;,onComplete:function()&#123; console.log(&quot;search completed!&quot;) &#125; &#125;) console.log(&quot;end2&quot;) &#125;)&#125;function main()&#123; &#x2F;&#x2F; hook() Java.perform(function()&#123; traceClass(&quot;com.chanson.business.model.BasicUserInfoBean&quot;) &#x2F;&#x2F; traceClass(&quot;com.chanson.business.model.MyInfoBean&quot;); &#125;)&#125;setImmediate(main) java.lang.Throwable at com.chanson.business.model.BasicUserInfoBean.isVip(Native Method) at com.chanson.business.message.activity.ChatActivity.na(SourceFile:2) at com.chanson.business.message.activity.ChatActivity.k(SourceFile:1) at com.chanson.business.message.activity.a.run(SourceFile:1) at android.os.Handler.handleCallback(Handler.java:790) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:164) at android.app.ActivityThread.main(ActivityThread.java:6494) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807) at de.robv.android.xposed.XposedBridge.main(XposedBridge.java:108) 优化对应关系 frida -UF -l trace.js -o traceVip.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function traceMethod(targetClassMethod) &#123; var delim &#x3D; targetClassMethod.lastIndexOf(&quot;.&quot;); if (delim &#x3D;&#x3D;&#x3D; -1) return; var targetClass &#x3D; targetClassMethod.slice(0, delim) var targetMethod &#x3D; targetClassMethod.slice(delim + 1, targetClassMethod.length) var hook &#x3D; Java.use(targetClass); var overloadCount &#x3D; hook[targetMethod].overloads.length; console.log(&quot;Tracing &quot; + targetClassMethod + &quot; [&quot; + overloadCount + &quot; overload(s)]&quot;); for (var i &#x3D; 0; i &lt; overloadCount; i++) &#123; hook[targetMethod].overloads[i].implementation &#x3D; function () &#123; var output &#x3D; &quot;&quot;; for(var line&#x3D;0;line&lt;100;line++)&#123; output &#x3D; output.concat(&quot;&#x3D;&quot;) &#125; output &#x3D; output.concat(&quot;\\r\\n&quot;) const Class &#x3D; Java.use(&quot;java.lang.Class&quot;); &#x2F;&#x2F; const obj_class &#x3D; Java.cast(this.getClass(), Class); const obj_class &#x3D; this.class; const fields &#x3D; obj_class.getDeclaredFields(); &#x2F;&#x2F; output &#x3D; output.concat(&quot;Inspecting &quot; + this.getClass().toString()); output &#x3D; output.concat(&quot;Inspecting &quot; + this.class); output &#x3D; output.concat(&quot;\\r\\n&quot;) output &#x3D; output.concat(&quot;\\tFields:&quot;); output &#x3D; output.concat(&quot;\\r\\n&quot;) for (var i in fields) &#123; &#x2F;&#x2F; console.log(&quot;\\t\\t&quot; + fields[i].toString()); var className &#x3D; obj_class.toString().trim().split(&quot; &quot;)[1]; &#x2F;&#x2F; console.log(&quot;className is &#x3D;&gt; &quot;,className); var fieldName &#x3D; fields[i].toString().split(className.concat(&quot;.&quot;)).pop(); var fieldValue &#x3D; undefined; if(!(this[fieldName]&#x3D;&#x3D;&#x3D;undefined))&#123; fieldValue &#x3D; this[fieldName].value ; &#125; output &#x3D; output.concat(fieldName + &quot; &#x3D;&gt; &quot;, fieldValue); output &#x3D; output.concat(&quot;\\r\\n&quot;) &#125; &#x2F;&#x2F; inspectObject(this); output &#x3D; output.concat(&quot;\\n*** entered &quot; + targetClassMethod); output &#x3D; output.concat(&quot;\\r\\n&quot;) &#x2F;&#x2F; print backtrace &#x2F;&#x2F; Java.perform(function() &#123; &#x2F;&#x2F; var bt &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()); &#x2F;&#x2F; console.log(&quot;\\nBacktrace:\\n&quot; + bt); &#x2F;&#x2F; &#125;); &#x2F;&#x2F; print args if (arguments.length) console.log(); for (var j &#x3D; 0; j &lt; arguments.length; j++) &#123; output &#x3D; output.concat(&quot;arg[&quot; + j + &quot;]: &quot; + arguments[j] + &quot; &#x3D;&gt; &quot; + JSON.stringify(arguments[j])); output &#x3D; output.concat(&quot;\\r\\n&quot;) &#125; output &#x3D; output.concat(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); output &#x3D; output.concat(&quot;\\r\\n&quot;); &#x2F;&#x2F; print retval var retval &#x3D; this[targetMethod].apply(this, arguments); &#x2F;&#x2F; rare crash (Frida bug?) output &#x3D; output.concat(&quot;\\nretval: &quot; + retval + &quot; &#x3D;&gt; &quot; + JSON.stringify(retval)); output &#x3D; output.concat(&quot;\\r\\n&quot;) output &#x3D; output.concat(&quot;\\n*** exiting &quot; + targetClassMethod); output &#x3D; output.concat(&quot;\\r\\n&quot;) console.log(output); return retval; &#125; &#125;&#125; vip旧版4.1.0frida -UF -l hookCaratVip.js 1234567891011121314function hookVIP()&#123; Java.perform(function()&#123; Java.use(&quot;com.chanson.business.model.BasicUserInfoBean&quot;).isVip.implementation &#x3D; function()&#123; console.log(&quot;Calling isVIP &quot;) return true; &#125; &#125;) &#125;function main()&#123; console.log(&quot;Start hook&quot;) hookVIP()&#125;setImmediate(main) 新版4.6.01android hooking watch class com.chanson.business.message.activity.ChatActivity --dump-args --dump-backtrace --dump-return 当我们无法判断什么时候判断vip时，hook整个类，查看调用链，点击发送消息时，弹窗付费 查看jadx中的com.chanson.business.message.activity.ChatActivity类，通过aa方法得知只有在被拉黑等情况，返回false则无法发送消息，我们在第一步让Z()返回false，直接进入return true 1234567891011121314151617181920212223242526272829303132333435363738394041private final boolean aa() &#123; if (!Z()) &#123; return true; &#125; if (this.f10873d &#x3D;&#x3D; null) &#123; Hb.a(Hb.f11628c, &quot;数据异常&quot;, 0, 2, (Object) null); return false; &#125; else if (ga()) &#123; return false; &#125; else &#123; CheckTalkBean checkTalkBean &#x3D; this.f10873d; if (checkTalkBean &#x3D;&#x3D; null) &#123; i.a(); throw null; &#125; else if (!checkTalkBean.getUnlock()) &#123; ChatLayout chatLayout &#x3D; (ChatLayout) k(R$id.chatLayout); i.a((Object) chatLayout, &quot;chatLayout&quot;); chatLayout.getInputLayout().hideSoftInput(); x.a(new RunnableC1179a(this), 100); return false; &#125; else if (checkTalkBean.getStatus() &#x3D;&#x3D; 3 || checkTalkBean.getStatus() &#x3D;&#x3D; 2) &#123; Hb.a(Hb.f11628c, &quot;你已将对方拉黑，无法发送消息&quot;, 0, 2, (Object) null); ChatLayout chatLayout2 &#x3D; (ChatLayout) k(R$id.chatLayout); i.a((Object) chatLayout2, &quot;chatLayout&quot;); InputLayout inputLayout &#x3D; chatLayout2.getInputLayout(); i.a((Object) inputLayout, &quot;chatLayout.inputLayout&quot;); inputLayout.getInputText().setText(&quot;&quot;); return false; &#125; else if (checkTalkBean.getStatus() !&#x3D; 1) &#123; return true; &#125; else &#123; Hb.a(Hb.f11628c, &quot;对方已将你拉黑，无法发送消息&quot;, 0, 2, (Object) null); ChatLayout chatLayout3 &#x3D; (ChatLayout) k(R$id.chatLayout); i.a((Object) chatLayout3, &quot;chatLayout&quot;); InputLayout inputLayout2 &#x3D; chatLayout3.getInputLayout(); i.a((Object) inputLayout2, &quot;chatLayout.inputLayout&quot;); inputLayout2.getInputText().setText(&quot;&quot;); return false; &#125; &#125;&#125; 通过objection判断ChatActivity源码实现 1234objection -g com.caratlover explore -P ~&#x2F;.objection&#x2F;pluginsandroid hooking search classes ChatActivityplugin wallbreaker classdump --fullname com.chanson.business.message.activity.ChatActivityandroid hooking watch class_method com.chanson.business.message.activity.ChatActivity.Z --dump-args --dump-backtrace --dump-return 每次Z()返回true自然进不了发送消息逻辑，主动调用Z()返回false，破解vip 1234567891011121314function hookVIP()&#123; Java.perform(function()&#123; Java.use(&quot;com.chanson.business.message.activity.ChatActivity&quot;).Z.implementation &#x3D; function()&#123; console.log(&quot;Calling isVIP &quot;) return false; &#125; &#125;) &#125;function main()&#123; console.log(&quot;Start hook&quot;) hookVIP()&#125;setImmediate(main) 抓包Postern配置代理，其中192.168.0.107是charles主机ip，8889是charles的socks 配置规则 遇到8668端口抓不到，报错SSL：Unsupported or unrecognized SSL message,修改charles的Proxy Settings 盲猜一波是base64加密 1python r0capture.py -U -f com.caratlover -v -w 2 &gt;&gt; capture.txt 抓包发现都被加密，类被混淆的非常厉害，虽然无法识别类的作用，我们可以有通过trace去跟踪调用返回值 找到登录包/auth/login-check,其调用栈中at com.chanson.common.a.j.intercept(SourceFile:45) 通过jadx查看com.chanson.common.a.j方法，其中com.chanson.common.utils.a.b将传入的jsonObject转成string后调用c方法。 12frida -U -f com.caratlover -l trace.js --no-pause -o traffic.txt 修改trace的classtraceClass(&quot;com.chanson.common.utils.a.b&quot;) Error: java.lang.ClassNotFoundException: Didn’t find class “com.chanson.common.utils.a.b” 报错是因为app启动还要时间，修改setTimeout(main, 2000); trace登录,先打开登录界面，输入密码后frida -U com.caratlover -l r0tracer.js --no-pause -o traffic.txt 大量的加密字段类似base64，尝试trace Base64。修改traceClass(&quot;android.util.Base64&quot;)，开启trace，frida -U com.caratlover -l r0tracer.js --no-pause -o base64.txt追查调用栈 通过jadx查看com.chanson.common.a.d,其中String a2 = a.a(string, &quot;f87210e0ed3079d8&quot;);的a方法跳转到实现发现是一个完整的标准aes加密。 全局搜索还有AESUtils，完全自己开发的非标准的AES加密，7z x com.caratlover.apk 查看lib/armeabi-v7a下存在alicomphonenumberauthsdk-log-online-standard-release_alijtca_plus.so strings查看该so中的字符串，traceClass(&quot;com.mobile.auth.gatewayauth.utils.security.CheckRoot&quot;) 对抗更新123adb connect 172.20.103.172 启动wifiadbadb install com.caratlover4.1.0.apkfrida -UF -l hookEvent.js 点击马上更新按钮，触发点击时间，打印点击类 打开jadx逐个查看脱完壳后的dex文件，新版本的jadx对加密后的dex反编译结果会rename 查看ConfirmDialogFragment类，其中有 1234public &#x2F;* synthetic *&#x2F; void onDestroyView() &#123; super.onDestroyView(); g();&#125; 主动调用去除弹窗frida -UF -l disableUPDATE.js 再destory 1234567891011121314151617181920function disableUPDATE()&#123; Java.perform(function()&#123; Java.choose(&quot;com.chanson.business.widget.ConfirmDialogFragment&quot;,&#123; onMatch:function(ins)&#123; &#x2F;&#x2F; 动态方法choose onMatch找到实例进行调用 console.log(&quot;found ins &#x3D;&gt; &quot;,ins); &#x2F;&#x2F; smali或objection看真实方法名 ins.onDestroyView() &#125;, onComplete:function()&#123; console.log(&quot;Search completed!&quot;) &#125; &#125;) &#125;)&#125;function main()&#123; console.log(&quot;Start hook&quot;) disableUPDATE()&#125;setImmediate(main) ![GIF 2021-6-3 16-37-29](克拉恋人会员制取证分析/GIF 2021-6-3 16-37-29.gif) 不过页面无法操作,尝试直接跳到MainActivity 12objection -g com.caratlover explore -P ~&#x2F;.objection&#x2F;pluginsandroid intent launch_activity com.chanson.business.MainActivity tracefrida -U -f com.caratlover -l r0trace.js --runtime=v8 --no-pause -o trace.txt 在traceClass中添加targets = []; 只hook构造函数，点击马上更新 12traceClass(&quot;com.chanson.business.widget.ConfirmDialogFragment&quot;)setTimeout(main, 1000); setImmediate是立即执行函数，setTimeout是等待毫秒后延迟执行函数二者在attach模式下没有区别在spawn模式下，hook系统API时如javax.crypto.Cipher建议使用setImmediate立即执行，不需要延时在spawn模式下，hook应用自己的函数或含壳时，建议使用setImmediate并给出适当的延时(500~5000) 找到com.chanson.business.login.presenter.PhoneLoginPresenter$a.a实现方法 找到a方法的调用处，在switch的baseResponse.getErrorCode()的判断时调用PhoneLoginPresenter.f10498a.a,其中renamed from: com.chanson.business.g.s正是我们trace得到的类 12traceClass(&quot;com.chanson.common.base.BaseResponse&quot;) setTimeout(main, 1000); 尝试tracecom.chanson.common.base.BaseResponse查看getErrorCode的结果，返回10002，正巧会调用PhoneLoginPresenter.f10498a.a((Update) rVar.a(rVar.a(baseResponse.getUpdate()), Update.class)); 使用新版本的apk启动时重新tracecom.chanson.common.base.BaseResponse查看正常情况下case返回的值为10001。 12345Java.use(&quot;com.chanson.common.base.BaseResponse&quot;).getErrorCode.implementation &#x3D; function()&#123; console.log(&quot;Calling getErrorCode &quot;) return 10001;&#125;setTimeout(main,2000) &#x2F;&#x2F; 壳的切换需要时间 frida -U -f com.caratlover -l disableUPDATE.js --no-pausehook getErrorCode直接返回10001，发现正常进入登录，登录时发现我们检测到你的账号存在异常数据，为确保你的账号安全，请重新登录,r0capture抓包发现对版本号进行了校验，接下来将SSLOutputStream的入参改成新版本 1234567891011121314151617181920212223Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (bytearry, int1, int2) &#123; for(var i &#x3D; 0; i &lt; bytearry.length; ++i)&#123; &#x2F;&#x2F; Memory.writeS8(ptr.add(i), array[i]); if(bytearry[i]&#x3D;&#x3D;&#39;0x34&#39;)&#123; console.log(&quot;found 4&quot;); if(bytearry.length - i &gt; 4)&#123; if(bytearry[i+1] &#x3D;&#x3D; &#39;0x2e&#39; &amp;&amp; bytearry[i+2] &#x3D;&#x3D; &#39;0x31&#39; &amp;&amp; bytearry[i+3] &#x3D;&#x3D; &#39;0x2e&#39; &amp;&amp; bytearry[i+4] &#x3D;&#x3D; &#39;0x30&#39; )&#123; bytearry[i+2] &#x3D; 50 console.log(&quot;finally change to 4.2.0!&quot;) &#125; &#125; &#x2F;&#x2F; 4.1.0 字符串转16进制转 0x34 0x2e 0x31 0x2e 0x30 &#125; &#125; var result &#x3D; this.write(bytearry, int1, int2); jhexdump(bytearry) &#x2F;&#x2F; var trafficstring &#x3D; StringClass.$new(bytearry).replace(StringClass.$new(&quot;4.1.0&quot;),StringClass.$new(&quot;4.2.0&quot;)) &#x2F;&#x2F; console.log(&quot;write &#x3D;&gt; &quot;,trafficstring) &#x2F;&#x2F; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()).toString(); &#x2F;&#x2F; var result &#x3D; this.write(trafficstring.getBytes(), int1, int2); return result;&#125; 批量撩妹jadx-gui查看新版本依旧加壳 1234567.&#x2F;fs14216arm64pyenv local 3.9.0git clone https:&#x2F;&#x2F;github.com&#x2F;hanbinglengyue&#x2F;FART.gitadb push frida_fart&#x2F;lib&#x2F;fart* &#x2F;data&#x2F;local&#x2F;tmpadb shell &amp;&amp; cp fart* &#x2F;data&#x2F;app &amp;&amp; chmod 777frida -U -f com.caratlover -l frida_fart_hook.js --no-pause 使用安卓8和安卓8.1进行脱壳mv ..&#x2F;*.dex carat &amp;&amp; adb pull &#x2F;sdcard&#x2F;carat 开启内存漫游 1234pyenv local 3.8.0.&#x2F;fs128arm64objection -g com.caratlover exploreandroid intent launch_activity com.chanson.business.MainActivity 直接绕过强制会员购买页面 将破解vip添加在r0trace的main中执行一次，实现trace某一个类时执行单次hook 123456789101112function main() &#123; Java.perform(function () &#123; console.warn(&quot;r0tracer begin ... !&quot;) Java.perform(function()&#123; Java.use(&quot;com.chanson.business.message.activity.ChatActivity&quot;).Z.implementation &#x3D; function()&#123; console.log(&quot;Calling isVIP &quot;) return false; &#125; &#125;) &#125;)&#125; frida -UF -l hookEvent.js 点击发送消息，触发com.tencent.qcloud.tim.uikit.modules.chat.layout.input.InputLayout`，并弹窗要求付费，我们尝试trace该类的同时并破解vip 12345678910111213function main() &#123; Java.perform(function () &#123; console.warn(&quot;r0tracer begin ... !&quot;) traceClass(&quot;com.tencent.qcloud.tim.uikit.modules.chat.layout.input.InputLayout&quot;); Java.perform(function()&#123; Java.use(&quot;com.chanson.business.message.activity.ChatActivity&quot;).Z.implementation &#x3D; function()&#123; console.log(&quot;Calling isVIP &quot;) return false; &#125; &#125;) &#125;)&#125; frida -UF -l r0tracer.js --no-pause &gt; chat.txt 开启trace,只有frida12 没有runtime=v8的选项，发送消息，查看调用栈 在jadx中找到InputLayout的onClick方法 尝试traceClass(&quot;com.tencent.qcloud.tim.uikit.modules.message.MessageInfoUtil&quot;) 1234567891011121314function main() &#123; Java.perform(function () &#123; console.warn(&quot;r0tracer begin ... !&quot;) traceClass(&quot;com.tencent.qcloud.tim.uikit.modules.message.MessageInfoUtil&quot;) Java.perform(function()&#123; Java.use(&quot;com.chanson.business.message.activity.ChatActivity&quot;).Z.implementation &#x3D; function()&#123; console.log(&quot;Calling isVIP &quot;) return false; &#125; &#125;) &#125;)&#125; frida -UF -l r0tracer.js --no-pause &gt; chat.txt 开启trace，再次发送消息,搜索我们发送的ccccdddd 通过jadx找到com.tencent.qcloud.tim.uikit.modules.message.MessageInfoUtil的buildTextMessage方法 想办法获取MessageInfo返回值的内容 1234567891011121314function main() &#123; Java.perform(function () &#123; console.warn(&quot;r0tracer begin ... !&quot;) traceClass(&quot;com.tencent.qcloud.tim.uikit.modules.message.MessageInfo&quot;) Java.perform(function()&#123; Java.use(&quot;com.chanson.business.message.activity.ChatActivity&quot;).Z.implementation &#x3D; function()&#123; console.log(&quot;Calling isVIP &quot;) return false; &#125; &#125;) &#125;)&#125; frida -UF -l r0tracer.js --no-pause &gt; chat.txt 开启trace，再次发送消息tttttttt,搜索tttttttt Inspecting Fields: =&gt; true =&gt; class com.tencent.qcloud.tim.uikit.modules.message.MessageInfocom.tencent.imsdk.TIMMessage TIMMessage =&gt; TIMMessage{ ConverstaionType:Invalid ConversationId: MsgId:2148258574 MsgSeq:32779 Rand:2148258574 time:1614087810 isSelf:true Status:Sending Sender:klover1_server_550179 elements:[ {Type:Text, Content:tttttttt} ]} =&gt; “&lt;instance: com.tencent.imsdk.TIMMessage&gt;”java.lang.String dataPath =&gt; null =&gt; nullandroid.net.Uri dataUri =&gt; null =&gt; nullcom.tencent.imsdk.TIMElem element =&gt; com.tencent.imsdk.TIMTextElem@7d67029 =&gt; “&lt;instance: com.tencent.imsdk.TIMElem, $className: com.tencent.imsdk.TIMTextElem&gt;”java.lang.Object extra =&gt; tttttttt =&gt; “&lt;instance: java.lang.Object, $className: java.lang.String&gt;”java.lang.String fromUser =&gt; klover1_server_550179 =&gt; “klover1_server_550179”boolean group =&gt; false =&gt; falsejava.lang.String groupNameCard =&gt; null =&gt; nulljava.lang.String id =&gt; 70b42de0-097a-4b9c-927d-13e660ce86a6 =&gt; “70b42de0-097a-4b9c-927d-13e660ce86a6”int imgHeight =&gt; 0 =&gt; 0int imgWidth =&gt; 0 =&gt; 0long msgTime =&gt; 1614087810 =&gt; “1614087810”int msgType =&gt; 0 =&gt; 0boolean peerRead =&gt; false =&gt; falseboolean read =&gt; true =&gt; trueboolean self =&gt; true =&gt; trueint status =&gt; 1 =&gt; 1long uniqueId =&gt; 0 =&gt; “0”int MSG_STATUS_DELETE =&gt; 274 =&gt; 274int MSG_STATUS_DOWNLOADED =&gt; 6 =&gt; 6int MSG_STATUS_DOWNLOADING =&gt; 4 =&gt; 4int MSG_STATUS_NORMAL =&gt; 0 =&gt; 0int MSG_STATUS_READ =&gt; 273 =&gt; 273int MSG_STATUS_REVOKE =&gt; 275 =&gt; 275int MSG_STATUS_SENDING =&gt; 1 =&gt; 1int MSG_STATUS_SEND_FAIL =&gt; 3 =&gt; 3int MSG_STATUS_SEND_SUCCESS =&gt; 2 =&gt; 2int MSG_STATUS_UN_DOWNLOAD =&gt; 5 =&gt; 5int MSG_TYPE_AUDIO =&gt; 48 =&gt; 48int MSG_TYPE_CUSTOM =&gt; 128 =&gt; 128int MSG_TYPE_CUSTOM_FACE =&gt; 112 =&gt; 112int MSG_TYPE_FILE =&gt; 80 =&gt; 80int MSG_TYPE_GROUP_CREATE =&gt; 257 =&gt; 257int MSG_TYPE_GROUP_DELETE =&gt; 258 =&gt; 258int MSG_TYPE_GROUP_JOIN =&gt; 259 =&gt; 259int MSG_TYPE_GROUP_KICK =&gt; 261 =&gt; 261int MSG_TYPE_GROUP_MODIFY_NAME =&gt; 262 =&gt; 262int MSG_TYPE_GROUP_MODIFY_NOTICE =&gt; 263 =&gt; 263int MSG_TYPE_GROUP_QUITE =&gt; 260 =&gt; 260int MSG_TYPE_IMAGE =&gt; 32 =&gt; 32int MSG_TYPE_LOCATION =&gt; 96 =&gt; 96int MSG_TYPE_MIME =&gt; 1 =&gt; 1int MSG_TYPE_TEXT =&gt; 0 =&gt; 0int MSG_TYPE_TIPS =&gt; 256 =&gt; 256int MSG_TYPE_VIDEO =&gt; 64 =&gt; 64[native function h() { [native code]} =&gt; undefined =&gt; undefined entered com.tencent.qcloud.tim.uikit.modules.message.MessageInfo.getTIMMessagejava.lang.Throwable at com.tencent.qcloud.tim.uikit.modules.message.MessageInfo.getTIMMessage(Native Method) at com.tencent.qcloud.tim.uikit.modules.chat.base.ChatManagerKit.sendMessage(SourceFile:11) 主要逻辑在this.mCurrentConversation.sendMessage，进入sendMessage方法 进入conversation.sendMessage方法 具体流程在native层，使用的是腾讯云sdk，很难抓到包，不过可以在com.tencent.qcloud.tim.uikit.modules.message.MessageInfoUtil.buildTextMessage构造消息体 123456android heap search instances com.tencent.imsdk.TIMManager android hooking list class_methods com.tencent.imsdk.TIMManagerandroid heap execute 227890024 getLoginUser 根据堆中的实例主动调用方法android heap execute 227890024 getVersionandroid hooking search classes TIMConversationandroid hooking list class_methods com.tencent.imsdk.TIMConversation trace单个函数在r0trace中添加 123if(targetMethod.toString().indexOf(&quot;getConversation&quot;) &lt; 0)&#123; return&#125; 查看腾讯云官方文档文档中心 &gt; 即时通信 IM &gt; SDK 文档 &gt; 旧版 API 教程 &gt; 消息收发 &gt; 消息收发（Android）,获取会话由 TIMManager 中的 getConversation 实现。 1234567891011121314151617function TIMManager() &#123; Java.perform(function () &#123; Java.choose(&quot;com.tencent.imsdk.TIMManager&quot;, &#123; onMatch: function (ins) &#123; console.log(&quot;found ins &#x3D;&gt; &quot;, ins) console.log(&quot;found ins.getNetworkStatus() &#x3D;&gt; &quot;, ins.getNetworkStatus()) console.log(&quot;found ins.getSdkConfig() &#x3D;&gt; &quot;, ins.getSdkConfig()) console.log(&quot;found ins.getUserConfig() &#x3D;&gt; &quot;, ins.getUserConfig()) &#x2F;&#x2F;看不到内容可以通过r0trace的inspectObject单独看 var output &#x3D; &quot;&quot;; output &#x3D; inspectObject(ins.getUserConfig(), output); console.log(output) &#125;, onComplete: function () &#123; console.log(&quot;search compeled&quot;) &#125; &#125;) &#125;)&#125; 尝试trace腾讯云sdk,frida -UF -l r0tracer.js --no-pause -o chat.txt,重新进入聊天界面获取log中的peer，即用户id 12345678910111213function main() &#123; Java.perform(function () &#123; console.warn(&quot;r0tracer begin ... !&quot;) traceClass(&quot;com.tencent.imsdk.TIMManager&quot;) Java.perform(function()&#123; Java.use(&quot;com.chanson.business.message.activity.ChatActivity&quot;).Z.implementation &#x3D; function()&#123; console.log(&quot;Calling isVIP &quot;) return false; &#125; &#125;) &#125;)&#125; 有了peer就可以调用TIMManager.getInstance().getConversation的sendMessage发送消息了 1234567891011121314151617181920212223242526272829303132333435363738394041function TIMManager() &#123; Java.perform(function () &#123; Java.choose(&quot;com.tencent.imsdk.TIMManager&quot;, &#123; onMatch: function (ins) &#123; console.log(&quot;found ins &#x3D;&gt; &quot;, ins) console.log(&quot;found ins.getNetworkStatus() &#x3D;&gt; &quot;, ins.getNetworkStatus()) console.log(&quot;found ins.getSdkConfig() &#x3D;&gt; &quot;, ins.getSdkConfig()) &#x2F;&#x2F; console.log(&quot;found ins.getUserConfig() &#x3D;&gt; &quot;, ins.getUserConfig()) 看不到内容可以通过r0trace的inspectObject单独看 &#x2F;&#x2F; var output &#x3D; &quot;&quot;; &#x2F;&#x2F; output &#x3D; inspectObject(ins.getUserConfig(), output); &#x2F;&#x2F; console.log(output) var peer &#x3D; Java.use(&#39;java.lang.String&#39;).$new(&quot;klover1_server_190249&quot;); &#x2F;&#x2F; 这就是peer用户id var conversation &#x3D; ins.getConversation(Java.use(&quot;com.tencent.imsdk.TIMConversationType&quot;).C2C.value, peer); var msg &#x3D; Java.use(&quot;com.tencent.imsdk.TIMMessage&quot;).$new(); &#x2F;&#x2F;添加文本内容 var elem &#x3D; Java.use(&quot;com.tencent.imsdk.TIMTextElem&quot;).$new(); elem.setText(Java.use(&quot;java.lang.String&quot;).$new(&quot;cpdd&quot;)); msg.addElement(elem) const callback &#x3D; Java.registerClass(&#123; &#x2F;&#x2F; new 一个接口 name: &#39;callback&#39;, implements: [Java.use(&quot;com.tencent.imsdk.TIMValueCallBack&quot;)], methods: &#123; onError(code, desc) &#123; console.log(&quot;send message failed. code: &quot; + code + &quot; errmsg: &quot; + desc); &#125;, onSuccess(msg) &#123;&#x2F;&#x2F;发送消息成功 console.log(&quot;SendMsg ok&quot; + msg); &#125;, &#125; &#125;); conversation.sendMessage(msg, callback.$new()) &#125;, onComplete: function () &#123; console.log(&quot;search compeled&quot;) &#125; &#125;) &#125;)&#125; 以上实现了sdk中完整的发送消息的流程 调用批量发送 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function TIMManager() &#123; Java.perform(function () &#123; Java.choose(&quot;com.tencent.imsdk.TIMManager&quot;, &#123; onMatch: function (ins) &#123; console.log(&quot;found ins &#x3D;&gt; &quot;, ins) console.log(&quot;found ins.getNetworkStatus() &#x3D;&gt; &quot;, ins.getNetworkStatus()) console.log(&quot;found ins.getSdkConfig() &#x3D;&gt; &quot;, ins.getSdkConfig()) &#x2F;&#x2F; console.log(&quot;found ins.getUserConfig() &#x3D;&gt; &quot;, ins.getUserConfig()) 看不到内容可以通过r0trace的inspectObject单独看 &#x2F;&#x2F; var output &#x3D; &quot;&quot;; &#x2F;&#x2F; output &#x3D; inspectObject(ins.getUserConfig(), output); &#x2F;&#x2F; console.log(output) console.log(&quot;found ins.getConversationList() &#x3D;&gt; &quot;, ins.getConversationList()) console.log(&quot;found ins.getConversationList() &#x3D;&gt; &quot;, ins.getConversationList().toString()) console.log(&quot;found ins.getConversationList() &#x3D;&gt; &quot;, JSON.stringify(ins.getConversationList())) var iter &#x3D; ins.getConversationList().listIterator(); while (iter.hasNext()) &#123; console.log(iter.next()); if (iter.next() !&#x3D; null) &#123; var TIMConversation &#x3D; Java.cast(iter.next(), Java.use(&quot;com.tencent.imsdk.TIMConversation&quot;)) console.log(TIMConversation.getPeer()); &#x2F;&#x2F; if (TIMConversation.getPeer().toString().indexOf(&quot;209509&quot;) &gt;&#x3D; 0) &#123; console.log(&quot;try send message...&quot;) &#x2F;&#x2F;构造一条消息 var msg &#x3D; Java.use(&quot;com.tencent.imsdk.TIMMessage&quot;).$new(); &#x2F;&#x2F;添加文本内容 var elem &#x3D; Java.use(&quot;com.tencent.imsdk.TIMTextElem&quot;).$new(); elem.setText(&quot;cpdd 你是唯一 问我是谁 codewj&quot;); &#x2F;&#x2F;将elem添加到消息 msg.addElement(elem) const callback &#x3D; Java.registerClass(&#123; name: &#39;com.tencent.imsdk.TIMValueCallBackCallback&#39;, implements: [Java.use(&quot;com.tencent.imsdk.TIMValueCallBack&quot;)], methods: &#123; onError(i, str) &#123; console.log(&quot;send message failed. code: &quot; + i + &quot; errmsg: &quot; + str) &#125;, onSuccess(msg) &#123; console.log(&quot;SendMsg ok&quot;, +msg) &#125; &#125; &#125;); &#x2F;&#x2F;发送消息 TIMConversation.sendMessage(msg, callback.$new()) &#125; &#125; &#125;, onComplete: function () &#123; console.log(&quot;search compeled&quot;) &#125; &#125;) &#125;)&#125;","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"haydream收费直播间的取证分析","slug":"haydream收费直播间的取证分析","date":"2021-05-29T03:49:08.000Z","updated":"2021-05-31T14:39:52.504Z","comments":true,"path":"2021/05/29/haydream收费直播间的取证分析/","link":"","permalink":"http://onejane.github.io/2021/05/29/haydream%E6%94%B6%E8%B4%B9%E7%9B%B4%E6%92%AD%E9%97%B4%E7%9A%84%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/","excerpt":"","text":"脱壳 1234567git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;FRIDA-DEXDump.git.&#x2F;fs1280arm64pyenv local 3.8.0python main.py app保持最前端,开始脱壳python merge_dex.py .&#x2F;com.hay.dreamlover&#x2F; livedex 将脱壳后的dex反编译成java，推荐！！！git clone https:&#x2F;&#x2F;github.com&#x2F;Simp1er&#x2F;AndroidSec.git python dex2apk.py -a haydream.apk -i .&#x2F;com.hay.dreamlover -o output.apk 将脱壳后的dex重打包成apk 抓包charles-postern连接socks5启动vpn 发现任何一个页面只要连接代理或者vpn都无法访问请求 某抢票app逆向续篇之干掉vpn抓包检测 api有java.net.NetworkInterface.getName(),android.net.ConnectivityManager 1234567891011objection -g com.hay.dreamlover exploreandroid hooking search classes networkinterfaceandroid hooking watch class java.net.NetworkInterfaceandroid hooking search classes connectivitymanagerandroid hooking watch class android.net.ConnectivityManagerandroid hooking watch class android.net.IConnectivityManager 进入页面后果然触发了这些方法，说明确实做了vpn检测android hooking watch class_method android.net.ConnectivityManager.getActiveNetworkInfo --dump-args --dump-backtrace --dump-return 打印调用栈，通过jadx查看LiveNetChecker,尝试使用frida脚本过这段代码逻辑git clone https:&#x2F;&#x2F;github.com&#x2F;r0ysue&#x2F;r0capture.gitpython3 r0capture.py -U com.hay.dreamlover -v 先打开app后attach，log显示127.0.0.1和127.0.0.1通信，且所有内容都已经加密frida -U -f com.hay.dreamlover -l script.js -o out.txtpython3 r0capture.py -U com.hay.dreamlover -v -w 3 延迟3秒 使用带有kali nethunter底包的nexus 6p，开启ssh服务 12345ssh root@192.168.0.104 默认密码toorjnettop 点开直播间，可以看到直播间地址和ip手机自制路由器，电脑插上网卡连接到虚拟机，nm-connection-editor，新加一个Wi-Fi,设置SSID，Mode设置Hotspot,Band设置B&#x2F;G(2.4 GHZ),Device选择wlan0,配置IPv4 Settings的Address,手机即可收到新wifi热点lsusb 查看设备型号wireshark 抓包 收费直播间分析直播弹窗倒计时9s后强制退出 1234567objection -g com.hay.dreamlover exploreandroid hooking search classes Dialogandroid hooking search classes AlertDialogandroid hooking search classes PopupWindowandroid hooking watch class android.app.Dialog --dump-args --dump-backtrace --dump-returnandroid hooking watch class android.app.AlertDialog --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method android.app.Dialog.show --dump-args --dump-backtrace --dump-return (agent) [8z3ukmteu2y] Called android.app.Dialog.show()(agent) [8z3ukmteu2y] Backtrace: android.app.Dialog.show(Native Method) com.fanwe.lib.dialog.impl.SDDialogBase.show(SDDialogBase.java:337) com.fanwe.live.activity.room.LiveLayoutViewerExtendActivity.showScenePayJoinDialog(LiveLayoutViewerExtendActivity.java:618) com.fanwe.live.activity.room.LiveLayoutViewerExtendActivity.onScenePayViewerShowWhetherJoin(LiveLayoutViewerExtendActivity.java:516) com.fanwe.pay.LiveScenePayViewerBusiness.dealPayModelRoomInfoSuccess(LiveScenePayViewerBusiness.java:156) com.fanwe.live.activity.room.LiveLayoutViewerExtendActivity.onBsRequestRoomInfoSuccess(LiveLayoutViewerExtendActivity.java:111) com.fanwe.live.activity.room.LivePushViewerActivity.onBsRequestRoomInfoSuccess(LivePushViewerActivity.java:405) com.fanwe.live.business.LiveBusiness.onRequestRoomInfoSuccess(LiveBusiness.java:306) com.fanwe.live.business.LiveViewerBusiness.onRequestRoomInfoSuccess(LiveViewerBusiness.java:79) com.fanwe.live.business.LiveBusiness$2.onSuccess(LiveBusiness.java:257) com.fanwe.library.adapter.http.callback.SDRequestCallback.onSuccessInternal(SDRequestCallback.java:127) com.fanwe.library.adapter.http.callback.SDRequestCallback.notifySuccess(SDRequestCallback.java:175) com.fanwe.hybrid.http.AppHttpUtil$1.onSuccess(AppHttpUtil.java:105) com.fanwe.hybrid.http.AppHttpUtil$1.onSuccess(AppHttpUtil.java:74) org.xutils.http.HttpTask.onSuccess(HttpTask.java:447) org.xutils.common.task.TaskProxy$InternalHandler.handleMessage(TaskProxy.java:198) android.os.Handler.dispatchMessage(Handler.java:106) android.os.Looper.loop(Looper.java:164) android.app.ActivityThread.main(ActivityThread.java:6494) java.lang.reflect.Method.invoke(Native Method) com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438) com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807) (agent) [8z3ukmteu2y] Return Value: (none) frida -UF -l trace.js -o hay.txt 打印了多个android.app.Dialog.show 1traceClass(&quot;android.app.Dialog&quot;) 结合jadx分析弹窗堆栈，实现逻辑可以干掉弹窗或者干掉倒计时 1234android hooking search methods startCountDownandroid hooking watch class com.fanwe.pay.appview.PayLiveBlackBgView 进入直播间确实触发了该方法android hooking watch class_method com.fanwe.pay.appview.PayLiveBlackBgView.startCountDown --dump-args --dump-backtrace --dump-return android hooking list class_methods com.fanwe.lib.dialog.impl.SDDialogBase frida -UF -l hookVIP.js 破解收费直播间 1234567891011121314setImmediate(function()&#123; Java.perform(function()&#123; console.log(&quot;Entering hook&quot;) &#x2F;&#x2F; 干掉弹窗 Java.use(&quot;com.fanwe.lib.dialog.impl.SDDialogBase&quot;).show.implementation &#x3D; function()&#123; console.log(&quot;hook show &quot;) &#125; &#x2F;&#x2F; 设置倒计时 Java.use(&quot;com.fanwe.pay.appview.PayLiveBlackBgView&quot;).startCountDown.implementation &#x3D; function(x)&#123; console.log(&quot;Calling countdown &quot;) return this.startCountDown(1000*3600) &#125; &#125;)&#125;) 在 com.fanwe.live.business.LiveBusiness.onRequestRoomInfoSuccess类中大部分request都来自于CommonInterface类 123456android hooking watch class com.fanwe.live.common.CommonInterface 每进一个房间或下拉自动触发该类的方法android hooking watch class_method com.fanwe.live.common.CommonInterface.requestIndex --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method com.fanwe.live.common.CommonInterface.requestRoomInfo --dump-args --dump-backtrace --dump-return 进入直播间，log打印room_idplugin wallbreaker classdump --fullname com.fanwe.live.business.LiveBusiness$2android hooking search classes com.fanwe.live.business.LiveBusinessandroid hooking watch class com.fanwe.live.business.LiveBusiness (agent) [2xhzmmkxx1r] Called com.fanwe.live.common.CommonInterface.requestIndex(int, int, int, java.lang.String, com.fanwe.hybrid.http.AppRequestCallback) (agent) [2xhzmmkxx1r] Backtrace: com.fanwe.live.common.CommonInterface.requestIndex(Native Method) com.fanwe.live.appview.main.LiveTabHotView.requestData(LiveTabHotView.java:390) com.fanwe.live.appview.main.LiveTabHotView.onLoopRun(LiveTabHotView.java:382) com.fanwe.live.appview.main.LiveTabBaseView$1.run(LiveTabBaseView.java:116) com.fanwe.lib.looper.impl.SDSimpleLooper$1.handleMessage(SDSimpleLooper.java:54) android.os.Handler.dispatchMessage(Handler.java:106) android.os.Looper.loop(Looper.java:164) android.app.ActivityThread.main(ActivityThread.java:6494) java.lang.reflect.Method.invoke(Native Method) com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438) com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807) (agent) [2xhzmmkxx1r] Arguments com.fanwe.live.common.CommonInterface.requestIndex(1, (none), (none), 热门, com.fanwe.live.appview.main.LiveTabHotView$4@89cbef4)(agent) [2xhzmmkxx1r] Return Value: (none) 123android hooking search classes SDResponseplugin wallbreaker classdump --fullname com.fanwe.library.adapter.http.model.SDResponseandroid hooking watch class_method com.fanwe.library.adapter.http.model.SDResponse.getDecryptedResult --dump-args --dump-backtrace --dump-return frida -UF -l requestIndex.js 主动调用获取房间列表和详情 123456789101112131415161718192021222324252627282930313233343536373839404142434445function hook() &#123; Java.perform(function () &#123; var JSON &#x3D; Java.use(&quot;com.alibaba.fastjson.JSON&quot;) var Index_indexActModel &#x3D; Java.use(&quot;com.fanwe.live.model.Index_indexActModel&quot;); var gson &#x3D; Java.use(&quot;com.google.gson.Gson&quot;).$new(); var LiveRoomModel &#x3D; Java.use(&quot;com.fanwe.live.model.LiveRoomModel&quot;); Java.use(&quot;com.fanwe.live.appview.main.LiveTabHotView$4&quot;).onSuccess.implementation &#x3D; function (resp) &#123; console.log(&quot;Entering Room List Parser &#x3D;&gt; &quot;, resp) var result &#x3D; resp.getDecryptedResult(); &#x2F;&#x2F; 转成json对象 var resultModel &#x3D; JSON.parseObject(result, Index_indexActModel.class); &#x2F;&#x2F; json转成java对象，并调用getList方法 var roomList &#x3D; Java.cast(resultModel, Index_indexActModel).getList(); console.log(&quot;size : &quot;, roomList.size(), roomList.get(0)) for (var i &#x3D; 0; i &lt; roomList.size(); i++) &#123; var LiveRoomModelInfo &#x3D; Java.cast(roomList.get(i), LiveRoomModel); console.log(&quot;roominfo: &quot;, i, &quot; &quot;, gson.toJson(LiveRoomModelInfo)); &#125; return this.onSuccess(resp) &#125; &#125;)&#125;&#x2F;&#x2F; 主动调用function invoke()&#123; Java.perform(function()&#123; Java.choose(&quot;com.fanwe.live.appview.main.LiveTabHotView&quot;,&#123; onMatch:function(ins)&#123; console.log(&quot;found ins &#x3D;&gt; &quot;,ins) ins.requestData(); &#125;,onComplete:function()&#123; console.log(&quot;Search completed!&quot;) &#125; &#125;) &#125;)&#125;function main() &#123; hook() &#x2F;&#x2F; invoke()&#125;setImmediate(main) frida -UF -l requestRoomInfo.js 1234567891011121314151617181920212223242526272829303132333435363738394041&#x2F;&#x2F; 遍历类所有的域function inspectObject(obj) &#123; Java.perform(function () &#123; const Class &#x3D; Java.use(&quot;java.lang.Class&quot;); const obj_class &#x3D; Java.cast(obj.getClass(), Class); const fields &#x3D; obj_class.getDeclaredFields(); const methods &#x3D; obj_class.getMethods(); console.log(&quot;Inspecting &quot; + obj.getClass().toString()); console.log(&quot;\\tFields:&quot;); for (var i in fields)&#123; &#x2F;&#x2F; console.log(&quot;\\t\\t&quot; + fields[i].toString()); var className &#x3D; obj_class.toString().trim().split(&quot; &quot;)[1] ; &#x2F;&#x2F; console.log(&quot;className is &#x3D;&gt; &quot;,className); var fieldName &#x3D; fields[i].toString().split(className.concat(&quot;.&quot;)).pop() ; console.log(fieldName + &quot; &#x3D;&gt; &quot;,obj[fieldName].value); &#125; &#x2F;&#x2F; console.log(&quot;\\tMethods:&quot;); &#x2F;&#x2F; for (var i in methods) &#x2F;&#x2F; console.log(&quot;\\t\\t&quot; + methods[i].toString()); &#125;)&#125;&#x2F;&#x2F; 打印调用结果的域及信息，类似wallbreakerfunction hookROOMinfo() &#123; Java.perform(function () &#123; var JSON &#x3D; Java.use(&quot;com.alibaba.fastjson.JSON&quot;) var gson &#x3D; Java.use(&quot;com.google.gson.Gson&quot;).$new(); var App_get_videoActModel &#x3D; Java.use(&quot;com.fanwe.live.model.App_get_videoActModel&quot;); Java.use(&quot;com.fanwe.live.business.LiveBusiness$2&quot;).onSuccess.implementation &#x3D; function (resp) &#123; console.log(&quot;Enter LiveBusiness$2 ... &quot;, resp) var result &#x3D; resp.getDecryptedResult(); var resultVideoModel &#x3D; JSON.parseObject(result, App_get_videoActModel.class); var roomDetail &#x3D; Java.cast(resultVideoModel, App_get_videoActModel); console.log(&quot;room id is &#x3D;&gt; &quot;, roomDetail.getRoom_id()); inspectObject(roomDetail); return this.onSuccess(resp); &#125; &#125;)&#125; 当jadx找不到类的时候，说明脱壳没脱全，通过objection去内存即可搜刮wallbreak内存漫游。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&#x2F;&#x2F; 内存中捞不到类function invoke()&#123; Java.perform(function()&#123; Java.choose(&quot;com.fanwe.live.business.LiveBusiness&quot;,&#123; onMatch:function(ins)&#123; console.log(&quot;found ins &#x3D;&gt; &quot;,ins) &#x2F;&#x2F; ins.requestData(); &#125;,onComplete:function()&#123; console.log(&quot;Search completed!&quot;) &#125; &#125;) &#125;)&#125;&#x2F;&#x2F; 自行调用构造函数创建类function invoke2()&#123; Java.perform(function()&#123; &#x2F;&#x2F; com.fanwe.live.business.LiveBusiness(ILiveActivity); var ILiveActivity &#x3D; Java.use(&quot;com.fanwe.live.activity.room.ILiveActivity&quot;); &#x2F;&#x2F; 实现接口 const ILiveActivityImpl &#x3D; Java.registerClass(&#123; name: &#39;com.fanwe.live.activity.room.ILiveActivityImpl&#39;, implements: [ILiveActivity], methods: &#123; openSendMsg()&#123;&#125;, getCreaterId()&#123;&#125;, getGroupId()&#123;&#125;, getRoomId()&#123;&#125;, getRoomInfo()&#123;&#125;, getSdkType()&#123;&#125;, isAuctioning()&#123;&#125;, isCreater()&#123;&#125;, isPlayback()&#123;&#125;, isPrivate()&#123;&#125; &#125; &#125;); var result &#x3D; Java.use(&quot;com.fanwe.live.business.LiveBusiness&quot;).$new(ILiveActivityImpl.$new()); console.log(&quot;result is &#x3D;&gt; &quot;,result.requestRoomInfo(&quot;123454&quot;)) &#125;)&#125;var LiveBusiness &#x3D; null ;console.log(&quot;LiveBusiness is &#x3D;&gt; &quot;, LiveBusiness)function hook3()&#123; Java.perform(function()&#123; Java.use(&quot;com.fanwe.live.business.LiveBusiness&quot;).getLiveQualityData.implementation &#x3D; function()&#123; LiveBusiness &#x3D; this; console.log(&quot;now LiveBusiness is &#x3D;&gt; &quot;, LiveBusiness) LiveBusiness.requestRoomInfo(&quot;12343&quot;); var result &#x3D; this.getLiveQualityData() return result; &#125; &#125;)&#125;function invoke3()&#123; Java.perform(function()&#123; var result &#x3D; LiveBusiness.requestRoomInfo(&quot;12343&quot;); console.log(&quot;result is &#x3D;&gt; &quot;,result) &#125;)&#125;function invoke4()&#123; Java.perform(function()&#123; &#x2F;&#x2F; com.fanwe.live.business.LiveBusiness(ILiveActivity); var ILiveActivity &#x3D; Java.use(&quot;com.fanwe.live.activity.room.ILiveActivity&quot;); const ILiveActivityImpl &#x3D; Java.registerClass(&#123; name: &#39;com.fanwe.live.activity.room.ILiveActivityImpl&#39;, implements: [ILiveActivity], methods: &#123; openSendMsg()&#123;&#125;, getCreaterId()&#123;&#125;, getGroupId()&#123;&#125;, getRoomId()&#123;&#125;, getRoomInfo()&#123;&#125;, getSdkType()&#123;&#125;, isAuctioning()&#123;&#125;, isCreater()&#123;&#125;, isPlayback()&#123;&#125;, isPrivate()&#123;&#125; &#125; &#125;); var LB &#x3D; Java.use(&quot;com.fanwe.live.business.LiveBusiness&quot;).$new(ILiveActivityImpl.$new()); var LB2 &#x3D; Java.use(&quot;com.fanwe.live.business.LiveBusiness$2&quot;); var AppRequestCallback &#x3D; Java.use(&#39;com.fanwe.hybrid.http.AppRequestCallback&#39;); Java.use(&quot;com.fanwe.live.common.CommonInterface&quot;).requestRoomInfo(1377894,123,&quot;1234&quot;,Java.cast(LB2.$new(LB),AppRequestCallback)); &#125;)&#125;function main() &#123; hookROOMinfo(); hook3();&#125;setImmediate(main) 以上hook2时无法返回数据，是因为roomId为空，获取room_id时发现getRoomId来自于一个接口ILiveInfo，可以通过该接口找到实现类，或者通过jadx的smali查看是不是确实为getRoomId。 12android hooking search methods getRoomId 全局搜索方法android hooking watch class_method com.fanwe.live.activity.room.LiveActivity.getRoomId --dump-args --dump-backtrace --dump-return 123456789101112131415161718192021222324252627282930313233343536function hookROOMinfo() &#123; Java.perform(function () &#123; var JSON &#x3D; Java.use(&quot;com.alibaba.fastjson.JSON&quot;) var gson &#x3D; Java.use(&quot;com.google.gson.Gson&quot;).$new(); var App_get_videoActModel &#x3D; Java.use(&quot;com.fanwe.live.model.App_get_videoActModel&quot;); Java.use(&quot;com.fanwe.live.business.LiveBusiness$2&quot;).onSuccess.implementation &#x3D; function (resp) &#123; console.log(&quot;Enter LiveBusiness$2 ... &quot;, resp) var result &#x3D; resp.getDecryptedResult(); var resultVideoModel &#x3D; JSON.parseObject(result, App_get_videoActModel.class); var roomDetail &#x3D; Java.cast(resultVideoModel, App_get_videoActModel); console.log(&quot;room id is &#x3D;&gt; &quot;, roomDetail.getRoom_id()); inspectObject(roomDetail); return this.onSuccess(resp); &#125; &#x2F;&#x2F; 直接主动调用，设置房间号 &#x2F;&#x2F; Java.use(&quot;com.fanwe.live.common.CommonInterface&quot;).requestRoomInfo.implementation &#x3D; function (roomid, vod, key, ins) &#123; &#x2F;&#x2F; console.log(&quot;Calling common.CommonInterface.requestRoomInfo...&quot;) &#x2F;&#x2F; return this.requestRoomInfo(1379212, vod, key, ins); &#x2F;&#x2F; &#125; Java.use(&quot;com.fanwe.live.LiveInformation&quot;).getRoomId.implementation &#x3D; function()&#123; console.log(&quot;calling com.fanwe.live.activity.room.LiveActivity.getRoomId ...&quot;) return 1379212 ; &#125; &#x2F;&#x2F; com.fanwe.live.ILiveInfo.getRoomId &#x2F;&#x2F; com.fanwe.live.LiveInformation.getRoomId &#x2F;&#x2F; com.fanwe.live.activity.room.LiveActivity.getRoomId &#x2F;&#x2F; com.fanwe.live.appview.room.RoomSelectFriendsView.getRoomId &#x2F;&#x2F; com.fanwe.live.model.CreateLiveData.getRoomId &#x2F;&#x2F; com.fanwe.live.model.JoinLiveData.getRoomId &#x2F;&#x2F; com.fanwe.live.model.JoinPlayBackData.getRoomId &#125;)&#125; frida -UF -l rquestRoomInfo.js 再次调用invoke2()实现房间详情抓取 主动调用的原则：离数据越远，中间需要自己实现的细节就越多；哪个细节实现不对，APP就崩掉了。 针对单个类AppHttpUtil找不到，使用fart可以脱单个类 1234567android hooking search classes AppHttpUtilgit clone https:&#x2F;&#x2F;github.com&#x2F;hanbinglengyue&#x2F;FART.gitadb push lib&#x2F;fart* &#x2F;data&#x2F;local&#x2F;tmpadb shell -&gt;cp fart* &#x2F;data&#x2F;app &amp;&amp; chmod 777frida -UF -l frida_fart_reflection.jsdump(&quot;com.fanwe.hybrid.http.AppHttpUtil&quot;)adb pull &#x2F;sdcard&#x2F;6850924_22686.dex 通过jadx-gui打开看不到源码，file 6850924_22686.dex是data格式，而非Dalvik dex格式。通过010 Editor打开该dex发现文件魔术字全是00 00 00 00 00 00 00 00, 查看正常dex文件头为64 65 78 0a 30 33 35 00，再次打开即可找到AppHttpUtil，可以看到拼接参数时用的标准的加密库。 使用沙箱安装该apk后查看/data/data/com.hay.dreamlover的加密文件数据，找到Cipher文件中base64定位加解密的方法。 1android hooking watch class_method com.fanwe.library.utils.MD5Util.MD5 --dump-args --dump-backtrace --dump-return 通过vnc连接kali nethunter后启动wireshark抓包，保存为pcapng格式文件，使用电脑分析，找到最终发出去的包，发现通过本地端口转发出去，获取请求头参数后实现解密 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283## Time: 2020-7-31 19:41:11## com.hay.dreamlover import requests, os, time, sysfrom lxml import etreeimport reimport jsonimport threadingimport hashlibimport base64from urllib import parse# import click# import frida# import logging# import tracebackimport base64import refrom Crypto.Cipher import AES# https:&#x2F;&#x2F;blog.csdn.net&#x2F;wangziyang777&#x2F;article&#x2F;details&#x2F;104982823## aes 加密&#x2F;解密class AESECB: def __init__(self, key): self.key &#x3D; key self.mode &#x3D; AES.MODE_ECB self.bs &#x3D; 16 # block size self.PADDING &#x3D; lambda s: s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs) def encrypt(self, text): generator &#x3D; AES.new(self.key, self.mode) # ECB模式无需向量iv crypt &#x3D; generator.encrypt(self.PADDING(text)) crypted_str &#x3D; base64.b64encode(crypt) result &#x3D; crypted_str.decode() return result def decrypt(self, text): generator &#x3D; AES.new(self.key, self.mode) # ECB模式无需向量iv text +&#x3D; (len(text) % 4) * &#39;&#x3D;&#39; decrpyt_bytes &#x3D; base64.b64decode(text) meg &#x3D; generator.decrypt(decrpyt_bytes) # 去除解码后的非法字符 try: result &#x3D; re.compile(&#39;[\\\\x00-\\\\x08\\\\x0b-\\\\x0c\\\\x0e-\\\\x1f\\n\\r\\t]&#39;).sub(&#39;&#39;, meg.decode()) except Exception: result &#x3D; &#39;解码失败，请重试!&#39; return result#计算密码的md5值def get_md5(s): md &#x3D; hashlib.md5() md.update(s.encode(&#39;utf-8&#39;)) return md.hexdigest()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: aes &#x3D; AESECB(&#39;8648754518945235&#39;) ctl &#x3D; &quot;index&quot; act &#x3D; &quot;index&quot; signqt &#x3D; get_md5(&quot;528094&amp;*3564695()&quot; + ctl + &quot;+_&quot; + act + &quot;@!@###@&quot;); timeqt &#x3D; str(round(time.time() * 1000)); headers &#x3D; &#123;&quot;X-JSL-API-AUTH&quot;:&quot;sha1|1596358731|VOI1X6448Y4f4E|fd941812d5b875b021f92cf2b0044552462d8cd9&quot;&#125;; body &#x3D; &#123;&quot;screen_width&quot;:1080, &quot;screen_height&quot;:1794, &quot;sdk_type&quot;:&quot;android&quot;, &quot;sdk_version_name&quot;:&quot;1.3.0&quot;, &quot;sdk_version&quot;:2020031801, &quot;xpoint&quot;:120.107042, &quot;ypoint&quot;:30.302162, &quot;ctl&quot;:ctl, &quot;act&quot;:&quot;new_video&quot;, &quot;p&quot;:1, &quot;signqt&quot;:signqt, &quot;timeqt&quot;:timeqt&#125; requestData &#x3D; aes.encrypt(str(body)); url &#x3D; &quot;http:&#x2F;&#x2F;hhy2.hhyssing.com:37462&#x2F;mapi&#x2F;index.php?requestData&#x3D;&quot; + requestData + &quot;i_type&#x3D;1&amp;ctl&#x3D;&quot; + ctl + &quot;&amp;act&#x3D;&quot; + act; rsp &#x3D; requests.post(url, headers &#x3D; headers); result &#x3D; json.loads(rsp.text).get(&quot;output&quot;); decodeAes &#x3D; AESECB(&quot;7489148794156147&quot;); print(decodeAes.decrypt(result)); python r0capture.py -U com.hay.dreamlover -v -w 3 &gt;&gt; hay.txt 抓包进出直播间,查看请求 netstat -tuulp|grep hay 查看端口 adb forward tcp:37462 tcp:37462 将给本地发请求包转发到手机端的37462端口 nethunter 中wireshark抓lo包，本地对本地的包，因为app都是对本地请求，再转发到服务端(使用vnc viewer连接) 阿里游戏盾SDK的作用： 防止抓包 隐藏真实的服务器地址，流量包二次 抗D","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"ElasticSearch之搜索引擎结果分析","slug":"ElasticSearch之搜索引擎结果分析","date":"2021-05-25T09:09:09.000Z","updated":"2021-05-29T03:44:28.806Z","comments":true,"path":"2021/05/25/ElasticSearch之搜索引擎结果分析/","link":"","permalink":"http://onejane.github.io/2021/05/25/ElasticSearch%E4%B9%8B%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90/","excerpt":"","text":"_search解析1234567891011121314151617181920212223242526GET &#x2F;_search&#123; &quot;took&quot;: 6, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 6, &quot;successful&quot;: 6, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: 10, &quot;max_score&quot;: 1, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;.kibana&quot;, &quot;_type&quot;: &quot;config&quot;, &quot;_id&quot;: &quot;5.2.0&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;buildNum&quot;: 14695 &#125; &#125; ] &#125;&#125; took：整个搜索请求花费了多少毫秒 hits.total：本次搜索，返回了几条结果hits.max_score：本次搜索的所有结果中，最大的相关度分数是多少，每一条document对于search的相关度，越相关，_score分数越大，排位越靠前hits.hits：默认查询前10条数据，完整数据，_score降序排序 shards：shards fail的条件（primary和replica全部挂掉），不影响其他shard。默认情况下来说，一个搜索请求，会打到一个index的所有primary shard上去，当然了，每个primary shard都可能会有一个或多个replic shard，所以请求也可以到primary shard的其中一个replica shard上去。 timeout：默认无timeout，latency平衡completeness，手动指定timeout，timeout查询执行机制 timeout=10ms，timeout=1s，timeout=1mGET /_search?timeout=10m 搜索模式解析multi-index和multi-type搜索模式 12345678&#x2F;_search：所有索引，所有type下的所有数据都搜索出来&#x2F;index1&#x2F;_search：指定一个index，搜索其下所有type的数据&#x2F;index1,index2&#x2F;_search：同时搜索两个index下的数据&#x2F;*1,*2&#x2F;_search：按照通配符去匹配多个索引&#x2F;index1&#x2F;type1&#x2F;_search：搜索一个index下指定的type的数据&#x2F;index1&#x2F;type1,type2&#x2F;_search：可以搜索一个index下多个type的数据&#x2F;index1,index2&#x2F;type1,type2&#x2F;_search：搜索多个index下的多个type的数据&#x2F;_all&#x2F;type1,type2&#x2F;_search：_all可以代表搜索所有index下的指定type的数据 exact value 2017-01-01，exact value，搜索的时候，必须输入2017-01-01，才能搜索出来，如果你输入一个01，是搜索不出来的 full text（1）缩写 vs. 全程：cn vs. china（2）格式转化：like liked likes（3）大小写：Tom vs tom（4）同义词：like vs love 2017-01-01，2017 01 01，搜索2017，或者01，都可以搜索出来china，搜索cn，也可以将china搜索出来likes，搜索like，也可以将likes搜索出来Tom，搜索tom，也可以将Tom搜索出来like，搜索love，同义词，也可以将like搜索出来 就不是说单纯的只是匹配完整的一个值，而是可以对值进行拆分词语后（分词）进行匹配，也可以通过缩写、时态、大小写、同义词等进行匹配。 倒排索引doc1：I really liked my small dogs, and I think my mom also liked them.doc2：He never liked any dogs, so I hope that my mom will not expect me to liked him. mother like little dog，不可能有任何结果 normalization，建立倒排索引的时候，会执行一个操作，也就是说对拆分出的各个单词进行相应的处理，以提升后面搜索的时候能够搜索到相关联的文档的概率，包括时态的转换，单复数的转换，同义词的转换，大小写的转换。 word doc1 doc2 I * * really * like * * my * * little * dog * * and * think * mom * * also * them * He * never * any * so * hope * that * will * not * expect * me * to * him * 分词器切分词语，normalization（提升recall召回率），将句子拆分成一个一个的单个的单词，同时对每个单词进行normalization（时态转换，单复数转换），分词器。 recall召回率：搜索的时候，增加能够搜索到的结果的数量 123character filter：在一段文本进行分词之前，先进行预处理，比如说最常见的就是，过滤html标签（&lt;span&gt;hello&lt;span&gt; --&gt; hello），&amp; --&gt; and（I&amp;you --&gt; I and you）tokenizer：分词，hello you and me --&gt; hello, you, and, metoken filter：lowercase，stop word，synonymom，dogs --&gt; dog，liked --&gt; like，Tom --&gt; tom，a&#x2F;the&#x2F;an --&gt; 干掉，mother --&gt; mom，small --&gt; little 内置分词器Set the shape to semi-transparent by calling set_trans(5) 1234standard analyzer：set, the, shape, to, semi, transparent, by, calling, set_trans, 5（默认的是standard）simple analyzer：set, the, shape, to, semi, transparent, by, calling, set, transwhitespace analyzer：Set, the, shape, to, semi-transparent, by, calling, set_trans(5)language analyzer（特定的语言的分词器，比如说，english，英语分词器）：set, shape, semi, transpar, call, set_tran, 5 分页搜索es进行分页搜索size，from 1234567GET &#x2F;_search?size&#x3D;10GET &#x2F;_search?size&#x3D;10&amp;from&#x3D;0GET &#x2F;_search?size&#x3D;10&amp;from&#x3D;20GET &#x2F;test_index&#x2F;test_type&#x2F;_search 总共有9条GET &#x2F;test_index&#x2F;test_type&#x2F;_search?from&#x3D;0&amp;size&#x3D;3 将这9条数据分成3页，每一页是3条数据GET &#x2F;test_index&#x2F;test_type&#x2F;_search?from&#x3D;3&amp;size&#x3D;3 GET &#x2F;test_index&#x2F;test_type&#x2F;_search?from&#x3D;6&amp;size&#x3D;3 deep paging query string1234GET &#x2F;test_index&#x2F;test_type&#x2F;_search?q&#x3D;test_field:test 包含GET &#x2F;test_index&#x2F;test_type&#x2F;_search?q&#x3D;+test_field:test 包含GET &#x2F;test_index&#x2F;test_type&#x2F;_search?q&#x3D;-test_field:test 不包含GET &#x2F;test_index&#x2F;test_type&#x2F;_search?q&#x3D;test 直接可以搜索所有的field，任意一个field包含指定的关键字就可以搜索出来 es中的_all元数据，在建立索引的时候，我们插入一条document，它里面包含了多个field，此时，es会自动将多个field的值，全部用字符串的方式串联起来，变成一个长的字符串，作为_all field的值，同时建立索引，后面如果在搜索的时候，没有对某个field指定搜索，就默认搜索_all field，其中是包含了所有field的值的。 123456&#123; &quot;name&quot;: &quot;jack&quot;, &quot;age&quot;: 26, &quot;email&quot;: &quot;jack@sina.com&quot;, &quot;address&quot;: &quot;guamgzhou&quot;&#125; jack 26 jack@sina.com guangzhou，作为这一条document的_all field的值，同时进行分词后建立对应的倒排索引 mapping插入几条数据，让es自动为我们建立一个索引 12345678910111213141516171819202122232425262728PUT &#x2F;website&#x2F;article&#x2F;1&#123; &quot;post_date&quot;: &quot;2017-01-01&quot;, &quot;title&quot;: &quot;my first article&quot;, &quot;content&quot;: &quot;this is my first article in this website&quot;, &quot;author_id&quot;: 11400&#125;PUT &#x2F;website&#x2F;article&#x2F;2&#123; &quot;post_date&quot;: &quot;2017-01-02&quot;, &quot;title&quot;: &quot;my second article&quot;, &quot;content&quot;: &quot;this is my second article in this website&quot;, &quot;author_id&quot;: 11400&#125;PUT &#x2F;website&#x2F;article&#x2F;3&#123; &quot;post_date&quot;: &quot;2017-01-03&quot;, &quot;title&quot;: &quot;my third article&quot;, &quot;content&quot;: &quot;this is my third article in this website&quot;, &quot;author_id&quot;: 11400&#125;GET &#x2F;website&#x2F;article&#x2F;_search?q&#x3D;2017 3条结果 GET &#x2F;website&#x2F;article&#x2F;_search?q&#x3D;2017-01-01 3条结果GET &#x2F;website&#x2F;article&#x2F;_search?q&#x3D;post_date:2017-01-01 1条结果GET &#x2F;website&#x2F;article&#x2F;_search?q&#x3D;post_date:2017 1条结果 dynamic mapping，自动为我们建立index，创建type，以及type对应的mapping，mapping中包含了每个field对应的数据类型，以及如何分词等设置 123456789101112131415161718192021222324252627282930313233343536GET &#x2F;website&#x2F;_mapping&#x2F;article&#123; &quot;website&quot;: &#123; &quot;mappings&quot;: &#123; &quot;article&quot;: &#123; &quot;properties&quot;: &#123; &quot;author_id&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;post_date&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125;, &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 因为es自动建立mapping的时候，设置了不同的field不同的data type。不同的data type的分词、搜索等行为是不一样的。所以出现了_all field和post_date field的搜索表现完全不一样。","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://onejane.github.io/tags/elasticsearch/"}]},{"title":"打造完美逆向和沙箱编译环境","slug":"打造完美逆向和沙箱编译环境","date":"2021-05-22T01:38:12.000Z","updated":"2021-05-22T03:52:01.610Z","comments":true,"path":"2021/05/22/打造完美逆向和沙箱编译环境/","link":"","permalink":"http://onejane.github.io/2021/05/22/%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E9%80%86%E5%90%91%E5%92%8C%E6%B2%99%E7%AE%B1%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"md5校验：CertUtil -hashfile ide-eval-resetter-2.1.13.jar MD5 apt install neofetch 显示系统信息 echo $SHELL 查看终端 pyenv versions pyenv install –list htop jnettop iotop 010 Editor-Template Repository-Executable 选择指定文件格式解析 无限续期： 123先关闭软件：rm -rf ~&#x2F;.config&#x2F;SweetScape&#x2F;rm -rf ~&#x2F;.local&#x2F;share&#x2F;SweetScape&#x2F; 8.1.0_r1 对应代号 OPM1.171019.011 wget https://dl.google.com/dl/android/aosp/bullhead-opm1.171019.011-factory-3be6fd1c.zip ./flush-all.sh 如报错替换fastboot,which fastboot adb push n5x_nethunter /sdcard/ adb reboot bootloader fastboot flash recovery nex_nethunter/twrp-3.3.0-0-bullhead.img 刷入SR5-SuperSU和nethunter-2020.3-bullhead-oreo-kalifs-full.zip adb push /root/Android/Sdk/ndk/22.1.7171670/prebuilt/android-arm /data/local/tmp ./fs14248arm74 objection -g com.roysue.easyso1 explore memory list modules memory list exports libroysue.so 查看so的导出符号 ./gdbserver 0.0.0.0:23946 –attach pid hyper gdb-multiarch set arch armset arm fallback-mode thumb target remote192.168.0.10:23946 info shared libroysue.so b *0xcc7143f5 info break 打断点 c 执行下一个断点 nexti 汇编级别下一步F8 n 源码级别下一步 ctrl+shift+pageup 选寄存器状态 `ctrl+shift+pagedown 选寄存器状态 Nethunter 刷机","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"kali","slug":"kali","permalink":"http://onejane.github.io/tags/kali/"}]},{"title":"识货跳转淘宝时携带参数的实现","slug":"识货跳转淘宝时携带参数的实现","date":"2021-05-14T06:07:57.000Z","updated":"2021-05-15T03:27:15.670Z","comments":true,"path":"2021/05/14/识货跳转淘宝时携带参数的实现/","link":"","permalink":"http://onejane.github.io/2021/05/14/%E8%AF%86%E8%B4%A7%E8%B7%B3%E8%BD%AC%E6%B7%98%E5%AE%9D%E6%97%B6%E6%90%BA%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"需求最近在电商业务的设计中要求像识货app一样实现选好型号尺寸之类的商品属性后，跳转到淘宝时携带这些参数帮助用户自行选中，如下图所示： 分析 启动frida-server； 123adb shellsu.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64 使用PKiD判断是否加壳； 安装好识货app，由于没有加固，直接从AndroidMainfest.xml中拿到包名。jadx-gui *.apk 查看，package=&quot;com.hupu.shihuo&quot;找到包名； hook点击事件获取触发的类frida -UF -l hookEvent.js 12pyenv local 3.8.2 该环境的frida版本为12.8.0frida --version 点击尺寸型号时，选择配色尺码触发事件 1[Google Pixel XL::识货]-&gt; [WatchEvent] onClick: cn.shihuo.modulelib.views.widget.easyrecyclerview.adapter.RecyclerArrayAdapter$3 选好型号后，点击立即购买触发事件 1[Google Pixel XL::识货]-&gt; [WatchEvent] onClick: com.module.shoes.view.DetailOfShoesBFragment$ab 点击担保购买，查看触发事件 1[Google Pixel XL::识货]-&gt; [WatchEvent] onClick: com.module.shoes.view.adapter.ChannelOfShoesAdapter$ViewHolder$a 内存漫游属性点击1android hooking watch class cn.shihuo.modulelib.views.widget.easyrecyclerview.adapter.RecyclerArrayAdapter$3 --dump-args --dump-backtrace --dump-return 对整个RecyclerArrayAdapter类进行hook第三个匿名内部类 12jobs listjobs kill o0jgr3f2i6j 拿到需要hook的方法后取消hook 123plugin wallbreaker objectsearch cn.shihuo.modulelib.views.widget.easyrecyclerview.adapter.RecyclerArrayAdapter$3 内存中搜索该匿名内部类plugin wallbreaker objectdump --fullname 0x10117a 打印该内部类plugin wallbreaker objectdump --fullname 0x10108a 查看该类中可能的实力对象ShoeStylesAdapter 以上的类中没有任何线索涉及到参数的传递或者请求的跳转。 立即购买12android hooking search classes DetailOfShoesBFragment$ab 内存中搜索DetailOfShoesBFragment内部类ab及涉及的方法android hooking list class_methods com.module.shoes.view.DetailOfShoesBFragment$ab 获取该类方法及参数类型 123android heap search instances com.module.shoes.view.DetailOfShoesBFragment$ab 获取内存实例plugin wallbreaker objectdump --fullname 0x10e5b6 将该实例dump出来plugin wallbreaker objectdump --fullname 0xe566 该实例中还有一个DetailOfShoesBFragment实例 在DetailOfShoesBFragment实例中，ShoeDetailSecondModel极有可能有关键性线索实现参数携带跳转。 可是当我整个字符串拷贝下来时，发现连个taobao的毛都没看到，再次dump该实例，也没有什么重要线索。 担保购买12android heap search instances com.module.shoes.view.adapter.ChannelOfShoesAdapter$ViewHolder$a 直接内存搜刮plugin wallbreaker objectdump --fullname 0x20e57e 找到SupplierInfoModel类在jadx看源码是有一些关键性字段的，如price,href等。 1plugin wallbreaker objectdump --fullname 0x20e512 将这段href拷贝下来，解码后如下： 1shihuo:&#x2F;&#x2F;www.shihuo.cn?route&#x3D;go&amp;goods_product_id&#x3D;12331971&amp;tpExtra&#x3D;&#123;&quot;dgReqId&quot;:&quot;TTfc4jvaelao00&quot;,&quot;fReqId&quot;:&quot;93E867875BE612E72CAF39F223AF0C08&quot;,&quot;fTp&quot;:&quot;list:list:1&quot;,&quot;fTpName&quot;:&quot;&quot;,&quot;ffTp&quot;:&quot;home:feed_list:1&quot;,&quot;ffTpName&quot;:&quot;推荐&quot;,&quot;layer&quot;:&quot;2&quot;,&quot;sc&quot;:&quot;HOME_FEED_RECOMMEND_RANK&quot;,&quot;si&quot;:&quot;1001&quot;,&quot;skc&quot;:&quot;1683465&quot;,&quot;sourceTp&quot;:&quot;home:feed_list:1&quot;,&quot;sourceTpName&quot;:&quot;推荐&quot;,&quot;style_id&quot;:&quot;6459093&quot;,&quot;supplier_id&quot;:&quot;8234343&quot;&#125;&amp;url&#x3D;https:&#x2F;&#x2F;item.taobao.com&#x2F;item.htm?id&#x3D;643291979969&amp;skuId&#x3D;4798775291256&amp;dspm&#x3D;46e625b0904faa9c&amp;fromShType&#x3D;1&amp;goodsType&#x3D;4&amp;openType&#x3D;1&amp;shopId&#x3D;cn.taobao.62301187&amp;category_type&#x3D;1&amp;goods_id&#x3D;13#&#123;&quot;from&quot;:&quot;shihuo:&#x2F;&#x2F;www.shihuo.cn?route&#x3D;goodsDetail&quot;,&quot;block&quot;:&quot;Supplier&quot;,&quot;tp&quot;:&quot;Supplier&quot;,&quot;sku_id&quot;:88366767,&quot;extra&quot;:&quot;2&quot;,&quot;dspm&quot;:&quot;46e625b0904faa9c&quot;,&quot;pos_type&quot;:2,&quot;goods_id&quot;:&quot;13&quot;,&quot;supplier_id&quot;:&quot;8234343&quot;,&quot;style_id&quot;:&quot;6459093&quot;,&quot;size&quot;:&quot;41&quot;,&quot;price&quot;:&quot;1002&quot;,&quot;sort&quot;:&quot;2&quot;,&quot;filter&quot;:&quot;0000000&quot;,&quot;is_recommend&quot;:0,&quot;goods_sku_id&quot;:12331971&#125; 很明显这段是识货自行封装的协议，后面参数url=应该就是跳转到淘宝的链接。 将https://item.taobao.com/item.htm?id=643291979969&amp;skuId=4798775291256&amp;dspm=46e625b0904faa9c&amp;fromShType=1&amp;goodsType=4&amp;openType=1&amp;shopId=cn.taobao.62301187&amp;category_type=1&amp;goods_id=13#{&quot;from&quot;:&quot;shihuo://www.shihuo.cn?route=goodsDetail&quot;,&quot;block&quot;:&quot;Supplier&quot;,&quot;tp&quot;:&quot;Supplier&quot;,&quot;sku_id&quot;:88366767,&quot;extra&quot;:&quot;2&quot;,&quot;dspm&quot;:&quot;46e625b0904faa9c&quot;,&quot;pos_type&quot;:2,&quot;goods_id&quot;:&quot;13&quot;,&quot;supplier_id&quot;:&quot;8234343&quot;,&quot;style_id&quot;:&quot;6459093&quot;,&quot;size&quot;:&quot;41&quot;,&quot;price&quot;:&quot;1002&quot;,&quot;sort&quot;:&quot;2&quot;,&quot;filter&quot;:&quot;0000000&quot;,&quot;is_recommend&quot;:0,&quot;goods_sku_id&quot;:12331971}链接拷贝到手机浏览器中自动跳转到淘宝，点击选项时加上了选择条件。 逐步删除条件，最终得到https://item.taobao.com/item.htm?id=643291979969&amp;skuId=4798775291256&amp;fromShType=1&amp;goodsType=4&amp;openType=1&amp;shopId=cn.taobao.62301187&amp;category_type=1&amp;goods_id=13,一旦删除skuId将不能携带型号等属性自动选择。 真相淘宝的skuId就是将信息同步到淘宝，淘宝将自动选中用户在识货选中的条件。","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"ElasticSearch之分布式特性","slug":"ElasticSearch之分布式特性","date":"2021-05-13T03:12:37.000Z","updated":"2021-05-25T13:17:40.237Z","comments":true,"path":"2021/05/13/ElasticSearch之分布式特性/","link":"","permalink":"http://onejane.github.io/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/","excerpt":"","text":"Elasticsearch是一套分布式的系统，分布式是为了应对大数据量，隐藏了复杂的分布式机制，实现了分片机制(数据插入分配不同的shard中)，集群发现机制(启动多个es进程自动发现集群并加入且接受部分数据当做副本)，shard负载均衡机制(增减节点时，多节点条件下es自动进行均匀分配，保持每个节点均衡读写负载请求)，shard副本机制(请求路由，集群扩容，shard重分配)。master节点实现创建或删除索引，增加或删除节点。节点对等，每个节点都能接收所有的请求，自动请求路由，响应收集。 ES就是一个分布式的文档数据存储系统。 文档数据：es可以存储和操作json文档类型的数据，而且这也是es的核心数据结构。 存储系统：es可以对json文档类型的数据进行存储，查询，创建，更新，删除，等等操作。其实ES满足了这些功能，就可以说已经是一个NoSQL的存储系统了。 场景： 数据量较大，es的分布式本质，可以帮助你快速进行扩容，承载大量数据 数据结构灵活多变，随时可能会变化，而且数据结构之间的关系，非常复杂，如果我们用传统数据库，那是不是很坑，因为要面临大量的表 对数据的相关操作，较为简单，比如就是一些简单的增删改查，用我们之前讲解的那些document操作就可以搞定 NoSQL数据库，适用的也是类似于上面的这种场景 shard&amp;replica机制 index包含多个shard 每个shard都是一个最小工作单元，承载部分数据，lucene实例，完整的建立索引和处理请求的能力 增减节点时，shard会自动在nodes中负载均衡,6个节点，7个shard，其中一个节点2个shard,进入新节点时，自动将shard负载均匀分配到所有节点。 primary shard和replica shard，每个document肯定只存在于某一个primary shard以及其对应的replica shard中，不可能存在于多个primary shard replica shard是primary shard的副本，负责容错，以及承担读请求负载 primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改 primary shard的默认数量是5，replica默认是1，默认有10个shard，5个primary shard，5个replica shard primary shard不能和自己的replica shard放在同一个节点上（否则节点宕机，primary shard和副本都丢失，起不到容错的作用），但是可以和其他primary shard的replica shard放在同一个节点上 单node创建index 单node环境下，创建一个index，有3个primary shard，3个replica shard 集群status是yellow 这个时候，只会将3个primary shard分配到仅有的一个node上去，另外3个replica shard是无法分配的 集群可以正常工作，但是一旦出现节点宕机，数据全部丢失，而且集群不可用，无法承接任何请求 1234567PUT &#x2F;test_index&#123; &quot;settings&quot; : &#123; &quot;number_of_shards&quot; : 3, &quot;number_of_replicas&quot; : 1 &#125;&#125; 双node分配shard replica shard分配：master(3个primary shard)，slave(3个replica shard)，新增1个node primary ---&gt; replica同步 读请求：primary/replica 横向扩容 primary&amp;replica自动负载均衡，6个shard，3 primary，3 replica 每个node有更少的shard，IO/CPU/Memory资源给每个shard分配更多，每个shard性能更好 扩容的极限，6个shard（3 primary，3 replica），最多扩容到6台机器，每个shard可以占用单台服务器的所有资源，性能最好 超出扩容极限，动态修改replica数量，9个shard（3primary，6 replica），扩容到9台机器，比3台机器时，拥有3倍的读吞吐量 3台机器下，9个shard（3 primary，6 replica），资源更少，但是容错性更好，最多容纳2台机器宕机，6个shard只能容纳0台机器宕机 容错机制 9 shard，3 node master node宕机，自动master选举，red replica容错：新master将replica提升为primary shard，yellow 重启宕机node，master copy replica到该node，使用原有的shard并同步宕机后的修改，green 元数据123456789101112131415PUT &#x2F;test_indx&#x2F;test_type&#x2F;1&#123; &quot;test_content&quot;: &quot;test test&quot;&#125;GET &#x2F;test_indx&#x2F;test_type&#x2F;1&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;test_content&quot;: &quot;test test&quot; &#125;&#125; _index元数据 （1）代表一个document存放在哪个index中（2）类似的数据放在一个索引，非类似的数据放不同索引：product index（包含了所有的商品），sales index（包含了所有的商品销售数据），inventory index（包含了所有库存相关的数据）。如果你把比如product，sales，human resource（employee），全都放在一个大的index里面，比如说company index，不合适的。（3）index中包含了很多类似的document：类似是什么意思，其实指的就是说，这些document的fields很大一部分是相同的，你说你放了3个document，每个document的fields都完全不一样，这就不是类似了，就不太适合放到一个index里面去了。（4）索引名称必须是小写的，不能用下划线开头，不能包含逗号：product，website，blog _type元数据 （1）代表document属于index中的哪个类别（type）（2）一个索引通常会划分为多个type，逻辑上对index中有些许不同的几类数据进行分类：因为一批相同的数据，可能有很多相同的fields，但是还是可能会有一些轻微的不同，可能会有少数fields是不一样的，举个例子，就比如说，商品，可能划分为电子商品，生鲜商品，日化商品，等等。（3）type名称可以是大写或者小写，但是同时不能用下划线开头，不能包含逗号 _id元数据 （1）代表document的唯一标识，与index和type一起，可以唯一标识和定位一个document（2）我们可以手动指定document的id（put /index/type/id），也可以不指定，由es自动为我们创建一个id document_id 手动指定document id 一般来说，是从某些其他的系统中，导入一些数据到es时，会采取这种方式，就是使用系统中已有数据的唯一标识，作为es中document的id。举个例子，比如说，我们现在在开发一个电商网站，做搜索功能，或者是OA系统，做员工检索功能。这个时候，数据首先会在网站系统或者IT系统内部的数据库中，会先有一份，此时就肯定会有一个数据库的primary key（自增长，UUID，或者是业务编号）。如果将数据导入到es中，此时就比较适合采用数据在数据库中已有的primary key。 如果说，我们是在做一个系统，这个系统主要的数据存储就是es一种，也就是说，数据产生出来以后，可能就没有id，直接就放es一个存储，那么这个时候，可能就不太适合说手动指定document id的形式了，因为你也不知道id应该是什么，此时可以采取下面要讲解的让es自动生成id的方式。 1234PUT &#x2F;test_index&#x2F;test_type&#x2F;2&#123; &quot;test_content&quot;: &quot;my test&quot;&#125; 自动生成document id （1）post /index/type 123456789101112131415161718POST &#x2F;test_index&#x2F;test_type&#123; &quot;test_content&quot;: &quot;my test&quot;&#125;&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;AVp4RN0bhjxldOOnBxaE&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;, &quot;created&quot;: true&#125; （2）自动生成的id，长度为20个字符，URL安全，base64编码，GUID，分布式系统并行生成时不可能会发生冲突 _source_source元数据：就是说，我们在创建一个document的时候，使用的那个放在request body中的json串，默认情况下，在get的时候，会原封不动的给我们返回回来。 12345678910111213141516171819put &#x2F;test_index&#x2F;test_type&#x2F;1&#123; &quot;test_field1&quot;: &quot;test field1&quot;, &quot;test_field2&quot;: &quot;test field2&quot;&#125;get &#x2F;test_index&#x2F;test_type&#x2F;1&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 2, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;test_field1&quot;: &quot;test field1&quot;, &quot;test_field2&quot;: &quot;test field2&quot; &#125;&#125; 定制返回的结果，指定_source中，返回哪些field,GET /test_index/test_type/1?_source=test_field1,test_field2 批量查询就是一条一条的查询，比如说要查询100条数据，那么就要发送100次网络请求，这个开销还是很大的如果进行批量查询的话，查询100条数据，就只要发送1次网络请求，网络请求的性能开销缩减100倍 12345678910111213141516171819202122232425262728293031323334GET &#x2F;test_index&#x2F;test_type&#x2F;1GET &#x2F;test_index&#x2F;test_type&#x2F;2GET &#x2F;_mget mget批量查询&#123; &quot;docs&quot; : [ &#123; &quot;_index&quot; : &quot;test_index&quot;, &quot;_type&quot; : &quot;test_type&quot;, &quot;_id&quot; : 1 &#125;, &#123; &quot;_index&quot; : &quot;test_index&quot;, &quot;_type&quot; : &quot;test_type&quot;, &quot;_id&quot; : 2 &#125; ]&#125;GET &#x2F;test_index&#x2F;_mget 查询的document是一个index下的不同type&#123; &quot;docs&quot; : [ &#123; &quot;_type&quot; : &quot;test_type&quot;, &quot;_id&quot; : 1 &#125;, &#123; &quot;_type&quot; : &quot;test_type&quot;, &quot;_id&quot; : 2 &#125; ]&#125;GET &#x2F;test_index&#x2F;test_type&#x2F;_mget 查询的数据都在同一个index下的同一个type&#123; &quot;ids&quot;: [1, 2]&#125; 可以说mget是很重要的，一般来说，在进行查询的时候，如果一次性要查询多条数据的话，那么一定要用batch批量操作的api，尽可能减少网络开销次数，可能可以将性能提升数倍，甚至数十倍。 bulk批量增删改bulk api对json的语法，有严格的要求，每个json串不能换行，只能放一行，同时一个json串和一个json串之间，必须有一个换行 delete：删除一个文档，只要1个json串就可以了 create：PUT /index/type/id/_create，强制创建 index：普通的put操作，可以是创建文档，也可以是全量替换文档 update：执行的partial update操作 12345678POST &#x2F;_bulk&#123; &quot;delete&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;3&quot; &#125;&#125; &#123; &quot;create&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;12&quot; &#125;&#125;&#123; &quot;test_field&quot;: &quot;test12&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;2&quot; &#125;&#125;&#123; &quot;test_field&quot;: &quot;replaced test2&quot; &#125;&#123; &quot;update&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_retry_on_conflict&quot; : 3&#125; &#125;&#123; &quot;doc&quot; : &#123;&quot;test_field2&quot; : &quot;bulk test1&quot;&#125; &#125; bulk操作中，任意一个操作失败，是不会影响其他的操作的，但是在返回结果里，会告诉你异常日志 123456789101112131415161718192021POST &#x2F;test_index&#x2F;_bulk&#123; &quot;delete&quot;: &#123; &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;3&quot; &#125;&#125; &#123; &quot;create&quot;: &#123; &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;12&quot; &#125;&#125;&#123; &quot;test_field&quot;: &quot;test12&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_type&quot;: &quot;test_type&quot; &#125;&#125;&#123; &quot;test_field&quot;: &quot;auto-generate id test&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;2&quot; &#125;&#125;&#123; &quot;test_field&quot;: &quot;replaced test2&quot; &#125;&#123; &quot;update&quot;: &#123; &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_retry_on_conflict&quot; : 3&#125; &#125;&#123; &quot;doc&quot; : &#123;&quot;test_field2&quot; : &quot;bulk test1&quot;&#125; &#125;POST &#x2F;test_index&#x2F;test_type&#x2F;_bulk&#123; &quot;delete&quot;: &#123; &quot;_id&quot;: &quot;3&quot; &#125;&#125; &#123; &quot;create&quot;: &#123; &quot;_id&quot;: &quot;12&quot; &#125;&#125;&#123; &quot;test_field&quot;: &quot;test12&quot; &#125;&#123; &quot;index&quot;: &#123; &#125;&#125;&#123; &quot;test_field&quot;: &quot;auto-generate id test&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_id&quot;: &quot;2&quot; &#125;&#125;&#123; &quot;test_field&quot;: &quot;replaced test2&quot; &#125;&#123; &quot;update&quot;: &#123; &quot;_id&quot;: &quot;1&quot;, &quot;_retry_on_conflict&quot; : 3&#125; &#125;&#123; &quot;doc&quot; : &#123;&quot;test_field2&quot; : &quot;bulk test1&quot;&#125; &#125; bulk request会加载到内存里，如果太大的话，性能反而会下降，因此需要反复尝试一个最佳的bulk size。一般从1000~5000条数据开始，尝试逐渐增加。另外，如果看大小的话，最好是在5~15MB之间。 bulk api奇特的json格式1234&#123;&quot;action&quot;: &#123;&quot;meta&quot;&#125;&#125;\\n&#123;&quot;data&quot;&#125;\\n&#123;&quot;action&quot;: &#123;&quot;meta&quot;&#125;&#125;\\n&#123;&quot;data&quot;&#125;\\n 不用将其转换为json对象，不会出现内存中的相同数据的拷贝，直接按照换行符切割json 对每两个一组的json，读取meta，进行document路由 直接将对应的json发送到node上去 最大的优势在于，不需要将json数组解析为一个JSONArray对象，形成一份大数据的拷贝，浪费内存空间，尽可能地保证性能 如果采用比较良好的json数组格式,允许任意的换行，整个可读性非常棒，读起来很爽，es拿到那种标准格式的json串以后，要按照下述流程去进行处理 将json数组解析为JSONArray对象，这个时候，整个数据，就会在内存中出现一份一模一样的拷贝，一份数据是json文本，一份数据是JSONArray对象 解析json数组里的每个json，对每个请求中的document进行路由 为路由到同一个shard上的多个请求，创建一个请求数组 将这个请求数组序列化 将序列化后的请求数组发送到对应的节点上去 耗费更多内存，更多的jvm gc开销，我们之前提到过bulk size最佳大小的那个问题，一般建议说在几千条那样，然后大小在10MB左右，所以说，可怕的事情来了。假设说现在100个bulk请求发送到了一个节点上去，然后每个请求是10MB，100个请求，就是1000MB = 1GB，然后每个请求的json都copy一份为jsonarray对象，此时内存中的占用就会翻倍，就会占用2GB的内存，甚至还不止。因为弄成jsonarray之后，还可能会多搞一些其他的数据结构，2GB+的内存占用。占用更多的内存可能就会积压其他请求的内存使用量，比如说最重要的搜索请求，分析请求，等等，此时就可能会导致其他请求的性能急速下降。占用内存更多，就会导致java虚拟机的垃圾回收次数更多，跟频繁，每次要回收的垃圾对象更多，耗费的时间更多，导致es的java虚拟机停止工作线程的时间更多 更新全量替换 语法与创建文档是一样的，如果document id不存在，那么就是创建；如果document id已经存在，那么就是全量替换操作，替换document的json串内容，更新_version的值 document是不可变的，如果要修改document的内容，第一种方式就是全量替换，直接对document重新建立索引，替换里面所有的内容 es会将老的document标记为deleted，然后新增我们给定的一个document，当我们创建越来越多的document的时候，es会在适当的时机在后台自动删除标记为deleted的document 局部更新PUT /index/type/id，创建文档&amp;替换文档，就是一样的语法 应用程序先发起一个get请求，获取到document，展示到前台界面，供用户查看和修改 用户在前台界面修改数据，发送到后台 后台代码，会将用户修改的数据在内存中进行执行，然后封装好修改后的全量数据 然后发送PUT请求，到es中，进行全量替换 es将老的document标记为deleted，然后重新创建一个新的document 123456post &#x2F;index&#x2F;type&#x2F;id&#x2F;_update &#123; &quot;doc&quot;: &#123; &quot;要修改的少数几个field即可，不需要全量的数据&quot; &#125;&#125; 原理 实战partial update123456789101112PUT &#x2F;test_index&#x2F;test_type&#x2F;10&#123; &quot;test_field1&quot;: &quot;test1&quot;, &quot;test_field2&quot;: &quot;test2&quot;&#125;POST &#x2F;test_index&#x2F;test_type&#x2F;10&#x2F;_update&#123; &quot;doc&quot;: &#123; &quot;test_field2&quot;: &quot;updated test2&quot; &#125;&#125; groovy实现partial updatees，其实是有个内置的脚本支持的，可以基于groovy脚本实现各种各样的复杂操作 准备数据 12345PUT &#x2F;test_index&#x2F;test_type&#x2F;11&#123; &quot;num&quot;: 0, &quot;tags&quot;: []&#125; 更新数据 1234POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update&#123; &quot;script&quot; : &quot;ctx._source.num+&#x3D;1&quot;&#125; 外部脚本 vim elasticsearch-5.2.0\\config\\scripts\\test-add-tags.groovyctx._source.tags+=new_tag 为tags字段添加tag1,test-add-tags.groovy 12345678910POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update&#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;groovy&quot;, &quot;file&quot;: &quot;test-add-tags&quot;, &quot;params&quot;: &#123; &quot;new_tag&quot;: &quot;tag1&quot; &#125; &#125;&#125; ctx.op = ctx._source.num == count ? &#39;delete&#39; : &#39;none&#39; 删除文档test-delete-document.groovy 12345678910POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update&#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;groovy&quot;, &quot;file&quot;: &quot;test-delete-document&quot;, &quot;params&quot;: &#123; &quot;count&quot;: 1 &#125; &#125;&#125; upsert操作 123456POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update&#123; &quot;doc&quot;: &#123; &quot;num&quot;: 1 &#125;&#125; 原始_update会直接报错404. 如果指定的document不存在，就执行upsert中的初始化操作；如果指定的document存在，就执行doc或者script指定的partial update操作 12345678POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update&#123; &quot;script&quot; : &quot;ctx._source.num+&#x3D;1&quot;, &quot;upsert&quot;: &#123; &quot;num&quot;: 0, &quot;tags&quot;: [] &#125;&#125; 强制创建PUT /index/type/id?op_type=create，PUT /index/type/id/_create 删除DELETE /index/type/id 不会理解物理删除，只会将其标记为deleted，当数据越来越多的时候，在后台自动删除 并发冲突 悲观锁与乐观锁方案 第一次创建一个document的时候，它的_version内部版本号就是1；以后，每次对这个document执行修改或者删除操作，都会对这个_version版本号自动加1；哪怕是删除，也会对这条数据的版本号加1。 在删除一个document之后，可以从一个侧面证明，它不是立即物理删除掉的，因为它的一些版本号等信息还是保留着的。先删除一条document，再重新创建这条document，其实会在delete version基础之上，再把version号加1 _version乐观锁实战 构造一条数据1234PUT &#x2F;test_index&#x2F;test_type&#x2F;7&#123; &quot;test_field&quot;: &quot;test test&quot;&#125; 模拟两个客户端，都获取到了同一条数据1234567891011GET test_index&#x2F;test_type&#x2F;7&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;7&quot;, &quot;_version&quot;: 1, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;test_field&quot;: &quot;test test&quot; &#125;&#125; 其中一个客户端，先更新了一下这个数据，同时带上数据的版本号，确保说，es中的数据的版本号，跟客户端中的数据的版本号是相同的，才能修改1234567891011121314151617PUT &#x2F;test_index&#x2F;test_type&#x2F;7?version&#x3D;1 &#123; &quot;test_field&quot;: &quot;test client 1&quot;&#125;&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;7&quot;, &quot;_version&quot;: 2, &quot;result&quot;: &quot;updated&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;, &quot;created&quot;: false&#125; 另外一个客户端，尝试基于version=1的数据去进行修改，同样带上version版本号，进行乐观锁的并发控制1234567891011121314151617181920212223PUT &#x2F;test_index&#x2F;test_type&#x2F;7?version&#x3D;1 &#123; &quot;test_field&quot;: &quot;test client 2&quot;&#125;&#123; &quot;error&quot;: &#123; &quot;root_cause&quot;: [ &#123; &quot;type&quot;: &quot;version_conflict_engine_exception&quot;, &quot;reason&quot;: &quot;[test_type][7]: version conflict, current version [2] is different than the one provided [1]&quot;, &quot;index_uuid&quot;: &quot;6m0G7yx7R1KECWWGnfH1sw&quot;, &quot;shard&quot;: &quot;3&quot;, &quot;index&quot;: &quot;test_index&quot; &#125; ], &quot;type&quot;: &quot;version_conflict_engine_exception&quot;, &quot;reason&quot;: &quot;[test_type][7]: version conflict, current version [2] is different than the one provided [1]&quot;, &quot;index_uuid&quot;: &quot;6m0G7yx7R1KECWWGnfH1sw&quot;, &quot;shard&quot;: &quot;3&quot;, &quot;index&quot;: &quot;test_index&quot; &#125;, &quot;status&quot;: 409&#125; 在乐观锁成功阻止并发问题之后，尝试正确的完成更新 1234567891011GET &#x2F;test_index&#x2F;test_type&#x2F;7&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;7&quot;, &quot;_version&quot;: 2, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;test_field&quot;: &quot;test client 1&quot; &#125;&#125; 基于最新的数据和版本号，去进行修改，修改后，带上最新的版本号，可能这个步骤会需要反复执行好几次，才能成功，特别是在多线程并发更新同一条数据很频繁的情况下1234PUT &#x2F;test_index&#x2F;test_type&#x2F;7?version&#x3D;2 &#123; &quot;test_field&quot;: &quot;test client 2&quot;&#125; external version乐观锁实战es提供了一个feature，就是说，你可以不用它提供的内部_version版本号来进行并发控制，可以基于你自己维护的一个版本号来进行并发控制。比如，加入你的数据在mysql里也有一份，然后你的应用系统本身就维护了一个版本号，无论是什么自己生成的，程序控制的。这个时候，你进行乐观锁并发控制的时候，可能并不是想要用es内部的_version来进行控制，而是用你自己维护的那个version来进行控制。 _version=1，?version=1，才能更新成功_version=1，?version&gt;1&amp;version_type=external，才能成功，比如说?version=2&amp;version_type=external version_type=external，唯一的区别在于，_version，只有当你提供的version与es中的_version一模一样的时候，才可以进行修改，只要不一样，就报错；当version_type=external的时候，只有当你提供的version比es中的_version大的时候，才能完成修改。 先构造一条数据 123456789101112131415161718PUT &#x2F;test_index&#x2F;test_type&#x2F;8&#123; &quot;test_field&quot;: &quot;test&quot;&#125;&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;8&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;, &quot;created&quot;: true&#125; 模拟两个客户端同时查询到这条数据 123456789101112GET &#x2F;test_index&#x2F;test_type&#x2F;8&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;8&quot;, &quot;_version&quot;: 1, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;test_field&quot;: &quot;test&quot; &#125;&#125; 第一个客户端先进行修改，此时客户端程序是在自己的数据库中获取到了这条数据的最新版本号，比如说是2 123456789101112131415161718PUT &#x2F;test_index&#x2F;test_type&#x2F;8?version&#x3D;2&amp;version_type&#x3D;external&#123; &quot;test_field&quot;: &quot;test client 1&quot;&#125;&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;8&quot;, &quot;_version&quot;: 2, &quot;result&quot;: &quot;updated&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;, &quot;created&quot;: false&#125; 模拟第二个客户端，同时拿到了自己数据库中维护的那个版本号，也是2，同时基于version=2发起了修改 123456789101112131415161718192021222324PUT &#x2F;test_index&#x2F;test_type&#x2F;8?version&#x3D;2&amp;version_type&#x3D;external&#123; &quot;test_field&quot;: &quot;test client 2&quot;&#125;&#123; &quot;error&quot;: &#123; &quot;root_cause&quot;: [ &#123; &quot;type&quot;: &quot;version_conflict_engine_exception&quot;, &quot;reason&quot;: &quot;[test_type][8]: version conflict, current version [2] is higher or equal to the one provided [2]&quot;, &quot;index_uuid&quot;: &quot;6m0G7yx7R1KECWWGnfH1sw&quot;, &quot;shard&quot;: &quot;1&quot;, &quot;index&quot;: &quot;test_index&quot; &#125; ], &quot;type&quot;: &quot;version_conflict_engine_exception&quot;, &quot;reason&quot;: &quot;[test_type][8]: version conflict, current version [2] is higher or equal to the one provided [2]&quot;, &quot;index_uuid&quot;: &quot;6m0G7yx7R1KECWWGnfH1sw&quot;, &quot;shard&quot;: &quot;1&quot;, &quot;index&quot;: &quot;test_index&quot; &#125;, &quot;status&quot;: 409&#125; 在并发控制成功后，重新基于最新的版本号发起更新12345678910111213141516171819202122232425262728293031GET &#x2F;test_index&#x2F;test_type&#x2F;8&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;8&quot;, &quot;_version&quot;: 2, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;test_field&quot;: &quot;test client 1&quot; &#125;&#125;PUT &#x2F;test_index&#x2F;test_type&#x2F;8?version&#x3D;3&amp;version_type&#x3D;external&#123; &quot;test_field&quot;: &quot;test client 2&quot;&#125;&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;8&quot;, &quot;_version&quot;: 3, &quot;result&quot;: &quot;updated&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;, &quot;created&quot;: false&#125; partial update内置乐观锁并发控制 post /index/type/id/_update?retry_on_conflict=5&amp;version=6 document原理路由 document路由到shard上的路由算法：shard = hash(routing) % number_of_primary_shards 举个例子，一个index有3个primary shard，P0，P1，P2，每次增删改查一个document的时候，都会带过来一个routing number，默认就是这个document的_id（可能是手动指定，也可能是自动生成）,routing = _id，假设_id=1,会将这个routing值，传入一个hash函数中，产出一个routing值的hash值，hash(routing) = 21，然后将hash函数产出的值对这个index的primary shard的数量求余数，21 % 3 = 0，就决定了，这个document就放在P0上。 决定一个document在哪个shard上，最重要的一个值就是routing值，默认是_id，也可以手动指定，相同的routing值，每次过来，从hash函数中，产出的hash值一定是相同的。无论hash值是几，无论是什么数字，对number_of_primary_shards求余数，结果一定是在0~number_of_primary_shards-1之间这个范围内的。0,1,2。 默认的routing就是_id，也可以在发送请求的时候，手动指定一个routing value，比如说put /index/type/id?routing=user_id。手动指定routing value是很有用的，可以保证说，某一类document一定被路由到一个shard上去，那么在后续进行应用级别的负载均衡，以及提升批量读取的性能。 增删改 客户端选择一个node发送请求过去，这个node就是coordinating node（协调节点） coordinating node，对document进行路由，将请求转发给对应的node（有primary shard） 实际的node上的primary shard处理请求，然后将数据同步到replica node coordinating node，如果发现primary node和所有replica node都搞定之后，就返回响应结果给客户端 查 客户端发送请求到任意一个node，成为coordinate node coordinate node对document进行路由，将请求转发到对应的node，此时会使用round-robin随机轮询算法，在primary shard以及其所有replica中随机选择一个，让读请求负载均衡 接收请求的node返回document给coordinate node coordinate node返回document给客户端 特殊情况：document如果还在建立索引过程中，可能只有primary shard有，任何一个replica shard都没有，此时可能会导致无法读取到document，但是document完成索引建立之后，primary shard和replica shard就都有了 quorum我们在发送任何一个增删改操作的时候，比如说put /index/type/id，都可以带上一个consistency参数，指明我们想要的写一致性put /index/type/id?consistency=quorum one：要求我们这个写操作，只要有一个primary shard是active活跃可用的，就可以执行all：要求我们这个写操作，必须所有的primary shard和replica shard都是活跃的，才可以执行这个写操作quorum：默认的值，要求所有的shard中，必须是大部分的shard都是活跃的，可用的，才可以执行这个写操作 quorum机制，写之前必须确保大多数shard都可用，int( (primary + number_of_replicas) / 2 ) + 1，当number_of_replicas&gt;1时才生效 quroum = int( (primary + number_of_replicas) / 2 ) + 1举个例子，3个primary shard，number_of_replicas=1，总共有3 + 3 * 1 = 6个shardquorum = int( (3 + 1) / 2 ) + 1 = 3所以，要求6个shard中至少有3个shard是active状态的，才可以执行这个写操作 如果节点数少于quorum数量，可能导致quorum不齐全，进而导致无法执行任何写操作。3个primary shard，replica=1，要求至少3个shard是active，3个shard按照之前学习的shard&amp;replica机制，必须在不同的节点上，如果说只有2台机器的话，是不是有可能出现说，3个shard都没法分配齐全，此时就可能会出现写操作无法执行的情况。 1个primary shard，replica=3，quorum=((1 + 3) / 2) + 1 = 3，要求1个primary shard + 3个replica shard = 4个shard，其中必须有3个shard是要处于active状态的。如果这个时候只有2台机器的话，es提供了一种特殊的处理场景，就是说当number_of_replicas&gt;1时才生效，因为假如说，你就一个primary shard，replica=1，此时就2个shard，(1 + 1 / 2) + 1 = 2，要求必须有2个shard是活跃的，但是可能就1个node，此时就1个shard是活跃的，如果你不特殊处理的话，导致我们的单节点集群就无法工作 quorum不齐全时，wait，默认1分钟，timeout，100，30s，等待期间，期望活跃的shard数量可以增加，最后实在不行，就会timeout，我们其实可以在写操作的时候，加一个timeout参数，比如说put /index/type/id?timeout=30，这个就是说自己去设定quorum不齐全的时候，es的timeout时长，可以缩短，也可以增长","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://onejane.github.io/tags/elasticsearch/"}]},{"title":"ElasticSearch之基础介绍","slug":"ElasticSearch之基础介绍","date":"2021-05-10T07:10:32.000Z","updated":"2021-05-15T03:27:15.659Z","comments":true,"path":"2021/05/10/ElasticSearch之基础介绍/","link":"","permalink":"http://onejane.github.io/2021/05/10/ElasticSearch%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"介绍垂直搜索（站内搜索） 互联网的搜索：电商网站，招聘网站，新闻网站，各种appIT系统的搜索：OA软件，办公自动化软件，会议管理，日程管理，项目管理，员工管理，搜索“张三”，“张三儿”，“张小三”；有个电商网站，卖家，后台管理系统，搜索“牙膏”，订单，“牙膏相关的订单” 搜索，就是在任何场景下，找寻你想要的信息，这个时候，会输入一段你要搜索的关键字，然后就期望找到这个关键字相关的有些信息 Elasticsearch，分布式，高性能，高可用，可伸缩的搜索和分析系统 elasticsearch，基于lucene，隐藏复杂性，提供简单易用的restful api接口、java api接口（还有其他语言的api接口）,开箱即用，优秀的默认参数，不需要任何额外设置，完全开源 分布式的文档存储引擎 分布式的搜索引擎和分析引擎 分布式，支持PB级数据 lucene，最先进、功能最强大的搜索库，直接基于lucene开发，非常复杂，api复杂（实现一些简单的功能，写大量的java代码），需要深入理解原理（各种索引结构） 数据库的弊端全表扫描 比方说，每条记录的指定字段的文本，可能会很长，比如说“商品描述”字段的长度，有长达数千个，甚至数万个字符，这个时候，每次都要对每条记录的所有文本进行扫描，来判断说，你包不包含我指定的这个关键词（比如说“牙膏”） 还不能将搜索词拆分开来，尽可能去搜索更多的符合你的期望的结果，比如输入“生化机”，就搜索不出来“生化危机”，输入“牙膏”搜索不到“牙刷膏”。 1select * from products where product_name like &quot;%牙膏%&quot; 什么是倒排索引 全文检索，倒排索引 lucene，就是一个jar包，里面包含了封装好的各种建立倒排索引，以及进行搜索的代码，包括各种算法。我们就用java开发的时候，引入lucene jar，然后基于lucene的api进行去进行开发就可以了。用lucene，我们就可以去将已有的数据建立索引，lucene会在本地磁盘上面，给我们组织索引的数据结构。另外的话，我们也可以用lucene提供的一些功能和api来针对磁盘上数据进行搜索 ElasticSearch功能分布式的搜索引擎和数据分析引擎 分布式搜索：百度，网站的站内搜索，IT系统的检索数据分析：电商网站，最近7天牙膏这种商品销量排名前10的商家有哪些；新闻网站，最近1个月访问量排名前3的新闻版块是哪些 全文检索，结构化检索，数据分析 全文检索：我想搜索商品名称包含牙膏的商品，select * from products where product_name like “%牙膏%”结构化检索：我想搜索商品分类为日化用品的商品都有哪些，select * from products where category_id=”日化用品”==&gt;实现部分匹配、自动完成、搜索纠错、搜索推荐数据分析：我们分析每一个商品分类下有多少个商品，select category_id,count(*) from products group by category_id 对海量数据进行近实时的处理 分布式：ES自动可以将海量数据分散到多台服务器上去存储和检索海量数据的处理：分布式以后，就可以采用大量的服务器去存储和检索数据，自然而然就可以实现海量数据的处理了近实时：检索个数据要花费1小时（这就不要近实时，离线批处理，batch-processing）；在秒级别对数据进行搜索和分析 跟分布式/海量数据相反的：lucene，单机应用，只能在单台服务器上使用，最多只能处理单台服务器可以处理的数据量 ElasticSearch适用场景国外 维基百科，类似百度百科，牙膏，牙膏的维基百科，全文检索，高亮，搜索推荐 The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈（好，坏，热门，垃圾，鄙视，崇拜） Stack Overflow（国外的程序异常讨论论坛），IT问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案 GitHub（开源代码管理），搜索上千亿行代码 电商网站，检索商品 日志数据分析，logstash采集日志，ES进行复杂的数据分析（ELK技术，elasticsearch+logstash+kibana） 商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买 BI系统，商业智能，Business Intelligence。比如说有个大型商场集团，BI，分析一下某某区域最近3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表，**区，最近3年，每年消费金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘，Kibana进行数据可视化 国内 站内搜索（电商，招聘，门户，等等），IT系统搜索（OA，CRM，ERP，等等），数据分析（ES热门的一个使用场景） ElasticSearch特点 可以作为一个大型分布式集群（数百台服务器）技术，处理PB级数据，服务大公司；也可以运行在单机上，服务小公司 Elasticsearch不是什么新技术，主要是将全文检索、数据分析以及分布式技术，合并在了一起，才形成了独一无二的ES；lucene（全文检索），商用的数据分析软件（也是有的），分布式数据库（mycat） 对用户而言，是开箱即用的，非常简单，作为中小型的应用，直接3分钟部署一下ES，就可以作为生产环境的系统来使用了，数据量不大，操作不是太复杂 数据库的功能面对很多领域是不够用的（事务，还有各种联机事务型的操作）；特殊的功能，比如全文检索，同义词处理，相关度排名，复杂数据分析，海量数据的近实时处理；Elasticsearch作为传统数据库的一个补充，提供了数据库所不不能提供的很多功能 ES核心概念 Near Realtime（NRT）：近实时，两个意思，从写入数据到数据可以被搜索到有一个小延迟（大概1秒）；基于es执行搜索和分析可以达到秒级 Cluster：集群，包含多个节点，每个节点属于哪个集群是通过一个配置（集群名称，默认是elasticsearch）来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常 Node：节点，集群中的一个节点，节点也有一个名称（默认是随机分配的），节点名称很重要（在执行运维管理操作的时候），默认节点会去加入一个名称为“elasticsearch”的集群，如果直接启动一堆节点，那么它们会自动组成一个elasticsearch集群，当然一个节点也可以组成一个elasticsearch集群 Document&amp;field：文档，es中的最小数据单元，一个document可以是一条客户数据，一条商品分类数据，一条订单数据，通常用JSON数据结构表示，每个index下的type中，都可以去存储多个document。一个document里面有多个field，每个field就是一个数据字段。 12345678product document&#123; &quot;product_id&quot;: &quot;1&quot;, &quot;product_name&quot;: &quot;高露洁牙膏&quot;, &quot;product_desc&quot;: &quot;高效美白&quot;, &quot;category_id&quot;: &quot;2&quot;, &quot;category_name&quot;: &quot;日化用品&quot;&#125; Index：索引，包含一堆有相似结构的文档数据，比如可以有一个客户索引，商品分类索引，订单索引，索引有一个名称。一个index包含很多document，一个index就代表了一类类似的或者相同的document。比如说建立一个product index，商品索引，里面可能就存放了所有的商品数据，所有的商品document。 Type：类型，每个索引里都可以有一个或多个type，type是index中的一个逻辑数据分类，一个type下的document，都有相同的field，比如博客系统，有一个索引，可以定义用户数据type，博客数据type，评论数据type。 商品index，里面存放了所有的商品数据，商品document，但是商品分很多种类，每个种类的document的field可能不太一样，比如说电器商品，可能还包含一些诸如售后时间范围这样的特殊field；生鲜商品，还包含一些诸如生鲜保质期之类的特殊field，type，日化商品type，电器商品type，生鲜商品type 日化商品type：product_id，product_name，product_desc，category_id，category_name电器商品type：product_id，product_name，product_desc，category_id，category_name，service_period生鲜商品type：product_id，product_name，product_desc，category_id，category_name，eat_period 12345678910111213141516171819每一个type里面，都会包含一堆document&#123; &quot;product_id&quot;: &quot;2&quot;, &quot;product_name&quot;: &quot;长虹电视机&quot;, &quot;product_desc&quot;: &quot;4k高清&quot;, &quot;category_id&quot;: &quot;3&quot;, &quot;category_name&quot;: &quot;电器&quot;, &quot;service_period&quot;: &quot;1年&quot;&#125;&#123; &quot;product_id&quot;: &quot;3&quot;, &quot;product_name&quot;: &quot;基围虾&quot;, &quot;product_desc&quot;: &quot;纯天然，冰岛产&quot;, &quot;category_id&quot;: &quot;4&quot;, &quot;category_name&quot;: &quot;生鲜&quot;, &quot;eat_period&quot;: &quot;7天&quot;&#125; shard：单台机器无法存储大量数据，es可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。有了shard就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个shard都是一个lucene index。 replica：任何一个服务器随时可能故障或宕机，此时shard可能就会丢失，因此可以为每个shard创建多个replica副本。replica可以在shard故障时提供备用服务，保证数据不丢失，多个replica还可以提升搜索操作的吞吐量和性能。primary shard（建立索引时一次设置，不能修改，默认5个），replica shard（随时修改数量，默认1个），默认每个索引10个shard，5个primary shard，5个replica shard，最小的高可用配置，是2台服务器。 Document 行 Type 表 Index 库 安装 安装JDK，至少1.8.0_73以上版本，java -version 下载和解压缩elasticsearch-5.2.0.zip，目录结构 启动Elasticsearch：bin\\elasticsearch.bat，es本身特点之一就是开箱即用，如果是中小型应用，数据量少，操作不是很复杂，直接启动就可以用了 检查ES是否启动成功：http://localhost:9200/?pretty 123name: node名称cluster_name: 集群名称（默认的集群名称就是elasticsearch）version.number: 5.2.0，es版本号 修改集群名称：elasticsearch.yml 下载和解压缩Kibana安装包，使用里面的开发界面，去操作elasticsearch，作为我们操作es的一个主要的界面入口 启动Kibana：bin\\kibana.bat 进入Dev Tools界面 GET _cluster/health CRUD面向文档的搜索分析引擎 应用系统的数据结构都是面向对象的，复杂的 对象数据存储到数据库中，只能拆解开来，变为扁平的多张表，每次查询的时候还得还原回对象格式，相当麻烦 ES是面向文档的，文档中存储的数据结构，与面向对象的数据结构是一样的，基于这种文档数据结构，es可以提供复杂的索引，全文检索，分析聚合等功能 es的document用json数据格式来表达 12345678910111213141516public class Employee &#123; private String email; private String firstName; private String lastName; private EmployeeInfo info; private Date joinDate;&#125;private class EmployeeInfo &#123; private String bio; &#x2F;&#x2F; 性格 private Integer age; private String[] interests; &#x2F;&#x2F; 兴趣爱好&#125; 两张表：employee表，employee_info表，将employee对象的数据重新拆开来，变成Employee数据和EmployeeInfo数据employee表：email，first_name，last_name，join_date，4个字段employee_info表：bio，age，interests，3个字段；此外还有一个外键字段，比如employee_id，关联着employee表 1234567891011&#123; &quot;email&quot;: &quot;zhangsan@sina.com&quot;, &quot;first_name&quot;: &quot;san&quot;, &quot;last_name&quot;: &quot;zhang&quot;, &quot;info&quot;: &#123; &quot;bio&quot;: &quot;curious and modest&quot;, &quot;age&quot;: 30, &quot;interests&quot;: [ &quot;bike&quot;, &quot;climb&quot; ] &#125;, &quot;join_date&quot;: &quot;2021&#x2F;01&#x2F;01&quot;&#125; 集群管理GET /_cat/health?v 快速检查集群的健康状况 12345epoch timestamp cluster status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent1488006741 15:12:21 elasticsearch yellow 1 1 1 1 0 0 1 0 - 50.0%epoch timestamp cluster status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent1488007113 15:18:33 elasticsearch green 2 2 2 1 0 0 0 0 - 100.0% green: 每个索引的primary shard和replica shard都是active状态的yellow: 每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态red: 不是所有索引的primary shard都是active状态的，部分索引有数据丢失了 PUT /test_index?pretty 创建索引 123health status index uuid pri rep docs.count docs.deleted store.size pri.store.sizeyellow open test_index XmS9DTAtSkSZSwWhhGEKkQ 5 1 0 0 650b 650byellow open .kibana rUm9n9wMRQCCrRDEhqneBg 1 1 1 0 3.1kb 3.1kb DELETE /test_index?pretty 删除索引 12health status index uuid pri rep docs.count docs.deleted store.size pri.store.sizeyellow open .kibana rUm9n9wMRQCCrRDEhqneBg 1 1 1 0 3.1kb 3.1kb 新增商品12345678910111213141516171819202122232425PUT &#x2F;ecommerce&#x2F;product&#x2F;1&#123; &quot;name&quot; : &quot;gaolujie yagao&quot;, &quot;desc&quot; : &quot;gaoxiao meibai&quot;, &quot;price&quot; : 30, &quot;producer&quot; : &quot;gaolujie producer&quot;, &quot;tags&quot;: [ &quot;meibai&quot;, &quot;fangzhu&quot; ]&#125;PUT &#x2F;ecommerce&#x2F;product&#x2F;2&#123; &quot;name&quot; : &quot;jiajieshi yagao&quot;, &quot;desc&quot; : &quot;youxiao fangzhu&quot;, &quot;price&quot; : 25, &quot;producer&quot; : &quot;jiajieshi producer&quot;, &quot;tags&quot;: [ &quot;fangzhu&quot; ]&#125;PUT &#x2F;ecommerce&#x2F;product&#x2F;3&#123; &quot;name&quot; : &quot;zhonghua yagao&quot;, &quot;desc&quot; : &quot;caoben zhiwu&quot;, &quot;price&quot; : 40, &quot;producer&quot; : &quot;zhonghua producer&quot;, &quot;tags&quot;: [ &quot;qingxin&quot; ]&#125; es会自动建立index和type，不需要提前创建，而且es默认会对document每个field都建立倒排索引，让其可以被搜索 12345678910111213&#123; &quot;_index&quot;: &quot;ecommerce&quot;, &quot;_type&quot;: &quot;product&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, # 创建与更新计数 &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, # 只有一个节点 &quot;failed&quot;: 0 &#125;, &quot;created&quot;: true&#125; 查询商品GET /ecommerce/product/1 替换文档123456789101112PUT &#x2F;ecommerce&#x2F;product&#x2F;1&#123; &quot;name&quot; : &quot;jiaqiangban gaolujie yagao&quot;, &quot;desc&quot; : &quot;gaoxiao meibai&quot;, &quot;price&quot; : 30, &quot;producer&quot; : &quot;gaolujie producer&quot;, &quot;tags&quot;: [ &quot;meibai&quot;, &quot;fangzhu&quot; ]&#125;PUT &#x2F;ecommerce&#x2F;product&#x2F;1&#123; &quot;name&quot; : &quot;jiaqiangban gaolujie yagao&quot;&#125; 替换方式有一个不好，即使必须带上所有的field，才能去进行信息的修改 更新文档123456POST &#x2F;ecommerce&#x2F;product&#x2F;1&#x2F;_update&#123; &quot;doc&quot;: &#123; &quot;name&quot;: &quot;jiaqiangban gaolujie yagao&quot; &#125;&#125; 删除文档DELETE /ecommerce/product/1 搜索方式 query string search query DSL query filter full-text search phrase search highlight search agg search query string searchtook：耗费了几毫秒timed_out：是否超时，这里是没有_shards：数据拆成了5个分片，所以对于搜索请求，会打到所有的primary shard（或者是它的某个replica shard也可以）hits.total：查询结果的数量，3个documenthits.max_score：score的含义，就是document对于一个search的相关度的匹配分数，越相关，就越匹配，分数也高hits.hits：包含了匹配搜索的document的详细数据 GET /ecommerce/product/_search 搜索全部商品 GET /ecommerce/product/_search?q=name:yagao&amp;sort=price:desc 搜索商品名称中包含yagao的商品，按照售价降序排序 适用于临时的在命令行使用一些工具，比如curl，快速的发出请求，来检索想要的信息；但是如果查询请求很复杂，是很难去构建的，在生产环境中，几乎很少使用query string search query DSL查询所有商品 1234GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; 查询名称包含yagao的商品，同时按照价格降序排序 1234567891011GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;name&quot; : &quot;yagao&quot; &#125; &#125;, &quot;sort&quot;: [ &#123; &quot;price&quot;: &quot;desc&quot; &#125; ]&#125; 分页查询商品，总共3条商品，假设每页就显示1条商品，现在显示第2页，所以就查出来第2个商品 123456GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;from&quot;: 1, &quot;size&quot;: 1&#125; 指定要查询出来商品的名称和价格 12345GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;_source&quot;: [&quot;name&quot;, &quot;price&quot;]&#125; 更加适合生产环境的使用，可以构建复杂的查询 query filter搜索商品名称包含yagao，而且售价大于25元的商品 1234567891011121314151617GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot; : &#123; &quot;bool&quot; : &#123; &quot;must&quot; : &#123; &quot;match&quot; : &#123; &quot;name&quot; : &quot;yagao&quot; &#125; &#125;, &quot;filter&quot; : &#123; &quot;range&quot; : &#123; &quot;price&quot; : &#123; &quot;gt&quot; : 25 &#125; &#125; &#125; &#125; &#125;&#125; full-text search（全文检索）1234567891011121314151617PUT &#x2F;ecommerce&#x2F;product&#x2F;4&#123; &quot;name&quot; : &quot;special yagao&quot;, &quot;desc&quot; : &quot;special meibai&quot;, &quot;price&quot; : 50, &quot;producer&quot; : &quot;special yagao producer&quot;, &quot;tags&quot;: [ &quot;meibai&quot;, &quot;fangzhu&quot; ]&#125;GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;producer&quot; : &quot;yagao producer&quot; &#125; &#125;&#125; special 4yagao 4producer 1,2,3,4gaolujie 1zhognhua 3jiajieshi 2 yagao producer ---&gt; 拆成yagao和producer,搜索结果根据score排序 phrase search（短语搜索）跟全文检索相对应，相反，全文检索会将输入的搜索串拆解开来，去倒排索引里面去一一匹配，只要能匹配上任意一个拆解后的单词，就可以作为结果返回phrase search，要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配，才能作为结果返回 12345678GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot; : &#123; &quot;match_phrase&quot; : &#123; &quot;producer&quot; : &quot;yagao producer&quot; &#125; &#125;&#125; highlight search（高亮搜索结果）12345678910111213GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;producer&quot; : &quot;producer&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;fields&quot; : &#123; &quot;producer&quot; : &#123;&#125; &#125; &#125;&#125; agg（聚合搜索）计算每个tag下的商品数量 12345678GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;aggs&quot;: &#123; &quot;group_by_tags&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;tags&quot; &#125; &#125; &#125;&#125; 报错：Fielddata is disabled on text fields by default. Set fielddata=true on [tags] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. 将文本field的fielddata属性设置为true 123456789PUT &#x2F;ecommerce&#x2F;_mapping&#x2F;product&#123; &quot;properties&quot;: &#123; &quot;tags&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fielddata&quot;: true &#125; &#125;&#125; GET /ecommerce/product/_search 12345678&#123; &quot;size&quot;: 0, # 不显示查询出来原始的doc &quot;aggs&quot;: &#123; &quot;all_tags&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;tags&quot; &#125; &#125; &#125;&#125; { “took”: 20, “timed_out”: false, “_shards”: { “total”: 5, “successful”: 5, “failed”: 0 }, “hits”: { “total”: 4, “max_score”: 0, “hits”: [] }, “aggregations”: { “group_by_tags”: { “doc_count_error_upper_bound”: 0, “sum_other_doc_count”: 0, “buckets”: [ { “key”: “fangzhu”, “doc_count”: 3 }, { “key”: “meibai”, “doc_count”: 2 }, { “key”: “qingxin”, “doc_count”: 1 } ] } }} 计算名称中包含yagao的商品，每个tag下的商品数量 GET /ecommerce/product/_search 1234567891011121314&#123; &quot;size&quot;: 0, &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;yagao&quot; &#125; &#125;, &quot;aggs&quot;: &#123; &quot;all_tags&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;tags&quot; &#125; &#125; &#125; 先分组，再算每组的平均值，计算每个tag下的商品的平均价格 GET /ecommerce/product/_search 12345678910111213&#123; &quot;size&quot;: 0, &quot;aggs&quot; : &#123; &quot;group_by_tags&quot; : &#123; &quot;terms&quot; : &#123; &quot;field&quot; : &quot;tags&quot; &#125;, &quot;aggs&quot; : &#123; &quot;avg_price&quot; : &#123; &quot;avg&quot; : &#123; &quot;field&quot; : &quot;price&quot; &#125; &#125; &#125; &#125; &#125;&#125; { “took”: 8, “timed_out”: false, “_shards”: { “total”: 5, “successful”: 5, “failed”: 0 }, “hits”: { “total”: 4, “max_score”: 0, “hits”: [] }, “aggregations”: { “group_by_tags”: { “doc_count_error_upper_bound”: 0, “sum_other_doc_count”: 0, “buckets”: [ { “key”: “fangzhu”, “doc_count”: 2, “avg_price”: { “value”: 27.5 } }, { “key”: “meibai”, “doc_count”: 2, “avg_price”: { “value”: 40 } }, { “key”: “qingxin”, “doc_count”: 1, “avg_price”: { “value”: 40 } } ] } }} 计算每个tag下的商品的平均价格，并且按照平均价格降序排序 GET /ecommerce/product/_search 12345678910111213&#123; &quot;size&quot;: 0, &quot;aggs&quot; : &#123; &quot;all_tags&quot; : &#123; &quot;terms&quot; : &#123; &quot;field&quot; : &quot;tags&quot;, &quot;order&quot;: &#123; &quot;avg_price&quot;: &quot;desc&quot; &#125; &#125;, &quot;aggs&quot; : &#123; &quot;avg_price&quot; : &#123; &quot;avg&quot; : &#123; &quot;field&quot; : &quot;price&quot; &#125; &#125; &#125; &#125; &#125;&#125; 按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格 123456789101112131415161718192021222324252627282930313233343536373839GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;group_by_price&quot;: &#123; &quot;range&quot;: &#123; &quot;field&quot;: &quot;price&quot;, &quot;ranges&quot;: [ &#123; &quot;from&quot;: 0, &quot;to&quot;: 20 &#125;, &#123; &quot;from&quot;: 20, &quot;to&quot;: 40 &#125;, &#123; &quot;from&quot;: 40, &quot;to&quot;: 50 &#125; ] &#125;, &quot;aggs&quot;: &#123; &quot;group_by_tags&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;tags&quot; &#125;, &quot;aggs&quot;: &#123; &quot;average_price&quot;: &#123; &quot;avg&quot;: &#123; &quot;field&quot;: &quot;price&quot; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://onejane.github.io/tags/elasticsearch/"}]},{"title":"Redis基本数据类型与应用场景","slug":"Redis基本数据类型与应用场景","date":"2021-05-09T09:05:24.000Z","updated":"2021-05-09T16:39:55.245Z","comments":true,"path":"2021/05/09/Redis基本数据类型与应用场景/","link":"","permalink":"http://onejane.github.io/2021/05/09/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"基本数据类型Redis作为内存中的数据结构存储系统,它可以用作数据库、缓存和消息中间件。它的 value支持多种类型的数据结构,基本数据结构包含:字符串( strings)、散列( hashes)、列表(ists)、集合(sets)、有序集合( sorted sets)五种。这五种数据结构在我们工作中经常使用到,面试过程中经常被问到,因此熟练掌握这5种基本数据结构的使用和应用场景是Redis知识最基础也是最重要的部分。 共同好友：set 用户积分排行榜：sorted set feed流：list … 字符串类型介绍字符串是 Redis最简单的储存类型,它存储的值可以是字符串、整数或者浮点数,对整个字符串或者字符串的其中一部分执行操作;对整数或者浮点数执行自增( increment)或者自减( decrement)操作。 Redis的字符串是一个由字节组成的序列,跟java里面的 ArrayList有点类似,采用预分配冗余空间的方式来减少内存的频繁分配,内部为当前字符串实际分配的空间 capacity一般要高于实际字符串长度len。当字符串长度小于1M时,扩容都是加倍现有的空间,如果超过1M,扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。 应用场景字符串类型在工作中使用广泛,主要用于不怎么更改但频繁查询的缓存数据,提高査询性能。比如存储登录用户信息、电商中存储商品信息、可以做计数器(想知道什么时候封锁一个IP地址(访问超过几次))等等。 123456789set username onejaneget usernamemset age 18 address suzhoumget username ageincr num decr numincrby num 2decrby num 2del num 散列散列相当于Java中的 HashMap,内部是无序字典。实现原理跟 HashMap一致。一个哈希表有多个节点,每个节点保存一个键值对。与Java中的 HashMap不同的是, rehash的方式不一样,因为Java的 HashMap在字典很大时, rehash是个耗时的操作,需要次性全部 rehash。 Redis为了高性能,不能堵塞服务,所以采用了渐进式 rehash策略。渐进式 rehash会在 rehash的同时,保留新旧两个hash结构,查询时会同时查询两个hash结构,然后在后续的定时任务中以及hash操作指令中,循序渐进地将旧hash的内容一点点迁移到新的hash结构中。当搬迁完成了,就会使用新的hash结。构取而代之当hash移除了最后一个元素之后,该数据结构自动被删除,内存被回收。","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://onejane.github.io/tags/redis/"}]},{"title":"Redis快速入门","slug":"Redis快速入门","date":"2021-05-08T18:26:01.000Z","updated":"2021-05-09T09:00:51.299Z","comments":true,"path":"2021/05/09/Redis快速入门/","link":"","permalink":"http://onejane.github.io/2021/05/09/Redis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"介绍优点高性能：底层C语言编写，内存数据库，通讯采用epoll非阻塞I/O多路复用机制 线程安全：单线程属于原子操作，高并发场景下保证数据安全。 redis 6.0多线程体现在网络协议解析。同步数据上，底层核心操作还是单线程的。 功能丰富： 数据结构：String,List,HashSet,SortedSet,GEO,BitMap,HyperLogLog 持久化：RDB持久化,AOF持久化,RDB-AOF混合持久化 主从：Master-Slave应对高并发场景，一般单机QPS都在几万左右，如果需要支撑高并发，我们可以将Redis做成主从架构来支持读写分离。 主从架构 -&gt; 读写分离 -&gt; 支撑10万+读QPS 并发10w以内：单节点读11w qps 写8.1w qps 10w-20w：读写分离 主从模式，为了主节点高可用，提供哨兵监控，为了降低各节点存储数据压力，提供集群模式 哨兵：主节点不能出现单点故障，哨兵机制Sentinel监控主节点，自动主从切换 集群：数据存储压力通过cluster分片存储，模块化实现自定义实现个性化需求 场景用户：注册，单点登录，签到 好友功能：关注，取消，互粉 排行榜：积分，热度排行榜 缓存：缓存餐厅数据 秒杀：预售，倒计时秒杀 订单：分布式锁 附近的人：地理位置搜索 Feed：添加，点赞，评论，列表 方案Springboot整合Redis SpringCloud搭建微服务 系统响应慢：连接池优化，用合适的数据类型缓存，慢日志查询，BigKey处理 缓存异常：分布式锁，LRU淘汰算法，通过限流等处理缓存雪崩，穿透。 数据丢失不安全：主从复制数据一致性，RDB-AOF混合持久化，全量/部分同步 主从复制故障：哨兵监控，主观/客观下线 存储不够用：集群分片存储，集群内部原理，故障自动转移 服务器宕机：集群动态收缩，moved/ask转向，故障演示与恢复方案 底层原理：网络底层，事务处理，持久化原理，主从复制原理，哨兵机制，分片存储原理 底层算法：Sorted Set底层，Bitmap、Geo算法，数据过期淘汰算法，Leader选举流程，槽位定位算法，备份迁移及其算法 性能提升方案：Key与Value设计规范，避免BigKey，避免耗时操作，Pipline管道操作，连接池性能优化，子进程的开销与优化 故障解决方案：数据延迟，数据脏读，数据抖动，数据一致性，热点数据存储，RDB文件损坏 版本说明 Redis2.6 键的过期时间支持毫秒 从节点支持只读功能 Redis2.8 可以用bind命令绑定多个IP地址 发布订阅添加了pub/sub Redis Sentienl第二版，相比于Redis2.6的RedisSentinel，已经变成生产可用 Redis3.0 添加Redis的分布式实现Redis Cluster Redis3.2 添加GEO相关功能 新List类型：quicklist Redis4.0 提供了模块系统,方便第三方开发者拓展 Redis的功能 提供了新的缓存剔除算法:LFU( Last Frequently Used),并对已有算法进行了优化。 提供了非阻塞del和 flushall/flushdb功能,有效解决删除了 bigKey可能造成的 Redis阻塞。 提供了RDB-AOF混合持久化格式,充分利用了AOF和RDB各自优势。 Redis5.0 新的 Stream数据类型。 客户经常连接和断开连接时性能更好。 Redis6.0 多线程IO，多线程部分只是用来处理网络数据的读写和协议解析,执行命令仍然是单线程。 支撑10w+qps特点 内存数据库,速度快,也支持数据的持久化 Redis不仅仅攴持简单的 key-value类型的数据,同时还提供 Lists、 Hashes、Sets、 Sorted Sets等多种数据结构的存储。 Redis支持数据的备份( master-slave)与集群(分片存储),以及拥有哨兵监控机制。 支持事务 优势 性能极高- Redis能读的速度是110000次/s,写的速度是81000次/s 丰富的数据类型- Redis支持 Strings、 Lists、 Hashes、Sets、 Sorted Sets等数据类型操作。 原子操作- Redis的所有操作都是原子性的,同时 Redis还支持对几个操作合并后的原子性执行(事务) 丰富的特性- Redis还支持 publish/subscribe,通知,key过期等特性 主节点一旦故障，无法写入数据，哨兵机制解决，奇数哨兵&gt;1/2重新选举主节点，避免网络波动误判 读写分离，每次写入都会复制，从节点也会拥有实际数据，每个节点都有大量重复数据，服务器压力大，集群分片解决 Redis、Memcached、Ehcache区别Ehcache不能很好实现分布式项目缓存的同步共享的问题 Memcached数据类型单一 这三个中间件都可以应用于缓存,但目前市面上使用 Redis的场景会更多,更广泛,其原因是: Redis性能高、原子操作、支持多种数据类型,主从复制与哨兵监控,持久化操作等 Redis的高并发官方的 bench-mark数据:测试完成了50个并发执行100000个请求,设置和获取的值是一个256字节字符串。结果:读的速度是110000次/s,写的速度是81000次/s,redis尽量少写多读,符合缓存的适用要求,单机 redis支撑万级,如果10万+可以采用主从复制的模式。 原理 Redis是纯内存数据库,没有磁盘IO，所以读取速度快。 Redis使用的是非阻塞I/O多路复用,减少了线程切换时上下文的切换和竞争。 Redis采用了单线程的模型,保证了每个操作的原子性,也减少了线程的上下文切换和竞争。 Redis存储结构多样化,不同的数据结构对数据存储进行了优化加快读取的速度。 Redis采用自己实现的事件分离器,效率比较高,内部采用非阻塞的执行方式,吞吐能力比较大 Redis的单线程原因 不需要各种锁的性能消耗 单线程多进程集群方案 CPU消耗 优劣单进程单线程优势 代码更清晰,处理逻辑更简单 不用去考虑各种锁的问题,不存在加锁释放锁操作,没有因为可能出现死锁而导致的性能消耗 不存在多进程或者多线程导致的切换而消耗CPU 单进程单线程弊端 无法发挥多核CPU性能,不过可以通过在单机开多个 Redis实例来完善 IO多路复用Redis采用网络IO多路复用技术来保证在多连接的时候系统高吞吐量，提高快速的写入和读取能力。 环境安装1234567891011121314151617181920212223242526272829303132wget -P &#x2F;usr&#x2F;local&#x2F;src&#x2F; https:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-6.0.9.tar.gz 下载redis-6.0.9tar zxvf redis-6.0.9.tar.gz 解压yum install -y gcc-c++ autoconf automake 安装redis-6.0.9必备依赖,升级gccyum install -y centos-release-scl scl-utils-buildyum install -y devtoolset-9-toolchainscl enable devtoolset-9 bashgcc -vcd redis-6.0.9&#x2F; &amp;&amp; make 编译mkdir -p &#x2F;usr&#x2F;local&#x2F;redismake PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis&#x2F; install 安装rediscd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;.&#x2F;redis-server 启动redis-servercp &#x2F;usr&#x2F;local&#x2F;src&#x2F;redis-6.0.9&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;vi redis.conf 打开守护进程daemonize yes.&#x2F;redis-server redis.conf 后台运行redisvi &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;redis.service[Unit]Description&#x3D;redis-serverAfter&#x3D;network.target[Service]Type&#x3D;forkingExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis.confPrivateTmp&#x3D;true[Install]WantedBy&#x3D;multi-user.targetsystemctl daemon-reloadsystemctl start redis.servicesystemctl stop redis.servicesystemctl enable redis.service 配置Redis支持很多的参数,但都有默认值。 daemonize默认情况下, redis不是在后台运行的,如果需要在后台运行,把该项的值更改为yes bind指定 Redis只接收来自于该IP地址的请求。 port监听端口,默认为6379。 databases设置数据库的个数,默认使用的数据库是0。 save设置 Redis进行数据库镜像的频率 filename镜像备份文件的文件名。 dir数据库镜像备份的文件放置的路径。 requirepass设置客户端连接后进行任何其他指定前需要使用的密码。 maxclients限制同时连接的客户数量。 maxmemory设置 redis能够使用的最大内存 客户端redis-cli1234567891011121314151617181920systemctl stop firewalldvi redis.confbind 0.0.0.0protected-mode norequirepass 123456systemctl restart redis.servicevim Vagrantfileconfig.vm.network &quot;private_network&quot;, type: &quot;dhcp&quot;vagrant reloadcd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;.&#x2F;redis-cli -h 172.28.128.3 -p 6379 -a 123456.&#x2F;redis-cli -a 123456select 2set username wjkeys *info CPUinfo clusterinfoflushall Redis Desktop Manager jedisRedis的Java客户端也有很多:https://redis.io/clients#java,其中比较受欢迎的是 Jedis和 Lettuce。 Jedis在实现上是直接连接的 redis server,如果在多线程环境下是非线程安全的,这个时候只有使用连接池,为毎个Jedis实例增加物理连接,官方推荐 Lettuce的连接是基于Netty的,连接实例( StatefulRedisConnection)可以在多个线程间并发访问,应为StatefulRedisConnection是线程安全的,所以一个连接实例( StatefulRedisconnection)就可以满足多线程环境下的并发访问,当然这个也是可伸缩的设计,一个连接实例不够的情况也可以按需增加连接实例。 在 Spring Boot Data Redis1.X之前默认使用的是 Jedis,但目前最新版的修改成了 Lettuce。 之前公司使用 Jedis居多, Lettuce近两年在逐步上升,总的来讲 Jedis的性能会优于 Lettuce(因为它是直接操作 Redis)。 pom引入依赖 1234567891011121314&lt;dependencies&gt; &lt;!--jedis客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt; &lt;version&gt;3.3.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.13&lt;&#x2F;version&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 测试 1234567891011121314151617181920212223242526272829303132333435public class JedisTest &#123; Jedis jedis &#x3D; null; @Before public void testInit()&#123; jedis &#x3D; new Jedis(&quot;172.28.128.3&quot;,6379);&#x2F;&#x2F; jedis.auth(&quot;123456&quot;); String pong &#x3D; jedis.ping(); System.out.println(pong); &#125; @Test public void testString()&#123; System.out.println(jedis.select(2)); System.out.println(jedis.set(&quot;username&quot;,&quot;onejane&quot;)); System.out.println(jedis.get(&quot;username&quot;)); jedis.set(&quot;user:name:1&quot;,&quot;j&quot;); System.out.println(jedis.get(&quot;user:name:1&quot;)); &#125; @Test public void testKeys()&#123; System.out.println(jedis.select(2)); System.out.println(jedis.keys(&quot;*&quot;)); System.out.println(jedis.flushAll()); &#125; @After public void close()&#123; if(null !&#x3D; jedis)&#123; jedis.close(); &#125; &#125;&#125; Jedis连接池优化 我们知道 Jedis是直接操作 Redis,当在并发量非常大的时候,那么 Jedis操作 Redis的连接数很有可能就会异常,因此为了提髙操作效率,引入连接池。 Jedis池化技术( JedisPool)在创建时初始化一些连接资源存储到连接池中,使用 Jadis连接资源时不需要创建,而是从连接池中获取一个资源进行 redis的操作,使用完毕后,不需要销毁该 jedis连接资源,而是将该资源归还给连接池,供其他请求使用。 1234567891011121314151617181920212223242526public class JedisPoolConnectRedis &#123; private static JedisPool jedisPool; static &#123; &#x2F;&#x2F; 创建连接池配置对象 JedisPoolConfig jedisPoolConfig &#x3D; new JedisPoolConfig(); &#x2F;&#x2F; 设置最大连接数 默认8 jedisPoolConfig.setMaxTotal(5); &#x2F;&#x2F; 设置最大空闲数量 默认8 jedisPoolConfig.setMaxIdle(5); &#x2F;&#x2F; 设置最少空闲数量 默认0 jedisPoolConfig.setMinIdle(0); &#x2F;&#x2F; 设置等待时间 ms jedisPoolConfig.setMaxWaitMillis(100); &#x2F;&#x2F; 初始化 JedisPool 对象 jedisPool &#x3D; new JedisPool(jedisPoolConfig,&quot;172.28.128.3&quot;,6379,100);&#x2F;&#x2F; jedisPool &#x3D; new JedisPool(jedisPoolConfig,&quot;172.28.128.3&quot;,6379,100,&quot;123456&quot;); &#125; &#x2F;** * 获取jedis对象 * @return *&#x2F; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; 修改测试生成jedis对象 12345678Jedis jedis &#x3D; null;@Beforepublic void testInit()&#123; jedis &#x3D; JedisPoolConnectRedis.getJedis(); &#x2F;&#x2F; jedis.auth(&quot;123456&quot;); String pong &#x3D; jedis.ping(); System.out.println(pong);&#125; spring-datapom添加依赖 12345678910111213141516171819202122232425262728293031323334 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3.10.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt; &lt;&#x2F;parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!--lettuce线程安全 打开commons-pool2依赖， spring.redis.jedis改成spring.redis.lettuce即可--&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;--&gt;&lt;!-- &lt;&#x2F;dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt; &lt;&#x2F;exclusion&gt; &lt;&#x2F;exclusions&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; application.yml添加配置 1234567891011121314151617181920spring: # redis配置 redis: host: 172.28.128.3 port: 6379 database: 5 # jedis连接池配置 jedis: pool: max-active: 8 max-idle: 8 min-idle: 0 max-wait: 1000# password: 123456# lettuce:# pool:# max-active: 8# max-idle: 8# min-idle: 0# max-wait: 1000 启动类添加Redis序列化方法 1234567891011121314151617181920@Beanpublic RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; redisTemplate &#x3D; new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(redisConnectionFactory); &#x2F;&#x2F; 使用Jackson2JsonRedisSerialize 替换默认序列化 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class); ObjectMapper objectMapper &#x3D; new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); &#x2F;&#x2F; 设置value的序列化规则和 key的序列化规则 redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); redisTemplate.afterPropertiesSet(); return redisTemplate;&#125; 测试 123456789101112131415161718@SpringBootTest&#x2F;&#x2F; 默认 (classes &#x3D; &#123;SpringdataDemoApplication.class&#125;)class SpringdataDemoApplicationTests &#123; @Autowired private RedisTemplate redisTemplate; @Test void testInit() &#123; System.out.println(redisTemplate.getConnectionFactory().getConnection().ping()); &#125; @Test public void testString()&#123; redisTemplate.opsForValue().set(&quot;username&quot;,&quot;onejane&quot;);; System.out.println(redisTemplate.opsForValue().get(&quot;username&quot;)); &#125;&#125; 微服务架构 food-social-contact-parent12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;properties&gt; &lt;spring-boot-version&gt;2.3.5.RELEASE&lt;&#x2F;spring-boot-version&gt; &lt;spring-cloud-version&gt;Hoxton.SR8&lt;&#x2F;spring-cloud-version&gt; &lt;lombok-version&gt;1.18.16&lt;&#x2F;lombok-version&gt; &lt;commons-lang-version&gt;3.11&lt;&#x2F;commons-lang-version&gt; &lt;mybatis-starter-version&gt;2.1.3&lt;&#x2F;mybatis-starter-version&gt; &lt;swagger-starter-version&gt;2.1.5-RELEASE&lt;&#x2F;swagger-starter-version&gt; &lt;hutool-version&gt;5.4.7&lt;&#x2F;hutool-version&gt; &lt;guava-version&gt;20.0&lt;&#x2F;guava-version&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;&lt;&#x2F;properties&gt;&lt;!-- 集中定义依赖，不引入 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- spring boot 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-boot-version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!-- spring cloud 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud-version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!-- lombok 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;lombok-version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- common-lang3 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;commons-lang-version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- mybatis 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mybatis-starter-version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- swagger 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.battcn&lt;&#x2F;groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;swagger-starter-version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- mysql 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!-- hutool 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt; &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;hutool-version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- guava 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt; &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;guava-version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt;&lt;!-- 集中定义项目所需插件 --&gt;&lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- spring boot maven 项目打包插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;pluginManagement&gt;&lt;&#x2F;build&gt; 注册中心ms-registry123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 配置 1234567891011121314server: port: 8080spring: application: name: ms-registry# 配置 Eureka Server 注册中心eureka: client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http:&#x2F;&#x2F;localhost:8080&#x2F;eureka&#x2F; 启动类添加注册中心注解@EnableEurekaServer 访问http://127.0.0.1:8080/ 查看注册到eureka的实例 网关ms-gateway12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 配置 123456789101112131415161718192021222324252627server: port: 80spring: application: name: ms-gateway cloud: gateway: discovery: locator: enabled: true # 开启配置注册中心进行路由功能 lower-case-service-id: true # 将服务名称转小写 routes: - id: ms-diners uri: lb:&#x2F;&#x2F;ms-diners predicates: - Path&#x3D;&#x2F;hello&#x2F;**# 配置 Eureka Server 注册中心eureka: instance: # 注册中心实例以ip显示 prefer-ip-address: true instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125; client: service-url: defaultZone: http:&#x2F;&#x2F;localhost:8080&#x2F;eureka&#x2F; 食客ms-diners12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 配置 123456789101112131415server: port: 8081spring: application: name: ms-diners# 配置 Eureka Server 注册中心eureka: instance: prefer-ip-address: true instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125; client: service-url: defaultZone: http:&#x2F;&#x2F;localhost:8080&#x2F;eureka&#x2F; Controller 12345678910@RestController@RequestMapping(&quot;hello&quot;)public class HelloController &#123; @GetMapping public String hello(String name) &#123; return &quot;hello &quot; + name; &#125;&#125; 直接访问 http://localhost:8081/hello?name=redis网关访问 http://localhost/hello?name=redis","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://onejane.github.io/tags/redis/"}]},{"title":"frida沙箱自吐实现","slug":"frida沙箱自吐实现","date":"2021-05-05T16:08:14.000Z","updated":"2021-05-29T03:44:28.825Z","comments":true,"path":"2021/05/06/frida沙箱自吐实现/","link":"","permalink":"http://onejane.github.io/2021/05/06/frida%E6%B2%99%E7%AE%B1%E8%87%AA%E5%90%90%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"沙箱沙箱：对于系统来说，单个APP是没有隐私的，不管是脱壳、还是收发包，都是由系统的API来执行的。HOOK系统的API，就能得到很多APP的关键信息。 APP想要对抗沙箱： 尽可能减少系统API的调用； 尽可能自己实现一定量的算法； 对自己实现的算法进行强混淆； 增加自身算法的复杂度吧：VMP 各大安全公司、杀毒软件公司基本上都会有自己的沙箱，只要病毒/木马在自己的沙箱跑一遍，直接得到执行流、病毒相似性分析，如绑绑安全的安全密钥白盒，对于APP也是一样的。 基于hook的沙箱Youpk Fart 都是沙箱,由于基于系统本身基本无法对抗。 appmonappmon wiki 123456789101112.&#x2F;fs128arm64 vim &#x2F;etc&#x2F;proxychains4.conf socks5 192.168.0.107 1080 # 电脑主机 ssr选项设置-开启来自局域网的连接PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pyenv install 3.8.2PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pip install frida&#x3D;&#x3D;12.8.0PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pip install frida-tools&#x3D;&#x3D;5.3.0PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pip install objection&#x3D;&#x3D;1.8.4proxychains wget https:&#x2F;&#x2F;github.com&#x2F;dpnishant&#x2F;appmon&#x2F;archive&#x2F;refs&#x2F;heads&#x2F;master.zip7z x master.zip cd appmon-master pip install argparse flask termcolor dataset --upgrade --ignore-installed sixpython appmon.py -a &quot;com.xiaojianbang.app&quot; -p android -s scripts&#x2F;Android 点击HookTestDemo.apk的算法加密按钮，触发生成./app_dumps/com.xiaojianbang.app.db 访问http://127.0.0.1:5000/ 选择com.xiaojianbang.app 由于显示内容都是[Object Object],修改源码打印hook内容。 12345data.value &#x3D; byteArraytoHexString(digest); 删除var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); 替换data.value &#x3D; ByteString.of(digest).hex()frida -UF -l Hash.js 基于源码的沙箱aosp810r1 解压驱动Vendor image 驱动GPS, Audio, Camera, Gestures, Graphics, DRM, Video, Sensors 解压驱动解压到aosp810r1中后./extrace-google_devices-sailfish.sh 和./extrace-qcom-sailfish.sh 123456789101112131415161718192021222324252627# apt update# git config --global user.email &quot;you@example.com&quot;# git config --global user.name &quot;Your Name&quot;# apt install bison tree# dpkg --add-architecture i386# apt update# apt install libc6:i386 libncurses5:i386 libstdc++6:i386# apt install libxml2-utilsdd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;swapfile bs&#x3D;1024 count&#x3D;10240000 使用dd创建swapfile作为swap分区空间mkswap swapfile mkswap创建交换文件Kali下手动安装openjdk-8-jdk：# wget http:&#x2F;&#x2F;http.kali.org&#x2F;pool&#x2F;main&#x2F;o&#x2F;openjdk-8&#x2F;openjdk-8-jdk-headless_8u212-b01-1_amd64.deb# dpkg -i openjdk-8-jdk-headless_8u212-b01-1_amd64.deb# wget http:&#x2F;&#x2F;http.kali.org&#x2F;pool&#x2F;main&#x2F;o&#x2F;openjdk-8&#x2F;openjdk-8-jdk_8u212-b01-1_amd64.deb# dpkg -i openjdk-8-jdk_8u212-b01-1_amd64.deb安装完成后再用：# update-alternatives --config java# update-alternatives --config javac选择2来切换jdk的版本：见图最后用version选项来确认版本：# java -version# javac -versionsource build&#x2F;envsetup.shlunch 选择24 aosp_sailfish-userdebugmake 编译完成的系统镜像位于当前目录的out&#x2F;target&#x2F;product&#x2F;sailfish&#x2F;下包括各个img 官方镜像 下载下来后解压将上面编译好的所有img替换到官方镜像解压后的image-sailfish-opm1.171019.011文件夹，并还原创建zip包 12adb reboot bootloader.&#x2F;flash-all.sh Android Studio 导入 AOSP 源码 development/tools/idegen/idegen.sh 会在根目录下生成android.iml 和 android.ipr 这两个文件，这两个文件是 Android Studio 的工程配置文件，这时候其实已经可以直接导入 Android Studio，但会导入所有的源码模块，会很慢，可以进行过滤，除了 frameworks 模块和 packages 模块，其他都给过滤掉，不导入 Android Studio，打开 android.iml 文件，搜下excludeFolder，在后面加入如下代码： 12345678910111213141516171819202122232425&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;art&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;bionic&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;bootable&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;build&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;cts&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;dalvik&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;developers&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;development&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;device&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;docs&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;external&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;hardware&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;kernel&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;libcore&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;libnativehelper&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;out&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;pdk&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;platform_testing&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;prebuilts&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;sdk&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;system&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;test&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;toolchain&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;tools&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;.repo&quot; &#x2F;&gt; 发现 Android Studio 不停 scanning files to index，我的强迫症又犯了，解决： invalidate and restart 不起作用； 右击项目 –&gt; Open module setting –&gt; Modules –&gt; 找到 gen 文件夹 –&gt; 右键选择 Resources，终于告别烦人的 scanning files to index。 修改MessageDigest.java crypto_filter_aosp基于android6.0.1 Nexus 6P ROM,系统底包 先刷官方原版底包，老版本使用fastboot6.0放到kali的/root/Android/Sdk/plateform-tools,flash-all.sh 手机先刷入fastbboot flash recovery twrp 下载rom解压，adb push ROM/ /sdcard/TWRP/BACKUPS 进入twrp，从备份中恢复Restore,重启手机,然后修改权限 chmod 777 /data/local/tmp/monitor_package 安装你需要监控的apk(系统自动把最后一次安装的apk添加进去监控的列表 /data/local/tmp/monitor_package),只能同时监控一个adb install HookTestDemo.apk /data/data/package_name/下面生成APK调用的算法,只有三种(数据均为JSON编码,字段为BASE64编码)/data/data/com.xiaojianbang.app 参考crypto_filter_aosp文件夹源码添加到aosp810r1的源码中，将MyUtil.java,ContextHolder.java,AndroidBase64.java,Cipher.java放到aosp810r1/libcore/ojluni/src/main/java/javax/crypto 将参考20200212/MessageDigest.java代码实现到aosp810r1的MessageDigest.java。同理，修改Mac.java openjdk_java_files.mk添加新增的需要编译的类 123ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;javax&#x2F;crypto&#x2F;Mac.java \\ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;javax&#x2F;crypto&#x2F;ContextHolder.java \\ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;javax&#x2F;crypto&#x2F;MyUtil.java \\ 123source build&#x2F;envsetup.shlunch aosp_sailfish-usermake 如报错make update-api 编译完成后将编译好的img压缩成image-sailfish-opm1.17019.011.zip放到官方系统底包，./flash-all.bat刷机 AOSP网络库自吐适用于沙箱的原则：我们要可以在安卓源码中找到其实现、彻底的修改其实现。 App开发实力越强，App自己实现的内容越多，对系统的依赖程度越低，沙箱的作用就越小。→ 沙箱只能帮助定位到关键的点，如何把内容解开还是分析自己实现的部分。 为了能抓到包，无数安全研究人员使出浑身解数，我们可以按照OSI七层模型或TCP/IP四层模型。 我们在谈论MAC地址/ARP的时候，我们聊的就是链路层； 我们在谈论IP地址/路由器的时候，我们聊的就是网络层； 我们在谈论连接某个端口的时候，我们聊的就是传输层； 我们在谈论发送数据的内容的时候，我们聊的就是应用层； 应用层/Application：基于中间人的HTTP(S)抓包 该方法继承于网页端的抓包，只不过对抗性全面强化；在设计网站时无法控制客户端，但是App确是可以被厂商全面控制的； 在客户端校验服务器证书的情况下，需要将抓包软件（推荐Charles）的证书置于手机根证书目录下，推荐Magisk插件Move Certificates； 在服务器验证客户端证书的情况下，还需要在App中dump出证书导入到Charles中，这就涉及到证书密码和证书的解密； App使用特定API，绕过WIFI代理进行通信→ 使用VPN将所有流量导入到Charles → App还会检测VPN，发现即断网 → 需要hook过VPN检测； 哪些是可以改的：（沙箱在辅助中间人抓包的过程中发挥的作用） Charles证书内置到系统根目录中去，某文件→某目录下（aosp810r1/system/ca-certificates/files） App的客户端证书的文件和密码，并不是所有的客户端证书都是必须以文件的形式、打开密码的要求存储的。可以是明文硬编码在代码里。(https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java，) 对抗部分：有没有使用No_ Proxy、VPN检测,某抢票app逆向续篇之干掉vpn抓包检测(System.getProperty(“http.proxyHost”); System.getProperty(“http.proxyPort”); java.net.NetworkInterface.getName(),android.net.ConnectivityManager.getNetworkCapabilities()) SSL pinning：从文件打开、哈希的计算处打调用栈 App使用SSL pinning，只信任自己的证书 → 从数十种框架中找到hook点并绕过 → App进行了代码混淆 → 反混淆并hook绕过，而反混淆总是让人倒吸一口凉气。。。 由于厂商可以全面控制客户端，因此可以使用小众协议，比如WebSocket、Protobuf，甚至自己写协议，比如腾讯的JceStruct，此时除了自己分析协议字段别无他法 传输层/Transport：App使用纯Socket通信 比如某应用的数据采用点对点纯Socket的tcp通信，此时只有dump其通信流量，分析其raw data，结合源码分析字段构成； 某厂商开创性地提出了自建代理长连通道的网络加速方案，App中绝大部分的请求通过CIP通道中的TCP子通道与长连服务器通信，长连服务器将收到的请求代理转发到业务服务器，对于业务来讲大大提高了效率，但是对于逆向来说却加大了抓包的难度。 也幸亏其SDK中包含了降级方案，可以hook某些关键函数实现降级到HTTP，给了安全研究员一口饭吃。更有大厂已经在通讯标准演进的路线上大步快跑，在目前HTTP/2都没有普及的情况下，受益于相比于网页端而言、App客户端全面可控的优势，提前迈入HTTP/3时代，在性能优化的KPI上一骑绝尘而去，从内核、算法、传输层网络库和服务端全部自研。 面对连抓包工具都没有提供支持的kQUIC，逆向分析者只能说欲哭无泪。同样还是幸亏SDK中包含了plan B降级方案，可以通过hook来进行降级，安全研究员续命一秒钟。 网络层/Network：一般而言鲜有App可以更改设备的IP地址 科学上网软件、VPN可以改手机的路由表，因此可以用来抓包； 可以自建路由器进行抓包，对手机完全无侵入、无感知，彻底搞定抓不到包！ 缺点是加密内容也无法还原，可以dump流量，却无法解密内容；在手机端连标准的SSL也解不开。也可以在手机上安装使用Kali Nethunter，在手机上直接跑Wireshark，接在4G流量卡上进行抓包，这种方式甚至可以抓到手机的流量卡的网卡包，应该是目前已知的唯一抓流量卡的方法。 应用层抓包通杀脚本 App在开发过程中，以App自己的权限，可以用代码实现到的最底层为传输层，也就用Socket接口，进行纯二进制的收发包，此处包括Java层和Native层。 除了少数开发实力雄厚甚至过剩的大厂，掌握着纯二进制收发包的传输层创新、或者自定义协议的技术之外，占绝对数量绝大多数的App厂商采用的还是传统的HTTP/SSL方案。 而且占绝对数量中绝大多数的App，其实现HTTP/SSL的方案也是非常的直白，那就是调用系统的API，或者调用更加易用的网络框架，比如访问网站的Okhttp框架，播放视频的Exoplayer，异步平滑图片滚动加载框架Glide，对于非网络库或协议等底层开发者来说，这些才应当是普罗大众安卓应用开发者的日常。 所以我们在对Java层Socket接口进行trace之后打调用栈，即可清晰地得出从肉眼可见的视频、到被封装成HTTP包、再到进入SSL进行加解密，再通过Socket与服务器进行通信的完整过程。 只要开发者使用了应用层框架，即无法避免的使用了系统的Socket进行了收发，如果是HTTP则直接走了Socket，没有加解密、直接是明文，将内容dump下来即可；如果走了HTTPS，那么HTTP包还要“裹上”一层SSL，通过SSL的接口进行收发，SSL则将加密后和解密前的数据走Socket与服务器进行通信，明文数据只有SSL库自己知道。 因此想要得到SSL加密前和解密后的HTTP数据的话，就要对SSL库有深入的研究，而像这种大型的、历史悠久的基础库，研究它的人是非常多的；比如谷歌就有研究员对OpenSSL的收发包接口进行了深入的研究，并对其收发包等接口使用frida进行hook，提取明文HTTP数据，最终的成品为ssl_logger项目；因为这种库一般作为互联网世界架构的基础设施，所以其应用非常广泛，这也是为何当其暴漏出“心脏滴血”漏洞时，几乎影响到所有互联网设备的原因，不管是Linux、Macos/iOS、还是安卓，使用的都是OpenSSL，刚刚我们trace到的SSLInputStream.read函数，充其量只是OpenSSL库在Java层的一个包装器罢了。 而又有来自阿里的巨佬，在使用的过程中，进一步优化了该项目的JS脚本，修复了在新版frida上的语法错误，并在原项目只支持Linux和macOS的基础上，增加了对iOS和Android的支持，最终的成品就是frida_ssl_logger项目。 该项目的完成度已经非常高，其核心原理就是对SSL_read和SSL_write进行hook，得到其收发包的明文数据。 12[Process.platform &#x3D;&#x3D; &quot;darwin&quot; ? &quot;*libboringssl*&quot; : &quot;*libssl*&quot;, [&quot;SSL_read&quot;, &quot;SSL_write&quot;, &quot;SSL_get_fd&quot;, &quot;SSL_get_session&quot;, &quot;SSL_SESSION_get_id&quot;]], &#x2F;&#x2F; for ios and Android[Process.platform &#x3D;&#x3D; &quot;darwin&quot; ? &quot;*libsystem*&quot; : &quot;*libc*&quot;, [&quot;getpeername&quot;, &quot;getsockname&quot;, &quot;ntohs&quot;, &quot;ntohl&quot;]] 并将明文数据使用RPC传输到电脑上，使用hexdump在python的控制台进行输出： 12345678910111213if verbose: src_addr &#x3D; socket.inet_ntop(socket.AF_INET, struct.pack(&quot;&gt;I&quot;, p[&quot;src_addr&quot;])) dst_addr &#x3D; socket.inet_ntop(socket.AF_INET, struct.pack(&quot;&gt;I&quot;, p[&quot;dst_addr&quot;])) print(&quot;SSL Session: &quot; + p[&quot;ssl_session_id&quot;]) print(&quot;[%s] %s:%d --&gt; %s:%d&quot; % ( p[&quot;function&quot;], src_addr, p[&quot;src_port&quot;], dst_addr, p[&quot;dst_port&quot;])) hexdump.hexdump(data) 或者保存至pcap文件，以供后续进一步分析。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def log_pcap(pcap_file, ssl_session_id, function, src_addr, src_port, dst_addr, dst_port, data): &quot;&quot;&quot;Writes the captured data to a pcap file. Args: pcap_file: The opened pcap file. ssl_session_id: The SSL session ID for the communication. function: The function that was intercepted (&quot;SSL_read&quot; or &quot;SSL_write&quot;). src_addr: The source address of the logged packet. src_port: The source port of the logged packet. dst_addr: The destination address of the logged packet. dst_port: The destination port of the logged packet. data: The decrypted packet data. &quot;&quot;&quot; t &#x3D; time.time() if ssl_session_id not in ssl_sessions: ssl_sessions[ssl_session_id] &#x3D; (random.randint(0, 0xFFFFFFFF), random.randint(0, 0xFFFFFFFF)) client_sent, server_sent &#x3D; ssl_sessions[ssl_session_id] if function &#x3D;&#x3D; &quot;SSL_read&quot;: seq, ack &#x3D; (server_sent, client_sent) else: seq, ack &#x3D; (client_sent, server_sent) for writes in ( # PCAP record (packet) header (&quot;&#x3D;I&quot;, int(t)), # Timestamp seconds (&quot;&#x3D;I&quot;, int((t * 1000000) % 1000000)), # Timestamp microseconds (&quot;&#x3D;I&quot;, 40 + len(data)), # Number of octets saved (&quot;&#x3D;i&quot;, 40 + len(data)), # Actual length of packet # IPv4 header (&quot;&gt;B&quot;, 0x45), # Version and Header Length (&quot;&gt;B&quot;, 0), # Type of Service (&quot;&gt;H&quot;, 40 + len(data)), # Total Length (&quot;&gt;H&quot;, 0), # Identification (&quot;&gt;H&quot;, 0x4000), # Flags and Fragment Offset (&quot;&gt;B&quot;, 0xFF), # Time to Live (&quot;&gt;B&quot;, 6), # Protocol (&quot;&gt;H&quot;, 0), # Header Checksum (&quot;&gt;I&quot;, src_addr), # Source Address (&quot;&gt;I&quot;, dst_addr), # Destination Address # TCP header (&quot;&gt;H&quot;, src_port), # Source Port (&quot;&gt;H&quot;, dst_port), # Destination Port (&quot;&gt;I&quot;, seq), # Sequence Number (&quot;&gt;I&quot;, ack), # Acknowledgment Number (&quot;&gt;H&quot;, 0x5018), # Header Length and Flags (&quot;&gt;H&quot;, 0xFFFF), # Window Size (&quot;&gt;H&quot;, 0), # Checksum (&quot;&gt;H&quot;, 0)): # Urgent Pointer pcap_file.write(struct.pack(writes[0], writes[1])) pcap_file.write(data) if function &#x3D;&#x3D; &quot;SSL_read&quot;: server_sent +&#x3D; len(data) else: client_sent +&#x3D; len(data) ssl_sessions[ssl_session_id] &#x3D; (client_sent, server_sent) 由于完成度已经相当高了，在构建安卓应用层抓包通杀脚本时，应当尽可能复用其已经实现好的“基础设施”，只要为其再补上明文数据即可，而这明文数据从哪里来？根据多轮trace可以得知，明文数据的收发包接口，正是由java.net.SocketOutputStream.socketWrite0和java.net.SocketInputStream.socketRead0这两个API负责的，当然其实二者还有很多上层调用的接口，在选择分析的接口时，应尽量选择离native层更近的、并且在更多安卓版本上适用的，比如这两个API在安卓7、8、9、10上是通用和不变的，以降低工作量。 最后的任务就是与SSL_read和SSL_write一样，根据收发的函数、找到收发的IP地址和端口，而正好两个API均有socket的实例域，提供了收发包的IP地址和端口信息。 最终就是取出这些信息，构造与SSL一样发给电脑即可，需要注意的是Java的[B需要手动转化成JavaScript的ByteArray还是略微复杂的。 123456789101112131415161718192021222324252627282930313233343536if (Java.available) &#123; Java.perform(function () &#123; Java.use(&quot;java.net.SocketOutputStream&quot;).socketWrite0.overload(&#39;java.io.FileDescriptor&#39;, &#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (fd, bytearry, offset, byteCount) &#123; var result &#x3D; this.socketWrite0(fd, bytearry, offset, byteCount); var message &#x3D; &#123;&#125;; message[&quot;function&quot;] &#x3D; &quot;HTTP_send&quot;; message[&quot;ssl_session_id&quot;] &#x3D; &quot;&quot;; message[&quot;src_addr&quot;] &#x3D; ntohl(ipToNumber((this.socket.value.getLocalAddress().toString().split(&quot;:&quot;)[0]).split(&quot;&#x2F;&quot;).pop())); message[&quot;src_port&quot;] &#x3D; parseInt(this.socket.value.getLocalPort().toString()); message[&quot;dst_addr&quot;] &#x3D; ntohl(ipToNumber((this.socket.value.getRemoteSocketAddress().toString().split(&quot;:&quot;)[0]).split(&quot;&#x2F;&quot;).pop())); message[&quot;dst_port&quot;] &#x3D; parseInt(this.socket.value.getRemoteSocketAddress().toString().split(&quot;:&quot;).pop()); var ptr &#x3D; Memory.alloc(byteCount); for (var i &#x3D; 0; i &lt; byteCount; ++i) Memory.writeS8(ptr.add(i), bytearry[offset + i]); send(message, Memory.readByteArray(ptr, byteCount)) return result; &#125; Java.use(&quot;java.net.SocketInputStream&quot;).socketRead0.overload(&#39;java.io.FileDescriptor&#39;, &#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (fd, bytearry, offset, byteCount, timeout) &#123; var result &#x3D; this.socketRead0(fd, bytearry, offset, byteCount, timeout); var message &#x3D; &#123;&#125;; message[&quot;function&quot;] &#x3D; &quot;HTTP_recv&quot;; message[&quot;ssl_session_id&quot;] &#x3D; &quot;&quot;; message[&quot;src_addr&quot;] &#x3D; ntohl(ipToNumber((this.socket.value.getRemoteSocketAddress().toString().split(&quot;:&quot;)[0]).split(&quot;&#x2F;&quot;).pop())); message[&quot;src_port&quot;] &#x3D; parseInt(this.socket.value.getRemoteSocketAddress().toString().split(&quot;:&quot;).pop()); message[&quot;dst_addr&quot;] &#x3D; ntohl(ipToNumber((this.socket.value.getLocalAddress().toString().split(&quot;:&quot;)[0]).split(&quot;&#x2F;&quot;).pop())); message[&quot;dst_port&quot;] &#x3D; parseInt(this.socket.value.getLocalPort()); if (result &gt; 0) &#123; var ptr &#x3D; Memory.alloc(result); for (var i &#x3D; 0; i &lt; result; ++i) Memory.writeS8(ptr.add(i), bytearry[offset + i]); send(message, Memory.readByteArray(ptr, result)) &#125; return result; &#125; &#125;)&#125; One more thing，虽然直接调用native层Socket的应用框架几乎没有；但是Javs层的Socket API是可以进一步下沉到C层的Socket，以支援so文件的socket抓包。以java.net.SocketOutputStream.socketWrite0举例，其native层的实现为JNIEXPORT void JNICALL 55SocketOutputStream_socketWrite0(JNIEnv *env, jobject this,jobject fdObj,jbyteArray data,jint off, jint len)（地址），其核心为一句话int n = NET_Send(fd, bufP + loff, llen, 0);，进一步追踪NET_Send可以在linux_close.cpp文件中找到其实现(地址)，本质上也是libc的send、sendto、recv、recvfrom这些，因此可以直接hook这些接口，捕获该进程的所有通信流量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int NET_Read(int s, void* buf, size_t len) &#123; BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );&#125; int NET_ReadV(int s, const struct iovec * vector, int count) &#123; BLOCKING_IO_RETURN_INT( s, readv(s, vector, count) );&#125; int NET_RecvFrom(int s, void *buf, int len, unsigned int flags, struct sockaddr *from, int *fromlen) &#123; socklen_t socklen &#x3D; *fromlen; BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, &amp;socklen) ); *fromlen &#x3D; socklen;&#125; int NET_Send(int s, void *msg, int len, unsigned int flags) &#123; BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );&#125; int NET_WriteV(int s, const struct iovec * vector, int count) &#123; BLOCKING_IO_RETURN_INT( s, writev(s, vector, count) );&#125; int NET_SendTo(int s, const void *msg, int len, unsigned int flags, const struct sockaddr *to, int tolen) &#123; BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );&#125; int NET_Accept(int s, struct sockaddr *addr, int *addrlen) &#123; socklen_t socklen &#x3D; *addrlen; BLOCKING_IO_RETURN_INT( s, accept(s, addr, &amp;socklen) ); *addrlen &#x3D; socklen;&#125; int NET_Connect(int s, struct sockaddr *addr, int addrlen) &#123; BLOCKING_IO_RETURN_INT( s, connect(s, addr, addrlen) );&#125; #ifndef USE_SELECTint NET_Poll(struct pollfd *ufds, unsigned int nfds, int timeout) &#123; BLOCKING_IO_RETURN_INT( ufds[0].fd, poll(ufds, nfds, timeout) );&#125;#elseint NET_Select(int s, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout) &#123; BLOCKING_IO_RETURN_INT( s-1, select(s, readfds, writefds, exceptfds, timeout) );&#125; 只是如果hook native层的这些接口的话，会混进openssl/boringssl的经过加密的流量，届时会比较难以区分，所以其实duck不必下降到native层，Java层的通信足以覆盖99%以上的场景（这个百分比是我估计的）。 最终也就是现在的效果：r0capture：安卓应用层抓包通杀脚本，地址：https://github.com/r0ysue/r0capture 仅限安卓平台，测试安卓7、8、9、10 可用 ； 无视所有证书校验或绑定，不用考虑任何证书的事情； 通杀TCP/IP四层模型中的应用层中的全部协议； 通杀协议包括：Http,WebSocket,Ftp,Xmpp,Imap,Smtp,Protobuf等等、以及它们的SSL版本； 通杀所有应用层框架，包括HttpUrlConnection、Okhttp1/3/4、Retrofit/Volley等等； 用法 Spawn 模式： 1$ python3 r0capture.py -U -f com.qiyi.video Attach 模式，抓包内容保存成pcap文件供后续分析： 1$ python3 r0capture.py -U com.qiyi.video -p iqiyi.pcap 建议使用Attach模式，从感兴趣的地方开始抓包，并且保存成pcap文件，供后续使用Wireshark进行分析。 PS：用来抓注册包，效果尤佳。 To-do： 此处还是有部分开发实力过强的大厂或框架，采用的是自身的SSL框架，比如WebView、小程序或Flutter，这部分目前暂未支持。当然这部分App也是少数。 暂不支持HTTP/2、或HTTP/3，该部分API在安卓系统上暂未普及或布署，为App自带，无法进行通用hook。 各种模拟器架构、实现、环境较为复杂，建议珍爱生命、使用真机。 暂未添加多进程支持，比如:service或:push等子进程，可以使用Frida的Child-gating来支持一下。 支持多进程之后要考虑pcap文件的写入锁问题，可以用frida-tool的Reactor线程锁来支持一下。 TCP/IP中可以实现的部分： 网络层：可以拿到所有的收发包。效果同Wireshark。如果是明文，其实效果跟传输层是一样的。非明文、跟传输层也是一样的。 传输层：可以拿到所有（应用层）的收发包，明文→明文；java.net.SocketInputStream.socketRead0、java.net.SocketOutputStream.socketWrite0都是native函数，意味着 应用层非明文→非明文：SSLInputStream.read 应用层2：com.android.okhttp.internal.http.HttpURLConnectionImpl SSL安装HttpSocket 123objection -g com.onejane.httpsocket exploreandroid hooking search ssl 将所有打印出的类放到sslandroid8.txt中，前面批量加上android hooking watch class objection -g com.onejane.httpsocket explore -c sslandroid8.txt 批量hook，报错ClassLoader就删除包括ClassLoader类 android hooking watch class com.android.org.conscrypt.OpenSSLBIOInputStreamandroid hooking watch class com.android.org.conscrypt.OpenSSLCipherandroid hooking watch class com.android.org.conscrypt.OpenSSLCipher$EVP_CIPHERandroid hooking watch class com.android.org.conscrypt.OpenSSLCipher​$EVP_CIPHER​$AESandroid hooking watch class com.android.org.conscrypt.OpenSSLCipher​$EVP_CIPHER​$AES​$CBCandroid hooking watch class com.android.org.conscrypt.OpenSSLCipher$EVP_CIPHER$AES$CBC$PKCS5Paddingandroid hooking watch class com.android.org.conscrypt.OpenSSLCipher$EVP_CIPHER$AES_BASEandroid hooking watch class com.android.org.conscrypt.OpenSSLContextImpl … 在安卓8上结果 (agent) [lrxbzy1b2ea] Called javax.net.ssl.HttpsURLConnection.getDefaultHostnameVerifier()(agent) [lrxbzy1b2ea] Called javax.net.ssl.HttpsURLConnection.getDefaultSSLSocketFactory()(agent) [lrxbzy1b2ea] Called javax.net.ssl.HttpsURLConnection.getDefaultSSLSocketFactory()(agent) [nrgnn66lv3e] Called com.android.org.conscrypt.OpenSSLSocketImpl.isClosed()(agent) [nrgnn66lv3e] Called com.android.org.conscrypt.OpenSSLSocketImpl.isInputShutdown()(agent) [nrgnn66lv3e] Called com.android.org.conscrypt.OpenSSLSocketImpl.isOutputShutdown()(agent) [42lol483nwl] Called com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write([B, int, int)(agent) [nrgnn66lv3e] Called com.android.org.conscrypt.OpenSSLSocketImpl.isClosed()(agent) [43hq04cbdn1] Called com.android.org.conscrypt.SslWrapper.write(java.io.FileDescriptor, [B, int, int, int)(agent) [yz4ikx9fcpb] Called com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read([B, int, int)(agent) [nrgnn66lv3e] Called com.android.org.conscrypt.OpenSSLSocketImpl.isClosed()(agent) [43hq04cbdn1] Called com.android.org.conscrypt.SslWrapper.read(java.io.FileDescriptor, [B, int, int, int) android hooking watch class_method com.android.org.conscrypt.ConscryptFileDescriptorSocket.$init 在安卓10上结果 (agent) [4816499695697] Called javax.net.ssl.HttpsURLConnection.getDefaultHostnameVerifier()com.roysue.httpsocket on (google: 10) [usb] #(agent) [4816499695697] Called javax.net.ssl.HttpsURLConnection.getDefaultSSLSocketFactory()(agent) [4816499695697] Called javax.net.ssl.HttpsURLConnection.getDefaultSSLSocketFactory()com.roysue.httpsocket on (google: 10) [usb] # (agent) [2575726777846] Called com.android.org.conscrypt.OpenSSLSocketImpl.isClosed()(agent) [2575726777846] Called com.android.org.conscrypt.OpenSSLSocketImpl.isInputShutdown()(agent) [2575726777846] Called com.android.org.conscrypt.OpenSSLSocketImpl.isOutputShutdown()(agent) [4979599214099] Called com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write([B, int, int)(agent) [2575726777846] Called com.android.org.conscrypt.OpenSSLSocketImpl.isClosed()(agent) [1105531481296] Called com.android.org.conscrypt.NativeSsl.write(java.io.FileDescriptor, [B, int, int, int)(agent) [1105531481296] Called com.android.org.conscrypt.NativeSsl.isClosed()(agent) [7367730933988] Called com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read([B, int, int)(agent) [2575726777846] Called com.android.org.conscrypt.OpenSSLSocketImpl.isClosed()(agent) [1105531481296] Called com.android.org.conscrypt.NativeSsl.read(java.io.FileDescriptor, [B, int, int, int)(agent) [1105531481296] Called com.android.org.conscrypt.NativeSsl.isClosed() frida -UF -l hookSocket.js 打印http抓包的结果 12plugin wallbreaker objectsearch com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStreamplugin wallbreaker objectdump --fullname 0x3486 1234567891011121314151617181920212223242526272829303132333435function hook_SSLsocketandroid8()&#123; Java.perform(function()&#123; console.log(&quot;hook_SSLsocket&quot;) Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); &#x2F;&#x2F; console.log(&quot;HTTPS write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) &#x2F;&#x2F; var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); &#x2F;&#x2F; console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) &#x2F;&#x2F;console.log(jhexdump(bytearry,int1,int2)); &#x2F;&#x2F; console.log(jhexdump(bytearry)); &#x2F;&#x2F; com.android.org.conscrypt.ConscryptFileDescriptorSocket this$0 console.log(this.this$0.value.sslSession.value.peerHost.value) console.log(this.this$0.value.sslSession.value.peerPort.value) console.log(this.this$0.value.sslSession.value.getProtocol()) console.log(this.this$0.value.sslSession.value.getRequestedServerName()) console.log(JSON.stringify( this.this$0.value.sslSession.value.getStatusResponses())) console.log(this.this$0.value.sslSession.value.getValueNames().toString()) return result; &#125; &#x2F;&#x2F; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; &#x2F;&#x2F; var result &#x3D; this.read(bytearry,int1,int2); &#x2F;&#x2F; console.log(&quot;HTTPS read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) &#x2F;&#x2F; var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); &#x2F;&#x2F; console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) &#x2F;&#x2F; &#x2F;&#x2F;console.log(jhexdump(bytearry,int1,int2)); &#x2F;&#x2F; &#x2F;&#x2F; console.log(jhexdump(bytearry)); &#x2F;&#x2F; return result; &#x2F;&#x2F; &#125; &#125;)&#125; frida 14 android hooking watch class_method com.android.org.conscrypt.ConscryptFileDescriptorSocket.$init objection -g com.onejane.httpsocket explore -s “android hooking watch class_method com.android.org.conscrypt.ConscryptFileDescriptorSocket.$init” Fileappmon中用到的API。12.8.0报错就切到14.*,frida -UF -l HTTP.js和frida -UF -l Storage.js和frida -UF -l SharedPreferences.js Mobile-Security-Framework-MobSF 123objection -g comoolapk.market explore -s &quot;android hooking watch class android.content.ContextWrapper&quot; 下载app查看agent用到的apiandroid hooking watch class_method android.content.ContextWrapper.getDataDir --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method android.content.ContextWrapper.getCacheDir --dump-args --dump-backtrace --dump-return 1234frida-ps -U|grep -i gravityobjection -g com.ceco.oreo.gravitybox exploreandroid hooking watch class android.app.SharedPreferencesImplandroid hooking watch class_method android.app.SharedPreferencesImpl.getString --dump-args --dump-backtrace --dump-return 通杀123456789objection -g comoolapk.market exploreandroid hooking search classes Fileandroid hooking watch class java.io.Fileandroid hooking watch class_method java.io.File.getPath --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method java.io.File.delete --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method java.io.File.exists --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method java.io.File.list --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method java.io.File.getName --dump-args --dump-backtrace --dump-returncat objection.log | grep Return java.io.Filejava.lang.String 1234567891011android hooking watch class java.lang.String android hooking watch class_method java.lang.String.toString --dump-args --dump-return 安卓8android hooking watch class_method java.lang.String.equals --dump-args --dump-return 安卓10android hooking watch class_method java.lang.StringBuilder.$init --dump-args --dump-returnandroid hooking watch class android.telephony.TelephonyManager 获取硬件信息plugin wallbreaker objectsearch android.telephony.TelephonyManagerplugin wallbreaker objectdump 0x4563plugin wallbreaker classdump android.os.Buildandroid hooking watch class_method android.telephony.TelephonyManager.getDeviceId --dump-args --dump-backtrace --dump-returnfrida -U -f com.coolapk.market -l File.js --no-pause -o file.txtfrida -UF -l File.js --no-pause -o file.txt 利用Frida修改Android设备的唯一标识符 修改Build.java 12345678910111213141516171819202122232425262728private static String getString(String property) &#123; String result &#x3D; SystemProperties.get(property, UNKNOWN) ; if(property.equals(&quot;ro.product.brand&quot;))&#123; result &#x3D; new String(&quot;r0ysueBRAND&quot;); &#125;else if(property.equals((&quot;ro.product.manufacturer&quot;)))&#123; result &#x3D; new String(&quot;r0ysueMANUFACTUERER&quot;); &#125;else if(property.equals(&quot;ro.product.board&quot;))&#123; result &#x3D; new String(&quot;r0ysueBOARD&quot;); &#125;else if(property.equals(&quot;no.such.thing&quot;))&#123; result &#x3D; new String(&quot;r0ysueAAAABBBBCCCCDDDD&quot;); &#125; Exception e &#x3D; new Exception(&quot;r0ysueFINGERPRINT&quot;); e.printStackTrace(); return result;&#125;@RequiresPermission(Manifest.permission.READ_PHONE_STATE)public static String getSerial() &#123; IDeviceIdentifiersPolicyService service &#x3D; IDeviceIdentifiersPolicyService.Stub .asInterface(ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE)); try &#123; String result &#x3D;service.getSerial(); return &quot;r0ysueserial1234&quot;; &#125; catch (RemoteException e) &#123; e.rethrowFromSystemServer(); &#125; return UNKNOWN;&#125; 修改TelephonyManager.java 123456789101112131415161718192021222324252627282930@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)public String getSimSerialNumber(int subId) &#123; try &#123; IPhoneSubInfo info &#x3D; getSubscriberInfo(); String resutlt &#x3D; info.getIccSerialNumberForSubscriber(subId, mContext.getOpPackageName()); if (info &#x3D;&#x3D; null) return null; return &quot;r0ysueSERIALAAAABBBB&quot;; &#125; catch (RemoteException ex) &#123; return null; &#125; catch (NullPointerException ex) &#123; &#x2F;&#x2F; This could happen before phone restarts due to crashing return null; &#125;&#125;@Deprecated@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)public String getDeviceId() &#123; try &#123; ITelephony telephony &#x3D; getITelephony(); String result &#x3D; telephony.getDeviceId(mContext.getOpPackageName()); if (telephony &#x3D;&#x3D; null) return null; return &quot;r0ysueIMEI&quot;; &#125; catch (RemoteException ex) &#123; return null; &#125; catch (NullPointerException ex) &#123; return null; &#125;&#125; . build/envsetup.sh lunch aosp_bullhead-user m 替换编译生成img到官方镜像包中，重新打包成image-bullhead-opm1.171019.011.zip ./flash-all.sh 指纹识别技术安全分析 对抗 不检测root，检测aosp，正常人不会用aosp，App可以通过判断java.net.NetworkInterface.getName()是否等于“tun0”或“ppp0”来判断是否存在VPN。Bypass也很简单，hook该api使其返回“rmnet_data1”，即可达到过vpn检测目的。 风险控制笔记 自制沙箱检测Android虚拟机的方法和代码实现 2020年安卓源码编译指南 Android 应用多开对抗实践 使用手机连接charles的代理，chsl.pro/ssl安装证书。 123456cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added 查看新安装的证书a27a90a2.0cp a27a90a2.0 &#x2F;sdcard&#x2F;Downloadcd Desktop&#x2F;asop810r1&#x2F;system&#x2F;ca-certificates&#x2F;filesadb pull &#x2F;sdcard&#x2F;Download&#x2F;a27a90a2.0. build&#x2F;envsetup.shlunch aosp_bullhead-user 编译，没有root，使用user-debug有root 修改KeyStore.java 123456789101112131415161718192021222324252627282930313233343536373839404142public final void load(InputStream stream, char[] password) throws IOException, NoSuchAlgorithmException, CertificateException &#123; if (password !&#x3D; null) &#123; String inputPASSWORD &#x3D; new String(password); Class logClass &#x3D; null; try &#123; logClass &#x3D; this.getClass().getClassLoader().loadClass(&quot;android.util.Log&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method loge &#x3D; null; try &#123; loge &#x3D; logClass.getMethod(&quot;e&quot;, String.class, String.class); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; try &#123; loge.invoke(null, &quot;r0ysueKeyStoreLoad&quot;, &quot;KeyStore load PASSWORD is &#x3D;&gt; &quot; + inputPASSWORD); Exception e &#x3D; new Exception(&quot;r0ysueKeyStoreLoad&quot;); e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; Date now &#x3D; new Date(); String currentTime &#x3D; String.valueOf(now.getTime()); FileOutputStream fos &#x3D; new FileOutputStream(&quot;&#x2F;sdcard&#x2F;Download&#x2F;&quot; + inputPASSWORD + currentTime); byte[] b &#x3D; new byte[1024]; int length; while ((length &#x3D; stream.read(b)) &gt; 0) &#123; fos.write(b, 0, length); &#125; fos.flush(); fos.close(); &#125; keyStoreSpi.engineLoad(stream, password); initialized &#x3D; true;&#125; 修改SocketOutputStream.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private void socketWrite(byte b[], int off, int len) throws IOException &#123; if (len &lt;&#x3D; 0 || off &lt; 0 || len &gt; b.length - off) &#123; if (len &#x3D;&#x3D; 0) &#123; return; &#125; throw new ArrayIndexOutOfBoundsException(&quot;len &#x3D;&#x3D; &quot; + len + &quot; off &#x3D;&#x3D; &quot; + off + &quot; buffer length &#x3D;&#x3D; &quot; + b.length); &#125; FileDescriptor fd &#x3D; impl.acquireFD(); try &#123; BlockGuard.getThreadPolicy().onNetwork(); socketWrite0(fd, b, off, len); if(len&gt;0)&#123; byte[] input &#x3D; new byte[len]; System.arraycopy(b,off,input,0,len); String inputString &#x3D; new String(input); Class logClass &#x3D; null; try &#123; logClass &#x3D; this.getClass().getClassLoader().loadClass(&quot;android.util.Log&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method loge &#x3D; null; try &#123; loge &#x3D; logClass.getMethod(&quot;e&quot;,String.class,String.class); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; try &#123; loge.invoke(null,&quot;r0ysueSOCKETrequest&quot;,&quot;Socket is &#x3D;&gt; &quot;+this.socket.toString()); loge.invoke(null,&quot;r0ysueSOCKETrequest&quot;,&quot;buffer is &#x3D;&gt; &quot;+inputString); Exception e &#x3D; new Exception(&quot;r0ysueSOCKETrequest&quot;); e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (SocketException se) &#123; if (se instanceof sun.net.ConnectionResetException) &#123; impl.setConnectionResetPending(); se &#x3D; new SocketException(&quot;Connection reset&quot;); &#125; if (impl.isClosedOrPending()) &#123; throw new SocketException(&quot;Socket closed&quot;); &#125; else &#123; throw se; &#125; &#125; finally &#123; impl.releaseFD(); &#125;&#125;SocketOutputStream 修改SocketInputStream.java 12345678910111213141516171819202122232425262728293031323334353637private int socketRead(FileDescriptor fd, byte b[], int off, int len, int timeout) throws IOException &#123; int result &#x3D; socketRead0(fd, b, off, len, timeout); if(result&gt;0)&#123; byte[] input &#x3D; new byte[result]; System.arraycopy(b,off,input,0,result); String inputString &#x3D; new String(input); Class logClass &#x3D; null; try &#123; logClass &#x3D; this.getClass().getClassLoader().loadClass(&quot;android.util.Log&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method loge &#x3D; null; try &#123; loge &#x3D; logClass.getMethod(&quot;e&quot;,String.class,String.class); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; try &#123; loge.invoke(null,&quot;r0ysueSOCKETresponse&quot;,&quot;Socket is &#x3D;&gt; &quot;+this.socket.toString()); loge.invoke(null,&quot;r0ysueSOCKETresponse&quot;,&quot;buffer is &#x3D;&gt; &quot;+inputString); Exception e &#x3D; new Exception(&quot;r0ysueSOCKETresponse&quot;); e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; return result;&#125; 修改SslWrapper.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869int read(FileDescriptor fd, byte[] buf, int offset, int len, int timeoutMillis) throws IOException &#123; int result &#x3D; NativeCrypto.SSL_read(ssl, fd, handshakeCallbacks, buf, offset, len, timeoutMillis) ; if(result&gt;0)&#123; byte[] input &#x3D; new byte[result]; System.arraycopy(buf,offset,input,0,result); String inputString &#x3D; new String(input); Class logClass &#x3D; null; try &#123; logClass &#x3D; this.getClass().getClassLoader().loadClass(&quot;android.util.Log&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method loge &#x3D; null; try &#123; loge &#x3D; logClass.getMethod(&quot;e&quot;,String.class,String.class); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; try &#123; loge.invoke(null,&quot;r0ysueSOCKETresponse&quot;,&quot;SSL is &#x3D;&gt;&quot;+this.handshakeCallbacks.toString()); loge.invoke(null,&quot;r0ysueSOCKETresponse&quot;,&quot;buffer is &#x3D;&gt; &quot;+inputString); Exception e &#x3D; new Exception(&quot;r0ysueSOCKETresponse&quot;); e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; return result; &#125; void write(FileDescriptor fd, byte[] buf, int offset, int len, int timeoutMillis) throws IOException &#123; if(len&gt;0)&#123; byte[] input &#x3D; new byte[len]; System.arraycopy(buf,offset,input,0,len); String inputString &#x3D; new String(input); Class logClass &#x3D; null; try &#123; logClass &#x3D; this.getClass().getClassLoader().loadClass(&quot;android.util.Log&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method loge &#x3D; null; try &#123; loge &#x3D; logClass.getMethod(&quot;e&quot;,String.class,String.class); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; try &#123; loge.invoke(null,&quot;r0ysueSSLrequest&quot;,&quot;SSL is &#x3D;&gt; &quot;+this.handshakeCallbacks.toString()); loge.invoke(null,&quot;r0ysueSSLrequest&quot;,&quot;buffer is &#x3D;&gt; &quot;+inputString); Exception e &#x3D; new Exception(&quot;r0ysueSSLrequest&quot;); e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; NativeCrypto.SSL_write(ssl, fd, handshakeCallbacks, buf, offset, len, timeoutMillis); &#125; 编译好后，刷机，安装soul使用chales抓包,查看logcat中Keystore加载的Password，下载下来的证书改名为soul.p12安装实现App客户端证书文件和密码自吐 12make update-api 由于修改了文件，更新apim 甲方风控实用FRIDA进阶：内存漫游、hook anywhere、抓包 r0capturegit clone https://github.com/r0ysue/r0capture.git 仅限安卓平台，测试安卓7、8、9、10、11 可用 ； 无视所有证书校验或绑定，不用考虑任何证书的事情； 通杀TCP/IP四层模型中的应用层中的全部协议； 通杀协议包括：Http,WebSocket,Ftp,Xmpp,Imap,Smtp,Protobuf等等、以及它们的SSL版本； 通杀所有应用层框架，包括HttpUrlConnection、Okhttp1/3/4、Retrofit/Volley等等； 无视加固，不管是整体壳还是二代壳或VMP，不用考虑加固的事情； python r0capture.py -U cn.soulapp.android -v python r0capture.py -U -f com.qiyi.video -v frida -UF -l hookSSLSocket.js frida -U -f cn.soulapp.android -l saveClientCet.js –no-pause 增加客户端证书dump功能 adb pull /sdcard/Download/ff93e99.p12 证书转换工具 支持bks to p12 把安卓转成Charles支持的p12 charles-Proxy-SSL Proxying Settings-Client Certificates-Create Secure Store-设置自定义密码，配置Host/Port为*对任何IP任何端口使用该证书，Import P12-填入SSL Certificate Password,即抓到的key密码 为沙箱增加调用栈dump证书 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function hook_KeyStore_load() &#123; Java.perform(function () &#123; var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); var myArray&#x3D;new Array(1024); var i &#x3D; 0 for (i &#x3D; 0; i &lt; myArray.length; i++) &#123; myArray[i]&#x3D; 0x0; &#125; var buffer &#x3D; Java.array(&#39;byte&#39;,myArray); var StringClass &#x3D; Java.use(&quot;java.lang.String&quot;); var KeyStore &#x3D; Java.use(&quot;java.security.KeyStore&quot;); KeyStore.load.overload(&#39;java.security.KeyStore$LoadStoreParameter&#39;).implementation &#x3D; function (arg0) &#123; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(&quot;KeyStore.load1:&quot;, arg0); this.load(arg0); &#125;; KeyStore.load.overload(&#39;java.io.InputStream&#39;, &#39;[C&#39;).implementation &#x3D; function (arg0, arg1) &#123; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(&quot;KeyStore.load2:&quot;, arg0, arg1 ? StringClass.$new(arg1) : null); if (arg0)&#123; var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(&quot;&#x2F;sdcard&#x2F;Download&#x2F;&quot;+ String(arg0)+&quot;.p12&quot;); var out &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); var r; while( (r &#x3D; arg0.read(buffer)) &gt; 0)&#123; out.write(buffer,0,r) &#125; console.log(&quot;save success!&quot;) out.close() &#125; this.load(arg0, arg1); &#125;; console.log(&quot;hook_KeyStore_load...&quot;);&#x2F;&#x2F; android.content.res.AssetManager$AssetInputStream@9b10ad6 bxMAFPL9gc@ntKTqmV@A&#x2F;&#x2F; android.content.res.AssetManager$AssetInputStream@41ce8f6 &#125;%2R+\\OSsjpP!w%X&#x2F;&#x2F; android.content.res.AssetManager$AssetInputStream@54858e6 cods.org.cn &#125;);&#125; 重新使用charles即可抓到soul包 1234567objection -g cn.soulapp.android explore android hooking search classes keystore 将打印的类放到文keystore.txt件中，批量hook,前面加上android hooking watch classobjection -g cn.soulapp.android explore -c keystore.txtplugin wallbreaker objectsearch java.security.KeyStore$PrivateKeyEntryplugin wallbreaker objectdump --fullname 0x0123uandroid hooking watch class_method java.security.KeyStore$PrivateKeyEntry.getCertificateChain --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method java.security.KeyStore$PrivateKeyEntry.getPrivateKey --dump-args --dump-backtrace --dump-return QtScrCpy 手机投屏 Linux版 12apt install libsdl2-2.0-0.&#x2F;run x 为沙箱增加客户端证书DUMP的功能 1234567frida -U -f cn.soulapp.android -l 2021trace.js --no-pause -o traceresult.txt 查看java.security.KeyStore$PrivateKeyEntry的调用栈objection -g cn.soulapp.android explore plugin load &#x2F;root&#x2F;Desktop&#x2F;Wallbreakerplugin wallbreaker objectsearch java.security.KeyStore$PrivateKeyEntryplugin wallbreaker objectdump --fullname 0x123f 查看KeyStore$PrivateKeyEntry类的privateKey和publicKeyandroid heap search instances java.security.KeyStore$PrivateKeyEntryandroid heap execute 0x2ce7 getPrivateKey() 主动调用 js实现,frida -U- f cn.soulapp.android -l savePrivateKey.js --no-pause 打开app后查看/data/local/tmp/soul下的证书文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960setImmediate(function () &#123; Java.perform(function () &#123; console.log(&quot;Entering&quot;) Java.use(&quot;java.security.KeyStore$PrivateKeyEntry&quot;).getPrivateKey.implementation &#x3D; function () &#123; console.log(&quot;Calling java.security.KeyStore$PrivateKeyEntry.getPrivateKey method &quot;) var result &#x3D; this.getPrivateKey() console.log(&quot;toString result is &#x3D;&gt; &quot;, result.toString()) storeP12(this.getPrivateKey(),this.getCertificate(),&#39;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;soul&#39;+uuid(10,16)+&#39;.p12&#39;,&#39;hello&#39;); return result; &#125; Java.use(&quot;java.security.KeyStore$PrivateKeyEntry&quot;).getCertificateChain.implementation &#x3D; function () &#123; console.log(&quot;Calling java.security.KeyStore$PrivateKeyEntry.getCertificateChain method &quot;) var result &#x3D; this.getCertificateChain() storeP12(this.getPrivateKey(),this.getCertificate(),&#39;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;soul&#39;+uuid(10,16)+&#39;.p12&#39;,&#39;hello&#39;); return result; &#125; &#125;)&#125;)function storeP12(pri, p7, p12Path, p12Password) &#123; var X509Certificate &#x3D; Java.use(&quot;java.security.cert.X509Certificate&quot;) var p7X509 &#x3D; Java.cast(p7, X509Certificate); var chain &#x3D; Java.array(&quot;java.security.cert.X509Certificate&quot;, [p7X509]) var ks &#x3D; Java.use(&quot;java.security.KeyStore&quot;).getInstance(&quot;PKCS12&quot;, &quot;BC&quot;); ks.load(null, null); ks.setKeyEntry(&quot;client&quot;, pri, Java.use(&#39;java.lang.String&#39;).$new(p12Password).toCharArray(), chain); try &#123; var out &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(p12Path); ks.store(out, Java.use(&#39;java.lang.String&#39;).$new(p12Password).toCharArray()) &#125; catch (exp) &#123; console.log(exp) &#125;&#125;function uuid(len, radix) &#123; var chars &#x3D; &#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#39;.split(&#39;&#39;); var uuid &#x3D; [], i; radix &#x3D; radix || chars.length; if (len) &#123; &#x2F;&#x2F; Compact form for (i &#x3D; 0; i &lt; len; i++) uuid[i] &#x3D; chars[0 | Math.random() * radix]; &#125; else &#123; &#x2F;&#x2F; rfc4122, version 4 form var r; &#x2F;&#x2F; rfc4122 requires these characters uuid[8] &#x3D; uuid[13] &#x3D; uuid[18] &#x3D; uuid[23] &#x3D; &#39;-&#39;; uuid[14] &#x3D; &#39;4&#39;; &#x2F;&#x2F; Fill in random data. At i&#x3D;&#x3D;19 set the high bits of clock sequence as &#x2F;&#x2F; per rfc4122, sec. 4.1.5 for (i &#x3D; 0; i &lt; 36; i++) &#123; if (!uuid[i]) &#123; r &#x3D; 0 | Math.random() * 16; uuid[i] &#x3D; chars[(i &#x3D;&#x3D; 19) ? (r &amp; 0x3) | 0x8 : r]; &#125; &#125; &#125; return uuid.join(&#39;&#39;);&#125; adb pull /data/local/tmp 使用KeyStore Explorer打开，密码是hello charles-手机连接代理-SSL Proxying Settings-Client Certificates-Add-Import P12-密码hello-Host和Port配置*，启动Postern,启动soul成功抓包 adb install dida.apk 通过top查看包名cn.ticktick.task 1objection -g cn.ticktick.task explore -s &quot;android hooking watch class_method java.io.File.\\$init --dump-args --dump-return --dump-backtrace&quot; frida -U -f cn.ticktick.task -l sslpinninghelper.js --no-pause 打印证书路径 123456789101112131415setImmediate(function()&#123; Java.perform(function()&#123; Java.use(&quot;java.io.File&quot;).$init.overload(&#39;java.io.File&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function(file,cert)&#123; var result &#x3D; this.$init(file,cert) var stack &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()); if(file.getPath().indexOf(&quot;cacert&quot;)&gt;0 &amp;&amp; stack.indexOf(&quot;X509TrustManagerExtensions.checkServerTrusted&quot;)&gt; 0)&#123; console.log(&quot;path,cart&quot;,file.getPath(), cert) console.log(stack); &#125; return result; &#125; &#125;)&#125;) SSL pinning helper 帮助定位证书绑定的关键代码，在服务器校验客户端的情形下，帮助dump客户端证书，并保存为p12的格式 pm -l | grep -i soul pm -l | grep -i ticktick pip install hexdump python r0capture.py -U -f cn.soulapp.android -v &gt;&gt;sout.txt 重新抓包，frida 14.0.8 python r0capture.py -U -f cn.ticktick.task -v &gt;&gt;tick.txt 框架层抓包沙箱SslWrapper.java 的修改等同于hook Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;)实现定位收发包函数的功能。 基于trace的内存漫游确认Java.use(&quot;java.security.KeyStore$PrivateKeyEntry&quot;).getCertificateChain客户端证书dump导出功能。 增加混淆后的SSLping代码定位功能stack.indexOf(&quot;X509TrustManagerExtensions.checkServerTrusted&quot;) 抓包沙箱植入根证书绕过客户端校验服务器，cd aosp810r1/system/ca-certificates/files 根证书目录，将charles的证书下载到该文件目录下，编译生成镜像，形成中间人 抓包沙箱导出客户端证书绕过服务器校验客户端，KeyStore.java有个内部方法PrivateKeyEntry KeyStore.java 去除上面自制沙箱时 public final void load(InputStream stream, char[] password)的修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public PrivateKey getPrivateKey() &#123; String p12Password &#x3D; &quot;r0ysue&quot;; Date now &#x3D; new Date(); String currentTime &#x3D; String.valueOf(now.getTime()); String p12Path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&quot; + currentTime + &quot;.p12&quot;; X509Certificate p7X509 &#x3D; (X509Certificate) chain[0]; Certificate[] mychain &#x3D; new Certificate[]&#123;p7X509&#125;; &#x2F;&#x2F; 生成一个空的p12证书 KeyStore myks &#x3D; null; try &#123; myks &#x3D; KeyStore.getInstance(&quot;PKCS12&quot;, &quot;BC&quot;); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (NoSuchProviderException e) &#123; e.printStackTrace(); &#125; try &#123; myks.load(null, null); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F; 将服务器返回的证书导入到p12中去 try &#123; myks.setKeyEntry(&quot;client&quot;, privKey, p12Password.toCharArray(), mychain); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F; 加密保存p12证书 FileOutputStream fOut &#x3D; null; try &#123; fOut &#x3D; new FileOutputStream(p12Path); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; try &#123; myks.store(fOut, p12Password.toCharArray()); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; return privKey; &#125; 抓包沙箱之定位(混淆后的)SSLpinning代码，修改File.java,去除上面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public File(File parent, String child) &#123; if (child &#x3D;&#x3D; null) &#123; throw new NullPointerException(); &#125; if (parent !&#x3D; null) &#123; if (parent.path.equals(&quot;&quot;)) &#123; this.path &#x3D; fs.resolve(fs.getDefaultParent(), fs.normalize(child)); &#125; else &#123; this.path &#x3D; fs.resolve(parent.path, fs.normalize(child)); &#125; &#125; else &#123; this.path &#x3D; fs.normalize(child); &#125; Class logClass &#x3D; null; try &#123; logClass &#x3D; this.getClass().getClassLoader().loadClass(&quot;android.util.Log&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method loge &#x3D; null; Method getStackTraceString &#x3D; null; try &#123;&#x2F;&#x2F; loge &#x3D; logClass.getMethod(&quot;e&quot;, String.class, String.class); getStackTraceString &#x3D; logClass.getMethod(&quot;getStackTraceString&quot;,Throwable.class); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; try &#123;&#x2F;&#x2F; loge.invoke(null, &quot;r0ysueKeyStoreLoad&quot;, &quot;KeyStore load PASSWORD is &#x3D;&gt; &quot; + inputPASSWORD); String stack &#x3D; (String)getStackTraceString.invoke(null,new Throwable()); if (parent.getPath().indexOf(&quot;cacert&quot;) &gt;&#x3D; 0 &amp;&amp; stack.indexOf(&quot;X509TrustManagerExtensions.checkServerTrusted&quot;) &gt;&#x3D; 0) &#123; Exception e &#x3D; new Exception(&quot;r0ysueFileSSLpinning&quot;); e.printStackTrace(); &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; this.prefixLength &#x3D; fs.prefixLength(this.path); &#125; 编译刷机 12lunch aosp_bullhead-userm 编译完更新system.img到官方镜像bullhead刷机 默认系统报错400 No required SSL certificate was sent,导入证书到SSLProxying Setting才能正确抓到soul包 绕过滴答 frida -U -f cn.ticktick.task -l bypassPinning.js --no-pause默认报错trust the Charles Root Certificate ,客户端收到charles的证书，计算公钥hash后比对结果决定发请求结果。 123456789setImmediate(function()&#123; Java.perform(function()&#123; console.log(&quot;Bypassing&quot;) Java.use(&quot;z1.g&quot;).a.implementation &#x3D; function()&#123; console.log(&quot;called here&quot;) return; &#125; &#125;)&#125;) HTTPS客户端证书多重证书绑定咪咕视频登录抓包，SSL handshake with client failed: An unknown issue occurred processing the certificate (certificate_unknown)从抓包发现证书 绑定,可能客户端只信任信任的公钥签名，不信任就不允许，停止客户端访问的证书绑定。客户端发了，我们已经绕过了校验，把自己公钥发给charles，charles用自己私钥解开客户端的公钥发现不正常的结果。 123456dumpsys activity top 查看包名 com.ophone.reader.uiobjection -g com.ophone.reader.ui exploreandroid sslpinning disable 需要在启动时运行objection -g com.ophone.reader.ui explore -s &quot;android sslpinning disable&quot; 在点我登录页面触发解绑定，如果崩溃objection -g com.ophone.reader.ui explore 在点我登录时开始漫游android sslpinning disable 解绑定后再获取验证码，再抓包 证书绑定的逻辑没有hook掉：”at com.bangcle.andjni.JniLib.cL(Native Method)” → 只有逆代码来过证书绑定 1python r0capture.py -U com.ophone.reader.ui -v -p migu.pcap 关闭postern抓包,获取验证码没有更新log，说明没有一些底层的框架 通过wireshark查看migu.pcap结果，发现也没有关键性信息，抓包也抓不到。 123456python r0capture.py -U -f com.ophone.reader.ui -v 尝试导出证书frida -U -f com.ophone.reader.ui -l script.js --no-pauseadb shell 查看sdcard&#x2F;Download下的证书adb pull &#x2F;sdcard&#x2F;Download&#x2F;ophone 下的证书导入到Charles的SSL Proxying Settings中，打开postern抓包objection -g com.ophone.reader.ui explore 在点我登录时开始漫游android sslpinning disable 解绑定后再获取验证码抓包即可获取passport.migu.cn:8443的包信息 SSL handshake with server failed - Remote host terminated the handshakeThe remote SSL server rejected the connection. The server may require a specific certificate or cipher not supported by Charles. 过客户端证书后发现更多证书绑定,Frida.Android.Practice 1objection -g com.ophone.reader.ui explore -s &quot;android sslpinning disable&quot; git clone https://github.com/WooyunDota/DroidSSLUnpinning.git 1frida -U -f com.ophone.reader.ui -l hooks.js --no-pause 抓发送验证码包依旧有请求失败 FRIDA 使用经验交流分享，git clone https://github.com/deathmemory/FridaContainer.git 1234cd utils&#x2F;androidfrida -U -f com.ophone.reader.ui -l multi_unpinning.js --no-pauseobjection -g com.ophone.reader.ui explore -s &quot;android hooking watch class_method java.io.File.\\$init --dump-args --dump-backtrace --dump-return&quot; 查看证书frida -U -f com.ophone.reader.ui -l trace.js --no-pause -o ophone.txt 修改trace.js中traceClass(&quot;java.io.File&quot;),在traceClass中修改targets&#x3D;[]只trace init方法,在traceMethod中打开调用栈android.util.log，发送验证码后查看文件,搜索cacert查看调用栈 北京银行1234python r0capture.py -U -f com.bankofbeijing.mobilebanking -v.&#x2F;hluda-server-14.2.1-android-arm64frida -U -f com.bankofbeijing.mobilebanking -l script.js --no-pause -o bjbank.txtfrida -U -f com.bankofbeijing.mobilebanking -l trace.js --no-pause -o bjbank2.txt 打开traceClass(&quot;java.security.KeyStore$PrivateKeyEntry&quot;) 加固厂商自定义开发的证书绑定对抗很难被攻克。","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"ssl","slug":"ssl","permalink":"http://onejane.github.io/tags/ssl/"},{"name":"aosp","slug":"aosp","permalink":"http://onejane.github.io/tags/aosp/"}]},{"title":"魔改系统源码编译","slug":"魔改系统源码编译","date":"2021-05-04T08:18:45.000Z","updated":"2021-05-05T19:45:11.641Z","comments":true,"path":"2021/05/04/魔改系统源码编译/","link":"","permalink":"http://onejane.github.io/2021/05/04/%E9%AD%94%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/","excerpt":"","text":"环境frida pixel(salfish)+官方8.1.0_r1+twrp3.3.0+Magisk+Frida pixel(salfish)+twrp3.3.0+lineage16.0+addonsu16.0 xposed pixel(salfish)+官方7.1.2_r8+twrp3.2.1-0+SuperSU+XposedInstaller fart同aosp pixel(salfish)+最新fastboot+fart8.1.0 n6p(angler)+老fastboot+fart8.1.0 NetHunter n6p(angler)+原生8.1.0_r1+twrp3.3.1+SuoerSU 编译aosp刷机环境准备123456789# apt update# git config --global user.email &quot;you@example.com&quot;# git config --global user.name &quot;Your Name&quot;# apt install bison tree# dpkg --add-architecture i386# apt update# apt install libc6:i386 libncurses5:i386 libstdc++6:i386# apt install libxml2-utilsapt install nethogs 查看流量由哪个进程产生 android版本列表 同步清华 同步中科大 编译内存不足加swap 123456789101112131415161718192021222324252627282930313233343536dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;swapfile bs&#x3D;1024 count&#x3D;10240000 使用dd创建swapfile作为swap分区空间mkswap swapfile mkswap创建交换文件## 下载repo工具mkdir ~&#x2F;binPATH&#x3D;~&#x2F;bin:$PATHcurl https:&#x2F;&#x2F;storage.googleapis.com&#x2F;git-repo-downloads&#x2F;repo &gt; ~&#x2F;bin&#x2F;repo## 如果上述 URL 不可访问，可以用下面的：## curl -sSL &#39;https:&#x2F;&#x2F;gerrit-googlesource.proxy.ustclug.org&#x2F;git-repo&#x2F;+&#x2F;master&#x2F;repo?format&#x3D;TEXT&#39; |base64 -d &gt; ~&#x2F;bin&#x2F;repochmod a+x ~&#x2F;bin&#x2F;repomkdir COMPILEcd COMPILE## 初始化仓库：repo init -u git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;aosp&#x2F;platform&#x2F;manifest## 如果提示无法连接到 gerrit.googlesource.com，可以编辑 ~&#x2F;bin&#x2F;repo，把 REPO_URL 一行替换成下面的：## REPO_URL &#x3D; &#39;https:&#x2F;&#x2F;gerrit-googlesource.proxy.ustclug.org&#x2F;git-repo&#39;## 如果需要某个特定的 Android 版本：repo init -u git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;aosp&#x2F;platform&#x2F;manifest -b android-7.1.2_r8或者wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;aosp-monthly&#x2F;aosp-latest.tartar xf aosp-latest.tar## 同步源码树（以后只需执行这条命令来同步）：## 默认线程数4，可增加repo sync -j8# 下载java8 或者 apt install openjdk-8-jdkwget https:&#x2F;&#x2F;download.java.net&#x2F;openjdk&#x2F;jdk8u41&#x2F;ri&#x2F;openjdk-8u41-b04-linux-x64-14_jan_2020.tar.gz# 解压到&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;openjdk8&#x2F;#修改.zshrcnano ~&#x2F;.zshrc# 在zshrc中加入下面内容export JAVA_HOME&#x3D;&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;openjdk8&#x2F;java-se-8u41-riexport PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATHexport CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar 编译刷机7z x aosp712r8 7.62g 驱动下载 注意版本一致，在aosp712r8目录下解压安装 ./extrace-google_devices-sailfish.sh 和./extrace-qcom-sailfish.sh不装驱动，编译后没有vender 1234export LC_ALL&#x3D;C 编译前执行命令去除本地化设置cd COMPILE&#x2F;aosp712r8source build&#x2F;envsetup.sh 导入环境变量chsh -s &#x2F;bin&#x2F;bash 提示只支持bash，但kali2021默认是zsh，用zsh可能会导致编译版本不对，需要改成bash 重启-选择设备 1234lunch 选择版本18 aosp_sailfish_userdebug# j后面参数可以选则核心数*2make -j8 开始，编译完成的系统镜像位于当前目录的out&#x2F;target&#x2F;product&#x2F;sailfish&#x2F;下包括各个imgwhich fastboot 查看fastboot位置 关机+音量- 进入fastboot unzip sailfish-n2g47o-factory-f2bc8024.zip 将上面编译好的boot.img,ramdisk.img,ramdisk-recovery.img,system.img,system_other.img,userdata.img拷贝到解压后的image-sailfish-n2g47o.zip 删除所有镜像，保留android-info.txt，压缩image-sailfish-n2g47o下所有内容，压缩包名称与flash-all.sh里的内容匹配，压缩包内不要有文件夹zip -j image-sailfish-n2g47o.zip ./image-sailfish-n2g47o/* ./flush-all.sh 开始刷机 记一次安卓系统源码下载过程 记一次安卓系统源码编译刷机过程 记一次安卓内核源码编译刷机过程(修改反调试标志位) 编译原版Xposed刷机XPOSED魔改一：获取特征 123456mkdir XPOSEDgit clone https:&#x2F;&#x2F;github.com&#x2F;rovo89&#x2F;XposedInstaller.git xposed框架安装工具git clone https:&#x2F;&#x2F;github.com&#x2F;rovo89&#x2F;XposedBridge.git xposed框架java部分git clone https:&#x2F;&#x2F;github.com&#x2F;rovo89&#x2F;android_art.git android 5.0及以上用art虚拟机，对这部分的修改git clone https:&#x2F;&#x2F;github.com&#x2F;rovo89&#x2F;XposedTools.git 打包编译xposed框架git clone https:&#x2F;&#x2F;github.com&#x2F;rovo89&#x2F;Xposed.git xposed框架native部分 android-studio编译XposedInstaller 1234cd ~&#x2F;Android&#x2F;Sdk&#x2F;build-tools&#x2F;23.0.3.&#x2F;aaptapt-file search libz.so.1apt install lib32z1 下载的android_art复制到aosp712r8目录，用android_art替换原art重命名为art文件夹 1234export LC_ALL&#x3D;Csource build&#x2F;envsetup.shlunch 18make -j8 XposedBridge编译生成的apk改名为XposedBridge.jar放到/root/Desktop/COMPILE/aosp712r8/out/java/ XposedTools目录，cp build.conf.example ./build.conf修改配置文件build.conf 1234567891011121314151617181920212223242526272829[General]# 输出目录outdir &#x3D; &#x2F;root&#x2F;Desktop&#x2F;COMPILE&#x2F;aosp712r8&#x2F;out&#x2F;# xposedBridge.jar目录javadir &#x3D; &#x2F;root&#x2F;Desktop&#x2F;COMPILE&#x2F;aosp712r8&#x2F;out&#x2F;java&#x2F;[Build]# Please keep the base version number and add your custom suffix# 版本version &#x3D; 89 (custom build by xyz &#x2F; %s)# 编译时线程数makeflags &#x3D; -j8[GPG]sign &#x3D; releaseuser &#x3D; 852109AA!# Root directories of the AOSP source tree per SDK version[AospDir]# api版本和aosp源码目录25 &#x3D; &#x2F;root&#x2F;Desktop&#x2F;COMPILE&#x2F;aosp712r8&#x2F;# SDKs to be used for compiling BusyBox# Needs https:&#x2F;&#x2F;github.com&#x2F;rovo89&#x2F;android_external_busybox[BusyBox]# api版本一致arm &#x3D; 25x86 &#x3D; 25armv5 &#x3D; 25 下载Xposed复制到 aosp712r87/frameworks/base/cmds目录 安装perl包 12345678910111213141516apt-get install libauthen-ntlm-perlapt-get install libclass-load-perlapt-get install libcrypt-ssleay-perlapt-get install libdata-uniqid-perlapt-get install libdigest-hmac-perlapt-get install libdist-checkconflicts-perlapt-get install libfile-copy-recursive-perlapt-get install libfile-tail-perlapt-get install libconfig-inifiles-perlperl -MCPAN -e &#39;install Config::IniFiles&#39;perl -MCPAN -e &#39;install File::ReadBackwards&#39;perl -MCPAN -e &#39;install File::Tail&#39;cpaninstall Archive::Zipexit.&#x2F;build.pl -t arm64:25 hook远程url，修改xposed下载源 1234frida-ps -U | grep -i xposedobjection -g de.robv.android.xposed.installer exploreandroid hooking watch class de.robv.android.xposed.installer.util.DownloadsUtil --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method de.robv.android.xposed.installer.util.DownloadsUtil.getDownloadTargetForUrl --dump-args --dump-backtrace --dump-return 点击install触发打印调用栈 修改DownloadsUtil是setUrl方法中的mUrl的值为本地的zip地址，zip包目录：aosp712r8/out/sdk25/arm64/，apt install lighttpd Android.mk没找到ART.mk，路径问题，修改Android.mk最下面ART.mk路径改成绝对路径 魔改Xposed去特征定制Xposed框架 XposedBridge通过Gradle工具jarStubs和jarStubsSource编译生成的XposedBridge/app/build/api/api.jar替换xposed的项目的libs下的api.jar build.gradle compileOnly files(&#39;libs/api.jar&#39;) 修改XposedInstaller中的包名xposed为xppsed，所有的de.robv.android.xposed.installer改成de.robv.android.xppsed.installer，所有的/su/xposed/xposed.prop和/system/xposed.prop的xposed.prop改成xppsed.prop 修改XposedBridged的包名xposed改为xppsed，所有的de.robv.android.xposed改成所有的de.robv.android.xppsed，build好后的XposedBridge后包app-release-unsigned.apk的名字改成XppsedBridge.jar 进入aosp712r87/frameworks/base/cmds/xposed/ 修改libxposed_common.h 123#define CLASS_XPOSED_BRIDGE &quot;de&#x2F;robv&#x2F;android&#x2F;xppsed&#x2F;XposedBridge&quot;#define CLASS_ZYGOTE_SERVICE &quot;de&#x2F;robv&#x2F;android&#x2F;xppsed&#x2F;services&#x2F;ZygoteService&quot;#define CLASS_FILE_RESULT &quot;de&#x2F;robv&#x2F;android&#x2F;xppsed&#x2F;services&#x2F;FileResult&quot; 修改xposed.h 12345#define XPOSED_PROP_FILE &quot;&#x2F;system&#x2F;xppsed.prop&quot;#define XPOSED_LIB_ART XPOSED_LIB_DIR &quot;libxppsed_art.so&quot;#define XPOSED_JAR &quot;&#x2F;system&#x2F;framework&#x2F;XppsedBridge.jar&quot;#define XPOSED_CLASS_DOTS_ZYGOTE &quot;de.robv.android.xppsed.XposedBridge&quot;#define XPOSED_CLASS_DOTS_TOOLS &quot;de.robv.android.xppsed.XposedBridge$ToolEntryPoint&quot; 修改xposed_service.cpp 1IMPLEMENT_META_INTERFACE(XposedService, &quot;de.robv.android.xppsed.IXposedService&quot;); 修改xposed_shared.h 12#define XPOSED_DIR &quot;&#x2F;data&#x2F;user_de&#x2F;0&#x2F;de.robv.android.xppsed.installer&#x2F;&quot;#define XPOSED_DIR &quot;&#x2F;data&#x2F;data&#x2F;de.robv.android.xppsed.installer&#x2F;&quot; 修改libxposed_art.cpp名为libxppsed_art.cpp 修改ART.mk libxposed_art改成libxppsed_art 进入XposedTools 修改build.pl xposed.prop改成xppsed.prop XposedBridge.jar改成XppsedBridge.jar libxposed_art改成libxppsed_art grep -ril “xposedbridge.jar” * 找到所有包含的文件flash-script.sh等文件中的有上述xposed.prop，XposedBridge.jar，libxposed_art改掉即可。 1.&#x2F;build.pl -t arm64:25 重新编译生成路径aosp712r8&#x2F;out&#x2F;sdk25&#x2F;arm64下的zip包改成xposed-v89-sdk25-arm64.zip apt install lighttpd &amp;&amp; service lighttpd start cp xposed-v89-sdk25-arm64.zip /var/www/html/ 手机端访问192.168.0.102/xposed-v89-sdk25-arm64.zip (虚拟机) 可以直接下载 安装XposedInstaller(DownloadsUtil下的setUrl的mUrl改为虚拟机下载)进入Install界面进行安装xposed框架 adb install xposed_checker_app 过检测 开发新的xposed模块时，移除libs下的api.jar使用XposedBridge通过jarStubs生成的api.jar，更改代码中的de.robv.android.xppsed…","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"xposed","slug":"xposed","permalink":"http://onejane.github.io/tags/xposed/"}]},{"title":"Xposed主动调用开发","slug":"Xposed主动调用开发","date":"2021-05-01T07:39:54.000Z","updated":"2021-05-05T15:09:59.513Z","comments":true,"path":"2021/05/01/Xposed主动调用开发/","link":"","permalink":"http://onejane.github.io/2021/05/01/Xposed%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%BC%80%E5%8F%91/","excerpt":"","text":"相比于Frida，Xposed在参数的构造上是更有优势的,因为它就是使用的Java进行的开发； hook(想通过hook的方式得到一个obj的话需要hook一个实例方法) constructor.newInstance xposed.newInstance 案例Qualification分析adb install Qualification-1.3-easy-release.apk 目标就是找到pin的真实值 jadx-gui Qualification-1.3-easy-release.apk 搜索not the 找不到可能的结果，弹窗可能存在于dialog_failure或者dialog_success 查看strings.xml中定义的变量，&lt;string name=&quot;dialog_failure&quot;&gt;Unfortunately, not the right PIN :(&lt;/string&gt; 通过hookEvent.js进行hook所有动作触发的组件，找到android.support.v7.app.AppCompatViewInflater$DeclaredOnClickListener jadx中搜索android.support.v7.app.AppCompatViewInflater.DeclaredOnClickListener,使用了系统框架，无法准确定位最近的方法。 1234objection -g org.teamsik.ahe17.qualification.easy explore -P ~&#x2F;.objection&#x2F;plugins AndroidManifest.xml拿到包名开始objectionandroid hooking search classes MainActivityandroid hooking list class_methods org.teamsik.ahe17.qualification.MainActivity android hooking watch class org.teamsik.ahe17.qualification.MainActivity 点击VERIFY PIN按钮触发事件 根据org.teamsik.ahe17.qualification.MainActivity.verifyPasswordClick触发hook verifyPasswordClick 1android hooking watch class_method org.teamsik.ahe17.qualification.MainActivity.verifyPasswordClick --dump-args --dump-backtrace --dump-return 12plugin wallbreaker objectsearch android.support.v7.app.AppCompatViewInflater$DeclaredOnClickListener plugin wallbreaker objectdump --fullname 0x227a 使用反射进行调用的框架 破解校验秘钥逻辑如下，通过调用逻辑改写verifyPassword实现解密。 1android hooking search classes Verifier 最好从内存中捞这个类，而非根据静态反编译，hook方法也最好从内存中获取，不要从静态编译结果中获取不准确 反射调用encodePasswordf (v[i] != p[i]) 1234567891011121314151617181920if (loadPackageParam.packageName.equals(&quot;org.teamsik.ahe17.qualification.easy&quot;)) &#123; &#x2F;&#x2F; 安装xposed1点击button触发反射调用 XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); Class clazz &#x3D; loadPackageParam.classLoader.loadClass(&quot;org.teamsik.ahe17.qualification.Verifier&quot;); Method encodePassword &#x3D; clazz.getDeclaredMethod(&quot;encodePassword&quot;, String.class); encodePassword.setAccessible(true); byte[] p &#x3D; &quot;09042ec2c2c08c4cbece042681caf1d13984f24a&quot;.getBytes(); &#x2F;&#x2F; XposedBridge.log(&quot;result i is &#x3D;&gt; &quot; + new String(p)); 打印字节数组 String pStr &#x3D; new String((p)); for (int i &#x3D; 999; i &lt; 10000; i++) &#123; byte[] v &#x3D; (byte[]) encodePassword.invoke(null, String.valueOf(i)); if (v.length !&#x3D; p.length) &#123; break; &#125; String vStr &#x3D; new String(v); if (vStr &#x3D;&#x3D; pStr) &#123; XposedBridge.log(&quot;Current i is &#x3D;&gt; &quot; + String.valueOf(i)); &#125; &#125;&#125; 反射调用verifyPasswordif (!Verifier.verifyPassword(this, this.txPassword.getText().toString())) 1234567891011121314if (loadPackageParam.packageName.equals(&quot;org.teamsik.ahe17.qualification.easy&quot;)) &#123; XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); Class clazz &#x3D; loadPackageParam.classLoader.loadClass(&quot;org.teamsik.ahe17.qualification.Verifier&quot;); &#x2F;&#x2F; public 方法不需要getDeclaredMethod和setAccessible，反射拿到verifyPassword Method verifyPassword &#x3D; clazz.getMethod(&quot;verifyPassword&quot;, Context.class, String.class); Context context &#x3D; AndroidAppHelper.currentApplication(); for (int i &#x3D; 999; i &lt; 10000; i++) &#123; if ((boolean) verifyPassword.invoke(null, context, String.valueOf(i))) &#123; XposedBridge.log(&quot;Current i is &#x3D;&gt; &quot; + String.valueOf(i)); &#125; &#125;&#125; callStaticMethod verifyPassword123456789101112if (loadPackageParam.packageName.equals(&quot;org.teamsik.ahe17.qualification.easy&quot;)) &#123; XposedBridge.log(&quot;inner&quot;+loadPackageParam.processName); Class clazz &#x3D; XposedHelpers.findClass(&quot;org.teamsik.ahe17.qualification.Verifier&quot;,loadPackageParam.classLoader); &#x2F;&#x2F; hook Verifier类，并直接调用静态方法verifyPassword Context context &#x3D; AndroidAppHelper.currentApplication(); for(int i &#x3D; 999;i&lt;10000;i++)&#123; if((boolean) XposedHelpers.callStaticMethod(clazz,&quot;verifyPassword&quot;,context,String.valueOf(i)))&#123; XposedBridge.log(&quot;Current i is &#x3D;&gt; &quot;+ String.valueOf(i)); &#125; &#125;&#125; findAndHookMethod encodePassword1234567891011121314151617if (loadPackageParam.packageName.equals(&quot;org.teamsik.ahe17.qualification.easy&quot;)) &#123; XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); Class clazz &#x3D; XposedHelpers.findClass(&quot;org.teamsik.ahe17.qualification.Verifier&quot;, loadPackageParam.classLoader); XposedHelpers.findAndHookMethod(clazz, &quot;encodePassword&quot;, String.class, new XC_MethodHook() &#123; &#x2F;&#x2F; hook encodePassword后拿到所在类，调用该类的verifyPassword protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; Context context &#x3D; AndroidAppHelper.currentApplication(); for (int i &#x3D; 999; i &lt; 10000; i++) &#123; if ((boolean) XposedHelpers.callMethod(param.thisObject, &quot;verifyPassword&quot;, context, String.valueOf(i))) &#123; XposedBridge.log(&quot;Current i is &#x3D;&gt; &quot; + String.valueOf(i)); &#125; &#125; Log.d(&quot;getResult is &#x3D;&gt; &quot;, (String) param.getResult()); &#125; &#125;);&#125; newInstance Verifier123456789101112131415if (loadPackageParam.packageName.equals(&quot;org.teamsik.ahe17.qualification.easy&quot;)) &#123; XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); Class clazz &#x3D; XposedHelpers.findClass(&quot;org.teamsik.ahe17.qualification.Verifier&quot;, loadPackageParam.classLoader); &#x2F;&#x2F; newInstance拿到Verifier类并调用verifyPassword Object Verifier &#x3D; XposedHelpers.newInstance(clazz); Context context &#x3D; AndroidAppHelper.currentApplication(); for (int i &#x3D; 999; i &lt; 10000; i++) &#123; if ((boolean) XposedHelpers.callMethod(Verifier, &quot;verifyPassword&quot;, context, String.valueOf(i))) &#123; XposedBridge.log(&quot;Current i is &#x3D;&gt; &quot; + String.valueOf(i)); &#125; &#125;&#125; findConstructorExact Verifier1234567891011121314if (loadPackageParam.packageName.equals(&quot;org.teamsik.ahe17.qualification.easy&quot;)) &#123; XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); &#x2F;&#x2F; Constructor获取构造器newInstance拿到Verifier并调用verifyPassword Constructor cons &#x3D; XposedHelpers.findConstructorExact(&quot;org.teamsik.ahe17.qualification.Verifier&quot;,loadPackageParam.classLoader); Object Verifier &#x3D; cons.newInstance(); Context context &#x3D; AndroidAppHelper.currentApplication(); for (int i &#x3D; 999; i &lt; 10000; i++) &#123; if ((boolean) XposedHelpers.callMethod(Verifier, &quot;verifyPassword&quot;, context, String.valueOf(i))) &#123; XposedBridge.log(&quot;Current i is &#x3D;&gt; &quot; + String.valueOf(i)); &#125; &#125;&#125; hookAllMethods onCreate12345678910111213141516if (loadPackageParam.packageName.equals(&quot;org.teamsik.ahe17.qualification.easy&quot;)) &#123; XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); Class clazz &#x3D; loadPackageParam.classLoader.loadClass(&quot;org.teamsik.ahe17.qualification.MainActivity&quot;); &#x2F;&#x2F; 直接调用verifyPassword成功后回调的方法showSuccessDialog XposedBridge.hookAllMethods(clazz, &quot;onCreate&quot;,new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); Object mMainAciticity &#x3D; param.thisObject; XposedHelpers.callMethod(mMainAciticity,&quot;showSuccessDialog&quot;); &#125; &#125;);&#125; 案例demoso11234567.&#x2F;fs1426arm64 pyenv local 3.9.0objection -g com.example.demoso1 explore android hooking search classes MainActivityandroid hooking list class_methods com.example.demoso1.MainActivity 查看该类中所有函数android hooking watch class com.example.demoso1.MainActivityandroid hooking watch class_method com.example.demoso1.MainActivity.$init 查看构造函数的参数 给android hooking list class_methods 加上构造函数 12345cd ~&#x2F;.pyenvtree -NCfhl|grep objectioncd .&#x2F;versions&#x2F;3.9.0&#x2F;lib&#x2F;python3.9&#x2F;site-packagestree -NCfhl |grep -i agent.jsvi .&#x2F;objection&#x2F;agent.js //android hooking list class_methods com.example.demoso1.MainActivity//protected void com.example.demoso1.MainActivity.onCreate(android.os.Bundle)//public native int com.example.demoso1.MainActivity.init()//public native int com.example.demoso1.MainActivity.myfirstjni()//public native java.lang.String com.example.demoso1.MainActivity.method02(java.lang.String)//public static native java.lang.String com.example.demoso1.MainActivity.method01(java.lang.String)//public static native java.lang.String com.example.demoso1.MainActivity.myfirstjniJNI(java.lang.String)//public static native java.lang.String com.example.demoso1.MainActivity.stringFromJNI()//public static native java.lang.String com.example.demoso1.MainActivity.stringFromJNI2()//public void com.example.demoso1.MainActivity.testField()//public void com.example.demoso1.MainActivity.testMethod()// Found 10 method(s) 1234567891011121314151617181920212223if (loadPackageParam.packageName.equals(&quot;com.example.demoso1&quot;)) &#123; XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); final Class clazz &#x3D; loadPackageParam.classLoader.loadClass(&quot;com.example.demoso1.MainActivity&quot;); &#x2F;&#x2F;得到对象：hook(想通过hook的方式得到一个obj的话得hook一个实例方法) onCreate 循环调用method01和method02，onCreate执行后再触发 XposedBridge.hookAllMethods(clazz, &quot;onCreate&quot;, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Object mMainAciticity &#x3D; param.thisObject; String cipherText &#x3D; (String) XposedHelpers.callMethod(mMainAciticity, &quot;method01&quot;, &quot;roysue&quot;); String clearText &#x3D; (String) XposedHelpers.callMethod(mMainAciticity, &quot;method02&quot;, &quot;47fcda3822cd10a8e2f667fa49da783f&quot;); XposedBridge.log(&quot;Cipher text is &#x3D;&gt; &quot; + cipherText); XposedBridge.log(&quot;Clear text is &#x3D;&gt; &quot; + clearText); &#125; &#125;); &#x2F;&#x2F;xposed.newInstance获取对象 毕竟在hook中，进行主动调用的话，触发条件需要将mMainActivity进行newInstance，包只要打开就会触发 Object newMainActivity &#x3D; XposedHelpers.newInstance(clazz); String cipherText &#x3D; (String) XposedHelpers.callMethod(newMainActivity, &quot;method01&quot;, &quot;roysue&quot;); String clearText &#x3D; (String) XposedHelpers.callMethod(newMainActivity, &quot;method02&quot;, &quot;47fcda3822cd10a8e2f667fa49da783f&quot;); XposedBridge.log(&quot;Cipher text 2 is &#x3D;&gt; &quot; + cipherText); XposedBridge.log(&quot;Clear text 2 is &#x3D;&gt; &quot; + clearText);&#125; Nanohttpd利用NanoHTTPD反射调用Android APP加密函数 build.gradle添加依赖implementation &#39;org.nanohttpd:nanohttpd:2.3.1&#39; AndroidManifest.xml添加网络权限声明&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384Object mMainActivity &#x3D; null;public void setActivity(Object obj) &#123; mMainActivity &#x3D; obj;&#125;public Object getActivity() &#123; return mMainActivity;&#125;if (loadPackageParam.packageName.equals(&quot;com.example.demoso1&quot;)) &#123; XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); final Class clazz &#x3D; loadPackageParam.classLoader.loadClass(&quot;com.example.demoso1.MainActivity&quot;); &#x2F;&#x2F;得到对象：hook(想通过hook的方式得到一个obj的话得hook一个实例方法) onCreate 循环调用method01和method02 XposedBridge.hookAllMethods(clazz, &quot;onCreate&quot;, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Object mMainAciticity &#x3D; param.thisObject; String cipherText &#x3D; (String) XposedHelpers.callMethod(mMainAciticity, &quot;method01&quot;, &quot;roysue&quot;); String clearText &#x3D; (String) XposedHelpers.callMethod(mMainAciticity, &quot;method02&quot;, &quot;47fcda3822cd10a8e2f667fa49da783f&quot;); XposedBridge.log(&quot;Cipher text is &#x3D;&gt; &quot; + cipherText); XposedBridge.log(&quot;Clear text is &#x3D;&gt; &quot; + clearText);&#x2F;&#x2F; setActivity(mMainAciticity); &#125; &#125;); &#x2F;&#x2F;xposed.newInstance获取对象 毕竟在hook中，进行主动调用的话，触发条件需要将mMainActivity进行newInstance Object newMainActivity &#x3D; XposedHelpers.newInstance(clazz); String cipherText &#x3D; (String) XposedHelpers.callMethod(newMainActivity, &quot;method01&quot;, &quot;roysue&quot;); String clearText &#x3D; (String) XposedHelpers.callMethod(newMainActivity, &quot;method02&quot;, &quot;47fcda3822cd10a8e2f667fa49da783f&quot;); XposedBridge.log(&quot;Cipher text 2 is &#x3D;&gt; &quot; + cipherText); XposedBridge.log(&quot;Clear text 2 is &#x3D;&gt; &quot; + clearText); setActivity(newMainActivity); class App extends NanoHTTPD &#123; public App() throws IOException &#123; super(8899); &#x2F;&#x2F; 内部新起线程实现http，无法直接调用当前类的变量，需要在上面定义setActivity拿到callMethod里的对象 start(NanoHTTPD.SOCKET_READ_TIMEOUT, true); XposedBridge.log(&quot;\\nRunning! Point your browsers to http:&#x2F;&#x2F;localhost:8899&#x2F; \\n&quot;); &#125; @Override public NanoHTTPD.Response serve(IHTTPSession session) &#123; Method method &#x3D; session.getMethod(); String uri &#x3D; session.getUri(); String RemoteIP &#x3D; session.getRemoteIpAddress(); String RemoteHostName &#x3D; session.getRemoteHostName(); Log.i(&quot;r0ysue nanohttpd &quot;,&quot;Method &#x3D;&gt; &quot;+method + &quot; ;Url &#x3D;&gt; &quot; + uri + &quot;&#39; &quot;); Log.i(&quot;r0ysue nanohttpd &quot;,&quot;Remote IP &#x3D;&gt; &quot;+RemoteIP + &quot; ;RemoteHostName &#x3D;&gt; &quot; + RemoteHostName + &quot;&#39; &quot;); String paramBody &#x3D; &quot;&quot;; Map&lt;String, String&gt; files &#x3D; new HashMap&lt;&gt;(); try &#123; session.parseBody(files); paramBody &#x3D; session.getQueryParameterString(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ResponseException e) &#123; e.printStackTrace(); &#125; Log.i(&quot;Nano_post_param &#x3D;&gt; &quot;, paramBody);&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; String msg &#x3D; &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello server&lt;&#x2F;h1&gt;\\n&quot;;&#x2F;&#x2F; Map&lt;String, String&gt; parms &#x3D; session.getParms();&#x2F;&#x2F; if (parms.get(&quot;username&quot;) &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; msg +&#x3D; &quot;&lt;form action&#x3D;&#39;?&#39; method&#x3D;&#39;get&#39;&gt;\\n &lt;p&gt;Your name: &lt;input type&#x3D;&#39;text&#39; name&#x3D;&#39;username&#39;&gt;&lt;&#x2F;p&gt;\\n&quot; + &quot;&lt;&#x2F;form&gt;\\n&quot;;&#x2F;&#x2F; &#125; else &#123;&#x2F;&#x2F; msg +&#x3D; &quot;&lt;p&gt;Hello, &quot; + parms.get(&quot;username&quot;) + &quot;!&lt;&#x2F;p&gt;&quot;;&#x2F;&#x2F; &#125; String result &#x3D; &quot;&quot;; result &#x3D; (String) XposedHelpers.callMethod(getActivity(), &quot;method01&quot;, &quot;r0ysue&quot;); return newFixedLengthResponse(Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, result); &#125; &#125; new App();&#125; curl -s -X POST “http://192.168.0.103:8899/&quot; -d ‘{“data”:onejane}’ python调用实现 12345678910111213import requestsdef encrypt(enParam): &#x2F;&#x2F; xposed1 app所在手机ip url &#x3D; &quot;http:&#x2F;&#x2F;192.168.0.103:8899&quot; param &#x3D; enParam headers &#x3D; &#123;&quot;Content-Type&quot;:&quot;application&#x2F;x-www-form-urlencoded&quot;&#125; r &#x3D; requests.post(url &#x3D; url ,data&#x3D;param,headers &#x3D; headers) print(r.content) return r.contentif __name__ &#x3D;&#x3D; &#39;__main__&#39; : encrypt(&quot;onejane&quot;) apt install siege https://www.jianshu.com/p/74c465ff136f 1siege -c5 -r10 &quot;http:&#x2F;&#x2F;192.168.0.103:8899 POST &lt;.&#x2F;iloveroysue.json &quot; 压测 iloveroysue.json { “data”:”iloveroysue” } adb forward tcp:8899 tcp:8899 将手机8899转发到电脑8899 siege -c5 -r10 “http://127.0.0.1:8899 POST &lt;./iloveroysue.json “ 1234567if(uri.contains(&quot;encrypt&quot;))&#123; result &#x3D; (String) XposedHelpers.callMethod(getActivity(), &quot;method01&quot;, paramBody);&#125;else if (uri.contains(&quot;decrypt&quot;))&#123; result &#x3D; (String) XposedHelpers.callMethod(getActivity(), &quot;method02&quot;, paramBody);&#125;else&#123; result &#x3D; paramBody;&#125; curl -s -X POST “http://192.168.0.103:8899/encrypt&quot; -d ‘{“data”:onejane}’ 123objection -g com.example.demoso1 explore -P ~&#x2F;.objection&#x2F;pluginsplugin wallbreaker classsearch Sessionandroid hooking watch class fi.iki.elonen.NanoHTTPD$IHTTPSession 该类不在目标进程中，在xposed的classloader中，可以hook但是objection没有切classloader的功能 暴露公网手机：npc file npc 查看该文件格式基本信息，执行客户端命令暴露一个公网ip出去，端口为58899 服务器：nps curl -s -X POST “http://118.126.66.193:58899/encrypt&quot; -d ‘{“data”:onejane}’ siege -c5 -r10 “http://118.126.66.193:8899 POST &lt;./iloveroysue.json “ 案例movetv1234567objection -g com.cz.babySister exploreandroid hooking search classes MainActivity android hooking list class_methods com.cz.babySister.activity.MainActivityandroid hooking watch class com.cz.babySister.activity.MainActivity 将所有MainActivity的方法进行hook，做任意操作打印调用方法android hooking search classes loadedapk 搜索类名包括loadedapk的类plugin wallbreaker objectsearch android.app.LoadedApk 内存漫游查找android.app.LoadedApkplugin wallbreaker objectdump 0x240a 可视化内存中类的信息 jadx-gui Desktop/movetv.apk 腾讯加固 123456789101112if (loadPackageParam.packageName.equals(&quot;com.cz.babySister&quot;)) &#123; Class clazz &#x3D; loadPackageParam.classLoader.loadClass(&quot;com.cz.babySister.activity.MainActivity&quot;); XposedHelpers.findAndHookMethod(clazz, &quot;getJiFen&quot;, float.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;float is &quot;+ String.valueOf( (float) param.args[0])); &#125; &#125;);&#125; 脱壳使用frida来hook加固的Android应用的java层，APP的启动过程，Android万能脱壳机，FART：ART环境下基于主动调用的自动化脱壳方案 1234plugin wallbreaker objectsearch android.app.ActivityThread plugin wallbreaker objectdump --fullname 0x2a6a 取mInitialApplication的内存地址plugin wallbreaker objectdump --fullname 0x10094eandroid hooking list class_methods java.lang.ClassLoader 有findClass方法 首先，对于获取Classloader的时机点的选择。在第一节的App启动流程以及第三节中APP加壳原理和执行流程的介绍中，可以看到，APP中的Application类中的attachBaseContext和onCreate函数是app中最先执行的方法。壳都是通过替换APP的Application类并自己实现这两个函数，并在这两个函数中实现dex的解密加载，hook系统中Class和method加载执行流程中的关键函数，最后通过反射完成关键变量如最终的Classloader，Application等的替换从而完成执行权的交付。因此，我们可以选在任意一个在Application的onCreate函数执行之后才开始被调用的任意一个函数中。众所周知，对于一个正常的应用来说，最终都要由一个个的Activity来展示应用的界面并和用户完成交互，那么我们就可以选择在ActivityThread中的performLaunchActivity函数作为时机，来获取最终的应用的Classloader。选择该函数还有一个好处在于该函数和应用的最终的application同在ActivityThread类中，可以很方便获取到该类的成员。 12345678910111213141516171819202122232425private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ...... Activity activity &#x3D; null; try &#123; java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();&#x2F;&#x2F;下面通过application的getClassLoader()获取最终的Classloader，并开启线程，在新线程中完成内存中的dex的dump以及主动调用过程，由于该过程相对耗时，为了防止应用出现ANR，从而开启新线程，在新线程中进行，主要的工作都在getDexFilesByClassLoader_23 &#x2F;&#x2F;addstart packagename&#x3D;r.packageInfo.getPackageName(); &#x2F;&#x2F;mInitialApplication &#x2F;&#x2F;final java.lang.ClassLoader finalcl&#x3D;cl if(mInitialApplication!&#x3D;null)&#123; final java.lang.ClassLoader finalcl&#x3D;mInitialApplication.getClassLoader(); new Thread(new Runnable() &#123; @Override public void run() &#123; getDexFilesByClassLoader_23(finalcl); &#125; &#125;).start(); &#125; &#x2F;&#x2F;addend &#125;&#125; wget https://github.com/hanbinglengyue/FART/blob/master/FART_6.0_sourcecode.zip 套用FART_6.0_sourcecod/frameworks/base/core/java/android/app/ActivityThread.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210if (loadPackageParam.packageName.equals(&quot;com.cz.babySister&quot;)) &#123; XposedBridge.log(&quot; has Hooked!&quot;); XposedBridge.log(&quot;inner &#x3D;&gt; &quot; + loadPackageParam.processName); Class ActivityThread &#x3D; XposedHelpers.findClass(&quot;android.app.ActivityThread&quot;,loadPackageParam.classLoader); XposedBridge.hookAllMethods(ActivityThread, &quot;performLaunchActivity&quot;, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); Object mInitialApplication &#x3D; (Application) XposedHelpers.getObjectField(param.thisObject,&quot;mInitialApplication&quot;); ClassLoader finalCL &#x3D; (ClassLoader) XposedHelpers.callMethod(mInitialApplication,&quot;getClassLoader&quot;); XposedBridge.log(&quot;found classload is &#x3D;&gt; &quot;+finalCL.toString()); Class BabyMain &#x3D; (Class)XposedHelpers.callMethod(finalCL,&quot;findClass&quot;,&quot;com.cz.babySister.activity.MainActivity&quot;); XposedBridge.log(&quot;found final class is &#x3D;&gt; &quot;+BabyMain.getName().toString()); fart(finalCL); &#125; &#125;);&#125;public static Object invokeStaticMethod(String class_name, String method_name, Class[] pareTyple, Object[] pareVaules) &#123; try &#123; Class obj_class &#x3D; Class.forName(class_name); Method method &#x3D; obj_class.getMethod(method_name, pareTyple); return method.invoke(null, pareVaules); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null;&#125;public static Object getFieldOjbect(String class_name, Object obj, String filedName) &#123; try &#123; Class obj_class &#x3D; Class.forName(class_name); Field field &#x3D; obj_class.getDeclaredField(filedName); field.setAccessible(true); return field.get(obj); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null;&#125;public static Field getClassField(ClassLoader classloader, String class_name, String filedName) &#123; try &#123; Class obj_class &#x3D; classloader.loadClass(class_name); Field field &#x3D; obj_class.getDeclaredField(filedName); field.setAccessible(true); return field; &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null;&#125;public static ClassLoader getClassloader() &#123; ClassLoader resultClassloader &#x3D; null; Object currentActivityThread &#x3D; invokeStaticMethod( &quot;android.app.ActivityThread&quot;, &quot;currentActivityThread&quot;, new Class[]&#123;&#125;, new Object[]&#123;&#125;); Object mBoundApplication &#x3D; getFieldOjbect( &quot;android.app.ActivityThread&quot;, currentActivityThread, &quot;mBoundApplication&quot;); Object loadedApkInfo &#x3D; getFieldOjbect( &quot;android.app.ActivityThread$AppBindData&quot;, mBoundApplication, &quot;info&quot;); Application mApplication &#x3D; (Application) getFieldOjbect(&quot;android.app.LoadedApk&quot;, loadedApkInfo, &quot;mApplication&quot;); resultClassloader &#x3D; mApplication.getClassLoader(); return resultClassloader;&#125;public static Object getClassFieldObject(ClassLoader classloader, String class_name, Object obj, String filedName) &#123; try &#123; Class obj_class &#x3D; classloader.loadClass(class_name); Field field &#x3D; obj_class.getDeclaredField(filedName); field.setAccessible(true); Object result &#x3D; null; result &#x3D; field.get(obj); return result; &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return null;&#125;public static void fart(ClassLoader clzloader) throws IOException &#123; ClassLoader appClassloader &#x3D; clzloader; List&lt;Object&gt; dexFilesArray &#x3D; new ArrayList&lt;Object&gt;(); Field pathList_Field &#x3D; (Field) getClassField(appClassloader, &quot;dalvik.system.BaseDexClassLoader&quot;, &quot;pathList&quot;); Object pathList_object &#x3D; getFieldOjbect(&quot;dalvik.system.BaseDexClassLoader&quot;, appClassloader, &quot;pathList&quot;); Object[] ElementsArray &#x3D; (Object[]) getFieldOjbect(&quot;dalvik.system.DexPathList&quot;, pathList_object, &quot;dexElements&quot;); Field dexFile_fileField &#x3D; null; try &#123; dexFile_fileField &#x3D; (Field) getClassField(appClassloader, &quot;dalvik.system.DexPathList$Element&quot;, &quot;dexFile&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Class DexFileClazz &#x3D; null; try &#123; DexFileClazz &#x3D; appClassloader.loadClass(&quot;dalvik.system.DexFile&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Method getClassNameList_method &#x3D; null; Method defineClass_method &#x3D; null; Method dumpDexFile_method &#x3D; null; Method dumpMethodCode_method &#x3D; null; for (Method field : DexFileClazz.getDeclaredMethods()) &#123; if (field.getName().equals(&quot;getClassNameList&quot;)) &#123; getClassNameList_method &#x3D; field; getClassNameList_method.setAccessible(true); &#125; if (field.getName().equals(&quot;defineClassNative&quot;)) &#123; defineClass_method &#x3D; field; defineClass_method.setAccessible(true); &#125; if (field.getName().equals(&quot;dumpMethodCode&quot;)) &#123; dumpMethodCode_method &#x3D; field; dumpMethodCode_method.setAccessible(true); &#125; &#125; Field mCookiefield &#x3D; getClassField(appClassloader, &quot;dalvik.system.DexFile&quot;, &quot;mCookie&quot;); for (int j &#x3D; 0; j &lt; ElementsArray.length; j++) &#123; Object element &#x3D; ElementsArray[j]; Object dexfile &#x3D; null; try &#123; dexfile &#x3D; (Object) dexFile_fileField.get(element); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if (dexfile &#x3D;&#x3D; null) &#123; continue; &#125; if (dexfile !&#x3D; null) &#123; dexFilesArray.add(dexfile); Object mcookie &#x3D; getClassFieldObject(appClassloader, &quot;dalvik.system.DexFile&quot;, dexfile, &quot;mCookie&quot;); if (mcookie &#x3D;&#x3D; null) &#123; continue; &#125; String[] classnames &#x3D; null; try &#123; classnames &#x3D; (String[]) getClassNameList_method.invoke(dexfile, mcookie); &#125; catch (Exception e) &#123; e.printStackTrace(); continue; &#125; catch (Error e) &#123; e.printStackTrace(); continue; &#125; if (classnames !&#x3D; null) &#123; File file &#x3D; new File(&quot;&#x2F;sdcard&#x2F;Download&#x2F;dumpClass1122.txt&quot;); if (!file.exists()) &#123; Log.d(&quot;TestFile&quot;, &quot;Create the file:&quot; ); file.createNewFile(); &#125; RandomAccessFile raf &#x3D; new RandomAccessFile(file, &quot;rw&quot;); raf.seek(file.length()); for (String eachclassname : classnames) &#123; String log &#x3D; &quot;ClassNameis::&quot; +eachclassname +&quot; :: &quot;+ dumpMethodCode_method +&quot;::&quot;+appClassloader.toString() +&quot;\\n&quot;; raf.write(log.getBytes()); Log.i(&quot;classes&#x3D;&gt;&quot;,log); &#125; raf.close(); &#125; &#125; &#125; return;&#125; cat dumpClass1122.txt |grep MainActivity 脱壳拿到类包括子类，完成trace到classloader所有类的功能 安卓逆向之基于Xposed-ZjDroid脱壳","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"xposed","slug":"xposed","permalink":"http://onejane.github.io/tags/xposed/"}]},{"title":"JS逆向之房天下pwd","slug":"JS逆向之房天下pwd","date":"2021-04-29T09:35:03.000Z","updated":"2021-05-01T07:40:46.687Z","comments":true,"path":"2021/04/29/JS逆向之房天下pwd/","link":"","permalink":"http://onejane.github.io/2021/04/29/JS%E9%80%86%E5%90%91%E4%B9%8B%E6%88%BF%E5%A4%A9%E4%B8%8Bpwd/","excerpt":"","text":"https://passport.fang.com/?backurl=https%3A%2F%2Fsuzhou.fang.com%2F 目标POST https://passport.fang.com/login.api 1234uid: 15806204095@163.compwd: 3854d2ef8cc2455ed263a3a697414c6f59043010efba9b24da93c6596123fee5fded0d948bc9148beaa5f58756817725617bb3c09ade11e5586e6430392a27db28005ebcfc442d8cf64c0369d439b17011c88e89a57914d78f45a7bba9a7c9e95b75e9fcb4cccbc4c6d65b3e0d3257d183ff2ba35bf3eb70e6bf0b50d4ffdaa1Service: soufun-passport-webAutoLogin: 1 分析搜索login.api，并打上断点，重新登录时可以知道pwd是由key_to_encode和我们输入的密码123456经过encryptedString函数生成 搜索key_to_encode，通过RSAKeyPair构造函数返回key_to_encode 进入RSAKeyPair的构造函数中，正好encryptedString方法也在其中，我们将整个RSA.min.js:formatted拷贝下来命名fang.js，添加新方法getpwd，实现通过传入的123456加密生成pwd。 1234function getpwd(pwd) &#123; var key_to_encode &#x3D; new RSAKeyPair(&quot;010001&quot;, &quot;&quot;, &quot;978C0A92D2173439707498F0944AA476B1B62595877DD6FA87F6E2AC6DCB3D0BF0B82857439C99B5091192BC134889DFF60C562EC54EFBA4FF2F9D55ADBCCEA4A2FBA80CB398ED501280A007C83AF30C3D1A142D6133C63012B90AB26AC60C898FB66EDC3192C3EC4FF66925A64003B72496099F4F09A9FB72A2CF9E4D770C41&quot;); return encryptedString(key_to_encode, pwd)&#125; 爬虫实现拷贝参数到sublime中，使用ctrl+H正则替换功能将(.*?):\\s(.*?)\\n 改成&#39;$1&#39;:&#39;$2&#39;,\\n,或者通过请求头加参数.py修改格式。 1234uid: 15806204095@163.compwd: 3854d2ef8cc2455ed263a3a697414c6f59043010efba9b24da93c6596123fee5fded0d948bc9148beaa5f58756817725617bb3c09ade11e5586e6430392a27db28005ebcfc442d8cf64c0369d439b17011c88e89a57914d78f45a7bba9a7c9e95b75e9fcb4cccbc4c6d65b3e0d3257d183ff2ba35bf3eb70e6bf0b50d4ffdaa1Service: soufun-passport-webAutoLogin: 1 接下来再通过exec执行扣下的js并利用requests库实现post请求完成登录。 12345678910111213141516171819202122232425262728293031323334def get_pwd(): with open(&quot;fang.js&quot;, &quot;r&quot;) as f: js_code &#x3D; f.read() results &#x3D; execjs.compile(js_code).call(&quot;getpwd&quot;, password) return resultsdef login(): url &#x3D; &#39;https:&#x2F;&#x2F;passport.fang.com&#x2F;login.api&#39; pwd &#x3D; get_pwd() data &#x3D; &#123; &#39;uid&#39;: account, &#39;pwd&#39;: pwd, &#39;Service&#39;: &#39;soufun-passport-web&#39;, &#39;AutoLogin&#39;: &#39;1&#39;, &#125; headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.111 Safari&#x2F;537.36&#39;, &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;, &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&#39;, &#39;Host&#39;: &#39;passport.fang.com&#39;, &#39;Origin&#39;: &#39;https:&#x2F;&#x2F;passport.fang.com&#39;, &#39;Pragma&#39;: &#39;no-cache&#39;, &#39;Referer&#39;: &#39;https:&#x2F;&#x2F;passport.fang.com&#x2F;?backurl&#x3D;https%3A%2F%2Fsuzhou.fang.com%2F&#39;, &#39;Sec-Fetch-Dest&#39;: &#39;empty&#39;, &#39;Sec-Fetch-Mode&#39;: &#39;cors&#39;, &#39;Sec-Fetch-Site&#39;: &#39;same-origin&#39;, &#125; response &#x3D; requests.post(url, data, headers&#x3D;headers) print(response.text)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: login() 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"爬虫基础篇之多途径抓取失信人名单","slug":"爬虫基础篇之多途径抓取失信人名单","date":"2021-04-27T12:14:07.000Z","updated":"2021-05-01T07:40:47.325Z","comments":true,"path":"2021/04/27/爬虫基础篇之多途径抓取失信人名单/","link":"","permalink":"http://onejane.github.io/2021/04/27/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%A4%9A%E9%80%94%E5%BE%84%E6%8A%93%E5%8F%96%E5%A4%B1%E4%BF%A1%E4%BA%BA%E5%90%8D%E5%8D%95/","excerpt":"","text":"需求继爬虫基础篇之Scrapy抓取京东之后，我们对scrapy有了一定的掌握，接下来通过多渠道汇总对失信人信息抓取入库。 抓取百度失信人名单 抓取最高人民法院失信人名单 抓取国家企业信用公示系统失信人公告 把上面三个来源的失信人信息进行合并,去重 目标百度 搜索失信人名单 抓取数据: 失信人名称, 失信人号码,法人(企业), 年龄(企业的年龄为0), 区域,失信内容, 公布日期, 公布执行单位, 创建日期, 更新日期 企业信用信息公示系统 访问http://www.gsxt.gov.cn/corp-query-entprise-info-xxgg-100000.html 抓取: 失信人名称, 失信人号码, 年龄(企业的年龄为0), 区域, 失信内容, 公布日期, 公布单位, 类型(个人/企业), 创建日期, 更新日期 实现 把抓取的数据, 统一存储到同一个数据库的, 同一张表中. 如何去重? 对于个人: 根据失信人号码, 检查一下, 如果不存在才插入. 对于企业/组织: 失信人证件号, 有的是组织机构代码, 有的是信用号, 企业信用信息公示系统的失信人公告有的没有证件号, 所以无法进行准确判断. 区域 和 企业名称进行检查, 如果有就重复了, 没有才插入. 百度scrapy startproject dishonest 创建爬虫项目 数据模型定义数据模型继承自scrapy.Item的数据模型DishonestItem 12345678910111213141516171819202122class DishonestItem(scrapy.Item): # define the fields for your item here like: # 失信人名称 name &#x3D; scrapy.Field() # 失信人证件号 card_num &#x3D; scrapy.Field() # 失信人年龄, 企业年龄都是0 age &#x3D; scrapy.Field() # 区域 area &#x3D; scrapy.Field() # 法人(企业) business_entity &#x3D; scrapy.Field() # 失信内容 content &#x3D; scrapy.Field() # 公布日期 publish_date &#x3D; scrapy.Field() # 公布&#x2F;执行单位 publish_unit &#x3D; scrapy.Field() # 创建日期 create_date &#x3D; scrapy.Field() # 更新日期 update_date &#x3D; scrapy.Field() 分析通过翻页发起请求，在控制台的All请求下出现了https://sp0.baidu.com/8aQDcjqpAAV3otqbppnN2DJv/api.php?resource_id=6899&amp;query=失信人名单&amp;pn=0&amp;ie=utf-8&amp;oe=utf-8&amp;format=json的目标地址 参数: resource_id=6899: 资源id, 固定值 query=失信人名单: 查询内容, 固定值 pn=0: 数据起始号码 ie=utf-8&amp;oe=utf-8: 指定数据的编码方式, 固定值 format=json: 数据格式, 固定值 我们可以根据第一次请求, 获取到总的数据条数, 生成所有页面的URL. demo123456789url &#x3D; &#39;https:&#x2F;&#x2F;sp0.baidu.com&#x2F;8aQDcjqpAAV3otqbppnN2DJv&#x2F;api.php?resource_id&#x3D;6899&amp;query&#x3D;失信人&amp;pn&#x3D;10&amp;rn&#x3D;10&amp;ie&#x3D;utf-8&amp;oe&#x3D;utf-8&#39;headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;70.0.3538.110 Safari&#x2F;537.36&#39;, &#39;Referer&#39;: &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;s?ie&#x3D;UTF-8&amp;wd&#x3D;%E5%A4%B1%E4%BF%A1%E4%BA%BA&#39;&#125;response &#x3D; requests.get(url, headers&#x3D;headers)print(response.status_code)print(response.content.decode()) 爬虫实现 设置默认请求头, 在settings.py文件中 1234DEFAULT_REQUEST_HEADERS &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;70.0.3538.110 Safari&#x2F;537.36&#39;, &#39;Referer&#39;: &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;s?ie&#x3D;UTF-8&amp;wd&#x3D;%E5%A4%B1%E4%BF%A1%E4%BA%BA&#39;&#125; scrapy genspider baidu baidu.com 创建爬虫 分页实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class BaiduSpider(scrapy.Spider): name &#x3D; &#39;baidu&#39; allowed_domains &#x3D; [&#39;baidu.com&#39;] start_urls &#x3D; [&#39;https:&#x2F;&#x2F;sp0.baidu.com&#x2F;8aQDcjqpAAV3otqbppnN2DJv&#x2F;api.php?resource_id&#x3D;6899&amp;query&#x3D;失信人&amp;pn&#x3D;0&amp;rn&#x3D;10&amp;ie&#x3D;utf-8&amp;oe&#x3D;utf-8&#39;] def parse(self, response): # 构建所有页面请求 # 把响应内容的json字符串, 转为字典 results &#x3D; json.loads(response.text) # 取出总数据条数 disp_num &#x3D; jsonpath(results, &#39;$..dispNum&#39;)[0] # print(disp_num) # URL模板 url_pattern &#x3D; &#39;https:&#x2F;&#x2F;sp0.baidu.com&#x2F;8aQDcjqpAAV3otqbppnN2DJv&#x2F;api.php?resource_id&#x3D;6899&amp;query&#x3D;失信人&amp;pn&#x3D;&#123;&#125;&amp;rn&#x3D;10&amp;ie&#x3D;utf-8&amp;oe&#x3D;utf-8&#39; # 每隔10条数据, 构建一个请求 for pn in range(0, disp_num, 10): # 构建URL url &#x3D; url_pattern.format(pn) # 创建请求, 交给引擎 yield scrapy.Request(url, callback&#x3D;self.parse_data) def parse_data(self, response): &quot;&quot;&quot;解析数据&quot;&quot;&quot; # 响应数据 datas &#x3D; json.loads(response.text) results &#x3D; jsonpath(datas, &#39;$..result&#39;)[0] # 遍历结果列表 for result in results: item &#x3D; DishonestItem() # 失信人名称 item[&#39;name&#39;] &#x3D; result[&#39;iname&#39;] # 失信人号码 item[&#39;card_num&#39;] &#x3D; result[&#39;cardNum&#39;] # 失信人年龄 item[&#39;age&#39;] &#x3D; int(result[&#39;age&#39;]) # 区域 item[&#39;area&#39;] &#x3D; result[&#39;areaName&#39;] # 法人(企业) item[&#39;business_entity&#39;] &#x3D; result[&#39;businessEntity&#39;] # 失信内容 item[&#39;content&#39;] &#x3D; result[&#39;duty&#39;] # 公布日期 item[&#39;publish_date&#39;] &#x3D; result[&#39;publishDate&#39;] # 公布&#x2F;执行单位 item[&#39;publish_unit&#39;] &#x3D; result[&#39;courtName&#39;] # 创建日期 item[&#39;create_date&#39;] &#x3D; datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;) # 更新日期 item[&#39;update_date&#39;] &#x3D; datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;) # print(item) # 把数据交给引擎 yield item 数据存储 创建数据库表 12345678910111213141516171819 -- 创建数据库create database dishonest;-- 如果表存在就删除drop table if exists dishonest;-- 创建表create table dishonest(dishonest_id INT NOT NULL AUTO_INCREMENT, -- id主键age INT NOT NULL, -- 年龄, 自然人年龄都是&gt;0的, 企业的年龄等于0name VARCHAR(200) NOT NULL, -- 失信人名称card_num VARCHAR(50) , -- 失信人号码area VARCHAR(50) NOT NULL, -- 区域content VARCHAR(2000) NOT NULL, -- 失信内容business_entity VARCHAR(20), -- 企业法人publish_unit VARCHAR(200), -- 发布单位publish_date VARCHAR(20), -- 发布单位create_date DATETIME, -- 创建日期update_date DATETIME, -- 更新日期PRIMARY KEY (dishonest_id)); 在settings中配置数据库信息 1234567891011# 配置MYSQL# MYSQL的主机IP地址MYSQL_HOST &#x3D; &#39;127.0.0.1&#39;# MYSQL端口号MYSQL_PORT &#x3D; 3306# MYSQL用户名MYSQL_USER &#x3D; &#39;root&#39;# MYSQL密码MYSQL_PASSWORD &#x3D; &#39;&#39;# MYSQL数据库名MYSQL_DB &#x3D; &#39;dishonest&#39; 使用pipeline存储数据到mysql 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class DishonestListPipeline(object): def open_spider(self, spider): # 创建数据链接 self.connect &#x3D; pymysql.connect(host&#x3D;&quot;127.0.0.1&quot;,user&#x3D;&quot;root&quot;, password&#x3D;&quot;123&quot;, db&#x3D;&quot;dishonest&quot;,port&#x3D;3306) # 获取执行SQL的cursor self.cursor &#x3D; self.connect.cursor() def close_spider(self, spider): # 释放游标 self.cursor.close() # 释放链接 self.connect.close() def process_item(self, item, spider): if item[&#39;age&#39;] &#x3D;&#x3D; 0: # 如果年龄 &#x3D;&#x3D; 0 , 就是企业, 就根据公司名和区域进行查询 name &#x3D; item[&#39;name&#39;] area_name &#x3D; item[&#39;area&#39;] select_sql &#x3D; &quot;select count(1) from t_dishonest where name&#x3D;&#39;&#123;&#125;&#39; and area &#x3D; &#39;&#123;&#125;&#39;&quot;.format(name, area) else: # 如果是个人根据证件号, 数据条数 select_sql &#x3D; &quot;select count(1) from t_dishonest where card_num&#x3D;&#39;&#123;&#125;&#39;&quot;.format(item[&#39;card_num&#39;] ) # 根据证件号, 数据条数 select_sql &#x3D; &quot;select count(1) from dishonest where card_num&#x3D;&#39;&#123;&#125;&#39;&quot;.format(item[&#39;card_num&#39;]) # 执行查询SQL self.cursor.execute(select_sql) # 获取查询结果 count &#x3D; self.cursor.fetchone()[0] # 如果查询的数量为0, 说明该人不存在, 不存在就插入 if count &#x3D;&#x3D; 0: # 获取当前的时间, 为插入数据库的时间 item[&#39;create_date&#39;] &#x3D; datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;) item[&#39;update_date&#39;] &#x3D; datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;) # 把数据转换为键, 值的格式, 方便插入数据库 keys, values &#x3D; zip(*dict(item).items()) # 插入数据库SQL insert_sql &#x3D; &#39;insert into dishonest (&#123;&#125;) values(&#123;&#125;)&#39;.format( &#39;,&#39;.join(keys), &#39;,&#39;.join([&#39;%s&#39;] * len(values)) ) # 执行插入数据SQL self.cursor.execute(insert_sql, values) # 提交 self.connect.commit() else: spider.logger.info(&#39;&#123;&#125; 重复&#39;.format(item)) return item if __name__ &#x3D;&#x3D; &#39;__main__&#39;: pipeline &#x3D; DishonestListPipeline() pipeline.open_spider(&#39;xx&#39;) item &#x3D; &#123; &#39;card_num&#39;: &#39;12345&#39; &#125; pipeline.process_item(item, &#39;&#39;) 随机User-Agent反反爬 在settings.py中添加USER_AGENTS列表 123456789101112131415161718192021222324252627282930313233343536USER_AGENTS &#x3D; [ &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident&#x2F;4.0; WOW64; Trident&#x2F;4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit&#x2F;523.15 (KHTML, like Gecko, Safari&#x2F;419.3) Arora&#x2F;0.3 (Change: 287 c9dfb30)&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux; en-US) AppleWebKit&#x2F;527+ (KHTML, like Gecko, Safari&#x2F;419.3) Arora&#x2F;0.6&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko&#x2F;20070215 K-Ninja&#x2F;2.1.1&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko&#x2F;20080705 Firefox&#x2F;3.0 Kapiko&#x2F;3.0&quot;, &quot;Mozilla&#x2F;5.0 (X11; Linux i686; U;) Gecko&#x2F;20070322 Kazehakase&#x2F;0.4.5&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora&#x2F;1.9.0.8-1.fc10 Kazehakase&#x2F;0.5.6&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;535.11 (KHTML, like Gecko) Chrome&#x2F;17.0.963.56 Safari&#x2F;535.11&quot;, &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit&#x2F;535.20 (KHTML, like Gecko) Chrome&#x2F;19.0.1036.7 Safari&#x2F;535.20&quot;, &quot;Opera&#x2F;9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto&#x2F;2.9.168 Version&#x2F;11.52&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;536.11 (KHTML, like Gecko) Chrome&#x2F;20.0.1132.11 TaoBrowser&#x2F;2.0 Safari&#x2F;536.11&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.71 Safari&#x2F;537.1 LBBROWSER&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;535.11 (KHTML, like Gecko) Chrome&#x2F;17.0.963.84 Safari&#x2F;535.11 LBBROWSER&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser&#x2F;7.0.3698.400)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident&#x2F;4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 5.1) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.89 Safari&#x2F;537.1&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.89 Safari&#x2F;537.1&quot;, &quot;Mozilla&#x2F;5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit&#x2F;533.17.9 (KHTML, like Gecko) Version&#x2F;5.0.2 Mobile&#x2F;8C148 Safari&#x2F;6533.18.5&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko&#x2F;20110307 Firefox&#x2F;4.0b13pre&quot;, &quot;Mozilla&#x2F;5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko&#x2F;20100101 Firefox&#x2F;16.0&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.11 (KHTML, like Gecko) Chrome&#x2F;23.0.1271.64 Safari&#x2F;537.11&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko&#x2F;20100922 Ubuntu&#x2F;10.10 (maverick) Firefox&#x2F;3.6.10&quot;] 实现随机User-Agent下载器中间件 12345678910class RandomUserAgent(object): def process_request(self, request, spider): # 如果spider是公示系统爬虫, 就直接跳过 if isinstance(spider, GsxtSpider): return None # 3. 实现process_request方法, 设置随机的User-Agent request.headers[&#39;User-Agent&#39;] &#x3D; random.choice(USER_AGENTS) return None settings.py中开启中间件 1234# 开启下载器中间件DOWNLOADER_MIDDLEWARES &#x3D; &#123; &#39;dishonest.dishonest.middlewares.RandomUserAgent&#39;: 543,&#125; 代理IP反反爬实现代理IP下载器中间件，在settings.py中开启, 并配置重试次数，继爬虫基础篇之IP代理池实现的动态IP代理池启动用于本次失信人抓取。 123456789101112131415161718class ProxyMiddleware(object): def process_request(self, request, spider): # 实现process_request方法, 设置代理IP # 如果spider是公示系统爬虫, 就直接跳过 if isinstance(spider, GsxtSpider): return None # 1. 获取协议头 protocol &#x3D; request.url.split(&#39;:&#x2F;&#x2F;&#39;)[0] # 2. 构建代理IP请求的URL proxy_url &#x3D; &#39;http:&#x2F;&#x2F;localhost:16888&#x2F;random?protocol&#x3D;&#123;&#125;&#39;.format(protocol) # 3. 发送请求, 获取代理IP response &#x3D; requests.get(proxy_url) # 4. 把代理IP设置给request.meta[&#39;proxy&#39;] request.meta[&#39;proxy&#39;] &#x3D; response.content.decode() return None 配置代理池中间件及重试次数(毕竟免费ip不稳定) 1234567# 开启下载器中间件DOWNLOADER_MIDDLEWARES &#x3D; &#123; &#39;dishonest.dishonest.middlewares.ProxyMiddleware&#39;: 500, &#39;dishonest.dishonest.middlewares.RandomUserAgent&#39;: 543,&#125;# 配置重试次数, 当使用不稳定代理的时候,可能会导致请求失败RETRY_TIMES &#x3D; 6 ![百度爬虫](爬虫基础篇之多途径抓取失信人名单/GIF 2021-4-27 22-15-36.gif) 国家企业信用公示系统继JS逆向之国家企业信用信息公示系统Cookie传递完成了cookie的逆向分析，本文利用Cookie的实现逻辑，在scrapy中实现公示系统的爬虫入库。 scrapy genspider gsxt gsxt.gov.cn 创建爬虫 准备起始URL, 打印响应内容 1234567891011class GsxtSpider(scrapy.Spider): name &#x3D; &#39;gsxt&#39; allowed_domains &#x3D; [&#39;gsxt.gov.cn&#39;] # 准备起始 start_urls &#x3D; [&#39;http:&#x2F;&#x2F;www.gsxt.gov.cn&#x2F;corp-query-entprise-info-xxgg-100000.html&#39;] def parse(self, response): # 打印状态吗 print(response.status) # 内容 print(response.text) 修改原来的随机User-Agent, 和随机代理的下载器中间件类, 如果是公示系统爬虫直接跳过. 123456789101112131415161718# 随机User-Agent下载器中间件class RandomUserAgent(object): def process_request(self, request, spider): # 国家企业信用信息系统爬虫, 每次发送请求必须携带cookie信息 if isinstance(spider, GsxtSpider): return ...# 代理下载器中间件class ProxyMiddleware(object): def process_request(self, request, spider): # 发送请求获取代理IP # 如果是国家企业信用信息系统爬虫, 直接返回 if isinstance(spider, GsxtSpider): return 定制cookie为了实现代理IP, User-Agent, cookie信息生成, 绑定和重用，实现步骤如下： 步骤: 实现生成cookie的脚本 用于生成多套代理IP, User-Agent, Cookie信息, 放到Redis 实现公示系统中间件类, 实现process_request方法, 从Redis中随机取出Cookie来使用, 关闭页面重定向. 实现process_response方法, 如果响应码不是200 或 没有内容重试 在setting.py文件件中配置, 开启该下载器中间 实现生成cookie的脚本 创建gen_gsxt_cookies.py文件, 在其中创建GenGsxtCookie的类 实现一个方法, 用于把一套代理IP, User-Agent, Cookie绑定在一起的信息放到Redis的list中 随机获取一个User-Agent 随机获取一个代理IP 获取request的session对象 把User-Agent, 通过请求头, 设置给session对象 把代理IP, 通过proxies, 设置给session对象 使用session对象, 发送请求, 获取需要的cookie信息 把代理IP, User-Agent, Cookie放到字典中, 序列化后, 存储到Redis的list中 实现一个run方法, 用于开启多个异步来执行这个方法. 注: 为了和下载器中间件交互方便, 需要在settings.py中配置一些常量. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374def push_cookie_to_redis(self): while True: try: &quot;&quot;&quot; 2. 实现一个方法, 用于把一套代理IP, User-Agent, Cookie绑定在一起的信息放到Redis的list中 &quot;&quot;&quot; # 1. 随机获取一个User-Agent user_agent &#x3D; random.choice(USER_AGENTS) # 2. 随机获取一个代理IP # response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;localhost:16888&#x2F;random?protocol&#x3D;http&#39;) # proxy &#x3D; response.content.decode() # 3. 获取requests的session对象 session &#x3D; requests.session() # 4. 把User-Agent, 通过请求头, 设置给session对象 session.headers &#x3D; &#123; &#39;User-Agent&#39;: user_agent &#125; # 5. 把代理IP, 通过proxies, 设置给session对象 # session.proxies &#x3D; &#123; # &#39;http&#39;: proxy # &#125; # 6. 使用session对象, 发送请求, 获取需要的cookie信息 index_url &#x3D; &#39;http:&#x2F;&#x2F;www.gsxt.gov.cn&#x2F;corp-query-entprise-info-xxgg-100000.html&#39; # 获取request的session对象, 可以自动合并cookie信息 # ######################################################使用session发送index_url请求########################### response &#x3D; session.get(index_url) print(response.status_code) # 第一次请求521 服务器借助这个请求设置一个Set-Cookie: __jsluid_h&#x3D;8af7a39f7cdb1c46f8f624c972968c8f; max-age&#x3D;31536000; path&#x3D;&#x2F;; HttpOnly到本地，并返回一段js ########################################################拿到第一个cookie######################## # 1. 提取script标签中的js js1 &#x3D; re.findall(&#39;&lt;script&gt;(.+?)&lt;&#x2F;script&gt;&#39;, response.content.decode())[0].replace(&#39;document.cookie&#x3D;&#39;, &#39;&#39;).replace( &#39;location.href&#x3D;location.pathname+location.search&#39;, &#39;&#39;) context &#x3D; js2py.EvalJs() ###################################################根据第一个请求返回的js生成第二个cookie############################### context.execute(&#39;cookies2 &#x3D;&#39; + js1) cookies &#x3D; context.cookies2.split(&#39;;&#39;)[0].split(&#39;&#x3D;&#39;) session.cookies.set(cookies[0], cookies[1]) # 到此拿到第两个cookie ######################################################拿到第二个cookie############################ # 第二次请求携带Cookie: __jsluid_h&#x3D;6ed2648e0a734bc66e3011d648f6f1ab; __jsl_clearance&#x3D;1619152879.013|-1|aS3lFknWlGtD%2FADiygf7vxl4yqk%3D返回一段js # 添加jsdom实现浏览器上下文 js2 &#x3D; &#39;&#39;&#39;const jsdom &#x3D; require(&quot;jsdom&quot;);const &#123;JSDOM&#125; &#x3D; jsdom;const dom &#x3D; new JSDOM();window &#x3D; dom.window;document &#x3D; window.document;location &#x3D; new Array();&#39;&#39;&#39; + \\ re.findall(&#39;&lt;script&gt;(.+?)&lt;&#x2F;script&gt;&#39;, session.get(index_url).content.decode(&#39;utf-8&#39;))[0] # 正则获取document[&#39;cookie&#39;]，由于每次个数不一样我们取最后一个 cookies2_1 &#x3D; re.findall(r&quot;document\\[.*?\\]&#x3D;(.*?)location&quot;, js2, re.S)[-1] # 将document[&#39;cookie&#39;]内容返回给go函数 js3 &#x3D; re.sub(&quot;&#125;;go&quot;, &quot;return &quot; + cookies2_1 + &quot;&#125;;go&quot;, js2, 1) # 获取调用go函数时里面的参数 request &#x3D; re.findall(r&quot;go\\(&#123;(.*?)&#125;\\)&quot;, js3, re.S)[-1] # 通过python修改js生成一个request方法 final_js &#x3D; js3 + &quot;\\nfunction request() &#123;return go(&#123;&quot; + request + &quot;&#125;)&#125;&quot; # js调用request方法返回cookie并将新的__jsl_clearance塞给session中 cookies3 &#x3D; execjs.compile(final_js).call(&#39;request&#39;).split(&#39;;&#39;)[0].split(&#39;&#x3D;&#39;) session.cookies.set(cookies3[0], cookies3[1]) # 第三次请求 修改了__jsl_clearance后服务端向客户端设置新cookie的SECTOKEN session.get(index_url) cookies &#x3D; requests.utils.dict_from_cookiejar(session.cookies) # print(cookies) # 7. 把代理IP, User-Agent, Cookie放到字典中, 序列化后, 存储到Redis的list中 cookies_dict &#x3D; &#123; COOKIES_KEY:cookies, COOKIES_USER_AGENT_KEY:user_agent, # COOKIES_PROXY_KEY:proxy &#125; # 序列化后, 存储到Redis的list中 self.redis.lpush(REDIS_COOKIES_KEY, pickle.dumps(cookies_dict)) print(cookies_dict) break except Exception as ex: print(&quot;error&quot;,ex) settings.py中配置信息 123456# 定义cookie的键COOKIE_KEY &#x3D; &#39;COOKIE&#39; # 字典中Cookie键COOKIE_PROXY_KEY &#x3D; &#39;COOKIE_PROXY&#39; # 字典中代理IP的键COOKIE_USER_AGENT_KEY &#x3D; &#39;COOKIE_USER_AGENT&#39; # 字典中User-Agent的键REDIS_COOKIES_KEY &#x3D; &#39;REDIS_COOKIES&#39; # Redis的cookie列表的键REDIS_URL &#x3D; &#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;0&#39; # Redis数据库的链接 定制中间件 步骤 实现process_request方法, 从Redis中随机取出Cookie来使用, 关闭页面重定向. 实现process_response方法, 如果响应码不是200 或 没有内容重试 1234567891011121314151617181920212223242526272829303132333435class GsxtCookieMiddleware(object): def __init__(self): &quot;&quot;&quot;建立Redis数据库连接&quot;&quot;&quot; self.redis &#x3D; StrictRedis.from_url(REDIS_URL) def process_request(self, request, spider): &quot;&quot;&quot;从Redis中随机取出Cookie来使用, 关闭页面重定向.&quot;&quot;&quot; count &#x3D; self.redis.llen(REDIS_COOKIES_KEY) random_index &#x3D; random.randint(0, count-1) cookie_data &#x3D; self.redis.lindex(REDIS_COOKIES_KEY, random_index) # 反序列化, 把二进制转换为字典 cookie_dict &#x3D; pickle.loads(cookie_data) # 把cookie信息设置request request.headers[&#39;User-Agent&#39;] &#x3D; cookie_dict[COOKIES_USER_AGENT_KEY] # 设置请求代理IP request.meta[&#39;proxy&#39;] &#x3D; cookie_dict[COOKIES_PROXY_KEY] # 设置cookie信息 request.cookies &#x3D; cookie_dict[COOKIES_KEY] # 设置不要重定向 request.meta[&#39;dont_redirect&#39;] &#x3D; True def process_response(self, request, response, spider): &quot;&quot;&quot;如果响应码不是200 或 没有内容重试&quot;&quot;&quot; # print(response.status) if response.status !&#x3D; 200 or response.body &#x3D;&#x3D; b&#39;&#39;: # 备份请求 req &#x3D; request.copy() # 设置请求不过滤 req.dont_filter &#x3D; True # 把请求交给引擎 return req return response 在setting.py文件件中配置中间件 12345DOWNLOADER_MIDDLEWARES &#x3D; &#123; &#39;dishonest.dishonest.middlewares.GsxtCookieMiddleware&#39;: 10, &#39;dishonest.dishonest.middlewares.ProxyMiddleware&#39;: 500, &#39;dishonest.dishonest.middlewares.RandomUserAgent&#39;: 543,&#125; 完善爬虫 解析页面中的城市名称和id, 构建公告信息的URL 解析失信企业公告信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class GsxtSpider(scrapy.Spider): name &#x3D; &#39;gsxt&#39; allowed_domains &#x3D; [&#39;gsxt.gov.cn&#39;] # 准备起始 start_urls &#x3D; [&#39;http:&#x2F;&#x2F;www.gsxt.gov.cn&#x2F;corp-query-entprise-info-xxgg-100000.html&#39;] custom_settings &#x3D; &#123; &#39;DOWNLOAD_DELAY&#39; : 5 &#125; def parse(self, response): # 获取城市标签的div列表 divs &#x3D; response.xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;qysx&quot;]&#x2F;div[3]&#x2F;div&#39;) # 遍历divs, 获取城市id和名称 for div in divs: area_id &#x3D; div.xpath(&#39;.&#x2F;@id&#39;).extract_first() area_name &#x3D; div.xpath(&#39;.&#x2F;label&#x2F;text()&#39;).extract_first() # 准备请求的URL url &#x3D; &#39;http:&#x2F;&#x2F;www.gsxt.gov.cn&#x2F;affiche-query-area-info-paperall.html?&#39; \\ &#39;noticeType&#x3D;11&amp;areaid&#x3D;100000&amp;noticeTitle&#x3D;&amp;regOrg&#x3D;&#123;&#125;&#39;.format(area_id) # 一个城市最多能够获取50条数据. for i in range(0, 50, 10): data &#x3D; &#123; &#39;start&#39;: str(i) &#125; # 构建请求, 交给引擎 yield scrapy.FormRequest(url, formdata&#x3D;data, callback&#x3D;self.parse_data, meta&#x3D;&#123;&#39;area_name&#39;: area_name&#125;) def parse_data(self, response): # print(response.text) &quot;&quot;&quot;解析页面中的城市&quot;&quot;&quot; area_name &#x3D; response.meta[&#39;area_name&#39;] result &#x3D; json.loads(response.text) datas &#x3D; result[&#39;data&#39;] for data in datas: item &#x3D; DishonestItem() # 区域名称 item[&#39;area_name&#39;] &#x3D; area_name # 公告标题 notice_title &#x3D; data[&#39;noticeTitle&#39;] name &#x3D; re.findall(&#39;关?于?(.+?)的?列入.*&#39;, notice_title)[0] item[&#39;name&#39;] &#x3D; name # 由于抓取的是失信企业公告, 所以抓到都是企业; 年龄设置为0 item[&#39;age&#39;] &#x3D; 0 notice_content &#x3D; data[&#39;noticeContent&#39;] card_id &#x3D; re.findall(&#39;经查.+[（\\(]统一社会信用码&#x2F;注册号：(\\w+)[）\\)]&#39;, notice_content) item[&#39;card_num&#39;] &#x3D; card_id[0] if len(card_id) !&#x3D; 0 else &#39;&#39; item[&#39;content&#39;] &#x3D; notice_content # 公布单位 item[&#39;publish_unit&#39;] &#x3D; data[&#39;judAuth_CN&#39;] # 获取到的时间, 是1970年1月1日 0时0分0秒 到发布时间的毫秒数 publish_ms &#x3D; data[&#39;noticeDate&#39;] # 转换为日期类型 publish_date &#x3D; datetime.fromtimestamp(publish_ms &#x2F; 1000) item[&#39;publish_date&#39;] &#x3D; publish_date.strftime(&#39;%Y年%m月%d日&#39;) yield item","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"http://onejane.github.io/tags/scrapy/"}]},{"title":"JS逆向之国家企业信用信息公示系统Cookie传递","slug":"JS逆向之国家企业信用信息公示系统Cookie","date":"2021-04-26T13:21:52.000Z","updated":"2021-05-15T03:27:15.665Z","comments":true,"path":"2021/04/26/JS逆向之国家企业信用信息公示系统Cookie/","link":"","permalink":"http://onejane.github.io/2021/04/26/JS%E9%80%86%E5%90%91%E4%B9%8B%E5%9B%BD%E5%AE%B6%E4%BC%81%E4%B8%9A%E4%BF%A1%E7%94%A8%E4%BF%A1%E6%81%AF%E5%85%AC%E7%A4%BA%E7%B3%BB%E7%BB%9FCookie/","excerpt":"","text":"目标http://www.gsxt.gov.cn/corp-query-entprise-info-xxgg-100000.html 分析POST http://www.gsxt.gov.cn/affiche-query-area-info-paperall.html?noticeType=21&amp;areaid=100000&amp;noticeTitle=&amp;regOrg=110000 参数: noticeType=21 通知类型, 失信企业固定21 areaid=100000 无论在哪个区域, 固定是100000 noticeTitle= 通知标题, 可以为空 regOrg= 通知的区域id, 可以从省份标签上获取 请求体数据: draw: 1 点击分页按钮的次数, 可以省略 start: 0 起始索引号 length: 10 长度, 固定是10, 设置多了也无效 直接访问该接口时，状态521，返回如下js混淆加密代码。 尝试给请求头中加上cookie__jsluid_h=f6db0fc02adff8425bebcd8ed1b5fffc; SECTOKEN=7445298838033400749; __jsl_clearance=1619443187.64|0|nGqWRKwajO%2BeHI6CP7Mt50EbdcU%3D;，正常返回如下结果。 __jsluid_h打开fiddler，刷新页面抓包http://www.gsxt.gov.cn/corp-query-entprise-info-xxgg-100000.html,一共访问了三次该页面，前两次521第三次正场返回请求页面。 第一次请求时服务端向服务器塞入第一个__jsluid_h关键cookie 1Set-Cookie: __jsluid_h&#x3D;01737b0139a221e260d1061c68b4232f; max-age&#x3D;31536000; path&#x3D;&#x2F;; HttpOnly 并向浏览器返回一段混淆过的js，内容如下，主要功能应该是设置cookie。 1&lt;script&gt;document.cookie&#x3D;(&#39;_&#39;)+(&#39;_&#39;)+(&#39;j&#39;)+(&#39;s&#39;)+(&#39;l&#39;)+(&#39;_&#39;)+(&#39;c&#39;)+(&#39;l&#39;)+(&#39;e&#39;)+(&#39;a&#39;)+(&#39;r&#39;)+(&#39;a&#39;)+(&#39;n&#39;)+(&#39;c&#39;)+(&#39;e&#39;)+(&#39;&#x3D;&#39;)+((+true)+&#39;&#39;)+((1+[2])&#x2F;[2]+&#39;&#39;)+(-~false+&#39;&#39;)+(3+6+&#39;&#39;)+(2+2+&#39;&#39;)+(-~[2]+&#39;&#39;)+(~~false+&#39;&#39;)+((2)*[4]+&#39;&#39;)+((1+[0])&#x2F;[2]+&#39;&#39;)+(9-1*2+&#39;&#39;)+(&#39;.&#39;)+((2)*[2]+&#39;&#39;)+(6+&#39;&#39;)+(1+6+&#39;&#39;)+(&#39;|&#39;)+(&#39;-&#39;)+(-~0+&#39;&#39;)+(&#39;|&#39;)+(&#39;w&#39;)+(&#39;Y&#39;)+(&#39;p&#39;)+(&#39;A&#39;)+(&#39;F&#39;)+(&#39;R&#39;)+(&#39;%&#39;)+(1+1+&#39;&#39;)+(&#39;B&#39;)+(-~(4)+&#39;&#39;)+(&#39;X&#39;)+(&#39;x&#39;)+(&#39;m&#39;)+(&#39;W&#39;)+(&#39;Y&#39;)+((1&lt;&lt;2)+&#39;&#39;)+(&#39;j&#39;)+(&#39;P&#39;)+(&#39;a&#39;)+(&#39;Q&#39;)+([3]*(3)+&#39;&#39;)+(&#39;t&#39;)+(&#39;Q&#39;)+(1+7+&#39;&#39;)+(&#39;T&#39;)+(&#39;P&#39;)+(&#39;Z&#39;)+(&#39;i&#39;)+(&#39;E&#39;)+(&#39;%&#39;)+(3+&#39;&#39;)+(&#39;D&#39;)+(&#39;;&#39;)+(&#39;m&#39;)+(&#39;a&#39;)+(&#39;x&#39;)+(&#39;-&#39;)+(&#39;a&#39;)+(&#39;g&#39;)+(&#39;e&#39;)+(&#39;&#x3D;&#39;)+(3+&#39;&#39;)+(3+3+&#39;&#39;)+(~~&#39;&#39;+&#39;&#39;)+(~~false+&#39;&#39;)+(&#39;;&#39;)+(&#39;p&#39;)+(&#39;a&#39;)+(&#39;t&#39;)+(&#39;h&#39;)+(&#39;&#x3D;&#39;)+(&#39;&#x2F;&#39;);location.href&#x3D;location.pathname+location.search&lt;&#x2F;script&gt; 我们将这段js放入浏览器中执行，如我们所料，正是返回第二个__jsl_clearance关键性cookie。 __jsl_clearance第二次请求http://www.gsxt.gov.cn/corp-query-entprise-info-xxgg-100000.html时，浏览器发送了__jsl_clearance和__jsluid_h两个关键cookie，服务端接收后并返回了一段混淆后的js，这次没有向浏览器塞入cookie。 1Cookie: __jsluid_h&#x3D;01737b0139a221e260d1061c68b4232f; __jsl_clearance&#x3D;1619430857.467|-1|wYpAFR%2B5XxmWY4jPaQ9tQ8TPZiE%3D SECTOKEN第三次请求http://www.gsxt.gov.cn/corp-query-entprise-info-xxgg-100000.html时，浏览器携带了两个关键性Cookie，不过这次__jsl_clearance和之前的值发生变化，怀疑是第二次请求返回的js做了手脚。 1Cookie: __jsluid_h&#x3D;01737b0139a221e260d1061c68b4232f; __jsl_clearance&#x3D;1619430857.529|0|WGn9gKxiPtYUHAGBZ1a%2B%2F3o9sJE%3D 这次请求不仅正常的返回了页面内容，而且还往请求头中塞入了第三个SECTOKEN关键性Cookie。 1Set-Cookie: SECTOKEN&#x3D;7448433543385710812; Expires&#x3D;Sat, 14-May-2089 13:03:34 GMT; Path&#x3D;&#x2F;; HttpOnly 请求数据在上面的三个cookie加持下，终于成功的返回了我们想要的数据，接下来就是分析这三个cookie在代码中如何拿到。 爬虫实现通过requests的session对象，自动合并cookie信息，并设置请求头。 12345headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;78.0.3904.70 Safari&#x2F;537.36&#39;,&#125;session &#x3D; requests.session()session.headers &#x3D; headers 第一次请求通过第一次请求，服务端往客户端返回__jsluid_h作为第一个关键cookie，根据返回的js通过正则表达式拿到script标签中的js逻辑，并去除后面无用jslocation.href... 12345678response &#x3D; session.get(index_url)js1 &#x3D; re.findall(&#39;&lt;script&gt;(.+?)&lt;&#x2F;script&gt;&#39;, response.content.decode())[0].replace(&#39;document.cookie&#x3D;&#39;, &#39;&#39;).replace( &#39;location.href&#x3D;location.pathname+location.search&#39;, &#39;&#39;)context &#x3D; js2py.EvalJs() context.execute(&#39;cookies2 &#x3D;&#39; + js1)cookies &#x3D; context.cookies2.split(&#39;;&#39;)[0].split(&#39;&#x3D;&#39;)session.cookies.set(cookies[0], cookies[1]) # 到此拿到第两个cookieprint(session.cookies) 第二次请求第二次请求携带了前面两个关键性cookie，并返回了一段js。这里我们的cookie都存在了session中，所以不用额外处理。通过正则取出第二次返回的js中script标签中的内容。 就算格式化后这段代码都难以阅读，我们通过ob混淆专解测试版V0.1进行反混淆，重新审视这段js。 逻辑就是通过调用go函数往document中塞入cookie，我们在function go(_0x2323c8)最后返回document[&#39;cookie&#39;],把setTimeout的时间设置久一点。 通过上面分析我们可以通过第二次请求返回的js进行修改后，python调用生成cookie传递后被修改的__jsl_clearance关键cookie。不过很多对象在python调用时不可用，如window，document，location等等，我们可以通过jsdom库npm install jsdom实现浏览器的上下文。 123456const jsdom &#x3D; require(&quot;jsdom&quot;);const &#123;JSDOM&#125; &#x3D; jsdom;const dom &#x3D; new JSDOM();window &#x3D; dom.window;document &#x3D; window.document;location &#x3D; new Array(); 就这段js存入文件后，python读取文件，使用execjs实现调用，返回第二个__jsl_clearance关键性cookie，为获取SECTOKEN埋下伏笔。 1234with open(r&#39;第二次请求.js&#39;, encoding&#x3D;&#39;utf-8&#39;, mode&#x3D;&#39;r&#39;) as f: JsData &#x3D; f.read()cookie &#x3D; execjs.compile(JsData).call(&#39;request&#39;)print(cookie) 在python中为了调用go函数，还需要在js中新创建一个request函数，让go函数的数据返回给python作为cookie存入session中。 123456789101112131415# 添加jsdom实现浏览器上下文js2 = '''const jsdom = require(\"jsdom\");const &#123;JSDOM&#125; = jsdom;const dom = new JSDOM();window = dom.window;document = window.document;location = new Array();''' + \\ re.findall('&lt;script&gt;(.+?)&lt;/script&gt;', session.get(index_url).content.decode('utf-8'))[0]# 正则获取document['cookie']，由于每次个数不一样我们取最后一个cookies2_1 = re.findall(r\"document\\[.*?\\]=(.*?)location\", js2, re.S)[-1]# 将document['cookie']内容返回给go函数js3 = re.sub(\"&#125;;go\", \"return \" + cookies2_1 + \"&#125;;go\", js2, 1)# 获取调用go函数时里面的参数request = re.findall(r\"go\\(&#123;(.*?)&#125;\\)\", js3, re.S)[-1]# 通过python修改js生成一个request方法final_js = js3+\"\\nfunction request() &#123;return go(&#123;\"+request+\"&#125;)&#125;\"# js调用request方法返回cookie并将新的__jsl_clearance塞给session中cookies3 = execjs.compile(final_js).call('request').split(';')[0].split('=')session.cookies.set(cookies3[0], cookies3[1])print(cookies3) 第三次请求利用新的__jsl_clearance和__jsluid_h发送第三次请求，服务端会向客户端返回新Cookie SECTOKEN，接下来我们打印出所有的cookie。 123session.get(index_url)cookies &#x3D; requests.utils.dict_from_cookiejar(session.cookies)print(cookies) 12345678&#123; &#39;__jsl_clearance&#39;: &#39;1619446283.778|0|DFaPnxb5OqsBcRBkaxTSCax2qLA%3D&#39;, &#39;HttpOnly&#39;: None, &#39;JSESSIONID&#39;: &#39;e80d7db0e1fe65e65ab6a29e8cc4&#39;, &#39;SECTOKEN&#39;: &#39;7448640433386424422&#39;, &#39;__jsluid_h&#39;: &#39;2c8e0b64535955d16c6db3072464d199&#39;, &#39;tlb_cookie&#39;: &#39;S172.16.12.67&#39;&#125; 数据抓取12345678910111213141516171819url &#x3D; &#39;http:&#x2F;&#x2F;www.gsxt.gov.cn&#x2F;affiche-query-area-info-paperall.html?noticeType&#x3D;21&amp;areaid&#x3D;100000&amp;noticeTitle&#x3D;&amp;regOrg&#x3D;110000&#39;data &#x3D; &#123; # &#39;draw&#39;: &#39;0&#39;, &#39;start&#39;: &#39;0&#39;, &#39;length&#39;: &#39;10&#39;&#125;# 准备请求头headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;78.0.3904.70 Safari&#x2F;537.36&#39;, # &#39;User-Agent&#39;: &#39;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&#39;, # &#39;Referer&#39;: &#39;http:&#x2F;&#x2F;www.gsxt.gov.cn&#x2F;corp-query-entprise-info-xxgg-100000.html&#39;, # &#39;Cookie&#39;: &#39;__jsluid&#x3D;fb0718dce34ccf53c4b94d15e9ab13d5; SECTOKEN&#x3D;7178252594204902863; __jsl_clearance&#x3D;1546475343.133|0|QZ7AOWMecndqD4CZG4hqoBAHtVw%3D;&#39;&#125;response &#x3D; requests.post(url, cookies&#x3D;cookies, data&#x3D;data, headers&#x3D;headers)print(response.status_code)print(response.content.decode()) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之淘宝h5视频sign破解","slug":"JS逆向之淘宝h5视频sign破解","date":"2021-04-25T09:54:37.000Z","updated":"2021-05-01T07:40:47.284Z","comments":true,"path":"2021/04/25/JS逆向之淘宝h5视频sign破解/","link":"","permalink":"http://onejane.github.io/2021/04/25/JS%E9%80%86%E5%90%91%E4%B9%8B%E6%B7%98%E5%AE%9Dh5%E8%A7%86%E9%A2%91sign%E7%A0%B4%E8%A7%A3/","excerpt":"","text":"需求最近需要抓取一些淘宝商品的首图视频，比如https://item.taobao.com/item.htm?spm=a230r.1.14.31.7ebfcec2qmczgd&amp;id=641116554739&amp;ns=1&amp;abbucket=2#detail，该页面首图视频页面元素是blob协议加密，该协议返回大多是m3u8格式的视频，并被切分为多个ts格式的小段视频集合。 分析通过chrome抓包果然找到了m3u8视频请求，第一个请求返回ts文件列表，紧接着发起视频请求返回ts视频数据。 12345# EXTM3U：.m3u8文件的格式定义# EXT-X-KEY： 密钥的信息# METHOD： 加密的方法，这里采用的是AES-128的加密方式# URI： 密钥的地址，需要获取访问得到密钥的信息# IV： 偏移量，AES加密的方法，通过这个密钥就可以解密，获取正确的视频信息 数据来源找到了，那么紧跟着就是找到这些链接的组成字段，如首个链接https://tbm-auth.alicdn.com/e99361edd833010b/1Ptetzs7wLumqr8DVXj/IZAAx7ivPbWWLLDYpm0_275076925941___hd.m3u8?auth_key=1619353994-0-0-7eac2e2d00d26717d7aad9746575f99f中大部分url参数都是加密串，通过搜索其中的1Ptetzs7wLumqr8DVXj，找到了多条符合条件的请求。 第一条请求中返回的数据中有两个参数的video_url，分别是hlsResources和mp4Resources，返回了m3u8和mp4格式，好家伙，这样省去了合并m3u8个流程，直接拿mp4格式的视频即可。 逆向拿到返回video_url的请求的参数，通过逐条过滤参数发现，最终生效的参数只有四个，分别是appKey,t,sign,data，每次请求都有失效时间。 其中appKey固定为12574478，t为精确到毫秒的时间戳，sign是今天的逆向主角参数，data动态内容为&#39;{&quot;videoId&quot;: &quot;%s&quot;,&quot;from&quot;:&quot;detail&quot;}&#39; % &quot;301079547561&quot;,其中301079547561作为videoId在页面请求时直接返回在页面js中。 sign无痕浏览器清空页面缓存，搜索sign，从众多页面中找到可能出现的位置，sign就是j，而 j = h(d.token + &quot;&amp;&quot; + i + &quot;&amp;&quot; + g + &quot;&amp;&quot; + c.data),其中d.token是加密字符串，i为时间戳，g为固定值12574478，c.data为{“videoId”:”275076925941”,”from”:”detail”} 在控制台中调用h函数返回32位字符串，猜测是md5加密，就不扣h函数的js了。 接下来就是分析这些参数中唯一变的参数d.token的来源。 d.token第一次断点时d.token为undefined。 放开断点后搜索d.token的值0027f0b395e6356158d06d22da238855,第一次出现在了返回video_url的请求返回时set-cookie中，作为Response Cookie返回了两个cookie，一个是_m_h5_tk，一个是_m_h5_tk_enc，_分割的前面一段就是d.token的值。 第二次进入断点时d.token=0027f0b395e6356158d06d22da238855,放开断点后搜索0027f0b395e6356158d06d22da238855出现在了同一个请求的Request Cookie中。 逻辑梳理大概思路清晰了，对同一个请求多次访问，第一次返回cookie作为第二次请求的cookie，cookie中的_m_h5_tk_enc通过_分割的前半段字符串作为d.token，根据d.token + &quot;&amp;&quot; + i + &quot;&amp;&quot; + g + &quot;&amp;&quot; + c.data进行md5得到sign，请求时加上两个cookie，完成video_url的请求，从而实现淘宝商品首图的视频抓取。 爬虫12345678910111213141516171819202122232425262728APPKEY &#x3D; &#39;12574478&#39;DATA &#x3D; &#39;&#123;&quot;videoId&quot;: &quot;%s&quot;,&quot;from&quot;:&quot;detail&quot;&#125;&#39; % &quot;301079547561&quot;URL &#x3D; &#39;https:&#x2F;&#x2F;h5api.m.taobao.com&#x2F;h5&#x2F;mtop.taobao.cloudvideo.video.queryforh5&#x2F;1.0&#x2F;&#39;params &#x3D; &#123;&#39;jsv&#39;: &#39;2.4.11&#39;, &#39;appKey&#39;: APPKEY, &#39;t&#39;: int(time.time() * 1000), &#39;sign&#39;: &#39;FAKE_SIGN_WITH_ANYTHING&#39;, &#39;api&#39;: &#39;mtop.wdetail.getItemDescx&#39;, &#39;callback&#39;: &#39;mtopjsonp1&#39;,&#39;v&#39;: &#39;4.9&#39;, &#39;type&#39;: &#39;jsonp&#39;, &#39;dataType&#39;: &#39;jsonp&#39;, &#39;data&#39;: DATA&#125;headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (iPhone; CPU iPhone OS 9_3_4 like Mac OS X) AppleWebKit&#x2F;601.1.46 &#39; + \\ &#39;(KHTML, like Gecko) Version&#x2F;9.0 Mobile&#x2F;13G35 Safari&#x2F;601.1&#39;,&#125;images &#x3D; []# get token in first requestr1 &#x3D; requests.get(URL, params&#x3D;params, headers&#x3D;headers)token_with_time &#x3D; r1.cookies.get(&#39;_m_h5_tk&#39;)token &#x3D; token_with_time.split(&#39;_&#39;)[0]enc_token &#x3D; r1.cookies.get(&#39;_m_h5_tk_enc&#39;)# get results in second requestt2 &#x3D; str(int(time.time() * 1000))c &#x3D; &#39;&amp;&#39;.join([token, t2, APPKEY, DATA])m &#x3D; hashlib.md5()m.update(c.encode(&#39;utf-8&#39;))params.update(&#123;&#39;t&#39;: t2, &#39;sign&#39;: m.hexdigest()&#125;)cookies &#x3D; &#123;&#39;_m_h5_tk&#39;: token_with_time, &#39;_m_h5_tk_enc&#39;: enc_token&#125;r2 &#x3D; requests.get(URL, params&#x3D;params, headers&#x3D;headers, cookies&#x3D;cookies)results&#x3D;json.loads(re.match(r&#39; mtopjsonp1\\((.*?)\\)&#39;, r2.text).group(1))video_url &#x3D; jsonpath(results, &#39;$..video_url&#39;)[1]print(video_url) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"Xposed搭建开发","slug":"Xposed搭建开发","date":"2021-04-23T13:06:27.000Z","updated":"2021-05-01T07:34:07.014Z","comments":true,"path":"2021/04/23/Xposed搭建开发/","link":"","permalink":"http://onejane.github.io/2021/04/23/Xposed%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91/","excerpt":"","text":"pixel刷安卓7proxychains wget https://dl.google.com/dl/android/aosp/sailfish-n2g47o-factory-f2bc8024.zip proxychains wget https://forum.xda-developers.com/attachments/xposedinstaller_3-1-5-apk.4393082/ proxychains wget https://supersuroot.org/downloads/supersu-pro.apk proxychains wget https://dl.twrp.me/sailfish/twrp-3.3.0-0-sailfish.img 123456cd sailfish-opm4.171019.021.p1 &amp;&amp; adb reboot bootloader &amp;&amp; .&#x2F;flash-all.shadb push SR5-SuperSU-v2.82-SR5-20171001224502.zip &#x2F;data&#x2F;local&#x2F;tmpadb reboot bootloader &amp;&amp; fastboot boot twrp-3.3.0-0-sailfish.img 刷入twrp后安装supersuadb install XposedInstaller_3.1.5.apk 常见模块https:&#x2F;&#x2F;github.com&#x2F;WrBug&#x2F;GravityBox.gitadb push timeadjust.sh &#x2F;data&#x2F;local&#x2F;tmp &amp;&amp; sh timeadjust.sh 时间修改正确adb install com.ttxapps.wifiadb_2.1.3-810031745_minAPI15.apk xposedxposed api demo过滤子进程：loadPackageParam.processName,可以通过hook参数、调用栈、返回值 ，打印和修改，Xposed的开发，本质上就是Java的开发。 创建安卓项目xposed1 build.gradle引入xposed api依赖 123456789101112131415161718192021222324252627apply plugin: &#39;com.android.application&#39;android &#123; compileSdkVersion 30 buildToolsVersion &quot;30.0.2&quot; defaultConfig &#123; applicationId &quot;com.roysue.xposed1&quot; minSdkVersion 16 targetSdkVersion 30 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; &#125;&#125;dependencies &#123; compileOnly &#39;de.robv.android.xposed:api:82&#39; compileOnly &#39;de.robv.android.xposed:api:82:sources&#39; implementation fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;]) implementation &#39;androidx.appcompat:appcompat:1.2.0&#39; implementation &#39;androidx.constraintlayout:constraintlayout:2.0.2&#39; testImplementation &#39;junit:junit:4.12&#39; androidTestImplementation &#39;androidx.test.ext:junit:1.1.2&#39; androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.3.0&#39;&#125; AndroidManifest.xml添加xposed项目基本配置 12345678910111213141516171819202122232425262728&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; package&#x3D;&quot;com.roysue.xposed1&quot;&gt; &lt;application android:allowBackup&#x3D;&quot;true&quot; android:icon&#x3D;&quot;@mipmap&#x2F;ic_launcher&quot; android:label&#x3D;&quot;@string&#x2F;app_name&quot; android:roundIcon&#x3D;&quot;@mipmap&#x2F;ic_launcher_round&quot; android:supportsRtl&#x3D;&quot;true&quot; android:theme&#x3D;&quot;@style&#x2F;AppTheme&quot;&gt; &lt;meta-data android:name&#x3D;&quot;xposedmodule&quot; android:value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;meta-data android:name&#x3D;&quot;xposeddescription&quot; android:value&#x3D;&quot;这是一个Xposed例程&quot; &#x2F;&gt; &lt;meta-data android:name&#x3D;&quot;xposedminversion&quot; android:value&#x3D;&quot;53&quot; &#x2F;&gt; &lt;activity android:name&#x3D;&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name&#x3D;&quot;android.intent.action.MAIN&quot; &#x2F;&gt; &lt;category android:name&#x3D;&quot;android.intent.category.LAUNCHER&quot; &#x2F;&gt; &lt;&#x2F;intent-filter&gt; &lt;&#x2F;activity&gt; &lt;&#x2F;application&gt;&lt;&#x2F;manifest&gt; activity_main.xml添加按钮组件 12345678910111213141516171819202122232425&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot; xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; tools:context&#x3D;&quot;.MainActivity&quot;&gt; &lt;TextView android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot; app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot; app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot; app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; &#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;button&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;Button&quot; tools:layout_editor_absoluteX&#x3D;&quot;158dp&quot; tools:layout_editor_absoluteY&#x3D;&quot;238dp&quot; &#x2F;&gt;&lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt; MainActivity调用Button组件，实现被hook方法toastMessage 1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity &#123; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button &#x3D; (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; public void onClick(View v) &#123; Toast.makeText(MainActivity.this, toastMessage(&quot;我未被劫持&quot;), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; public String toastMessage(String message) &#123; return message; &#125;&#125; 继承IXposedHookLoadPackage实现hook 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class HookTest implements IXposedHookLoadPackage &#123; &#x2F;&#x2F; 堆栈打印 public void PrintStack()&#123; XposedBridge.log(&quot;Dump Stack: &quot;+ &quot;---------------start----------------&quot;); Throwable ex &#x3D; new Throwable(); StackTraceElement[] stackElements &#x3D; ex.getStackTrace(); if (stackElements !&#x3D; null) &#123; for (int i &#x3D; 0; i &lt; stackElements.length; i++) &#123; XposedBridge.log(&quot;Dump Stack&quot;+i+&quot;: &quot;+ stackElements[i].getClassName() +&quot;----&quot;+stackElements[i].getFileName() +&quot;----&quot; + stackElements[i].getLineNumber() +&quot;----&quot; +stackElements[i].getMethodName()); &#125; &#125; XposedBridge.log(&quot;Dump Stack: &quot;+ &quot;---------------over----------------&quot;); RuntimeException e &#x3D; new RuntimeException(&quot;&lt;Start dump Stack !&gt;&quot;); e.fillInStackTrace(); Log.i(&quot;&lt;Dump Stack&gt;:&quot;, &quot;++++++++++++&quot;, e); &#125; public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; &#x2F;&#x2F;XposedBridge.log(loadPackageParam.processName); if (loadPackageParam.packageName.equals(&quot;com.roysue.xposed1&quot;)) &#123; XposedBridge.log(&quot; has Hooked!&quot;); XposedBridge.log(&quot;inner&quot;+loadPackageParam.processName); Class clazz &#x3D; loadPackageParam.classLoader.loadClass(&quot;com.roysue.xposed1.MainActivity&quot;); XposedHelpers.findAndHookMethod(clazz, &quot;toastMessage&quot;, String.class,new XC_MethodHook() &#123; protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; &#x2F;&#x2F; 原始参数 String oldText &#x3D; (String) param.args[0]; Log.d(&quot;din not hijacked&#x3D;&gt;&quot;, oldText); &#x2F;&#x2F;param.args[0] &#x3D; &quot;test&quot;; &#x2F;&#x2F; 修改新参数 param.args[0] &#x3D; &quot;你已被劫持&quot;; PrintStack(); &#x2F;&#x2F;super.beforeHookedMethod(param); &#x2F;&#x2F;XposedBridge.log(&quot; has Hooked!&quot;); &#125; protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; Log.d(&quot;getResult is &#x3D;&gt; &quot;,(String) param.getResult()); param.setResult(&quot;你已被劫持2&quot;); &#125; &#125;); &#125; &#125;&#125; xposed_init配置hook方法com.roysue.xposed1.HookTest 编译启动该app，注入Xposed 点击按钮查看log及调用栈 123objection -g com.roysue.xposed1 exploreandroid hooking search classes HookTest android hooking list class_methods com.roysue.xposed1.HookTest 找不到该类，原因是实现了接口IXposedHookLoadPackage，HookTest不在接口包中，需要在xposed_init里指定路径 hookHook HookTestobjection无法找到，通过frida进行hook拿到HookTest，frida -UF -l hookXposed.js 12345678910111213141516171819202122232425262728293031function hook() &#123; Java.perform(function () &#123; console.log(&quot;start&quot;) Java.enumerateClassLoaders(&#123; onMatch: function (loader) &#123; try &#123; if(loader.findClass(&quot;com.roysue.xposed1.HookTest&quot;))&#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); Java.classFactory.loader &#x3D; loader ; &#125; &#125; catch(error)&#123; console.log(&quot;find error:&quot; + error) &#125; &#125;, onComplete: function () &#123; console.log(&quot;end1&quot;) &#125; &#125;) &#125;) Java.use(&quot;com.roysue.xposed1.HookTest&quot;).PrintStack.implementation &#x3D; function (param)&#123; console.log(&quot;entering PrintStack&quot;); return true; &#125; console.log(&quot;end2&quot;) &#125;function main()&#123; hook()&#125;setImmediate(main) Hook XposedBridge1234567891011121314151617181920212223242526272829function hook() &#123; Java.perform(function () &#123; console.log(&quot;start&quot;) Java.enumerateClassLoaders(&#123; onMatch: function (loader) &#123; try &#123; &#x2F;&#x2F; if (loader.findClass(&quot;com.roysue.xposed1.HookTest&quot;)) &#123; if(loader.findClass(&quot;de.robv.android.xposed.XposedBridge&quot;))&#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); Java.classFactory.loader &#x3D; loader; &#125; &#125; catch (error) &#123; console.log(&quot;find error:&quot; + error) &#125; &#125;, onComplete: function () &#123; console.log(&quot;end1&quot;) &#125; &#125;) Java.use(&quot;de.robv.android.xposed.XposedBridge&quot;).log.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (str) &#123; console.log(&quot;entering XposedBridge.log&quot;,str.toString()); return true; &#125; console.log(&quot;end2&quot;) &#125;)&#125; Hook All Methods1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function uniqBy(array, key) &#123; var seen &#x3D; &#123;&#125;; return array.filter(function (item) &#123; var k &#x3D; key(item); return seen.hasOwnProperty(k) ? false : (seen[k] &#x3D; true); &#125;);&#125;&#x2F;&#x2F; trace a specific Java Methodfunction traceMethod(targetClassMethod) &#123; var delim &#x3D; targetClassMethod.lastIndexOf(&quot;.&quot;); if (delim &#x3D;&#x3D;&#x3D; -1) return; var targetClass &#x3D; targetClassMethod.slice(0, delim) var targetMethod &#x3D; targetClassMethod.slice(delim + 1, targetClassMethod.length) var hook &#x3D; Java.use(targetClass); var overloadCount &#x3D; hook[targetMethod].overloads.length; console.log(&quot;Tracing &quot; + targetClassMethod + &quot; [&quot; + overloadCount + &quot; overload(s)]&quot;); &#x2F;* &#x2F;&#x2F; hook all class_method for (var i &#x3D; 0; i &lt; overloadCount; i++) &#123; hook[targetMethod].overloads[i].implementation &#x3D; function () &#123; console.warn(&quot;\\n*** entered &quot; + targetClassMethod); &#x2F;&#x2F; print backtrace &#x2F;&#x2F; Java.perform(function() &#123; &#x2F;&#x2F; var bt &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()); &#x2F;&#x2F; console.log(&quot;\\nBacktrace:\\n&quot; + bt); &#x2F;&#x2F; &#125;); &#x2F;&#x2F; print args if (arguments.length) console.log(); for (var j &#x3D; 0; j &lt; arguments.length; j++) &#123; console.log(&quot;arg[&quot; + j + &quot;]: &quot; + arguments[j]); &#125; &#x2F;&#x2F; print retval var retval &#x3D; this[targetMethod].apply(this, arguments); &#x2F;&#x2F; rare crash (Frida bug?) console.log(&quot;\\nretval: &quot; + retval); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.warn(&quot;\\n*** exiting &quot; + targetClassMethod); return retval; &#125; &#125; *&#x2F;&#125;function traceClass(targetClass) &#123; &#x2F;&#x2F;Java.use是新建一个对象哈，大家还记得么？ var hook &#x3D; Java.use(targetClass); &#x2F;&#x2F;利用反射的方式，拿到当前类的所有方法 var methods &#x3D; hook.class.getDeclaredMethods(); &#x2F;&#x2F; var methods &#x3D; hook.class.getMethods(); &#x2F;&#x2F;建完对象之后记得将对象释放掉哈 hook.$dispose; &#x2F;&#x2F;将方法名保存到数组中 var parsedMethods &#x3D; []; methods.forEach(function (method) &#123; parsedMethods.push(method.toString().replace(targetClass + &quot;.&quot;, &quot;TOKEN&quot;).match(&#x2F;\\sTOKEN(.*)\\(&#x2F;)[1]); &#125;); &#x2F;&#x2F;去掉一些重复的值 var targets &#x3D; uniqBy(parsedMethods, JSON.stringify); &#x2F;&#x2F;对数组中所有的方法进行hook，traceMethod也就是第一小节的内容 targets.forEach(function (targetMethod) &#123; traceMethod(targetClass + &quot;.&quot; + targetMethod); &#125;);&#125; traceClass(“de.robv.android.xposed.XposedBridge”); 12if (loader.findClass(&quot;com.roysue.xposed1.HookTest$1&quot;)) &#123; traceClass(&quot;com.roysue.xposed1.HookTest$1&quot;); 说明com.roysue.xposed1.HookTest$1就是XposedHelpers.findAndHookMethod(clazz, &quot;toastMessage&quot;, String.class,new XC_MethodHook() {中的XC_MethodHook内部类 hook afterHookedMethod 1234567891011121314151617181920212223242526272829function hook() &#123; Java.perform(function () &#123; console.log(&quot;start&quot;) Java.enumerateClassLoaders(&#123; onMatch: function (loader) &#123; try &#123; &#x2F;&#x2F; if (loader.findClass(&quot;com.roysue.xposed1.HookTest&quot;)) &#123; if(loader.findClass(&quot;com.roysue.xposed1.HookTest$1&quot;))&#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); Java.classFactory.loader &#x3D; loader; &#125; &#125; catch (error) &#123; console.log(&quot;find error:&quot; + error) &#125; &#125;, onComplete: function () &#123; console.log(&quot;end1&quot;) &#125; &#125;) Java.use(&quot;com.roysue.xposed1.HookTest$1&quot;).afterHookedMethod.implementation &#x3D; function (param) &#123; console.log(&quot;entering afterHookedMethod param is &quot;,param); return this.afterHookedMethod(param); &#125; console.log(&quot;end2&quot;) &#125;)&#125; 通过traceClass(&quot;de.robv.android.xposed.XC_MethodHook$MethodHookParam&quot;)拿到所有的类方法，在classloader中而不是在app中 123456Java.use(&quot;de.robv.android.xposed.XC_MethodHook$MethodHookParam&quot;).setResult.implementation &#x3D; function (param) &#123; console.log(&quot;entering XC_MethodHook$MethodHookParam setResult param is &quot;,param); &#x2F;&#x2F; 打印调用栈 console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return this.setResult(param);&#125; XC_MethodHook是抽象类不能直接hook，需要hook实现。 traceClass(“com.roysue.xposed1.HookTest$1”) GravityBoxgit clone https://github.com/GravityBox/GravityBox.git 修改app/build.gradle 123456789compileSdkVersion 23targetSdkVersion 23 debug &#123; 避免打包需要秘钥&#x2F;&#x2F; versionNameSuffix &quot;-Dev&quot; &#x2F;&#x2F; if (signingConfigs.releaseConfig !&#x3D; null) &#123;&#x2F;&#x2F; signingConfig signingConfigs.releaseConfig&#x2F;&#x2F; &#125; &#125;compile &#39;com.android.support:appcompat-v7:26.0.2&#39; 指定版本 build.gradle 1234567891011121314151617buildscript &#123; repositories &#123; jcenter() google() 添加google镜像源 &#125; dependencies &#123; classpath &#39;com.android.tools.build:gradle:2.3.3&#39; &#125;&#125;allprojects &#123; repositories &#123; jcenter() google() maven &#123; url &#39;https:&#x2F;&#x2F;jitpack.io&#39; &#125; &#125;&#125; 源码分析src/assets/xposed_init 文件中提供了入口类com.wrbug.gravitybox.nougat.GravityBox 1public class GravityBox implements IXposedHookZygoteInit, IXposedHookInitPackageResources, IXposedHookLoadPackage 入口类中实现了三个接口IXposedHookInitPackageResources，IXposedHookLoadPackage，IXposedHookZygoteInit IXposedHookZygoteInit 所有的进程 Hook the initialization of ** (es), from which **all the apps are forked. Implement this interface in your module’s main class in order to be notified when Android is starting up. In IXposedHookZygoteInit, you can modify objects and place hooks that should be applied for every app. Only the Android framework/system classes are available at that point in time. Use null as class loader for XposedHelpers.findAndHookMethod(String, ClassLoader, String, Object...) and its variants. If you want to hook one/multiple specific apps, use IXposedHookLoadPackage instead. 说明initZygote只有在系统启动的时候执行一遍，只有系统框架库可以使用。 XposedBridge.log(“GB:Hardware: “ + Build.HARDWARE); 代码中调用了Build.HARDWARE 123frida-ps -U|grep gravityobjection -g com.ceco.nougat.gravitybox explore -P ~&#x2F;.objection&#x2F;pluginsplugin wallbreaker classdump --fullname android.os.Build **IXposedHookInitPackageResources ** 所有的资源 Get notified when the resources for an app are initialized. In handleInitPackageResources(XC_InitPackageResources.InitPackageResourcesParam), resource replacements can be created. This interface should be implemented by the module’s main class. Xposed will take care of registering it as a callback automatically. 说明handleInitPackageResources实现的回调在创建之后就会得到通知 **IXposedHookLoadPackage ** 所有的包 Get notified when an app (“Android package”) is loaded. This is especially useful to hook some app-specific methods. This interface should be implemented by the module’s main class. Xposed will take care of registering it as a callback automatically. xposed会将handleLoadPackage注册成为回调，app在加载时都会经过该回调，主要用来实现具体的hook逻辑。 在handleLoadPackage中调用了ModStatusbarColor.init 123if (lpparam.packageName.equals(ModStatusbarColor.PACKAGE_NAME)) &#123; ModStatusbarColor.init(prefs, lpparam.classLoader);&#125; 1234567891011121314151617181920212223242526272829303132public static final String PACKAGE_NAME &#x3D; &quot;com.android.systemui&quot;; private static final String CLASS_PHONE_STATUSBAR &#x3D; &quot;com.android.systemui.statusbar.phone.PhoneStatusBar&quot;; public static void init(final XSharedPreferences prefs, final ClassLoader classLoader) &#123; try &#123; &#x2F;&#x2F; findClass底层通过反射获取CLASS_PHONE_STATUSBAR类 final Class&lt;?&gt; phoneStatusbarClass &#x3D; XposedHelpers.findClass(CLASS_PHONE_STATUSBAR, classLoader); final Class&lt;?&gt; statusbarIconViewClass &#x3D; XposedHelpers.findClass(CLASS_STATUSBAR_ICON_VIEW, classLoader); final Class&lt;?&gt; sbTransitionsClass &#x3D; XposedHelpers.findClass(CLASS_SB_TRANSITIONS, classLoader); XposedHelpers.findAndHookMethod(phoneStatusbarClass, &#x2F;&#x2F; hook相同的类时XCallback.PRIORITY_LOWEST最低,优先级最高 &#x2F;&#x2F; https:&#x2F;&#x2F;api.xposed.info&#x2F;reference&#x2F;de&#x2F;robv&#x2F;android&#x2F;xposed&#x2F;XC_MethodHook.html &quot;makeStatusBarView&quot;, new XC_MethodHook(XCallback.PRIORITY_LOWEST) &#123; @Override protected void afterHookedMethod(final MethodHookParam param) throws Throwable &#123; mPhoneStatusBar &#x3D; param.thisObject; &#x2F;&#x2F; getObjectField获取对象的属性值 &#x2F;&#x2F; https:&#x2F;&#x2F;api.xposed.info&#x2F;reference&#x2F;de&#x2F;robv&#x2F;android&#x2F;xposed&#x2F;XposedHelpers.html Context context &#x3D; (Context) XposedHelpers.getObjectField(param.thisObject, &quot;mContext&quot;); if (SysUiManagers.IconManager !&#x3D; null) &#123; SysUiManagers.IconManager.registerListener(mIconManagerListener); &#125; Intent i &#x3D; new Intent(ACTION_PHONE_STATUSBAR_VIEW_MADE); context.sendBroadcast(i); &#125; &#125;); &#125; catch (Throwable t) &#123; GravityBox.log(TAG, t); &#125; &#125; 由于com.android.systemui和当前hook的包在不同进程中 123objection -g com.android.systemui exploreandroid hooking search classes com.android.systemui ~&#x2F;.objection&#x2F;pluginsplugin wallbreaker classdump --fullname com.android.systemui.statusbar.phone.PhoneStatusBar 静态域 https://api.xposed.info/reference/de/robv/android/xposed/XposedHelpers.html 12345BRIGHTNESS_ON &#x3D; XposedHelpers.getStaticIntField(powerManagerClass, &quot;BRIGHTNESS_ON&quot;);plugin wallbreaker classdump --fullname android.os.PowerManager 查看静态域(int[])XposedHelpers.getStaticObjectField(classAudioService, &quot;MAX_STREAM_VOLUME&quot;);XposedHelpers.getStaticLongField(param.thisObject.getClass(),&quot;SWIPE_TIMEOUT_MS&quot;)(boolean) XposedHelpers.getStaticBooleanField(mDisplayPowerController.getClass(), &quot;MTK_ULTRA_DIMMING_SUPPORT&quot;); 动态域 https://api.xposed.info/reference/de/robv/android/xposed/XposedHelpers.html 12345XposedHelpers.getObjectField(param.thisObject, &quot;mNotification&quot;) &#x3D;&#x3D; nullobjection -g com.ceco.nougat.gravitybox explore -P ~&#x2F;.objection&#x2F;pluginsandroid heap search instances com.android.systemui.statusbar.phone.PhoneStatusBar 内存搜索PhoneStatusBar类实例plugin wallbreaker objectsearch com.android.systemui.statusbar.phone.PhoneStatusBar 内存搜索对象plugin wallbreaker objectiondump --fullname 0x100e6e 查看类内容中的动态域mNotification 主动调用 https://api.xposed.info/reference/de/robv/android/xposed/XposedHelpers.html 123456(Float) XposedHelpers.callMethod(param.thisObject, &quot;getNonBatteryClockAlphaFor&quot;, (Integer) param.args[0]);XposedHelpers.callStaticMethod(mClsPhoneFactory, &quot;getPhone&quot;, mSimSlot);plugin wallbreaker objectsearch com.android.systemui.statusbar.phone.PhoneStatusBarTransitionsplugin wallbreaker objectdump --fullname 0x10141e 查找getNonBatteryClockAlphaFor方法int phoneId &#x3D; XposedHelpers.getIntField(param.thisObject, &quot;mPhoneId&quot;);Context context &#x3D; (Context) XposedHelpers.getObjectField(param.thisObject, &quot;mContext&quot;); 构造函数 123456789101112131415XposedHelpers.findAndHookConstructor(&quot;android.media.AudioManager&quot;, classLoader, Context.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; Object objService &#x3D; XposedHelpers.callMethod(param.thisObject, &quot;getService&quot;); Context mApplicationContext &#x3D; (Context) XposedHelpers.getObjectField(param.thisObject, &quot;mApplicationContext&quot;); if (objService !&#x3D; null &amp;&amp; mApplicationContext !&#x3D; null) &#123; XposedHelpers.callMethod(param.thisObject, &quot;disableSafeMediaVolume&quot;); &#125; &#125;&#125;);android hooking search classes android.media.AudioMangerplugin wallbreaker objectsearch android.media.AudioManagerplugin wallbreaker objectdump --fullname 0x186e 查看getService和disableSafeMediaVolume和mApplicationContext Not In Frida1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950setAdditionalInstanceField(param.thisObject, &quot;mVolumeUpLongPress&quot;, mVolumeUpLongPress); 给对象加静态域Object ls &#x3D; XposedHelpers.getSurroundingThis(mLight); 内部类对象返回给外部类Class[] params &#x3D; method.getParameterTypes(); 获取参数列表UserHandle uh &#x3D; (UserHandle) uhConst.newInstance(-2); 创建新实例对象Constructor&lt;?&gt; uhConst &#x3D; XposedHelpers.findConstructorExact(UserHandle.class, int.class); 查找一个构造函数让其可用XposedBridge.hookAllConstructors(XposedHelpers.findClass( hook所有构造函数 CLASS_TRUST_MANAGER_SERVICE, classLoader), new XC_MethodHook() &#123; @Override protected void afterHookedMethod(final MethodHookParam param) throws Throwable &#123; mTrustManager &#x3D; param.thisObject; Context context &#x3D; (Context) XposedHelpers.getObjectField(param.thisObject, &quot;mContext&quot;); mWifiManager &#x3D; new WifiManagerWrapper(context, null); mConnectivityManager &#x3D; (ConnectivityManager) context.getSystemService( Context.CONNECTIVITY_SERVICE); IntentFilter intentFilter &#x3D; new IntentFilter(); intentFilter.addAction(WifiPriorityActivity.ACTION_WIFI_TRUSTED_CHANGED); intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); context.registerReceiver(mBroadcastReceiver, intentFilter); if (DEBUG) log(&quot;Trust manager constructed&quot;); &#125;&#125;);XposedBridge.hookMethod(mtdHandlePlay, new XC_MethodHook() &#123; hook所有方法并创建回调 @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; qhPrefs.reload(); QuietHours qh &#x3D; new QuietHours(qhPrefs); if (qh.isSystemSoundMuted(QuietHours.SystemSound.RINGER)) &#123; param.setResult(null); &#125; &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; if (!mRingerConfig.enabled) return; mRingtone &#x3D; (Ringtone) XposedHelpers.getObjectField(mAsyncRinger, &quot;mRingtone&quot;); if (mRingtone &#x3D;&#x3D; null) &#123; if (DEBUG) log(&quot;handlePlay called but ringtone is null&quot;); return; &#125; setVolume(mRingerConfig.minVolume); mIncrementAmount &#x3D; (1f - mRingerConfig.minVolume) &#x2F; (float) mRingerConfig.rampUpDuration; mCurrentIncrementVolume &#x3D; mRingerConfig.minVolume; mHandler &#x3D; (Handler) XposedHelpers.getObjectField(mAsyncRinger, &quot;mHandler&quot;); mHandler.postDelayed(mRunnable, 1000); if (DEBUG) log(&quot;Starting increasing ring&quot;); &#125;&#125;); set(get)AdditionalInstanceField getMD5Sum getMethodDepth getParameterTypes getSurroundingThis hookMethod 系统级别的，过滤所有的进程 只要Xposed生效了，可以把Xposed理解为系统框架，作为系统的本身来考虑没有关系。 Not In Xposed Java.choose rpc 热重载/加载 单进程级别的，只能在hook的进程内生效 hook本项目中 xposed 系统级别的，过滤所有的进程，入口类中实现了三个接口，hook了所有的资源，进程，包。只会hook进程中的包等于ModStatusbarColor.PACKAGE_NAME即com.android.systemui时，才启动hook。所有逻辑不在GravityBox中，也不在xposed.jar中，而是在com.android.systemui if (lpparam.packageName.equals(ModStatusbarColor.PACKAGE_NAME)) { ModStatusbarColor.init(prefs, lpparam.classLoader); } frida-ps -U |grep com.android.systemui 在app逆向中遇到interface搜索其实现还是一顿乱搜，可以使用反射getInterfaces得到实现的接口数组，然后打印出来即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function hook() &#123; Java.perform(function () &#123; console.log(&quot;start&quot;) Java.enumerateClassLoaders(&#123; onMatch: function (loader) &#123; try &#123; if (loader.findClass(&quot;com.ceco.nougat.gravitybox.ModStatusbarColor$1&quot;)) &#123; &#x2F;&#x2F; if(loader.findClass(&quot;de.robv.android.xposed.XC_MethodHook&quot;))&#123; &#x2F;&#x2F; if(loader.findClass(&quot;com.roysue.xposed1.HookTest&quot;))&#123; &#x2F;&#x2F; if(loader.findClass(&quot;de.robv.android.xposed.XposedBridge&quot;))&#123; &#x2F;&#x2F;if(loader.findClass(&quot;com.android.internal.statusbar.StatusBarIcon&quot;))&#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); Java.classFactory.loader &#x3D; loader; &#125; &#125; catch (error) &#123; console.log(&quot;find error:&quot; + error) &#125; &#125;, onComplete: function () &#123; console.log(&quot;end1&quot;) &#125; &#125;) &#x2F;&#x2F; Java.use(&quot;de.robv.android.xposed.XposedBridge&quot;).log.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (str) &#123; &#x2F;&#x2F; console.log(&quot;entering Xposedbridge.log &quot;,str.toString()) &#x2F;&#x2F; return true &#x2F;&#x2F; &#125; &#x2F;&#x2F;traceClass(&quot;com.ceco.nougat.gravitybox.ModStatusbarColor&quot;) &#x2F;&#x2F; Java.use(&quot;com.roysue.xposed1.HookTest$1&quot;).afterHookedMethod.implementation &#x3D; function (param)&#123; &#x2F;&#x2F; console.log(&quot;entering afterHookedMethod param is &#x3D;&gt; &quot;,param); &#x2F;&#x2F; return this.afterHookedMethod(param); &#x2F;&#x2F; &#125; &#x2F;&#x2F; traceClass(&quot;de.robv.android.xposed.XC_MethodHook&quot;) &#x2F;&#x2F; Java.use(&quot;de.robv.android.xposed.XC_MethodHook$MethodHookParam&quot;).setResult.implementation &#x3D; function(str)&#123; &#x2F;&#x2F; console.log(&quot;entersing de.robv.android.xposed.XC_MethodHook$MethodHookParam setResult &#x3D;&gt; &quot;,str) &#x2F;&#x2F; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); &#x2F;&#x2F; return this.setResult(str); &#x2F;&#x2F; &#125; Java.enumerateLoadedClasses(&#123; onMatch: function (className) &#123; if (className.toString().indexOf(&quot;gravitybox&quot;) &gt; 0 &amp;&amp; className.toString().indexOf(&quot;$&quot;) &gt; 0 ) &#123; console.log(&quot;found &#x3D;&gt; &quot;, className) &#x2F;&#x2F; var interFaces &#x3D; Java.use(className).class.getInterfaces(); &#x2F;&#x2F; if(interFaces.length&gt;0)&#123; &#x2F;&#x2F; console.log(&quot;interface is &#x3D;&gt; &quot;); &#x2F;&#x2F; for(var i in interFaces)&#123; &#x2F;&#x2F; console.log(&quot;\\t&quot;,interFaces[i].toString()) &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; if (Java.use(className).class.getSuperclass()) &#123; var superClass &#x3D; Java.use(className).class.getSuperclass().getName(); &#x2F;&#x2F; console.log(&quot;superClass is &#x3D;&gt; &quot;,superClass); if (superClass.indexOf(&quot;XC_MethodHook&quot;) &gt; 0) &#123; console.log(&quot;found class is &#x3D;&gt; &quot;, className.toString()) traceClass(className); &#125; &#125; &#125; &#125;, onComplete: function () &#123; console.log(&quot;search completed!&quot;) &#125; &#125;) console.log(&quot;end2&quot;) &#125;)&#125;","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"xposed","slug":"xposed","permalink":"http://onejane.github.io/tags/xposed/"}]},{"title":"违法应用移动TV取证分析","slug":"违法应用移动TV取证分析","date":"2021-04-21T14:37:18.000Z","updated":"2021-05-01T07:40:47.253Z","comments":true,"path":"2021/04/21/违法应用移动TV取证分析/","link":"","permalink":"http://onejane.github.io/2021/04/21/%E8%BF%9D%E6%B3%95%E5%BA%94%E7%94%A8%E7%A7%BB%E5%8A%A8TV%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/","excerpt":"","text":"抓包应用层抓包 传输层抓包charles开启Enable socks proxy wget https://www.charlesproxy.com/assets/release/4.6.1/charles-proxy-4.6.1_amd64.tar.gz?k=17bcbd3dc2 tar zxf charles-proxy-4.6.1_amd64.tar.gz &amp;&amp; ./charles 通过注册码注册或生成加权jar包破解 vim ~/.zshrc 并source ~/.zshrc 使得charles在任意路径可启动 1export PATH&#x3D;&quot;&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;ndk-bundle:&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;platform-tools:$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH:&#x2F;root&#x2F;Desktop&#x2F;charles&#x2F;bin:&#x2F;root&#x2F;Desktop&#x2F;jadx-1.2.0&#x2F;bin&quot; htop 查看破解情况 电脑：192.168.0.106 手机：192.168.0.102 虚拟机：192.168.0.107 虚拟网络编辑器选择获取ip的网卡，保证这三台机器在同一局域网内且互相ping通。 配置charlessocks proxy工作于传输层，更好的观察应用层协议和socks抓包。 开启ssl posternadb install 0714com.tunnelworkshop.postern_2018-10-07.apk QtScrcpy 设置投屏 配置socks5抓包代理 配置socks5抓包配置规则 打开socks vpn连接虚拟机抓包，虚拟机收到连接请求后点击Allow 在手机浏览器输入地址 chls.pro/ssl 或者 charlesproxy.com/getssl ，出现证书安装页面，点击安装，如果依旧app抓不到，需要把个人证书放到系统根目录 Android8 12345cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o remount,rw &#x2F;chmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o remount,ro &#x2F; Android 7 12345cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o rw,remount &#x2F;systemchmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o ro,remount &#x2F;system movetv分析1234.&#x2F;fs1428arm64 pyenv local 3.8.5frida -UF -l hookSocket.js -o moveTV.txt attach方式hook登录抓包，基于socks层抓包无法对抗，除非做了VPN检测frida -U -f com.cz.babySister -l hookSocket.js -o moveTV.txt spawn方式hook，输入%resume重新启动，或者直接在命令后加--no-pause jadx-gui movetv.apk 已经加壳一个Activity都找不到 脱壳FRIDA-DEXDumpgit clone https://github.com/hluwa/FRIDA-DEXDump.git 启动app放在前台 cd ~/Desktop/FRIDA-DEXDump/frida_dexdump &amp;&amp; python main.py 开始脱壳 1234android hooking list activities 查看所有Activitygrep -ril &quot;MainActivity&quot; * 从脱下的dex中查找MainActivitygrep -ril &quot;LoginActivity&quot; *jadx-gui com.cz.babySister&#x2F;0x748d44201c.dex 登录抓登录包获取memi1字段其实来源于android-id android hooking watch class com.cz.babySister.activity.LoginActivity –dump-args –dump-backtrace –dump-return hook类中所有方法 android hooking watch class_method com.cz.babySister.activity.LoginActivity.b –dump-args –dump-backtrace –dump-return hook登录b方法 进入b方法中调用的RunnableC0042q类中 android hooking watch class_method com.cz.babySister.c.a.a –dump-args –dump-backtrace –dump-return hook方法a 12345objection -g com.cz.babySister exploreandroid hooking search classes Settings android hooking list class_methods android.provider.Settings android hooking list class_methods android.provider.Settings$Secureandroid hooking watch class_method android.provider.Settings$Secure.getString --dump-args --dump-backtrace --dump-return 通过hook获取返回的结果50463fa80244d95f和chales中抓包的memi1完全一致 注册android hooking watch class_method com.cz.babySister.c.a.a –dump-args –dump-backtrace –dump-return 对比抓包结果 取证实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import base64import timeimport requestsrequests.packages.urllib3.disable_warnings()class tv: def __init__(self): self.root &#x3D; &#39;http:&#x2F;&#x2F;39.108.64.125&#x2F;WebRoot&#x2F;superMaster&#x2F;Server&#39; self.memi1 &#x3D; &quot;50463fa80244d95f&quot; self.rightkey &#x3D; &quot;376035775&quot; self.key &#x3D; &quot;308202d5308201bda00302010202041669d9bf300d06092a864886f70d01010b0500301b310b3009060355040613023836310c300a06035504031303776569301e170d3136303731383038313935395a170d3431303731323038313935395a301b310b3009060355040613023836310c300a0603550403130377656930820122300d06092a864886f70d01010105000382010f003082010a028201010095f85892400aae03ca4ed9dcd838d162290ae8dd51939aac6ecfde8282f207c4cd9e507929a279e0a36f1e4847330cb53908c92915b2c6a93d7064be452d073a472093f7ca14f4ab68f827582fe0988e9e4bc8a6ea3b56001cbbbb760f9eec571b0bbc97392e65aaf08c686f0e2ba353896d48a37c36716239977bd0e4dd878025cab497d8164537aec9f6599eefb98577dce972a1b794e211226520e23497beec3fd8548bb5b4d263120d40115cca28116bac32378df5033f536a0d7367fef78c587fefed28c5c9b35ba684ed6e46d9369c40950cf7ad7236d10b7a51dfd2a8f218db72323bbd19f46947410b1191f263012ad4ba8f749223e37591254ee7f50203010001a321301f301d0603551d0e041604143d43284bd5e4b0d322c9962a5b70aad4dcbc3634300d06092a864886f70d01010b050003820101000f04c51ff763311aa011777ba2842b441b15c316373d1e1ed4116cf86e29d55c6ed3fa4c475251b1fb4fac57195dbca0166ebe565d9834552a3758b97c4528bab1f7ab82bb3a9faa932f5bc10943f3daf52e0fe5889ffb58a6be67ea1c9a2fb37dc8aa6f3af476039a467336991a4e52dccd520195cd473eb5b984e702ed9ff638a14c3abb575a7a80ae4062084d1138a06a20e173be9df32df631311b07352898706198ddebaaa011f0da8e5f288f7cfb77505bc943f6476d6cc1feef56b68137aad91f23c4bb772169539d05653a6f0d75f7192164e822b934322f3a975df677903b1667f5dc1e9ddb185da3281d31bfb8f67a84bd23bbcb398f8bb637dd72&quot; def post(self, data&#x3D;None): if data is None: data &#x3D; &#123;&#125; return requests.post(url&#x3D;self.root, data&#x3D;data) def query(self, name, password): ret &#x3D; self.post(&#123;&#39;name&#39;: name, &#39;pass&#39;: password&#125;) print(&quot;query result is : &quot;) print(ret.content.decode(&#39;utf-8&#39;)) def register(self, name, password): ret &#x3D; self.post(&#123;&#39;name&#39;: name, &#39;pass&#39;: password, &#39;memi1&#39;: self.memi1, &#39;key&#39;: self.key, &#39;rightkey&#39;: self.rightkey, &#39;register&#39;: &#39;register&#39;&#125;) print(&quot;Register response data: &quot;) print(ret.content.decode(&#39;utf-8&#39;)) def login(self, name, password): ret &#x3D; self.post(&#123;&#39;name&#39;: name, &#39;pass&#39;: password, &#39;memi1&#39;: self.memi1, &#39;key&#39;: self.key, &#39;rightkey&#39;: self.rightkey, &#39;login&#39;: &#39;login&#39;&#125;) print(&quot;Login response data: &quot;) print(ret.content.decode(&#39;utf-8&#39;)) def updateSocre(self, name, password, jifen): t &#x3D; int(round(time.time() * 1000)) sign &#x3D; base64.b64encode(str(5 * t).encode(&#39;utf-8&#39;)).decode(&#39;utf-8&#39;) ret &#x3D; self.post(&#123;&#39;name&#39;: name, &#39;pass&#39;: password, &#39;jifen&#39;: jifen, &#39;time&#39;: t, &#39;sign&#39;: sign&#125;) print(&quot;UpdataScore response data: &quot;) print(ret.content.decode(&#39;utf-8&#39;))if __name__ &#x3D;&#x3D; &quot;__main__&quot;: tv &#x3D; tv() # print(tv.query(&quot;eeeeffff&quot;, &quot;gggghhhh&quot;)) # 注册账号 print(tv.register(&quot;onejane3&quot;, &quot;123456&quot;)) # time.sleep(3) # 登录账号 print(tv.login(&quot;onejane3&quot;, &quot;123456&quot;)) # 更新积分 # print(tv.updateSocre(&quot;mee4&quot;,&quot;mee4&quot;,&quot;1000&quot;)) Youpkhttps://bbs.pediy.com/thread-259854.htm linux平台下载最新的platform-tools刷机的时候，fastboot会报各种unknow command或接近的错误，把fastboot文件替换成以下随着aosp一起编译出来的即可： fastboot_aosp7.1.zip fastboot6.0.zip fastboot8.1.0r1.zip 下载Youpk_v1.1 重启至bootloader: adb reboot bootloader 解压 Youpk_sailfish.zip 并双击 flash-all.bat,（尽量在kali上刷机，./flash-all.sh,因为windows会给我们的编程生涯带来80%的苦难） adb install movetv.apk adb shell “echo com.cz.babySister &gt;&gt; /data/local/tmp/unpacker.config” 启动apk等待脱壳，每隔10秒将自动重新脱壳(已完全dump的dex将被忽略), 当日志打印unpack end时脱壳完成 adb pull /data/data/com.cz.babySister/unpacker/ mv unpacker youpk/ 调用修复工具 dexfixer.jar, 两个参数, 第一个为dump文件目录(必须为有效路径), 第二个为重组后的DEX目录(不存在将会创建) java -jar dexfixer.jar youpk/ youpk_out/ jadx-gui _data_app_com.cz.babySister-1_base.apk_54276.dex 查看脱壳后的dex 使用场景 整体加固 抽取: nop占坑型(类似某加密) naitve化, 在中解密(类似早期阿里) goto解密型(类似新版某加密?najia): https://bbs.pediy.com/thread-259448.htm 问题 dump中途退出或卡死，重新启动进程，再次等待脱壳即可 当前仅支持被壳保护的dex, 不支持App动态加载的dex/jar fart脱抽取型壳并回填dex 安装新环境vim /etc/proxychains4.conf 配置代理 12socks5 192.168.0.106 1080#http 127.0.0.1 12333 主机192.168.0.106 ssr开启运行局域网连接 配置新环境 12PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains pyenv install 3.9.0 创建python3.9.0环境PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains pip install objection&#x3D;&#x3D;1.9.5 安装objection 1.9.5套件包括frida-tools 9.2.4，frida 14.2.16 wget frida-server-14.2.16-android-arm64.xz 7z x frida-server-14.2.16-android-arm64.xz 12345adb push ~&#x2F;Desktop&#x2F;frida-server-14.2.16-android-arm64 &#x2F;data&#x2F;local&#x2F;tmp&#x2F;adb shellmv &#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server-14.2.16-android-arm64 &#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs1426arm64 chmod 777 &#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs1426arm64.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs1426arm64 事实证明，新版本不兼容还是用12.8.0的frida吧 调用fart基于hook和反射脱壳，对比发现youpk最优秀。 adb reboot bootloader cd ~/Desktop/sailfish-nzh54d 安卓8.0 ./flash-all.sh 刷回去 root及基础配置 123456789101112131415adb push Magisk-v20.4.zip &#x2F;sdcard adb push magisk-riru-v21.3.zip &#x2F;sdcard&#x2F;Download 使用magisk模块安装并重启adb push magisk-EdXposed-SandHook-v0.4.5.1_beta.4463.-release.zip &#x2F;sdcard&#x2F;Download 使用magisk模块安装并重启adb install EdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apk 安装xposedadb push MagiskHidePropsConf-v5.3.4.zip &#x2F;sdcard&#x2F;Download adb install JustTrustMePlus-debug.apk 用于结合xposed突破SSL Pinning抓包限制adb reboot bootloaderfastboot boot twrp-3.4.0-0-sailfish.img 进入recovery modeinstall Magisk-v20.4.zipadb install MagiskManager-v7.5.1.apk 模块安装MagiskHidePropsConf，riru，EdXposed，adb shell su通过Magisk获取root权限settings put global captive_portal_http_url https:&#x2F;&#x2F;www.google.cn&#x2F;generate_204 去除wifi上的×settings put global captive_portal_https_url https:&#x2F;&#x2F;www.google.cn&#x2F;generate_204settings put global ntp_server 1.hk.pool.ntp.org 修改时区props Edit MagiskHide props--ro.debuggable 设置全局可调试，getprop ro.debuggable 即可查看1,开启全局可调试 1234567pyenv local 3.8.0proxychains4 wget https:&#x2F;&#x2F;github.com&#x2F;hanbinglengyue&#x2F;FART.git7z x frida_fart.zip &amp;&amp; adb push lib&#x2F;fart* &#x2F;data&#x2F;app &amp;&amp; chmod 777 *.so 如果没有权限，放到&#x2F;sdcard中再放入&#x2F;data&#x2F;appcd Desktop&#x2F;FART-master&#x2F;frida_fart&#x2F; &amp;&amp; frida -UF -l frida_fart_reflection.js attach模式启动frida -U -f com.cz.babySister -l frida_fart_reflection.js --no-pause spawn模式启动fart() 全量主动调用frida -U -f com.cz.babySister -l frida_fart_hook.js --no-pause 基于安卓8，生成dex，hook连壳一起脱 12adb pull &#x2F;sdcard&#x2F;com.cz.babySister.activitygrep -ril &quot;LoginActivity&quot; *.dex","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"fart","slug":"fart","permalink":"http://onejane.github.io/tags/fart/"},{"name":"postern","slug":"postern","permalink":"http://onejane.github.io/tags/postern/"},{"name":"charles","slug":"charles","permalink":"http://onejane.github.io/tags/charles/"},{"name":"youpk","slug":"youpk","permalink":"http://onejane.github.io/tags/youpk/"},{"name":"dexdump","slug":"dexdump","permalink":"http://onejane.github.io/tags/dexdump/"}]},{"title":"爬虫基础篇之selenium登陆获取阿里腾讯cookie","slug":"爬虫基础篇之selenium登陆获取阿里腾讯cookie","date":"2021-04-21T02:25:19.000Z","updated":"2021-05-01T07:40:46.713Z","comments":true,"path":"2021/04/21/爬虫基础篇之selenium登陆获取阿里腾讯cookie/","link":"","permalink":"http://onejane.github.io/2021/04/21/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8Bselenium%E7%99%BB%E9%99%86%E8%8E%B7%E5%8F%96%E9%98%BF%E9%87%8C%E8%85%BE%E8%AE%AFcookie/","excerpt":"","text":"简介selenium本身是自动化测试框架，只是在爬虫领域更能够显示出其一把梭的威力，所有网站比如淘宝，微博等必须登录状态才能访问页面，对数据进行抓取时，逆向分析js将是一条不归路，而自动化测试框架selenium完全模拟人的行为模式，对网站按钮的点击，元素的获取，内容文本的输入有着得天独厚的优势。不过相对于逆向加密参数执行的爬虫程序来说，selenium还是太过效率低下了，常规套路一般是通过selenium拿到cookie或者token后，再通过爬虫程序去抓取页面，事半功倍。 Alimama实战以阿里妈妈后台为例，通过分析我们拿到了请求json来自于https://pub.alimama.com/campaign/joinedSpecialCampaigns.json?toPage=1&amp;status=2&amp;perPageSize=40 不过单独访问该页面，会将我们地址重定向到登录界面，这种网站就必须我们登录再发起请求抓取数据了。 模拟登录该登录页面是淘宝的统一登录框架，右键重新加载时抓包拿到框架地址，去除无用参数拿到原始地址https://login.taobao.com/member/login.jhtml?style=mini&amp;newMini2=true&amp;from=alimama，避免其他请求干扰我们的判断。 步骤如下： 获取账户，密码，滑块，按钮的元素位置 输入账户密码 判断滑块存在并滑动滑块 点击登录 保存cookie并调用cookie发起请求 chromedriver初始化根据本机的chrome版本获取selenium的驱动程序chromedriver版本 特征隐藏面对一些网站通过ajax请求，同时携带一些难以破解加密参数，虽然selenium模拟浏览器行为操作，绕过这些反爬虫的手段，不过依旧有一些站点通过JavaScript 探测到Selenium启动的浏览器的天生存在的几十个特征来屏蔽这些爬虫的运行。通过https://bot.sannysoft.com/ 可以查看当前浏览器的一些特征值，正常浏览器打开如下： 而通过selenium打开该网站时，部分特征被检测到，这就被安全人员拿来作为关键参数，禁止改浏览器的数据请求。 比如某平台中对selenium的属性$cdc_asdjflasutopfhvcZLmcfl_做了校验，应对解决方案使用HexEdit 4.2修改chromedriver.exe 的$cdc_asdjflasutopfhvcZLmcfl_修改为同长度的字符串,如$ccccccccccccccccccccccccccc。 针对chrome弹窗请停用以开发者模式运行插件，可以通过Chrome.dll-patch75and76.exe放入chrome文件夹下包含包含chrome.dll文件的目录下并管理员身份执行。 针对CHROME正受到组件控制的提示，可以通过chrome_options.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])实现屏蔽’CHROME正受到组件控制’的提示。 针对chrome自带密码保存对爬虫的干扰影响，通过chrome_options.add_experimental_option(&quot;prefs&quot;, prefs)屏蔽。 针对封禁ip可以通过chrome_options.add_argument(&quot;--proxy-server=http://58.243.205.102:4543&quot;)开启ip代理。 设置请求头UA,browser.execute_cdp_cmd(&#39;Network.setUserAgentOverride&#39;, {&quot;userAgent&quot;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36&#39;}) 针对navigator属性中存在webdriver，新页面加载后browser.execute_script(&#39;Object.defineProperty(navigator,&quot;webdriver&quot;,{get:() =&gt; false,});&#39;)去除特征无效，可以通过CDP协议browser.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, {&quot;source&quot;: &quot;&quot;&quot;Object.defineProperty(navigator, &#39;webdriver&#39;, {get: () =&gt; undefined})&quot;&quot;&quot;, }) 不过仅仅靠隐藏几个特征是毫无意义的，针对众多的特征已经有大牛为我们做了完美隐藏，那就是stealth.min.js 道高一尺魔高一丈，完整隐藏特征代码如下： 1234567891011121314151617181920212223242526272829# chrome 版本78.0.3904.70，chromedriver版本78.0.3904.70# 设置代理# chrome_options.add_argument(&quot;--proxy-server&#x3D;http:&#x2F;&#x2F;58.243.205.102:4543&quot;)# chrome.exe --remote-debugging-port&#x3D;7222 本地启动selenium# chrome_options.add_experimental_option(&quot;debuggerAddress&quot;, &quot;127.0.0.1:7222&quot;)chrome_options &#x3D; Options()# 设置无头chrome_options.add_argument(&quot;--headless&quot;)chrome_options.add_argument( &#39;user-agent&#x3D;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.198 Safari&#x2F;537.36&#39;)# 屏蔽&#39;CHROME正受到组件控制&#39;的提示chrome_options.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])# 屏蔽保存密码prefs &#x3D; &#123;&quot;&quot;: &quot;&quot;&#125;prefs[&quot;credentials_enable_service&quot;] &#x3D; Falseprefs[&quot;profile.password_manager_enabled&quot;] &#x3D; Falsechrome_options.add_experimental_option(&quot;prefs&quot;, prefs)driver &#x3D; Chrome(&#39;.&#x2F;chromedriver&#39;, options&#x3D;chrome_options)#driver.execute_script(&#39;Object.defineProperty(navigator,&quot;webdriver&quot;,&#123;get:() &#x3D;&gt; false,&#125;);&#39;)#driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, &#123;&quot;source&quot;: &quot;&quot;&quot;Object.defineProperty(navigator, &#39;webdriver&#39;, &#123;get: () &#x3D;&gt; undefined&#125;)&quot;&quot;&quot;, &#125;)#driver.execute_cdp_cmd(&#39;Network.setUserAgentOverride&#39;, &#123;&quot;userAgent&quot;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;83.0.4103.97 Safari&#x2F;537.36&#39;&#125;) driver.set_page_load_timeout(10)with open(&#39;.&#x2F;stealth.min.js&#39;) as f: js &#x3D; f.read()driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, &#123; &quot;source&quot;: js&#125;) 保存cookie1234567891011121314151617181920212223242526def save_cookies(self): # 隐式等待，设置了一个最长等待时间 self.browser.implicitly_wait(10) # 最大化窗口 self.browser.maximize_window() # 向文本框发送账户密码 self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;input[@name&#x3D;&quot;fm-login-id&quot;]&#39;).send_keys(&#39;***&#39;) self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;input[@name&#x3D;&quot;fm-login-password&quot;]&#39;).send_keys(&#39;***&#39;) # 解决滑块 slide_block &#x3D; self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;nc_1_n1z&quot;]&#39;) if (slide_block.is_displayed()): # 点击移动滑块 action &#x3D; ActionChains(self.browser) action.click_and_hold(on_element&#x3D;slide_block) action.move_by_offset(xoffset&#x3D;258, yoffset&#x3D;0) action.pause(0.5).release().perform() # perform指定动作链 self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;button[@class&#x3D;&quot;fm-button fm-submit password-login&quot;]&#39;).click() time.sleep(5) if &quot;login_unusual&quot; in self.browser.current_url: print(&quot;gg了，要手机验证码了，救命啊啊啊啊啊&quot;) input(&quot;输入手机验证码啦：&quot;) self.cookies &#x3D; &#39;; &#39;.join( item for item in [item[&quot;name&quot;] + &quot;&#x3D;&quot; + item[&quot;value&quot;] for item in self.browser.get_cookies()]) with open(COOKIES_FILE_PATH, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as file: file.write(self.cookies) print(&quot;cookie写入成功：&quot;, self.cookies) 使用cookie登录123456789101112131415def taobao_login(self): print(&quot;登录中。。。。。&quot;) ok &#x3D; False while not ok: with open(COOKIES_FILE_PATH, &#39;r+&#39;, encoding&#x3D;&#39;utf-8&#39;) as file: self.headers[&quot;cookie&quot;] &#x3D; file.read() response &#x3D; self.session.get(self.shop_plan_url, headers&#x3D;self.headers, verify&#x3D;False) try: ok &#x3D; json.loads(response.text) except: self.browser.get(self.alimama_login_url) self.browser.delete_all_cookies() self.save_cookies() self.browser.close() self.browser.quit() Tencent实战由于腾讯优量汇中的报表不提供api，本次目标是抓取该报表中的广告收益数据。 通过抓包分析最关键的cookie为adnet_sso，只要拿到该cookie就可以成功请求数据，该cookie经过了cookie传递层层更新，太烦了，干脆selenium一把梭，登陆后拿到cookie存到文件中，访问api时添加cookie到header中即可。 模拟登录https://sso.e.qq.com/login/hub?sso_redirect_uri=https%3A%2F%2Fe.qq.com%2Fdev%2Flogin&amp;service_tag=14 我们肯定是避免扫码登录了，登录流程是当QQ账号登录界面出现时，点击账号密码登录，找到文本框输入qq号及密码后点击授权并登录按钮，获取selenium的cookie并保存到文件中，访问api数据时读取该cookie即可，如果异常则删除selenium的cookie重新登录保存cookie。 12345678910111213141516def adnet_login(self): print(&quot;登录中。。。。。&quot;) ok &#x3D; False while not ok: with open(COOKIES_FILE_PATH, &#39;r+&#39;, encoding&#x3D;&#39;utf-8&#39;) as file: self.headers[&quot;cookie&quot;] &#x3D; file.read() response &#x3D; self.session.post(self.get_date_url, data&#x3D;json.dumps(self.data), headers&#x3D;self.headers, verify&#x3D;False) try: res &#x3D; json.loads(response.text) ok &#x3D; True except: self.browser.get(self.adnet_login_url) self.browser.delete_all_cookies() self.save_cookies() self.browser.close() self.browser.quit() 初始化selenium的流程和Alimama的一致，腾讯广告的登录界面藏在id=&quot;qqLoginFrame&quot;的frame中的id=&quot;ptlogin_iframe&quot;的frame中，通过switch_to.frame直接切换到frame中获取元素，填写帐密实现登录保存cookie。 12345678910111213141516171819def save_cookies(self): self.browser.implicitly_wait(10) self.browser.maximize_window() self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;a[@id&#x3D;&quot;qqLogin&quot;]&#39;).click() # el_frame &#x3D; self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;qqLoginFrame&quot;]&#39;) # print(self.browser.page_source) self.browser.switch_to.frame(&#39;qqLoginFrame&#39;) self.browser.switch_to.frame(&#39;ptlogin_iframe&#39;) time.sleep(5) self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;a[contains(text(),&quot;帐号密码登录&quot;)]&#39;).click() self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;u&quot;]&#39;).send_keys(&#39;*&#39;) self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;p&quot;]&#39;).send_keys(&#39;*&#39;) self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;loginform&quot;]&#x2F;div[@class&#x3D;&quot;submit&quot;]&#x2F;a&#39;).click() time.sleep(5) self.cookies &#x3D; &#39;; &#39;.join( item for item in [item[&quot;name&quot;] + &quot;&#x3D;&quot; + item[&quot;value&quot;] for item in self.browser.get_cookies()]) with open(COOKIES_FILE_PATH, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as file: file.write(self.cookies) print(&quot;cookie写入成功：&quot;, self.cookies) 爬虫实现api请求是通过post提交payload格式的参数，爬虫实现如下 1234567891011def get_report_list(self): # 获取所有shop plan while True: try: response &#x3D; self.session.post(self.get_date_url, data&#x3D;json.dumps(self.data), headers&#x3D;self.headers, verify&#x3D;False) print(json.loads(response.text)[&quot;data&quot;][&quot;list&quot;]) response.raise_for_status() except Exception as e: print(&#39;获取优量汇主页请求失败！&#39;) self.adnet_login() raise e 常用操作不同系统12345678910chrome_options &#x3D; webdriver.ChromeOptions()if platform.system() &#x3D;&#x3D; &quot;Windows&quot;: driver &#x3D; webdriver.Chrome(&#39;chromedriver.exe&#39;, chrome_options&#x3D;chrome_options)elif platform.system() &#x3D;&#x3D; &quot;Linux&quot;: chrome_options.add_argument(&quot;--headless&quot;) chrome_options.add_argument(&#39;--disable-gpu&#39;) chrome_options.add_argument(&#39;--no-sandbox&#39;) driver &#x3D; webdriver.Chrome( executable_path&#x3D;&quot;&#x2F;usr&#x2F;bin&#x2F;chromedriver&quot;, chrome_options&#x3D;chrome_options) 获取元素信息12345678910111213141516def get_data(): divs &#x3D; driver.find_elements_by_xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;items&quot;]&#x2F;div[@class&#x3D;&quot;item J_MouserOnverReq &quot;]&#39;) for div in divs: info &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;div[@class&#x3D;&quot;row row-2 title&quot;]&#x2F;a&#39;).text price &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;strong&#39;).text deal &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;div[@class&#x3D;&quot;deal-cnt&quot;]&#39;).text shop &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;div[@class&#x3D;&quot;shop&quot;]&#x2F;a&#39;).text print(info, price, deal, shop, sep&#x3D;&quot;|&quot;) with open(&#39;taobao.csv&#39;, mode&#x3D;&#39;a&#39;, newline&#x3D;&quot;&quot;) as csvfile: csvwrite &#x3D; csv.writer(csvfile, delimiter&#x3D;&#39;,&#39;) csvwrite.writerow([info, price, deal, shop])browser.find_elements_by_xpath(&quot;&#x2F;&#x2F;div[@id&#x3D;&#39;J_DivItemDesc&#39;]&#x2F;descendant::*&#x2F;img&quot;) 查找后代元素 browser.find_elements_by_xpath(&quot;&#x2F;&#x2F;div[@id&#x3D;&#39;J_DivItemDesc&#39;]&#x2F;descendant::*&#x2F;img&quot;).tag_name 获取标签browser.find_elements_by_xpath(&quot;&#x2F;&#x2F;div[@id&#x3D;&#39;J_DivItemDesc&#39;]&#x2F;descendant::*&#x2F;img&quot;).get_attribute(&#39;value&#39;) 获取属性value信息或文本框信息js &#x3D; &#39;return document.getElementById(&quot;su&quot;).getAttribute(&quot;value&quot;)&#39;res &#x3D; driver.excute_script(js) 利用js获取元素属性值 鼠标操作1234567891011121314151617181920212223def get_data(): # 移动鼠标到距离元素的位置 title &#x3D; browser.find_element_by_xpath(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;title-bar&#39;]&quot;) ActionChains(browser).move_to_element_with_offset(title, 100, 600).perform() # 键盘指令 # browser.find_element_by_tag_name(&#39;body&#39;).send_keys(Keys.CONTROL + Keys.SHIFT + &#39;J&#39;) # hover到指定元素 # ActionChains(browser).move_to_element(browser.find_elements_by_xpath(&#39;&#x2F;&#x2F;tbody[@mx-ie&#x3D;&quot;mouseover&quot;]&#x2F;tr&#39;)[1]).perform() # 页面双击操作才能获取列表 ActionChains(browser).double_click(browser.find_element_by_xpath(&quot;&#x2F;&#x2F;body&quot;)).perform() tr_list &#x3D; browser.find_elements_by_xpath(&#39;&#x2F;&#x2F;tbody[contains(@mx-ie,&quot;mouseover&quot;)]&#x2F;tr&#39;) if len(tr_list) &#x3D;&#x3D; 0: # 页面重载 browser.execute_script(&quot;location.reload()&quot;) title &#x3D; browser.find_element_by_xpath(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;title-bar&#39;]&quot;) # 鼠标移动位置 ActionChains(browser).move_to_element_with_offset(title, 100, 600).perform() # 双击 ActionChains(browser).double_click(browser.find_element_by_xpath(&quot;&#x2F;&#x2F;body&quot;)).perform() # 判断元素属性是否包含 tr_list &#x3D; browser.find_elements_by_xpath(&#39;&#x2F;&#x2F;tbody[contains(@mx-ie,&quot;mouseover&quot;)]&#x2F;tr&#39;) # 滚轮直接滑到底部 browser.execute_script(&quot;window.scrollTo(0,document.body.scrollHeight);&quot;) 查找元素1234567891011121314151617181920212223# 通过不同的方式查找界面元素def findElement(by, value): if (by &#x3D;&#x3D; &quot;id&quot;): element &#x3D; browser.find_element_by_id(value) return element elif (by &#x3D;&#x3D; &quot;name&quot;): element &#x3D; browser.find_element_by_name(value) return element elif (by &#x3D;&#x3D; &quot;xpath&quot;): element &#x3D; browser.find_element_by_xpath(value) return element elif (by &#x3D;&#x3D; &quot;classname&quot;): element &#x3D; browser.find_element_by_class_name(value) return element elif (by &#x3D;&#x3D; &quot;css&quot;): element &#x3D; browser.find_element_by_css_selector(value) return element elif (by &#x3D;&#x3D; &quot;link_text&quot;): element &#x3D; browser.find_element_by_link_text(value) return element else: print(&quot;无对应方法，请检查&quot;) return None 元素存在123456789101112from selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdef is_element_present(locator): wait &#x3D; WebDriverWait(browser, 2) try: # 显式等待 wait.until(EC.visibility_of_element_located(locator)) except TimeoutException: return False return Trueis_element_present((By.XPATH, &#39;&#x2F;&#x2F;*[@id&#x3D;\\&quot;sufei-dialog-content\\&quot;]&#39;)) 点击元素1234567def move_element_click(xpath): if is_element_present((By.XPATH, xpath)): ele_loc &#x3D; browser.find_element_by_xpath(xpath) browser.execute_script(&quot;arguments[0].scrollIntoView();&quot;, ele_loc) ActionChains(browser).move_to_element(ele_loc).click().perform() time.sleep(random.randint(1, 3))move_element_click(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;dialog-contentbox&#39;]&#x2F;vframe&#x2F;div&#x2F;div&#x2F;button&quot;) hover元素1234def hover(by, value): element &#x3D; findElement(by, value) ActionChains(browser).move_to_element(element).perform()hover(&quot;xpath&quot;, &#39;&#x2F;&#x2F;tbody[contains(@mx-ie,&quot;mouseover&quot;)]&#x2F;tr[&#39; + str(tr_list.index(tr) + 1) + &#39;]&#39;) 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"selenium","slug":"selenium","permalink":"http://onejane.github.io/tags/selenium/"}]},{"title":"JS逆向之红岭创投encryption","slug":"JS逆向之红岭创投encryption","date":"2021-04-19T07:13:48.000Z","updated":"2021-04-19T13:10:02.468Z","comments":true,"path":"2021/04/19/JS逆向之红岭创投encryption/","link":"","permalink":"http://onejane.github.io/2021/04/19/JS%E9%80%86%E5%90%91%E4%B9%8B%E7%BA%A2%E5%B2%AD%E5%88%9B%E6%8A%95encryption/","excerpt":"","text":"https://sso.my089.com/sso/login 抓包登录url： POST https://sso.my089.com/sso/login 参数： 12345678910111213username: 15806204095phone: encryption: e10adc3949ba59abbe56e057f20f883epassword: password2: randomPageId: dc88cc75d91f4ecaa519f232a9a66361checkCode: 4ctksession_kept: 30loginCategory: 0back_url: app_key: 16ae450f970448619c3ce7193982089eltcc: requestId: my089-21041920-0757-0529-1535-632509802406 分析搜索sso/login，进入了html页面，点击登录或者回车跳转到loginSubmit方法 搜索loginSubmit 加密方法在jQuery.md5.js中，将js整个拷出，修改得到md5方法，完成encryption的解密。 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之万创帮sign","slug":"JS逆向之万创帮sign","date":"2021-04-18T03:46:33.000Z","updated":"2021-04-25T16:03:56.516Z","comments":true,"path":"2021/04/18/JS逆向之万创帮sign/","link":"","permalink":"http://onejane.github.io/2021/04/18/JS%E9%80%86%E5%90%91%E4%B9%8B%E4%B8%87%E5%88%9B%E5%B8%AEsign/","excerpt":"","text":"https://m.wcbchina.com/invite/invite.html 抓包注册urlPOST https://m.wcbchina.com/api/userRegister/registerByInvite?rnd=0.5886187290129845 参数{“auth”:{“timestamp”:1618717702730,”sign”:”81D4F3A45B3202E33971304201135FE5”},”phone”:”15806204095”,”validateCode”:”123”,”inviteCode”:””} 分析搜索userRegister/registerByInvite，进入函数中，打上断点，发起注册请求，此刻的参数中害没有出现加密参数sign，postJson时传递了一个大json数据包括参数service,data和方法success,error 进入postJson方法，发现重组了请求地址，这就是为什么搜索api/userRegister/registerByInvite不到的原因 跟进A(a)函数，发现其中的h对象中是data参数有W()构成，W()正是构成sign的关键函数 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之5173password","slug":"JS逆向之5173password","date":"2021-04-17T02:10:40.000Z","updated":"2021-04-27T19:15:43.962Z","comments":true,"path":"2021/04/17/JS逆向之5173password/","link":"","permalink":"http://onejane.github.io/2021/04/17/JS%E9%80%86%E5%90%91%E4%B9%8B5173password/","excerpt":"","text":"抓包登录URL： POST https://passport.5173.com/?returnUrl=http%3A//www.5173.com/ 参数： 123456789smsLogin: 0userName: 15806204095password: 6a771c7ecf7ebe2c3d4c0075cdb96ae5mobileNo: smsCaptcha: category: passpod: __validationToken__: 1680e6a3947c43aea45d83e69b0d7291__validationDna__: 分析passwordpassword有32位，有可能是md5 搜索password，出现的地方太多了，懒得看，放弃。 点击登录按钮，肯定触发事件发送请求，搜索submit-btn无效结果。 搜索tnSubmit加上断点，点击登录按钮时，果然断在了这个function中，不过此刻Network面板的请求包已经发送出去了，gg了，没能拦截到https://passport.5173.com/?returnUrl=http%3a%2f%2fwww.5173.com%2f请求发送前的时间点。 再一次尝试，在加密password时肯定要获取该输入框的值，通过id获取元素的话，我们搜索#txtPass在所出现的位置都打上断点 点击登录时查看Network已经拦截在了ValidateSlide请求，还没有到登录请求 查看断点时打印o为aec712a02d8c835b92369e5d7e5494cf,并直接跳到return $[[&quot;ajax&quot;]]处，查看此时提交的data中的a[[&quot;serialize&quot;]]()为&quot;smsLogin=0&amp;userName=15806204095&amp;password=aec712a02d8c835b92369e5d7e5494cf&amp;mobileNo=&amp;smsCaptcha=&amp;category=&amp;passpod=&amp;__validationToken__=31004cd552c94687ba27d1c7258576f7&amp;__validationDna__=&quot;,其中的password就是之前打印的o参数。 由于password=o，现在只需要追踪这个o参数来源即可。往上追溯是onsubmit: function(f, o)中作为第二个参数o传递进来的，通过调用的堆栈查看上一级调用方法submitHandle。 submitHandler这段代码返回a.onsubmit(a, c)，其中c就是onsubmit: function(f, o) 中的o=password。由于a.usingTpm || a.passwordHash是true，那么这个c就是通过a.getPassword(a.pkey)获取。 进入getPassword后，this.ready &amp;&amp; this.activeTpm &amp;&amp; this.usingTpm为false，必然进入的是else中的c = hex_md5(hex_md5(c).substr(8, 16) + a);实现加密。 (c = b(&quot;#&quot; + this.passwordControlId).val()) &amp;&amp; this.passwordHash赋值必然是true，其中(c = b(&quot;#&quot; + this.passwordControlId).val())的结果为123456，即我们输入的密码，由于传入的a为42m2gl，所以加密逻辑整理为c = hex_md5(hex_md5(&quot;123456&quot;).substr(8, 16) + &quot;42m2gl&quot;) 那么问题来了，传入的a是哪里来的，通过搜索42m2gl，原来每次页面生成的时候页面会加载PasswordKey，通过PasswordKey和SecurityToken等key实现相互验证进行校验。 __validationToken____validationToken__这个字段6b16902a6b134dc9a2c333b965c9405f在请求里面无法搜到是因为页面已经刷新，通过fiddler抓包https://passport.5173.com/?returnUrl=http%3a%2f%2fwww.5173.com%2f历史可以看到首页加载时传入该参数 爬虫实现首次先请求https://passport.5173.com/?returnUrl=http%3a%2f%2fwww.5173.com%2f 获取页面中的PasswordKey的值和SecurityToken的值，通过两次md5密码hex_md5(hex_md5(&quot;123456&quot;).substr(8, 16) + &quot;42m2gl&quot;)拿到password加密结果，发起请求。 123456789101112131415161718192021222324252627282930313233343536373839404142def hex_md5(s): m &#x3D; hashlib.md5() m.update(str(s).encode(&quot;utf-8&quot;)) return m.hexdigest()headers &#x3D; &#123; &#39;Host&#39;: &#39;passport.5173.com&#39;, &#39;Origin&#39;: &#39;https:&#x2F;&#x2F;passport.5173.com&#39;, &#39;Pragma&#39;: &#39;no-cache&#39;, &#39;Referer&#39;: &#39;https:&#x2F;&#x2F;passport.5173.com&#x2F;?returnUrl&#x3D;http%3A&#x2F;&#x2F;www.5173.com&#x2F;&#39;, &#39;Sec-Fetch-Mode&#39;: &#39;cors&#39;, &#39;Sec-Fetch-Site&#39;: &#39;same-origin&#39;, &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;78.0.3904.70 Safari&#x2F;537.36&#39;, &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;,&#125;login_url &#x3D; &#39;https:&#x2F;&#x2F;passport.5173.com&#x2F;?returnUrl&#x3D;http%3A&#x2F;&#x2F;www.5173.com&#x2F;&#39;html &#x3D; requests.get(login_url).text# print(html)securityToken &#x3D; re.findall(&#39;SecurityToken:&quot;(.*?)&quot;,&#39;, html, re.M | re.S)[0]passwordKey &#x3D; re.findall(&#39;PasswordKey:&quot;(.*?)&quot;,&#39;, html, re.M | re.S)[0]print(passwordKey)print(securityToken)# 滑块 &#39;https:&#x2F;&#x2F;passport.5173.com&#x2F;Sso&#x2F;ValidateSlide?token&#x3D;&#123;&#125;&#39;.format(securityToken)# hex_md5(hex_md5(&quot;123456&quot;).substr(8, 16) + &quot;42m2gl&quot;)password &#x3D; hex_md5(hex_md5(&quot;123456&quot;)[8:8 + 16] + passwordKey)userName &#x3D; &#39;15806204096&#39;data &#x3D; &#123; &#39;smsLogin&#39;: &#39;0&#39;, &#39;userName&#39;: userName, &#39;password&#39;: password, &#39;mobileNo&#39;: &#39;&#39;, &#39;smsCaptcha&#39;: &#39;&#39;, &#39;category&#39;: &#39;&#39;, &#39;passpod&#39;: &#39;&#39;, &#39;__validationToken__&#39;: securityToken, &#39;__validationDna__&#39;: &#39;&#39;&#125;r &#x3D; requests.post(login_url, data, headers&#x3D;headers)print(r.text) 虽然password逻辑已经破解，不过登录时还需要验证码滑块的校验，以后有时间再写吧。。。","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之金逸电影params","slug":"JS逆向之金逸电影params","date":"2021-04-17T00:10:27.000Z","updated":"2021-04-17T02:13:15.751Z","comments":true,"path":"2021/04/17/JS逆向之金逸电影params/","link":"","permalink":"http://onejane.github.io/2021/04/17/JS%E9%80%86%E5%90%91%E4%B9%8B%E9%87%91%E9%80%B8%E7%94%B5%E5%BD%B1params/","excerpt":"","text":"http://www.jycinema.com/wap/#/register 抓包登录url: POST http://www.jycinema.com/frontUIWebapp/appserver/photoMessageService/newsSendMessage 参数： params:ey622Jt557b2114Jp469bG373VO310dW8741i248ZX535Ii076Oi988Ix997NT571gw811Nj907Iw911ND991A5893NS763Is198In627Nl690bm498RU398eX141Bl991Ij727oi670cm475Vn649Ii854wi037Y2151hh831bm4625l109bE023lk146Ij946o3769LC284Jj066aG622Fu333bm353Vs667Q26149k642ZS856I6624Ik524ow241MD637A1091Ii342wi356bW787Vt825Ym215Vy105SW604Qi506Oi857Ii850fQ497==152 分析ey开头是base64中的{，fq是base64中的}，有可能是base64加密 搜索photoMessageService/newsSendMessage 定义了sendMg属性，那么必定被调用才发起请求，搜索.sendMg 点击获取验证码,请求参数中$scope.registerData.tel就是我们提交的手机号，那么加密必然是在getData中 跟进getData后对params进行处理生成{&quot;mobileNumber&quot;:&quot;15806204095&quot;,&quot;sendType&quot;:&quot;reg&quot;,&quot;channelId&quot;:7,&quot;channelCode&quot;:&quot;J0005&quot;,&quot;memberId&quot;:&quot;&quot;} 并发现了密码加密的函数，在下方通过$rootScope.getEncryption(params.params)调用生成密码。 由于Base64.encode有utf-8乱码问题，无法直接使用，var re_btou = new RegExp([&quot;[À-ß][-¿]&quot;, &quot;[à-ï][-¿]{2}&quot;, &quot;[ð-÷][-¿]{3}&quot;].join(&quot;|&quot;),&quot;g&quot;);通过base64.js源码提供Base64.encode(value)实现params加密关键函数getEncryption。 爬虫实现由于个人的js学的太孬了，在python调用js时报错execjs._exceptions.ProgramError: ReferenceError: Base64 is not defined,那么我只能避开，使用python实现base64加密并作为参数传入调用getEncryption。 1234567891011121314151617181920212223242526272829303132import jsonimport requestsimport execjsimport base64from requests_toolbelt import MultipartEncoderusername &#x3D; &quot;15806204095&quot;psssword &#x3D; &quot;123456&quot;with open(r&#39;jy_params.js&#39;, encoding&#x3D;&#39;utf-8&#39;, mode&#x3D;&#39;r&#39;) as f: JsData &#x3D; f.read()param &#x3D; &#123;&quot;mobileNumber&quot;: &quot;15806204095&quot;, &quot;sendType&quot;: &quot;reg&quot;, &quot;channelId&quot;: 7, &quot;channelCode&quot;: &quot;J0005&quot;, &quot;memberId&quot;: &quot;&quot;&#125;val &#x3D; base64.b64encode(json.dumps(param).encode())params &#x3D; execjs.compile(JsData).call(&#39;getEncryption&#39;, val.decode())print(params)headers &#x3D; &#123; &#39;Accept&#39;: &#39;application&#x2F;json, text&#x2F;plain, *&#x2F;*&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept-Language&#39;: &#39;zh-CN,zh;q&#x3D;0.9&#39;, &#39;Content-Length&#39;: &#39;341&#39;, &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8&#39;, &#39;Cookie&#39;: &#39;JSESSIONID&#x3D;DD188088D4E4EAC0098C9CCBCC32E52F; Hm_lvt_62d04228e1f84e012c1d9c0227f722c3&#x3D;1618618136; Hm_lpvt_62d04228e1f84e012c1d9c0227f722c3&#x3D;1618618136&#39;, &#39;Host&#39;: &#39;www.jycinema.com&#39;, &#39;Origin&#39;: &#39;http:&#x2F;&#x2F;www.jycinema.com&#39;, &#39;Proxy-Connection&#39;: &#39;keep-alive&#39;, &#39;Referer&#39;: &#39;http:&#x2F;&#x2F;www.jycinema.com&#x2F;wap&#x2F;&#39;, &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Linux; Android 6.0; Nexus 5 Build&#x2F;MRA58N) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;90.0.4430.72 Mobile Safari&#x2F;537.36&#39;,&#125;data &#x3D; &#123;&#39;params&#39;: params&#125;r &#x3D; requests.post(&quot;http:&#x2F;&#x2F;www.jycinema.com&#x2F;frontUIWebapp&#x2F;appserver&#x2F;photoMessageService&#x2F;newsSendMessage&quot;, data, headers&#x3D;headers)print(r.text) {“msg”:”短信发送成功”,”count”:0,”status”:”S”} 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"违法应用fulao2取证分析","slug":"违法应用fulao2取证分析","date":"2021-04-15T00:08:51.000Z","updated":"2021-04-21T14:33:33.262Z","comments":true,"path":"2021/04/15/违法应用fulao2取证分析/","link":"","permalink":"http://onejane.github.io/2021/04/15/%E8%BF%9D%E6%B3%95%E5%BA%94%E7%94%A8fulao2%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/","excerpt":"","text":"vip破解adb install -r -t fulao2.apk 通过jadx查询已经被混淆 hookEvent.js实现trace系统框架库android.view.View快速定位关键代码，trace所有的mOnClickListener，hook它们的onClick函数，实现点到哪里，定位到哪个类的功能。 前台运行fulao2.apk后，frida -UF -l hookEvent.js 启动hook 清晰度切换点击切换高清标清按钮，触发了发现在q0时的com.ilulutv.fulao2.film.l$t类，根据获取的类名进入jadx中搜索t，实现bool判断，下面我们手动将内存中的q0改成true。 12345pyenv local 3.8.0 objection -g com.ilulutv.fulao2 explore -P ~&#x2F;.objection&#x2F;pluginsplugin wallbreaker classdump --fullname com.ilulutv.fulao2.film.l\\$tplugin wallbreaker objectsearch com.ilulutv.fulao2.film.l\\$tplugin wallbreaker objectdump --fullname 0x26a2 获取到com.ilulutv.fulao2.film.l的对象实例 1plugin wallbreaker objectdump --fullname 0x2406 拿到内存中的对象数据 通过内存漫游修改q0的False的默认值，frida -UF -l fulao2.js 1234567891011121314151617181920212223function hookq0()&#123; Java.perform(function()&#123; Java.choose(&quot;com.ilulutv.fulao2.film.l&quot;,&#123; onMatch:function(ins)&#123; if(ins.e0.value)&#123; ins.q0.value &#x3D; true &#x2F;* if(ins.e0.value.toString().indexOf(&quot;宝宝睡&quot;)&gt;0)&#123; console.log(&quot;e0 value is :&quot;, ins.e0.value); &#x2F;&#x2F;ins.q0.value &#x3D; Java.use(&quot;java.lang.Boolean&quot;).\\$new(&quot;true&quot;); &#x2F;&#x2F;ins.q0.value &#x3D; true &#125; *&#x2F; &#125; &#125;,onComplete:function()&#123; console.log(&quot;search complete!&quot;) &#125; &#125;) &#125;)&#125;setImmediate(hookq0) android hooking search classes Boolean 获取Boolean类全路径java.lang.Boolean 重新调用plugin wallbreaker objectdump –fullname 0x2406 查看q0的值 这样就实现了标清切换高清的功能，破解了vip的切换视频清晰度。这种基于本地代码判断容易破解，基于服务器判断就只能根据逻辑漏洞判断。可以通过setInterval实现不断在内存循环调用，将内存中所有实例的q0改成true。 线路切换frida -UF -l hookEvent.js attach模式 frida -U -f com.ilulutv.fulao2 -l hookEvent.js –no-pause spawn模式一开始把所有View的OnClick类hook上，不用从内存中枚举 点击线路切换按钮，触发了com.ilulutv.fulao2.film.l$s和com.ilulutv.fulao2.film.l$m类方法 通过jadx查看这两个类方法 由于com.ilulutv.fulao2.film.l$s和之前的com.ilulutv.fulao2.film.l$t类似，都是以q0判断，不过没有生效，现在关注com.ilulutv.fulao2.film.l$m中的OnClick里的i方法 查看jadx的i方法 进入g()方法 通过hook androidx.fragment.app.Fragment.g方法，点击切换高清1的线路按钮，触发并返回了调用栈 登录抓包frida -UF -l hookSocket.js -o login.txt 所有内容包括手机号全部加密，除了一些请求头，gzip协议头关键字是1f 8b ，包括视频 图片都是加密的 图片下载12android hooking search classes ImageViewplugin wallbreaker objectsearch android.widget.ImageView 1234plugin wallbreaker classsearch bitmapandroid hooking search classes bitmap 将所有相关类保存到file.txt中，sed -i -e &#39;s&#x2F;^&#x2F;android hooking watch class &#x2F;&#39; file.txtobjection -g com.ilulutv.fulao2 explore -c file.txt 批量hookplugin wallbreaker objectsearch android.graphics.Bitmap Java.choose属于内存的搜刮，将现有内存的Bigmap对象实例保存，基于hook的话可以将未来持续增长的setInterval定时保存一份内存中的图片setInterval(main,5*1000) 1android hooking watch class_method android.graphics.BitmapFactory.decodeByteArray --dump-args --dump-backtrace --dump-return 通过批量hook拿到下拉触发的方法进行hook打印堆栈，glide是流式图片展示的框架 通过jadx搜索com.ilulutv.fulao2.other.helper.glide.b.a，decodeByteArray应该是解密开始了，返回b2应该就是明文。 开始hook Base64系统库，因为系统库不可能被混淆，下拉加载图片发现确实经过了android.util.Base64.encodeToString 1android hooking watch class_method android.util.Base64.encodeToString --dump-args --dump-backtrace --dump-return frida -UF -l fulao2.js -o /root/raw.txt 通过hook发现Base64.encodeToString得到的和SSLOutputStream得到的数据流一致 12345678910111213141516171819202122232425262728293031323334353637function hookImageByteCiphered()&#123; # 传输中的流 Java.perform(function()&#123; Java.use(&quot;android.util.Base64&quot;).encodeToString.overload(&#39;[B&#39;, &#39;int&#39;).implementation &#x3D; function(bytearray,int)&#123; var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;IMAGE DATA:bytearray,int&#x3D;&gt;&quot;,ByteString.of(bytearray).hex(),int) var result &#x3D; this.encodeToString(bytearray,int) return result; &#125; &#125;)&#125;function hook_SSLsocketandroid8()&#123; Java.perform(function()&#123; console.log(&quot;hook_SSLsocket&quot;) Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket\\$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTPS write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;HTTPS bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) &#x2F;&#x2F;console.log(jhexdump(bytearry,int1,int2)); console.log(jhexdump(bytearry)); return result; &#125; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket\\$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTPS read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;HTTPS bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) &#x2F;&#x2F;console.log(jhexdump(bytearry,int1,int2)); &#x2F;&#x2F;console.log(jhexdump(bytearry)); return result; &#125; &#125;)&#125; 说明com.ilulutv.fulao2.other.i.b.a((ByteBuffer) obj)确实是https传输的流，也是加密前的流，ffd8ff 是png文件头，通过后面的代码实现解密。 12android hooking search classes BitmapFactoryandroid hooking watch class_method android.graphics.BitmapFactory.decodeByteArray --dump-args --dump-backtrace --dump-return 开始hook BitmapFactory.decodeByteArray(b2, 0, b2.length) frida -UF -l fulao2.js 12345678910111213141516171819202122function hookImage()&#123; Java.perform(function()&#123; Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory\\$Options&#39;) .implementation &#x3D; function(data, offset, length, opts)&#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); &#x2F;&#x2F;console.log(&quot;data, offset, length, opts&#x3D;&gt;&quot;,data, offset, length, opts) &#x2F;&#x2F;console.log(&quot;IMAGE DATA:bytearray,int&#x3D;&gt;&quot;,ByteString.of(data).hex()) var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot;+guid()+&quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;,path) var file &#x3D; Java.use(&quot;java.io.File&quot;).\\$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).\\$new(file); fos.write(data); fos.close(); fos.close(); return result; &#125; &#125;)&#125; python调用保存fulao2.js 将解密后的字节数组发送给python，二进制写入图片 12345678910function hookImage()&#123; Java.perform(function()&#123; Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory\\$Options&#39;) .implementation &#x3D; function(data, offset, length, opts)&#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); send(data) return result; &#125; &#125;)&#125; 调用fulao2.js发送到本机 123456789101112131415161718192021222324252627282930313233343536373839import fridaimport jsonimport timeimport uuidimport base64import redef my_message_handler(message, payload): print(message) print(payload) if message[&quot;type&quot;] &#x3D;&#x3D; &quot;send&quot;: print(message[&quot;payload&quot;]) #image &#x3D; re.findall(&quot;(-?\\d+)&quot;, message[&quot;payload&quot;]) image &#x3D; message[&quot;payload&quot;] intArr &#x3D; [] for m in image: ival &#x3D; int(m) if ival &lt; 0: ival +&#x3D; 256 intArr.append(ival) bs &#x3D; bytes(intArr) fileName &#x3D; str(uuid.uuid1()) + &quot;.jpg&quot; f &#x3D; open(fileName,&#39;wb&#39;) f.write(bs) f.close() device &#x3D; frida.get_usb_device()target &#x3D; device.get_frontmost_application()session &#x3D; device.attach(target.pid)# 加载脚本with open(&quot;fulao2.js&quot;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot; , my_message_handler) #调用错误处理script.load()# 脚本会持续运行等待输入input() 不能够以战术的勤奋，掩盖战略的懒惰。 大多数人努力的程度还谈不上拼天分。 脱机二进制写入图片12objection -g com.ilulutv.fulao2 explore -P ~&#x2F;.objection&#x2F;pluginsandroid hooking watch class_method android.graphics.BitmapFactory.decodeByteArray --dump-args --dump-backtrace --dump-return hook解密方法，下拉获取调用栈 jadx搜索com.ilulutv.fulao2.other.helper.glide.b.a，抓包抓到的二进制数据流是encodeToString之前的b.a返回的数据，可以将协议中内容直接解密，不需要app参与，可以直接hook收发包 1android hooking watch class_method com.ilulutv.fulao2.other.i.b.a --dump-args --dump-backtrace --dump-return 下拉加载图片，关注Hooking com.ilulutv.fulao2.other.i.b.a(java.nio.ByteBuffer)，可以看到其他协议的解密也通过这个方法 由于返回是[object Object]，看不出结果还是通过hook实现吧。尽量不要用hookImageByteCiphered，因为其他类可能也用到了Base64 12345678910function hookImageByteCiphered() &#123; Java.perform(function () &#123; Java.use(&quot;android.util.Base64&quot;).encodeToString.overload(&#39;[B&#39;, &#39;int&#39;).implementation &#x3D; function (bytearray, int) &#123; var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;IMAGE DATA:bytearray,int&#x3D;&gt;&quot;, ByteString.of(bytearray).hex(), int) var result &#x3D; this.encodeToString(bytearray, int) return result; &#125; &#125;)&#125; 通过hook ByteBuffer获取com.ilulutv.fulao2.other.i.b.a 的入参实现hook com.ilulutv.fulao2.other.i.b.a((ByteBuffer) obj) 12345678910111213function hookByteBuffer() &#123; Java.perform(function () &#123; Java.use(&quot;com.ilulutv.fulao2.other.i.b&quot;).a.overload(&#39;java.nio.ByteBuffer&#39;).implementation &#x3D; function (bf) &#123; var result &#x3D; this.a(bf) &#x2F;&#x2F; [b &#x2F;&#x2F;var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) &#x2F;&#x2F;console.log(&quot;result is &#x3D;&gt; &quot;,result); send(result) &#x2F;&#x2F;console.log( gson.$new().toJson(result)) return result; &#125; &#125;)&#125; frida -UF -l fulao2.js 下拉显示图片，将打印返回的字节数组的结果，通过python实现解密后结果用于脱机处理。 通过hook byte[] b2 = com.ilulutv.fulao2.other.i.b.b(decode, Base64.decode(bytes2, 0), encodeToString);中的com.ilulutv.fulao2.other.i.b.b android hooking list class_methods com.ilulutv.fulao2.other.i.b 获取需要hook的方法 android hooking watch class_method net.idik.lib.cipher.so.CipherClient.decodeImgKey –dump-args –dump-backtrace –dump-return 获取hook的返回 android hooking search classes base64 获取android.util.Base64方法 123456789101112131415function hookdecodeimgkey() &#123; Java.perform(function () &#123; var base64 &#x3D; Java.use(&quot;android.util.Base64&quot;) Java.use(&quot;com.ilulutv.fulao2.other.i.b&quot;).b.overload(&#39;[B&#39;, &#39;[B&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function (key, iv, image) &#123; var result &#x3D; this.b(key, iv, image); console.log(&quot;key&quot;, base64.encodeToString(key, 0)); console.log(&quot;iv&quot;, base64.encodeToString(iv, 0)); return result; &#125; &#125;) &#x2F;* key svOEKGb5WD0ezmHE4FXCVQ&#x3D;&#x3D; iv 4B7eYzHTevzHvgVZfWVNIg&#x3D;&#x3D; *&#x2F;&#125; frida -UF -l fulao2.js 下拉加载图片 查看加密方式com.ilulutv.fulao2.other.i.b.b python实现解密 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pycrypto 1234567891011121314151617def IMGdecrypt(bytearray): imgkey &#x3D; base64.decodebytes( bytes(&quot;svOEKGb5WD0ezmHE4FXCVQ&#x3D;&#x3D;&quot;, encoding&#x3D;&#39;utf8&#39;)) imgiv &#x3D; base64.decodebytes( bytes(&quot;4B7eYzHTevzHvgVZfWVNIg&#x3D;&#x3D;&quot;, encoding&#x3D;&#39;utf8&#39;)) cipher &#x3D; AES.new(imgkey, AES.MODE_CBC, imgiv) # enStr +&#x3D; (len(enStr) % 4)*&quot;&#x3D;&quot; # decryptByts &#x3D; base64.urlsafe_b64decode(enStr) msg &#x3D; cipher.decrypt(bytearray) def unpad(s): return s[0:-s[-1]] return unpad(msg)# 拿到数据后Base64解密bs &#x3D; IMGdecrypt(bs) 将比较耗性能的加解密计算放到电脑端处理，减少了手机端的资源损耗，实现脱机处理。抓包后直接使用以上算法解码。 查看BitmapFactory.decodeByteArray返回的类型 12android hooking search classes Bitmapandroid hooking list class_methods android.graphics.Bitmap 123456789101112131415161718192021222324function getObjClassName(obj) &#123; if (!jclazz) &#123; var jclazz &#x3D; Java.use(&quot;java.lang.Class&quot;); &#125; if (!jobj) &#123; var jobj &#x3D; Java.use(&quot;java.lang.Object&quot;); &#125; return jclazz.getName.call(jobj.getClass.call(obj));&#125;function hookImage()&#123; Java.perform(function()&#123; Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory$Options&#39;) .implementation &#x3D; function(data, offset, length, opts)&#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) console.log(&quot;result is &#x3D;&gt;&quot;,gson.$new().toJson(result)) &#x2F;&#x2F; 打印BitmapFactory对象属性，说明BitmapFactory.decodeByteArray返回对象 console.log(&quot;className is &#x3D;&gt;&quot;,getObjClassName(result)) console.log(&#39;Object.getOwnPropertyNames()&#x3D;&gt;&#39;,Object.getOwnPropertyNames(result.$className)) return result; &#125; &#125;)&#125; 安卓保存图片12android hooking search classes CompressFormatplugin wallbreaker classdump --fullname android.graphics.Bitmap$CompressFormat frida -UF -l fulao2.js 123456789101112131415161718192021222324function hookImage()&#123; Java.perform(function()&#123; Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory$Options&#39;) .implementation &#x3D; function(data, offset, length, opts)&#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot; + guid() + &quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;, path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); result.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value, 100, fos) console.log(&quot;success!&quot;) fos.flush(); fos.close(); return result; &#125; &#125;)&#125; 多线程保存创建线程com.onejane.runnable，android hooking search classes onejane 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788function hookImage() &#123; Java.perform(function () &#123; var Runnable &#x3D; Java.use(&quot;java.lang.Runnable&quot;); var saveImg &#x3D; Java.registerClass(&#123; name: &quot;com.onejane.runnable&quot;, implements: [Runnable], fields: &#123; bm: &quot;android.graphics.Bitmap&quot;, &#125;, methods: &#123; $init: [&#123; returnType: &quot;void&quot;, argumentTypes: [&quot;android.graphics.Bitmap&quot;], implementation: function (bitmap) &#123; this.bm.value &#x3D; bitmap; &#125; &#125;], run: function () &#123; var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot; + guid() + &quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;, path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); this.bm.value.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value, 100, fos) console.log(&quot;success!&quot;) fos.flush(); fos.close(); &#125; &#125; &#125;); Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory$Options&#39;).implementation &#x3D; function (data, offset, length, opts) &#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); &#x2F;&#x2F;var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) &#x2F;&#x2F;send(data) &#x2F;&#x2F;send(gson.$new().toJson(data)) &#x2F;&#x2F;console.log(&quot;data, offset, length, opts&#x3D;&gt;&quot;,data, offset, length, opts) &#x2F;&#x2F;console.log(&quot;IMAGE DATA:bytearray,int&#x3D;&gt;&quot;,ByteString.of(data).hex()) &#x2F;* var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot;+guid()+&quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;,path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); fos.write(data); fos.flush(); fos.close(); *&#x2F; &#x2F;*var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) console.log(&quot;result is &#x3D;&gt;&quot;,gson.$new().toJson(result)) # 打印BitmapFactory对象属性，说明BitmapFactory.decodeByteArray返回 console.log(&quot;className is &#x3D;&gt;&quot;,getObjClassName(result)) console.log(&#39;Object.getOwnPropertyNames()&#x3D;&gt;&#39;,Object.getOwnPropertyNames(result.$className))*&#x2F; &#x2F;* var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot; + guid() + &quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;, path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); result.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value, 100, fos) console.log(&quot;success!&quot;) fos.flush(); fos.close(); *&#x2F; var runnable &#x3D; saveImg.$new(result); runnable.run() return result; &#125; &#125;)&#125; so分析CipherClient类中所有的返回都是CipherCore.get 而CipherCore又加载了cipher-lib的so库 1234objection -g com.ilulutv.fulao2 explore -P ~&#x2F;.objection&#x2F;pluginsmemory list modules 搜索cipher-libls -alt &#x2F;data&#x2F;app&#x2F;com.ilulutv.fulao2-6tvMrrptF1h1A4NvQbV85A&#x3D;&#x3D;&#x2F;lib&#x2F;arm&#x2F;memory list exports libcipher-lib.so 查看该so中有哪些导出函数 其中的getString对应了private static native String getString(String str); 1cp libcipher-lib.so &#x2F;sdcard&#x2F;Download&#x2F; 取出so后丢到IDA中分析 通过jnitrace trace下所有native的执行流。 1234.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs1428arm64 pyenv local 3.8.5pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple jnitracejnitrace -m attach -l libcipher-lib.so com.ilulutv.fulao2 下拉加载图片 查看trace的调用栈,默认是spawn so层再次调用java层方法AESEncryptor 1android hooking watch class net.idik.lib.cipher.so.encrypt.AESEncryptor 下拉图片加载，虽然到native进行转化，但是啥也没干，重新从java层调用加解密 由于每次hook时app总是崩掉，objection在app启动时直接执行hook方法 1objection -g com.ilulutv.fulao2 explore -P ~&#x2F;.objection&#x2F;plugins -s &quot;android hooking watch class_method net.idik.lib.cipher.so.encrypt.AESEncryptor.decrypt --dump-args --dump-backtrace --dump-return&quot; 堆栈说明确实从native层到了java层","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"JS逆向之爱拍password","slug":"js逆向之爱拍password","date":"2021-04-13T02:33:44.000Z","updated":"2021-05-01T07:40:46.706Z","comments":true,"path":"2021/04/13/js逆向之爱拍password/","link":"","permalink":"http://onejane.github.io/2021/04/13/js%E9%80%86%E5%90%91%E4%B9%8B%E7%88%B1%E6%8B%8Dpassword/","excerpt":"","text":"http://www.aipai.com/ 抓包登录url： POST http://www.aipai.com/login.php 参数： 123456action: loginNewuser: 15806204095password: 202cb962ac59075b964b07152d234b70keeplogin: 1comouterTime: 1userNowTime: 1618281089 分析参数中只有password加密，搜索/login.php,出现在了sea.js,header.js?t=20210312,global.js的多个地方中 逐步分析各个位置的/login.php,初步定位到两个地方的js处可能是加密password 的位置，因为这两处附近都有user,action等其他参数生成。 这两处同样的通过md5函数加密password所在id的内容，我们为这两处加上断点，重新登录发现停在了header.js?t=20210312 F10单步逐行跳过到metadata=&#39;action=&#39;+ action +&#39;&amp;account=&#39;+ user +&#39;&amp;password=&#39;+ _ts.md5(pass) +&#39;&amp;keeplogin=&#39;+ keep +&#39;&amp;comouterTime=&#39;+ keep +&#39;&amp;userNowTime=&#39;+ userNowTime; 通过Watch面板拿到idPass，pass和_ts.md5(pass)的值 点击进入md5方法，打上断点后，F9单步跳入后抠出md5算法js 爬虫实现通过python调用js实现password的逆向分析。 1234567891011121314151617181920import requestsimport execjsusername &#x3D; &quot;15806204095&quot;password &#x3D; &quot;123&quot;with open(r&#39;aipai_password.js&#39;, encoding&#x3D;&#39;utf-8&#39;, mode&#x3D;&#39;r&#39;) as f: JsData &#x3D; f.read()password &#x3D; execjs.compile(JsData).call(&#39;pwd&#39;, password)print(password)data &#x3D; &#123; &#39;action&#39;: &#39;loginNew&#39;, &#39;user&#39;: username, &#39;password&#39;: password, &#39;keeplogin&#39;: &#39;1&#39;, &#39;comouterTime&#39;: &#39;1&#39;, &#39;userNowTime&#39;: &#39;1618281089&#39;,&#125;r &#x3D; requests.post(&quot;http:&#x2F;&#x2F;www.aipai.com&#x2F;login.php&quot;, data)print(r.text) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之拉勾password","slug":"js逆向之拉勾password","date":"2021-04-12T11:43:44.000Z","updated":"2021-05-01T07:40:46.700Z","comments":true,"path":"2021/04/12/js逆向之拉勾password/","link":"","permalink":"http://onejane.github.io/2021/04/12/js%E9%80%86%E5%90%91%E4%B9%8B%E6%8B%89%E5%8B%BEpassword/","excerpt":"","text":"https://www.lagou.com/ 抓包登录url: GET https://passport.lagou.com/login/login.json 参数： 1234567jsoncallback: jQuery11130510950445912626_1618227551741isValidate: trueusername: 15806204095password: 990eb670f81e82f546cfaaae1587279arequest_form_verifyCode: challenge: c7a96a290ed4d75ca2a8bf139172dbe0_: 1618227551745 分析参数中password和challenge看起来是加密参数，其实challenge是极验验证码请求的参数，本文针对password进行参数分析，暂时先不做讨论。 搜索login/login.json并格式化js后，发现改password通过md5实现加密，在Watch界面输入g查看g的内容 放行程序后，在g.isValidate &amp;&amp; (g.password = md5(g.password)处重新打上断点并登录 那么分析得出password=md5(“veenike”+md5(passwrod)+”veenike”) 爬虫实现12345678910import requestsfrom hashlib import md5username &#x3D; &#39;15806204095&#39;pwd &#x3D; &#39;123&#39;md5_pwd &#x3D; md5((&quot;veenike&quot; + md5(pwd.encode(&#39;utf8&#39;)).hexdigest() + &quot;veenike&quot;).encode(&quot;utf8&quot;)).hexdigest()print(md5_pwd)url &#x3D; &#39;https:&#x2F;&#x2F;passport.lagou.com&#x2F;login&#x2F;login.json?jsoncallback&#x3D;jQuery111306946515748870927_1618229101639&amp;isValidate&#x3D;true&amp;username&#x3D;&#39;+username+&#39;&amp;password&#x3D;+&#39;+md5_pwd+&#39;+&amp;request_form_verifyCode&#x3D;&amp;challenge&#x3D;c3bebcad0648898aa58cb3f4dbf2f820&amp;_&#x3D;1618229101642&#39;r &#x3D;requests.get(url)print(r.text) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之中关村在线pwd","slug":"js逆向之中关村在线pwd","date":"2021-04-12T03:19:07.000Z","updated":"2021-05-01T07:40:46.695Z","comments":true,"path":"2021/04/12/js逆向之中关村在线pwd/","link":"","permalink":"http://onejane.github.io/2021/04/12/js%E9%80%86%E5%90%91%E4%B9%8B%E4%B8%AD%E5%85%B3%E6%9D%91%E5%9C%A8%E7%BA%BFpwd/","excerpt":"","text":"https://www.zol.com.cn/ 抓包本登录页面既然是框架，找到php页面，https://service.zol.com.cn/user/siteLogin.php?type=small&amp;callback=userLoginCallback&amp;backurl=https://www.zol.com.cn/ 直接访问该php网址，避免其他请求干扰分析 登录url: POST https://service.zol.com.cn/user/ajax/siteLogin/login.php 请求头： 12345678910111213141516:authority: service.zol.com.cn:method: POST:path: &#x2F;user&#x2F;ajax&#x2F;siteLogin&#x2F;login.php:scheme: httpsaccept: application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01accept-encoding: gzip, deflate, braccept-language: zh-CN,zh;q&#x3D;0.9content-length: 138content-type: application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8cookie: ip_ck&#x3D;5cKC7&#x2F;vxj7QuMjUzODE2LjE2MTgxOTc3OTM%3D; lv&#x3D;1618197793; vn&#x3D;1; Hm_lvt_ae5edc2bc4fc71370807f6187f0a2dd0&#x3D;1618197793; questionnaire_pv&#x3D;1618185602; Hm_lpvt_ae5edc2bc4fc71370807f6187f0a2dd0&#x3D;1618197883origin: https:&#x2F;&#x2F;service.zol.com.cnreferer: https:&#x2F;&#x2F;service.zol.com.cn&#x2F;user&#x2F;siteLogin.php?type&#x3D;small&amp;callback&#x3D;userLoginCallback&amp;backurl&#x3D;https:&#x2F;&#x2F;www.zol.com.cn&#x2F;sec-fetch-mode: corssec-fetch-site: same-originuser-agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;78.0.3904.70 Safari&#x2F;537.36x-requested-with: XMLHttpRequest 参数： 1234567userid: 15806204096pwd: 74ce2ba17b2c218246e778fb5e895c95isAuto: 1backurl: http:&#x2F;&#x2F;www.zol.com.cn&#x2F;tmallBtn: 0activeBtn: 0headPicid: 0 分析全局搜索siteLogin/login.php 中关村非常的耿直，加密使用md5,var md5Password = CryptoJS.MD5(password+&quot;zol&quot;) + &#39;&#39;;输入123提交的pwd为74ce2ba17b2c218246e778fb5e895c95，通过md5比对 爬虫实现拷贝Form Data到请求头加引号.py中自动生成dict格式 12345678910111213141516171819import requestsfrom hashlib import md5username &#x3D; &#39;15806204095&#39;pwd &#x3D; &#39;123&#39;md5_pwd &#x3D; md5((pwd + &#39;zol&#39;).encode(&#39;utf8&#39;)).hexdigest()print(md5_pwd)url &#x3D; &#39;https:&#x2F;&#x2F;service.zol.com.cn&#x2F;user&#x2F;ajax&#x2F;siteLogin&#x2F;login.php&#39;data &#x3D; &#123; &#39;userid&#39;: username, &#39;pwd&#39;: md5_pwd, &#39;isAuto&#39;: &#39;1&#39;, &#39;backurl&#39;: &#39;http:&#x2F;&#x2F;www.zol.com.cn&#x2F;&#39;, &#39;tmallBtn&#39;: &#39;0&#39;, &#39;activeBtn&#39;: &#39;0&#39;, &#39;headPicid&#39;: &#39;0&#39;,&#125;r &#x3D;requests.post(url,data)print(r.text) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之融金所sign","slug":"js逆向之融金所sign","date":"2021-04-11T02:20:26.000Z","updated":"2021-05-01T07:40:46.711Z","comments":true,"path":"2021/04/11/js逆向之融金所sign/","link":"","permalink":"http://onejane.github.io/2021/04/11/js%E9%80%86%E5%90%91%E4%B9%8B%E8%9E%8D%E9%87%91%E6%89%80sign/","excerpt":"","text":"https://m.rjs.com/member/user.html#1 抓包登录url: POST https://m.rjs.com/japi/account/login.json 请求头： 12345678910111213141516171819:authority: m.rjs.com:method: POST:path: &#x2F;japi&#x2F;account&#x2F;login.json:scheme: httpsaccept: application&#x2F;json, text&#x2F;plain, *&#x2F;*accept-encoding: gzip, deflate, braccept-language: zh-CN,zh;q&#x3D;0.9content-length: 172content-type: application&#x2F;jsoncookie: riskTipTimes1&#x3D;1; Hm_lvt_7ff1e43d61e6b35b46f6bb33c3aba9bb&#x3D;1618099071; Hm_lpvt_7ff1e43d61e6b35b46f6bb33c3aba9bb&#x3D;1618099071datatype: jsonorigin: https:&#x2F;&#x2F;m.rjs.comreferer: https:&#x2F;&#x2F;m.rjs.com&#x2F;member&#x2F;user.htmlsec-ch-ua: &quot;Google Chrome&quot;;v&#x3D;&quot;89&quot;, &quot;Chromium&quot;;v&#x3D;&quot;89&quot;, &quot;;Not\\&quot;A\\\\Brand&quot;;v&#x3D;&quot;99&quot;sec-ch-ua-mobile: ?1sec-fetch-dest: emptysec-fetch-mode: corssec-fetch-site: same-originUser-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;50.0.2661.87 Safari&#x2F;537.36 参数： 1&#123;&quot;platform&quot;:&quot;wap&quot;,&quot;session_token&quot;:&quot;&quot;,&quot;session_id&quot;:&quot;&quot;,&quot;data&quot;:&#123;&quot;userName&quot;:&quot;15806204085&quot;,&quot;password&quot;:&quot;123&quot;&#125;,&quot;sign&quot;:&quot;b6a20a0b1c82b87d65b78b2943bb3fbc&quot;,&quot;timestamp&quot;:1618099099626&#125; 分析搜索japi/account/login.json 无果 搜索account/login.json 1234567891011121314151617181920loginAction: function() &#123; if (this.checkLoginKey() &amp;&amp; this.checkLoginPwd()) &#123; var e &#x3D; this; c.Common.fajax(&#123; url: &quot;account&#x2F;login.json&quot;, easyOriginData: &#123; userName: e.loginKey, password: e.loginPwd &#125;, success: function(t) &#123; 1 &#x3D;&#x3D; t.status ? (c.Common.cookie.set(&quot;session_token_dp&quot;, t.data.sessionToken, &quot;&#x2F;&quot;, &quot;&#x2F;&quot;, 168), c.Common.cookie.set(&quot;platform&quot;, &quot;wap&quot;, &quot;&#x2F;&quot;, &quot;&#x2F;&quot;, 168), c.Common.localStore.set(&quot;session_token_dp&quot;, t.data.sessionToken), c.Common.localStore.set(&quot;uid_dp&quot;, t.data.uid), c.Common.cookie.set(&quot;secretKey&quot;, t.data.secretKey, &quot;&#x2F;&quot;, &quot;&#x2F;&quot;, 168), c.Common.alert(&quot;simpleSuccess&quot;, &quot;登录成功&quot;, 1, e.goHref, &quot;&#x2F;member-undp&#x2F;index.html&quot;)) : e.alert(t.message) &#125; &#125;) &#125;&#125;, 打上断点调试，此时并没有出现sign,说明sign应该是在fajax中生成，进入fajax中，逐步调试，t[&quot;sign&quot;] = i(f + &quot;&amp;&quot; + i(o.genSignData(t.data)) + &quot;&amp;&quot; + d),这一步出现了sign进行填值，f为/account/login.json d是””空字符串 接下来分析i(o.genSignData(t.data))中的o.genSignData(t.data),其中t.data为账户密码的对象 genSignDatai(o.genSignData(t.data))分析，先进入o.genSignData函数，拆分出来js如下 123456789101112131415161718192021222324var genSignData &#x3D; function(e) &#123; var t &#x3D; &quot;&quot; , n &#x3D; []; for (var r in e) n.push(r); n &#x3D; n.sort(); for (var i &#x3D; 0; i &lt; n.length; i++) &#123; var o &#x3D; n[i] , s &#x3D; e[o] , l &#x3D; !1; if (&quot;object&quot; &#x3D;&#x3D; (&quot;undefined&quot; &#x3D;&#x3D; typeof s ? &quot;undefined&quot; : (0, a.default)(s))) &#123; var c &#x3D; &quot;&#123;&quot;; for (var u in s) c +&#x3D; u + &quot;&#x3D;&quot; + s[u] + &quot;, &quot;, l &#x3D; !0; l &amp;&amp; (s &#x3D; c.substring(0, c.length - 2) + &quot;&#125;&quot;) &#125; &quot;sign&quot; !&#x3D; o &amp;&amp; null !&#x3D;&#x3D; s &amp;&amp; void 0 !&#x3D;&#x3D; s &amp;&amp; &quot;&quot; !&#x3D;&#x3D; s &amp;&amp; (&quot;object&quot; !&#x3D; (&quot;undefined&quot; &#x3D;&#x3D; typeof s ? &quot;undefined&quot; : (0, a.default)(s)) || l) &amp;&amp; (t +&#x3D; (0 &#x3D;&#x3D; i ? &quot;&quot; : &quot;&amp;&quot;) + o + &quot;&#x3D;&quot; + s) &#125; return null !&#x3D; t &amp;&amp; &quot;&quot; !&#x3D; t &amp;&amp; &quot;&amp;&quot; &#x3D;&#x3D; t.substr(0, 1) &amp;&amp; (t &#x3D; t.substr(1, t.length)), t&#125; 单独运行时报错Uncaught ReferenceError: a is not defined,打印a.default 进入a.default,该三元运算所得结果即为控制台打印结果，必然前面的是完全匹配的 123 t.default &#x3D; &quot;function&quot; &#x3D;&#x3D; typeof s.default &amp;&amp; &quot;symbol&quot; &#x3D;&#x3D;&#x3D; l(a.default) ? function(e) &#123; return &quot;undefined&quot; &#x3D;&#x3D; typeof e ? &quot;undefined&quot; : l(e)&#125; 该l函数在上面也有定义如下 那么我们定义函数k即a.default如下,替换genSignData完成函数解密password=123&amp;userName=15806204095 123var k &#x3D; function(e)&#123; return&quot;undefined&quot;&#x3D;&#x3D;typeof e?&quot;undefined&quot;: typeof e&#125; ii(o.genSignData(t.data))分析，接下来就是i函数的分析，进入i函数 第一次调用i函数时，先调用o函数进行加密，再调用wordsToBytes转成字节，返回bytesToHex生成16进制字符串，整体逻辑理清后进入o函数。 o 该函数中引用了n(694),n(247).utf8,n(974),n(247).bin,通过debug可知以上都生成了加密函数 这些加密函数搜索分别发现出现在了694:function，247:function等等，可以断定，这些函数其实就是作为变量在o函数中调用 扣出694,247,974的代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293var liu94 &#x3D; function (e, t) &#123; var t &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&quot; , n &#x3D; &#123; rotl: function (e, t) &#123; return e &lt;&lt; t | e &gt;&gt;&gt; 32 - t &#125;, rotr: function (e, t) &#123; return e &lt;&lt; 32 - t | e &gt;&gt;&gt; t &#125;, endian: function (e) &#123; if (e.constructor &#x3D;&#x3D; Number) return 16711935 &amp; n.rotl(e, 8) | 4278255360 &amp; n.rotl(e, 24); for (var t &#x3D; 0; t &lt; e.length; t++) e[t] &#x3D; n.endian(e[t]); return e &#125;, randomBytes: function (e) &#123; for (var t &#x3D; []; e &gt; 0; e--) t.push(Math.floor(256 * Math.random())); return t &#125;, bytesToWords: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0, r &#x3D; 0; n &lt; e.length; n++, r +&#x3D; 8) t[r &gt;&gt;&gt; 5] |&#x3D; e[n] &lt;&lt; 24 - r % 32; return t &#125;, wordsToBytes: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; 32 * e.length; n +&#x3D; 8) t.push(e[n &gt;&gt;&gt; 5] &gt;&gt;&gt; 24 - n % 32 &amp; 255); return t &#125;, bytesToHex: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; e.length; n++) t.push((e[n] &gt;&gt;&gt; 4).toString(16)), t.push((15 &amp; e[n]).toString(16)); return t.join(&quot;&quot;) &#125;, hexToBytes: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; e.length; n +&#x3D; 2) t.push(parseInt(e.substr(n, 2), 16)); return t &#125;, bytesToBase64: function (e) &#123; for (var n &#x3D; [], r &#x3D; 0; r &lt; e.length; r +&#x3D; 3) for (var i &#x3D; e[r] &lt;&lt; 16 | e[r + 1] &lt;&lt; 8 | e[r + 2], a &#x3D; 0; a &lt; 4; a++) 8 * r + 6 * a &lt;&#x3D; 8 * e.length ? n.push(t.charAt(i &gt;&gt;&gt; 6 * (3 - a) &amp; 63)) : n.push(&quot;&#x3D;&quot;); return n.join(&quot;&quot;) &#125;, base64ToBytes: function (e) &#123; e &#x3D; e.replace(&#x2F;[^A-Z0-9+\\&#x2F;]&#x2F;gi, &quot;&quot;); for (var n &#x3D; [], r &#x3D; 0, i &#x3D; 0; r &lt; e.length; i &#x3D; ++r % 4) 0 !&#x3D; i &amp;&amp; n.push((t.indexOf(e.charAt(r - 1)) &amp; Math.pow(2, -2 * i + 8) - 1) &lt;&lt; 2 * i | t.indexOf(e.charAt(r)) &gt;&gt;&gt; 6 - 2 * i); return n &#125; &#125;; return n;&#125;var er47 &#x3D; &#123; utf8: &#123; stringToBytes: function (e) &#123; return er47.bin.stringToBytes(unescape(encodeURIComponent(e))) &#125;, bytesToString: function (e) &#123; return decodeURIComponent(escape(er47.bin.bytesToString(e))) &#125; &#125;, bin: &#123; stringToBytes: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; e.length; n++) t.push(255 &amp; e.charCodeAt(n)); return t &#125;, bytesToString: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; e.length; n++) t.push(String.fromCharCode(e[n])); return t.join(&quot;&quot;) &#125; &#125;&#125;;var jiu74 &#x3D; function (e, t) &#123; function n(e) &#123; return !!e.constructor &amp;&amp; &quot;function&quot; &#x3D;&#x3D; typeof e.constructor.isBuffer &amp;&amp; e.constructor.isBuffer(e) &#125; function r(e) &#123; return &quot;function&quot; &#x3D;&#x3D; typeof e.readFloatLE &amp;&amp; &quot;function&quot; &#x3D;&#x3D; typeof e.slice &amp;&amp; n(e.slice(0, 0)) &#125; return function (e) &#123; return null !&#x3D; e &amp;&amp; (n(e) || r(e) || !!e._isBuffer) &#125;&#125; 在o函数中改写t,r,i,a 1234var t &#x3D; liu94() , r &#x3D; er47.utf8 , i &#x3D; jiu74() , a &#x3D; er47.bin 最终只要将o函数中exports的函数return出来即可 1234567891011res &#x3D; function (e, n) &#123; console.log(e) if (void 0 &#x3D;&#x3D;&#x3D; e || null &#x3D;&#x3D;&#x3D; e) throw new Error(&quot;Illegal argument &quot; + e); var r &#x3D; t.wordsToBytes(o(e, n)); console.log(r) return n &amp;&amp; n.asBytes ? r : n &amp;&amp; n.asString ? a.bytesToString(r) : t.bytesToHex(r)&#125;&#x2F;&#x2F;res(&quot;password&#x3D;123&amp;userName&#x3D;158062204095&quot;, undefined);&#x2F;&#x2F;console.log(&#39;--------&gt;&#39;,res(origin, undefined))return res; 由于o(e,n)中的即为o.genSignData生成的账密参数password=123&amp;userName=15806204095，n为undefined，那么我们就可以直接调用该方法返回真正的sign。 console.log(encrypt()(&quot;/account/login.json&quot;+&quot;&amp;&quot;+encrypt()(genSignData(UP))+&quot;&amp;&quot;+&quot;&quot;)); 查看抓包后的结果如下 爬虫实现12345678910111213import jsonimport requestsimport execjsusername &#x3D; &quot;15806204095&quot;psssword &#x3D; &quot;123&quot;with open(r&#39;rjs_sign.js&#39;, encoding&#x3D;&#39;utf-8&#39;, mode&#x3D;&#39;r&#39;) as f: JsData &#x3D; f.read()sign &#x3D; execjs.compile(JsData).call(&#39;request&#39;,username,psssword)data &#x3D; json.dumps(&#123;&quot;platform&quot;:&quot;wap&quot;,&quot;session_token&quot;:&quot;&quot;,&quot;session_id&quot;:&quot;&quot;,&quot;data&quot;:&#123;&quot;userName&quot;:username,&quot;password&quot;:psssword&#125;,&quot;sign&quot;:sign,&quot;timestamp&quot;:1618153079455&#125;)r &#x3D;requests.post(&quot;https:&#x2F;&#x2F;m.rjs.com&#x2F;japi&#x2F;account&#x2F;login.json&quot;,data)print(r.text) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"hook抓包trace定位实战","slug":"hook抓包trace定位实战","date":"2021-04-10T02:54:10.000Z","updated":"2021-07-03T19:54:58.190Z","comments":true,"path":"2021/04/10/hook抓包trace定位实战/","link":"","permalink":"http://onejane.github.io/2021/04/10/hook%E6%8A%93%E5%8C%85trace%E5%AE%9A%E4%BD%8D%E5%AE%9E%E6%88%98/","excerpt":"","text":"移动TVnpm install –save @types/frida-gum 配置vscode的frida自动代码提示 123456adb install movetv.apkgit clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;FRIDA-DEXDump.gitpython main.py 打开app操作一会积分查看视频开始脱壳cd com.cz.babySistergrep -ril &quot;LoginActivity&quot; * 查看该类在那个dex中frida -UF -l hookEvent.js 点击登录时，触发打印LoginActivity完整路径 通过jadx-gui 查看com.cz.babySister.activity.LoginActivity的onClick方法 12345678objection -g com.cz.babySister exploreandroid hooking search classes user 查找和用户相关的类android hooking search classes personandroid hooking watch class com.cz.babySister.javabean.UserInfo 查看该类在jadx中哪些地方调用了plugin load &#x2F;root&#x2F;.objection&#x2F;plugins&#x2F;Wallbreakerplugin wallbreaker objectsearch com.cz.babySister.javabean.UserInfo 内存搜索UserInfoplugin wallbreaker objectdump --fullname 0x112swa 查看内存中UserInfo信息android hooking list class_methods com.cz.babySister.javabean.UserInfo frida -U -f com.cz.babySister -l jifen.js --no-pause 有壳不能spawn,从登录开始hook frida -UF -l jifen.js 服务器检测校验了无法查看视频，客户端修改无效 123456789101112131415161718192021function hook_jifen()&#123; Java.perform(function()&#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) Java.use(&quot;com.cz.babySister.javabean.UserInfo&quot;).setJifen.implementation &#x3D; function(str) &#123; var result &#x3D; this.setJifen(javaString.$new(&quot;1000&quot;)) console.log(&quot;setJifen is :&quot; ,str) console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return result; &#125; Java.use(&quot;com.cz.babySister.javabean.UserInfo&quot;).setJifen.implementation &#x3D; function() &#123; var result &#x3D; this.getJifen() console.log(&quot;getJifen is :&quot;,result) console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return javaString.$new(&quot;1000&quot;) &#125; &#125;)&#125;function main()&#123; hook_jifen()&#125;setImmediate(main) 通过console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()));打印调用栈，找到最下面的com.cz.babySister.alipay.k.run，查看com.cz.babySister.alipay下的所有类，jadx搜索支付失败 123456789101112function hook_jifen2()&#123; Java.perform(function()&#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) Java.use(&quot;com.cz.babySister.alipay.o&quot;).b.implementation&#x3D;function()&#123; console.log(&quot;success&quot;) return javaString.$new(&quot;9000&quot;) &#125; &#125;)&#125;function main()&#123; hook_jifen2()&#125; 依旧失败，可能做了支付订单校验。 调用栈中害打印了com.cz.babySister.utils.ParseJson.parseRegisterName,查看com.cz.babySister.utils.ParseJson类，所有内容都是从该类中出现，jadx查看该类的调用处，出现queryJifen 进入a.a方法，a2就是json，所有查询从a.a中返回json，通过objection对该类进行hook，登录时查看调用的方法基本都是a.a 12android hooking watch class com.cz.babySister.c.a --dump-args --dump-return android hooking watch_method class com.cz.babySister.c.a.a --dump-args --dump-return 每次看成人台时都会queryJifen判断积分是否不足，不过Return Value是服务器判断了积分是否充足，充足才返回可以看的地址，没有逻辑漏洞了。 搜索memi1的来源 12android hooking watch class_method android.content.Context.getString --dump-args --dump-returnandroid hooking watch class_method android.content.Context.getText --dump-args --dump-return context在app启动后立即生成且销毁，因为有壳的原因，无法hook，只有一次捕捉机会 1234android hooking watch class android.provider.Settings$Secure --dump-args --dump-return 每次context实时获取的android hooking watch class_method android.provider.Settings$Secure.getString --dump-args --dump-return --dump-backtraceplugin wallbreaker objectsearch android.app.ContextImpl$ApplicationContentResolverplugin wallbreaker objectdump --fullname 0x2502 记一次frida实战——对某视频APP的脱壳、hook破解、模拟抓包、协议分析一条龙服务 fulao2adb install -r fulao2.apk 1234567891011.&#x2F;fs128arm64frida -UF -l hookSocket.js -o &#x2F;root&#x2F;Desktop&#x2F;img.txt 启动app后开始抓包，GET到的地址结合域名发现图片是被加密的objection -g com.ilulutv.fulao2 explore -P ~&#x2F;.objection&#x2F;pluginsandroid hooking search classes imageViewplugin wallbreaker objectsearch android.widget.ImageView 查看内存中的对象plugin wallbreaker objectdump --fullname 0x20212 打印内存对象属性内容android hooking search classes Bitmap 把所有Bitmap相关的类拷贝到文件bitmap.txt中，前面加上android hooking watch classplugin wallbreaker objectdump --fullname 0x2045 查看内存Bitmap属性，即图片属性objection -g com.ilulutv.fulao2 explore -c bitmap.txt 批量hook,如果app崩了查看最后一个hook的类，在文件中删除重新挂上objectionandroid hooking watch class_method android.graphics.BitmapFactory.decodeStream --dump-args --dump-backtrace --dump-return 下拉加载图片，堆栈中加载了glide图片加载库android hooking watch class_method android.graphics.BitmapFactory.decodeByteArray --dump-args --dump-backtrace --dump-return 堆栈中打印了业务代码com.ilulutv.fulao2.other.helper.glide.b.a jadx打开fulao2，搜索com.ilulutv.fulao2.other.helper.glide.b类的a方法 1android hooking list class_methods android.graphics.BigmapFactory 查看decodeByteArray返回值 其中byte[] c2 = com.ilulutv.fulao2.other.i.b.c(decode, Base64.decode(bytes2, 0), encodeToString);解密 hook网络流打印下载图片内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function hookRAW()&#123; Java.perform(function()&#123; console.log(&quot;hooking RAW...&quot;) Java.use(&quot;com.ilulutv.fulao2.other.i.b&quot;).a.overload(&#39;java.nio.ByteBuffer&#39;).implementation &#x3D; function(bytebuffer)&#123; var result &#x3D; this.a(bytebuffer) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;result is &#x3D;&gt; &quot;,ByteString.of(result).hex()) return result &#125; &#125;) &#125;function hook_SSLsocketandroid8()&#123; Java.perform(function()&#123; console.log(&quot;hook_SSLsocket&quot;) &#x2F;&#x2F; concrypt本质对libssl.so进行操作 Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTPS write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) &#x2F;&#x2F;console.log(jhexdump(bytearry,int1,int2)); &#x2F;&#x2F; console.log(jhexdump(bytearry)); return result; &#125; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTPS read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) &#x2F;&#x2F;console.log(jhexdump(bytearry,int1,int2)); &#x2F;&#x2F; console.log(jhexdump(bytearry)); return result; &#125; &#125;)&#125;function main()&#123; hookRAW() hook_SSLsocketandroid8()&#125;setImmediate(main) frida -UF -l fulao2.js -o hookRAW.txt 下拉内容查看log图片，对比抓包hook_SSLsocketandroid8结果和hookRAW结果的内容是否一致，说明com.ilulutv.fulao2.other.i.b.a((ByteBuffer) obj)确实是要加密的内容，明文在com.ilulutv.fulao2.other.i.b.b(decode, Base64.decode(bytes2, 0), encodeToString) 根据return com.bumptech.glide.load.q.d.e.a(BitmapFactory.decodeByteArray(b2, 0, b2.length), this.f11769a);,hook系统库查看解密后图片内容 1234567891011function hookClean()&#123; Java.perform(function()&#123; &#x2F;&#x2F; hook 系统库 不会被混淆 ,图片文件头jpeg都是ffd8ff Java.use(&quot;android.graphics.BigmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;,&#39;android.graphics.BitmapFactory$Options&#39;).implementation &#x3D; function (ba,int1,int2,op)&#123; var result &#x3D; this.decodeByteArray(ba,in1,int2,op) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;ba is&#x3D;&gt;&quot;,ByteString.of(ba).hex()) return result; &#125; &#125;)&#125; byte下载图片，frida -UF -l fulao2.js -o hookRAW.txt 下拉加载图片 1234567891011121314151617181920212223242526function guid() &#123; function S4() &#123; return (((1+Math.random())*0x10000)|0).toString(16).substring(1); &#125; return (S4()+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+S4()+S4()); &#125;function hookClean()&#123; Java.perform(function()&#123; &#x2F;&#x2F; hook 系统库 不会被混淆 ,图片文件头jpeg都是ffd8ff Java.use(&quot;android.graphics.BigmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;,&#39;android.graphics.BitmapFactory$Options&#39;).implementation &#x3D; function (ba,int1,int2,op)&#123; var result &#x3D; this.decodeByteArray(ba,in1,int2,op) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;ba is&#x3D;&gt;&quot;,ByteString.of(ba).hex()) var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot;+guid()+&quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;,path) &#x2F;&#x2F; android hooking search classes File var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) &#x2F;&#x2F; android hooking search classes FileOutputStream var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); fos.write(data); fos.close(); fos.close(); return result; &#125; &#125;)&#125; 根据正常图片访问方式，利用安卓api，通过Bigmap对象压缩到文件输出流 12345678910111213141516171819202122function hookClean()&#123; Java.perform(function()&#123; &#x2F;&#x2F; hook 系统库 不会被混淆 ,图片文件头jpeg都是ffd8ff Java.use(&quot;android.graphics.BigmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;,&#39;android.graphics.BitmapFactory$Options&#39;).implementation &#x3D; function (ba,int1,int2,op)&#123; var result &#x3D; this.decodeByteArray(ba,in1,int2,op) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;ba is&#x3D;&gt;&quot;,ByteString.of(ba).hex()) var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot;+guid()+&quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;,path) &#x2F;&#x2F; android hooking search classes File var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) &#x2F;&#x2F; android hooking search classes FileOutputStream var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); &#x2F;&#x2F; android hooking list class_methods android.graphics.Bitmap 查看compress实例方法 result.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value,100,fos) &#x2F;&#x2F; fos.write(data); fos.close(); fos.close(); return result; &#125; &#125;)&#125; compress占用主线程资源，阻塞主线程导致程序崩溃，可以另起线程专门用来下载图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344function hookImage() &#123; Java.perform(function () &#123; var Runnable &#x3D; Java.use(&quot;java.lang.Runnable&quot;); var saveImg &#x3D; Java.registerClass(&#123; name: &quot;com.roysue.runnable&quot;, implements: [Runnable], fields: &#123; bm: &quot;android.graphics.Bitmap&quot;, &#125;, methods: &#123; $init: [&#123; returnType: &quot;void&quot;, argumentTypes: [&quot;android.graphics.Bitmap&quot;], implementation: function (bitmap) &#123; this.bm.value &#x3D; bitmap; &#125; &#125;], run: function () &#123; var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot; + guid() + &quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;, path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); this.bm.value.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value, 100, fos) console.log(&quot;success!&quot;) fos.flush(); fos.close(); &#125; &#125; &#125;); Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory$Options&#39;).implementation &#x3D; function (data, offset, length, opts) &#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); var runnable &#x3D; saveImg.$new(result); runnable.run() return result; &#125; &#125;)&#125; 不建议多线程在手机端运行，可以将线程发送PC端执行 fulao2.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function hookImage() &#123; Java.perform(function () &#123; var Runnable &#x3D; Java.use(&quot;java.lang.Runnable&quot;); var saveImg &#x3D; Java.registerClass(&#123; name: &quot;com.roysue.runnable&quot;, implements: [Runnable], fields: &#123; bm: &quot;android.graphics.Bitmap&quot;, &#125;, methods: &#123; $init: [&#123; returnType: &quot;void&quot;, argumentTypes: [&quot;android.graphics.Bitmap&quot;], implementation: function (bitmap) &#123; this.bm.value &#x3D; bitmap; &#125; &#125;], run: function () &#123; var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot; + guid() + &quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;, path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); this.bm.value.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value, 100, fos) console.log(&quot;success!&quot;) fos.flush(); fos.close(); &#125; &#125; &#125;); Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory$Options&#39;).implementation &#x3D; function (data, offset, length, opts) &#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); send(data) return result; &#125; &#125;)&#125;function main()&#123; hookImage()&#125;setImmediate(main) fulao2.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import fridaimport jsonimport timeimport uuidimport base64import re def my_message_handler(message, payload): print(message) print(payload) if message[&quot;type&quot;] &#x3D;&#x3D; &quot;send&quot;: #image &#x3D; re.findall(&quot;(-?\\d+)&quot;, message[&quot;payload&quot;]) image &#x3D; message[&quot;payload&quot;] print(image) # 保存image intArr &#x3D; [] # 位数的转换 for m in image: ival &#x3D; int(m) if ival &lt; 0: ival +&#x3D; 256 intArr.append(ival) bs &#x3D; bytes(intArr) fileName &#x3D; str(uuid.uuid1()) + &quot;.jpg&quot; f &#x3D; open(fileName, &#39;wb&#39;) f.write(bs) f.close()device &#x3D; frida.get_usb_device()target &#x3D; device.get_frontmost_application()session &#x3D; device.attach(target.pid)# 加载脚本with open(&quot;fulao2.js&quot;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot;, my_message_handler) # 调用错误处理script.load()# 脚本会持续运行等待输入input() 接下来尝试从抓到的包中解密协议，获取解密后的图片在hookRAW中实现脱机 fulao2.js 1234567891011121314151617function hookRAW()&#123; Java.perform(function()&#123; console.log(&quot;hooking RAW...&quot;) Java.use(&quot;com.ilulutv.fulao2.other.i.b&quot;).a.overload(&#39;java.nio.ByteBuffer&#39;).implementation &#x3D; function(bytebuffer)&#123; var result &#x3D; this.a(bytebuffer) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;result is &#x3D;&gt; &quot;,ByteString.of(result).hex()) send(result) return result &#125; &#125;) &#125;function main()&#123; hookRAW()&#125;setImmediate(main) fulao2.py中image = message[&quot;payload&quot;]需要解密，进入decodeImageKey实现 进入CipherCore 发现从so库中加载的加密协议 12memory list modules 找到libcipher-lib.somemory list exports libcipher-lib.so 搜索getString 分析拿到byte之后通过base64加密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import fridaimport jsonimport timeimport uuidimport base64import refrom Crypto.Cipher import AESimport base64def IMGdecrypt(bytearray): # hook String decodeImgKey &#x3D; CipherClient.decodeImgKey(); imgkey &#x3D; base64.decodebytes( bytes(&quot;svOEKGb5WD0ezmHE4FXCVQ&#x3D;&#x3D;&quot;, encoding&#x3D;&#39;utf8&#39;)) imgiv &#x3D; base64.decodebytes( bytes(&quot;4B7eYzHTevzHvgVZfWVNIg&#x3D;&#x3D;&quot;, encoding&#x3D;&#39;utf8&#39;)) cipher &#x3D; AES.new(imgkey, AES.MODE_CBC, imgiv) # enStr +&#x3D; (len(enStr) % 4)*&quot;&#x3D;&quot; # decryptByts &#x3D; base64.urlsafe_b64decode(enStr) msg &#x3D; cipher.decrypt(bytearray) def unpad(s): return s[0:-s[-1]] return unpad(msg)def my_message_handler(message, payload): print(message) print(payload) if message[&quot;type&quot;] &#x3D;&#x3D; &quot;send&quot;: #image &#x3D; re.findall(&quot;(-?\\d+)&quot;, message[&quot;payload&quot;]) image &#x3D; message[&quot;payload&quot;] print(image) intArr &#x3D; [] # 位数的转换 for m in image: ival &#x3D; int(m) if ival &lt; 0: ival +&#x3D; 256 intArr.append(ival) bs &#x3D; bytes(intArr) # 拿到数据后Base64解密 bs &#x3D; IMGdecrypt(bs) fileName &#x3D; str(uuid.uuid1()) + &quot;.jpg&quot; f &#x3D; open(fileName, &#39;wb&#39;) f.write(bs) f.close()device &#x3D; frida.get_usb_device()target &#x3D; device.get_frontmost_application()session &#x3D; device.attach(target.pid)# 加载脚本with open(&quot;fulao2.js&quot;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot;, my_message_handler) # 调用错误处理script.load()# 脚本会持续运行等待输入input() VIP破解 切换高清视频，提示vip限定功能，无法切换vip，尝试hook按钮点击事件，frida -UF -l hookEvent.js,点击切换清晰度 jadx搜索com.ilulutv.fulao2.film.l.t 12plugin wallbreaker objectsearch com.ilulutv.fulao2.film.l$tplugin wallbreaker objectdump --fullname 0x2a76 12plugin wallbreaker objectdump --fullname 0x28f2 查看在看视频实例android heap search instances com.ilulutv.fulao2.film.l 尝试将this.f11151d.q0改为true,完成VIP功能中的清晰度切换 12345678910111213141516function hookVIP()&#123; Java.perform(function()&#123; Java.choose(&quot;com.ilulutv.fulao2.film.l&quot;,&#123; onMatch:function(ins)&#123; console.log(&quot;found ins:&#x3D;&gt;&quot;,ins) ins.q0.value&#x3D;true; &#125;,onComplete:function()&#123; console.log(&quot;search complete&quot;) &#125; &#125;) &#125;)&#125;function main()&#123; hookVIP()&#125;setInterval(main,500) 抓取所有收发包 frida -U -f com.ilulutv.fulao2 -l hookSocket.js -o traffic.txt 所有通信都是加密了，不是在https层加密，而是在业务层，那就尝试hook所有的cipher objection -g com.ilulutv.fulao2 explore -c cipher.txt 123android hooking watch class com.cz.babySister.c.a android hooking watch class_method javax.crypto.Cipher.init --dump-args --dump-return --dump-backtraceandroid hooking list class_methods com.ilulutv.fulao2.other.i.b 将所有的方法复制到ciph.txt中，前面添加上android hooking watch class_method,后面添加--dump-args --dump-return --dump-backtrace objection -g com.ilulutv.fulao2 explore -c cipher.txt 关闭app重新hook，打印出所有的通信内容包括加解密所有内容 查看com.ilulutv.fulao2.other.i.b.a ，改包将其中的vip改为true，expire修改过期时间 当所有业务返回都被加解密了，可以尝试hook系统库，不可被混淆加密 第一题.apkjadx-gui 第一题.apk 123objection -g com.kanxue.pediy1 exploreandroid hooking search classes com.kanxue.pediy1android hooking watch classe com.kanxue.pediy1.VVVV frida -UF -l question.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var CONTEXT &#x3D; null;&#x2F;&#x2F; 获取类名function getObjClassName(obj) &#123; if (!jclazz) &#123; var jclazz &#x3D; Java.use(&quot;java.lang.Class&quot;); &#125; if (!jobj) &#123; var jobj &#x3D; Java.use(&quot;java.lang.Object&quot;); &#125; return jclazz.getName.call(jobj.getClass.call(obj));&#125;function hookReturn() &#123; Java.perform(function () &#123; Java.use(&quot;com.kanxue.pediy1.VVVVV&quot;).VVVV.implementation &#x3D; function (context, str) &#123; var result &#x3D; this.VVVV(context, str) console.log(&quot;context,str,result &#x3D;&gt; &quot;, context, str, result); console.log(&quot;context className is &#x3D;&gt; &quot;, getObjClassName(context)); CONTEXT &#x3D; context; return true; &#125; &#125;)&#125;function invoke() &#123; Java.perform(function () &#123; &#x2F;&#x2F;console.log(&quot;CONTEXT IS &#x3D;&gt; &quot;,CONTEXT) var MainActivity &#x3D; null; Java.choose(&quot;com.kanxue.pediy1.MainActivity&quot;, &#123; onMatch: function (instance) &#123; MainActivity &#x3D; instance; &#125;, onComplete: function () &#123; &#125; &#125;) var CONTEXT2 &#x3D; Java.use(&quot;com.kanxue.pediy1.MainActivity$1&quot;).$new(MainActivity); var javaString &#x3D; Java.use(&quot;java.lang.String&quot;).$new(&quot;12345&quot;); for (var x &#x3D; 0; x &lt; (99999 + 1); x++) &#123; &#x2F;&#x2F; 静态函数VVVV 使用use直接调用 var result &#x3D; Java.use(&quot;com.kanxue.pediy1.VVVVV&quot;).VVVV(CONTEXT2, String(x)); console.log(&quot;now x is &#x3D;&gt; &quot;, String(x)) if (result) &#123; console.log(&quot;found result is &#x3D;&gt; &quot;, String(x)) break; &#125; &#125; &#125;)&#125;function main() &#123; hookReturn() invoke()&#125;setImmediate(main) 主动调用的参数构造两种方案： 一种先hook 自己单独new 域中反射获取 12cd ~&#x2F;.pyenvtree -NCfhl | grep agent.js 加上构造函数hook,如com.kanxue.pediy1.MainActivity$1 第二题.apkjadx-gui 第二题.apk 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function invoke2() &#123; Java.perform(function () &#123; &#x2F;&#x2F; console.log(&quot;CONTEXT IS &#x3D;&gt; &quot;,CONTEXT) var MainActivity &#x3D; null; Java.choose(&quot;com.kanxue.pediy1.MainActivity&quot;,&#123; onMatch:function(instance)&#123; MainActivity &#x3D; instance; &#125;, onComplete:function()&#123;&#125; &#125;) &#x2F;&#x2F; var CONTEXT2 &#x3D; Java.use(&quot;com.kanxue.pediy1.MainActivity$1&quot;).$new(MainActivity); var loader1 &#x3D; null; var loader2 &#x3D; null; Java.enumerateClassLoaders(&#123; onMatch: function (loader) &#123; try &#123; if (loader.findClass(&quot;com.kanxue.pediy1.VVVVV&quot;)) &#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); &#x2F;&#x2F; 切换classLoader loader2 &#x3D; loader; Java.classFactory.loader &#x3D; loader2; &#125;else if(loader.findClass(&quot;com.kanxue.pediy1.MainActivity&quot;))&#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); loader1 &#x3D; loader; &#125;else&#123; &#125; &#125; catch (error) &#123; console.log(&quot;find error:&quot; + error) &#125; &#125;, onComplete: function () &#123; console.log(&quot;end1&quot;) &#125; &#125;) var javaString &#x3D; Java.use(&quot;java.lang.String&quot;).$new(&quot;12345&quot;); for (var x &#x3D; 0; x &lt; (99999 + 1); x++) &#123; var result1 &#x3D; MainActivity.stringFromJNI(String(100000 - x)); var result2 &#x3D; Java.use(&quot;com.kanxue.pediy1.VVVVV&quot;).VVVV(String(result1)); console.log(&quot;now x is &#x3D;&gt; &quot;, String(x)) if (result2) &#123; console.log(&quot;found result2 is &#x3D;&gt; &quot;, String(100000 - x)) break; &#125; &#125; &#125;)&#125; frida -UF -l traceNativelibssl.js 拿到函数_ZTVNST3__19strstreamE ,修改if(exports[j].name.indexOf(&quot;ZTVNSt3&quot;)&gt;=0){,if(exports[j].name.indexOf(&quot;ZTVNSt3&quot;)&gt;=0){, 举杯邀Frida，对影成三题 123456789101112131415161718192021222324&#x2F;&#x2F; hook native函数，使其不要执行，Interceptor.replacefunction hookSTRSTR() &#123; var kill_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;); Interceptor.attach(strstr, &#123; onEnter: function (args) &#123; console.log(&quot;Entering &#x3D;&gt;&quot;) console.log(&quot;args[0] &#x3D;&gt; &quot;, args[0].readCString()) console.log(&quot;args[1] &#x3D;&gt; &quot;, args[1].readCString()) &#125;, onLeave: function (retval) &#123; &#125; &#125;)&#125;function replaceKill()&#123; var kill_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;kill&quot;); &#x2F;&#x2F; var kill &#x3D; new NativeFunction(kill_addr,&quot;int&quot;,[&#39;int&#39;,&#39;int&#39;]); Interceptor.replace(kill_addr,new NativeCallback(function(arg0,arg1)&#123; console.log(&quot;arg0&#x3D;&gt; &quot;,arg0) console.log(&quot;arg1&#x3D;&gt; &quot;,arg1) &#125;,&quot;int&quot;,[&#39;int&#39;,&#39;int&#39;]))&#125;","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"wallbreaker","slug":"wallbreaker","permalink":"http://onejane.github.io/tags/wallbreaker/"}]},{"title":"爬虫基础篇之Scrapy抓取京东","slug":"爬虫基础篇之Scrapy抓取京东","date":"2021-04-09T05:54:41.000Z","updated":"2021-04-22T12:46:32.068Z","comments":true,"path":"2021/04/09/爬虫基础篇之Scrapy抓取京东/","link":"","permalink":"http://onejane.github.io/2021/04/09/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BScrapy%E6%8A%93%E5%8F%96%E4%BA%AC%E4%B8%9C/","excerpt":"","text":"虚拟环境同一台服务器上不同的项目可能依赖的包不同版本，新版本默认覆盖旧版本，可能导致其他项目无法运行，通过虚拟环境，完全隔离各个项目各个版本的依赖包，实现运行环境互不影响。 virtualenv1234567891011121314pip install virtualenv 安装virtualenvpython -m pip install --upgrade pip 升级pippip install -i https:&#x2F;&#x2F;pypi.doubanio.com&#x2F;simple&#x2F; --trusted-host pypi.doubanio.com scrapypip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple 使用清华源pip uninstall scrapy 卸载django virtualenv scrapytest 默认环境创建虚拟环境cd scrapytest&#x2F;Scripts &amp;&amp; activate.bat &amp;&amp; python 进入3.7虚拟环境virtualenv -p D:\\Python27\\python.exe scrapytestcd scrapytest&#x2F;Scripts &amp;&amp; activate.bat &amp;&amp; python 进入2.7虚拟环境deactivate.bat 退出虚拟环境apt-get install python-virtualenv 安装虚拟环境virtualenv py2 &amp;&amp; cd py2 &amp;&amp; cd bin &amp;&amp; source activate &amp;&amp; python 进入2.7虚拟环境virtualenv -p &#x2F;usr&#x2F;bin&#x2F;python3 py3 &amp;&amp; &amp;&amp; cd py3 &amp;&amp; cd bin &amp;&amp; source activate &amp;&amp; python 进入3.7虚拟环境 virtualenvwrapper123456789101112131415161718192021222324252627pip install virtualenvwrapperpip install virtualenvwrapper-win 解决workon不是内部指令workon 列出所有虚拟环境新建环境变量 WORKON_HOME&#x3D;E:\\envsmkvirtualenv py3scrapy 新建并进入虚拟环境deactivate 退出虚拟环境workon py3scrapy 进入指定虚拟环境 pip install -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple scrapy 安装scrapy源 若缺少lxml出错https:&#x2F;&#x2F;www.lfd.uci.edu&#x2F;~gohlke&#x2F;pythonlibs&#x2F;寻找对应版本的lxml的whl源 python -m pip install --upgrade pip 更新pip pip install lxml-4.1.1-cp35-cp35m-win_amd64.whl 若缺少Twisted出错http:&#x2F;&#x2F;www.lfd.uci.edu&#x2F;~gohlke&#x2F;pythonlibs&#x2F;#lxml搜对应版本Twisted pip install Twisted‑17.9.0‑cp35‑cp35m‑win_amd64.whlmkvirtualenv --python&#x3D;D:\\Python27\\python.exe py2scrapy 一般不会出问题 pip install -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple scrapy pip install virtualenvwrapper find &#x2F; -name virualenvwrapper.sh vim ~&#x2F;.bashrc export WORKON_HOME&#x3D;$HOME&#x2F;.virtualenvs source &#x2F;home&#x2F;wj&#x2F;.local&#x2F;bin&#x2F;virtualenvwrapper.sh source ~&#x2F;.bashrc mkvirtualenv py2scrapy 指向生成~&#x2F;.virtualenvdeactivate 退出虚拟环境mkdirtualenv --python&#x3D;&#x2F;usr&#x2F;bin&#x2F;python3 py3scrapyrmvirtualenv py3scrapy 删除虚拟环境 Scrapy 12345678910pip install -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F; scrapy 安装scrapyscrapy startproject mall_spider 创建mall_spider项目scrapy genspider jd_category https:&#x2F;&#x2F;dc.3.cn&#x2F;category&#x2F;get 创建分类爬虫scrapy genspider --list 查看爬虫生成模板scrapy genspider -t crawl lagou www.lagou.com 创建全站爬虫pip freeze &gt; requirements.txt 生成依赖到文件pip install -r requirements.txt 一键安装依赖scrapy shell http:&#x2F;&#x2F;blog.jobbole.com&#x2F; 可以在脚本中调试xpath或者chrome浏览器右键copy xpath,chrome浏览器右键copy selectorscrapy shell -s USER_AGENT&#x3D;&quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64; rv:51.0) Gecko&#x2F;20100101 Firefox&#x2F;51.0&quot; https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;56320032view(response) 需求1.1 抓取首页的分类信息 抓取数据: 各级分类的名称 和 URL 1.2 抓取商品信息 抓取: 商品名称, 商品价格, 商品评论数量, 商品店铺, 商品促销, 商品选项, 商品图片的URL 由于全网爬虫, 抓取页面非常多, 为了提高抓的速度, 选择使用scrapy框架 + scrapy_redis分布式组件 由于京东全网的数据量达到了亿级, 存储又是结构化数据, 数据库, 选择使用MongoDB; 实现我们采用广度优先策略, 我们把类别和商品信息的抓取分开来做. 模型类别模型1234567891011121314class Category(scrapy.Item): &quot;&quot;&quot;商品类别&quot;&quot;&quot; # 大分类名称 b_category_name &#x3D; scrapy.Field() # 大分类URL b_category_url &#x3D; scrapy.Field() # 中分类名称 m_category_name &#x3D; scrapy.Field() # 中分类URL m_category_url &#x3D; scrapy.Field() # 小分类名称 s_category_name &#x3D; scrapy.Field() # 小分类URL s_category_url &#x3D; scrapy.Field() 数据模型123456789101112131415161718192021class Product(scrapy.Item): # 商品类别 product_category &#x3D; scrapy.Field() # 商品ID product_sku_id &#x3D; scrapy.Field() # 商品名称 product_name &#x3D; scrapy.Field() # 商品图片URL product_img_url &#x3D; scrapy.Field() # 商品店铺 product_shop &#x3D; scrapy.Field() # 图书信息, 作者,出版社 product_book_info &#x3D; scrapy.Field() # 商品选项 product_option &#x3D; scrapy.Field() # 商品评论数量 product_comments &#x3D; scrapy.Field() # 商品促销 product_ad &#x3D; scrapy.Field() # 商品价格 product_price &#x3D; scrapy.Field() 分类爬虫分析, 分类信息的URL 目标: 确定分类信息的URL 步骤: 进入到京东首页 右键检查, 打开开发者工具, 搜索 家用电器 确定分类的URL 图解: 结论: 分类URL: https://dc.3.cn/category/get 创建爬虫, 抓取数据 目标: 抓取分类数据, 交给引擎 步骤: 创建类别爬虫 \b指定起始URL 解析数据, 交给引擎 创建爬虫 进入项目目录: cd mall_spider 创建爬虫: scrapy genspider category_spider jd.com 指定起始URL 修改起始URL: https://dc.3.cn/category/get 解析数据, 交给引擎 分析数据格式: 整体数据 各级分类位置 分类信息格式 格式1: jiadian.jd.com|家用电器||0 特点: 第一项分类URL,第二项分类名称 格式2: 652-654|摄影摄像||0 对应的URL: https://channel.jd.com/652-654.html 特点:第一项是频道ID, 包含一个 - 格式3: 1318-2628-12131|户外风衣||0 对应URL: https://list.jd.com/list.html?cat=1318,2628,12131 特点: 第一项为分类ID, 包含两个 - 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class JdCategorySpider(scrapy.Spider): name &#x3D; &#39;jd_category&#39; allowed_domains &#x3D; [&#39;3.cn&#39;] start_urls &#x3D; [&#39;https:&#x2F;&#x2F;dc.3.cn&#x2F;category&#x2F;get&#39;] def parse(self, response): # print(response.body.decode(&#39;GBK&#39;)) result &#x3D; json.loads(response.body.decode(&#39;GBK&#39;)) datas &#x3D; result[&#39;data&#39;] # 遍历数据列表 for data in datas: item &#x3D; Category() b_category &#x3D; data[&#39;s&#39;][0] b_category_info &#x3D; b_category[&#39;n&#39;] # print(&#39;大分类: &#123;&#125;&#39;.format(b_category_info)) item[&#39;b_category_name&#39;], item[&#39;b_category_url&#39;] &#x3D; self.get_category_name_url(b_category_info) # 中分类信息列表 m_category_s &#x3D; b_category[&#39;s&#39;] # 遍历中分类列表 for m_category in m_category_s: # 中分类信息 m_category_info &#x3D; m_category[&#39;n&#39;] # print(&#39;中分类: &#123;&#125;&#39;.format(m_category_info)) item[&#39;m_category_name&#39;], item[&#39;m_category_url&#39;] &#x3D; self.get_category_name_url(m_category_info) # 小分类数据列表 s_category_s &#x3D; m_category[&#39;s&#39;] for s_category in s_category_s: s_category_info &#x3D; s_category[&#39;n&#39;] # print(&#39;小分类: &#123;&#125;&#39;.format(s_category_info)) item[&#39;s_category_name&#39;], item[&#39;s_category_url&#39;] &#x3D; self.get_category_name_url(s_category_info) # print(item) # 把数据交给引擎 yield item def get_category_name_url(self, category_info): &quot;&quot;&quot; 根据分类信息, 提取名称和URL :param category_info: 分类信息 :return: 分类的名称和URL 分析数据格式(三类数据格式) - book.jd.com&#x2F;library&#x2F;science.html|科学技术||0 - 1713-3287|计算机与互联网||0 - Https:&#x2F;&#x2F;channel.jd.com&#x2F;&#123;&#125;.html - 9987-12854-12856|屏幕换新||0 - Https:&#x2F;&#x2F;list.jd.com&#x2F;list.html?cat&#x3D;&#123;&#125; - 把 - 替换为逗号, 然后填充到占位的地方. &quot;&quot;&quot; category &#x3D; category_info.split(&#39;|&#39;) # 分类URL category_url &#x3D; category[0] # 分类名称 category_name &#x3D; category[1] # 处理第一类分类URL if category_url.count(&#39;jd.com&#39;) &#x3D;&#x3D; 1: # URL进行补全 category_url &#x3D; &#39;https:&#x2F;&#x2F;&#39; + category_url elif category_url.count(&#39;-&#39;) &#x3D;&#x3D; 1: # 1713-3287|计算机与互联网||0 category_url &#x3D; &#39;https:&#x2F;&#x2F;channel.jd.com&#x2F;&#123;&#125;.html&#39;.format(category_url) else: # 9987-12854-12856|屏幕换新||0 # 把URL中 &#96;-&#96; 替换为 &#96;,&#96; category_url &#x3D; category_url.replace(&#39;-&#39;, &#39;,&#39;) # 补全URL category_url &#x3D; &#39;https:&#x2F;&#x2F;list.jd.com&#x2F;list.html?cat&#x3D;&#123;&#125;&#39;.format(category_url) # 返回类别的名称 和 URL return category_name, category_url 保存分类数据12345# 在settings.py开启, 类别的PipelineROBOTSTXT_OBEY &#x3D; False 不遵守网络协议ITEM_PIPELINES &#x3D; &#123; &#39;mall_spider.pipelines.CategoryPipeline&#39;: 300,&#125; 步骤: open_spider方法中, 链接\bMongoDB数据库, 获取要操作的集合 process_item 方法中, 向MongoDB中插入类别\b数据 close_spider 方法中, 关闭MongoDB的链接 123456789101112131415161718192021222324252627&quot;&quot;&quot;实现保存分类的Pipeline类- open_spider方法中, 链接MongoDB数据库, 获取要操作的集合- process_item 方法中, 向MongoDB中插入类别数据- close_spider 方法中, 关闭MongoDB的链接&quot;&quot;&quot;class CategoryPipeline(object): def open_spider(self, spider): &quot;&quot;&quot;当爬虫启动的时候执行1次&quot;&quot;&quot; if isinstance(spider, JdCategorySpider): # open_spider方法中, 链接MongoDB数据库, 获取要操作的集合 self.client &#x3D; MongoClient(MONGODB_URL) self.collection &#x3D; self.client[&#39;jd&#39;][&#39;category&#39;] def process_item(self, item, spider): # process_item 方法中, 向MongoDB中插入类别数据 if isinstance(spider, JdCategorySpider): self.collection.insert_one(dict(item)) return item def close_spider(self, spider): # close_spider 方法中, 关闭MongoDB的链接 if isinstance(spider, JdCategorySpider): self.client.close() 商品爬虫总体设计: 把MongoDB中存储的分类信息, 放到redis_key指定列表中 支持分布式爬虫, 当然也可以在一台电脑上运行多次, 以启动多个进程,充分使用CPU的多核. 所以这里的爬虫, 先从一个分类开始抓就可以了, 后面再改造为分布式 分析 列表页 提取商品 skuid 实现翻页 获取下一页URL \b没有下一页的情况 详情页由于PC和手机页面商品信息, 在js中, 且比较分散, 并且每次请求数量页比较大, 我们这里使用手机抓包, 抓到json数据. 商品基本信息 图: URL: https://cdnware.m.jd.com/c1/skuDetail/apple/7.3.0/32426231880.json; 最后一部分是商品skuid 可以获取到的信息: 商品名称, 商品店铺信息 , 商品类别id, \b商品品牌id, 商品选项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 &#123;\"code\": \"0\",\"wareInfo\": &#123; \"recommendInfo\": &#123; \"recommendList\": null &#125;, // 商品店铺信息 \"shopInfo\": &#123; \"shop\": &#123; \"shopId\": 1000000127, \"name\": \"京东Apple产品专营店\", ... &#125;, \"basicInfo\": &#123; \"gift\": false, \"bookInfo\": &#123; // 如果是书, 这里是书的选项信息 \"display\": false &#125;, \"colorSizeInfo\": &#123; // 商品选项信息列表 有的没有 \"colorSize\": [&#123; \"buttons\": [&#123; \"no\": \"1\", \"skuList\": [\"100000177738\", \"100000287117\", \"100000287145\", \"100000309448\", \"100000309450\", \"100000375233\", \"100000435832\", \"100000458753\", \"100000458755\", \"100001860767\", \"100001860773\"], \"text\": \"金色\" &#125;, &#123; \"no\": \"2\", \"skuList\": [\"100000177764\", \"100000287113\", \"100000287135\", \"100000435780\", \"100000435816\", \"100000435818\", \"100000569049\", \"100000602206\", \"100000602208\", \"100001860765\", \"100002539302\"], \"text\": \"深空灰色\" &#125;, &#123; \"no\": \"3\", \"skuList\": [\"100000177740\", \"100000177784\", \"100000287147\", \"100000435834\", \"100000458737\", \"100000458739\", \"100000602174\", \"100000602176\", \"100000602204\", \"100001860789\", \"100002539304\"], \"text\": \"银色\" &#125;], \"title\": \"颜色\" &#125;, &#123; \"buttons\": [&#123; \"no\": \"1\", \"skuList\": [\"100000177738\", \"100000177740\", \"100000177764\", \"100000177784\", \"100000287113\", \"100000287117\", \"100000287135\", \"100000287145\", \"100000287147\"], \"text\": \"公开版\" &#125;, ... ], \"title\": \"版本\" &#125;, &#123; \"buttons\": [&#123; \"no\": \"1\", \"skuList\": [\"100000177764\", \"100000287145\", \"100000287147\", \"100000375233\", \"100000435818\", \"100000458739\", \"100000458755\", \"100000602204\", \"100000602208\", \"100001860765\", \"100001860773\", \"100001860789\"], \"text\": \"64GB\" &#125;, ... ], \"title\": \"内存\" &#125;], \"colorSizeTips\": \"#与其他已选项无法组成可售商品，请重选\" &#125;, ... // 品牌ID \"brandID\": \"14026\", ... // 商品图片 \"wareImage\": [&#123; \"small\": \"https://m.360buyimg.com/mobilecms/s720x720_jfs/t1/3/15/4536/138660/5b997bf8Ed72ebce7/819dcf182d743897.jpg!q70.jpg.webp\", ... &#125; ... ], ... // 商品名称 \"name\": \"Apple iPhone XS Max (A2104) 256GB 深空灰色 移动联通电信4G手机 双卡双待\", // 商品类别id \"category\": \"9987;653;655\" &#125; &#125; &#125; 商品促销信息(PC端): 图: URL: https://cd.jd.com/promotion/v2?skuId=4749506&amp;area=1_72_4137_0&amp;cat=737%2C794%2C798 参数 skuId=4749506: 商品sku_id area=1_72_4137_0: 购买者区域, 固定的 cat=737%2C794%2C798: 类别 数据 123456789&#123; ... // 商品促销信息 \"ads\": [&#123; \"id\": \"AD_4749506\", \"ad\": \"【即刻预约，21号秒杀到手价2999】\\n1、前100名晒单送腾讯企鹅影院季卡，联系客服领取！！\\n2、曲面爆款，5.5万好评推荐！&lt;a target=\\\"_blank\\\" href=\\\"https://item.jd.com/7055876.html\\\"&gt;升级55Q1D超清全面屏电视&lt;/a&gt;\" &#125;], ... &#125; 商品评论信息(PC端) 图: URL: https://club.jd.com/comment/productCommentSummaries.action?referenceIds=4749506 参数 referenceIds=4749506: 商品sku_id 数据: 12345678910&#123;\"CommentsCount\":[ &#123; \"CommentCountStr\":\"10万+\", \"CommentCount\":100000, //评论数量 \"AverageScore\":5, \"GoodRate\":0.98, //好评率 \"PoorCountStr\":\"600+\", \"PoorCount\":600, // 差评数量 ... &#125;]&#125; 商品价格信息: 图: URL: https://p.3.cn/prices/mgets?skuIds=J_4749506 参数: skuIds=J_4749506 商品的sku_id 数据: 12345678[ &#123; \"op\": \"5499.00\", \"m\": \"5999.00\", \"id\": \"J_4749506\", //商品skuid \"p\": \"3299.00\" // 商品价格 &#125; ] 代码实现 步骤: 重写start_requests方法, 根据分类信息构建列表页的请求 解析列表页, 提取商品的skuid, 构建商品基本的信息请求; 实现翻页 解析商品基本信息, 构建商品促销信息的请求 解析促销信息,构建商品评价信息的请求, 解析商品评价信息, 构建价格信息的请求 解析价格信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121class JdProductSpider(scrapy.Spider): name &#x3D; &#39;jd_product&#39; allowed_domains &#x3D; [&#39;jd.com&#39;, &#39;p.3.cn&#39;] def start_requests(self): category &#x3D; &#123; &quot;b_category_name&quot; : &quot;家用电器&quot;, &quot;b_category_url&quot; : &quot;https:&#x2F;&#x2F;jiadian.jd.com&quot;, &quot;m_category_name&quot; : &quot;洗衣机&quot;, &quot;m_category_url&quot; : &quot;https:&#x2F;&#x2F;list.jd.com&#x2F;list.html?cat&#x3D;737,794,880&quot;, &quot;s_category_name&quot; : &quot;洗衣机配件&quot;, &quot;s_category_url&quot; : &quot;https:&#x2F;&#x2F;list.jd.com&#x2F;list.html?cat&#x3D;737,794,877&quot; &#125; yield scrapy.Request(category[&#39;s_category_url&#39;], self.parse, meta&#x3D;&#123;&#39;category&#39;: category&#125;) def parse(self, response): # 获取类别信息 category &#x3D; response.meta[&#39;category&#39;] # 获取类别的URL category_url &#x3D; response.url.split(&#39;&amp;&#39;)[0] # 获取所有商品的sku_ids sku_ids &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[contains(@class, &quot;j-sku-item&quot;)]&#x2F;@data-sku&#39;).extract() # 遍历sku_ids, 构建基本详情信息的请求 for sku_id in sku_ids: item &#x3D; &#123; &#39;product_category&#39;: category, &#39;product_sku_id&#39;:sku_id &#125; product_url &#x3D; &#39;https:&#x2F;&#x2F;cdnware.m.jd.com&#x2F;c1&#x2F;skuDetail&#x2F;apple&#x2F;7.3.0&#x2F;&#123;&#125;.json&#39;.format(sku_id) yield scrapy.Request(product_url, callback&#x3D;self.parse_product, meta&#x3D;&#123;&#39;item&#39;: item&#125;) # 获取下一页的URL next_url &#x3D; response.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;&quot;pn-next&quot;]&#x2F;@href&#39;).extract_first() if next_url: # 补全URL next_url &#x3D; response.urljoin(next_url) # 构建下一页请求 yield scrapy.Request(next_url, callback&#x3D;self.parse, meta&#x3D;&#123;&#39;category&#39;: category&#125;) def parse_product(self, response): # 取出传递过来的数据 item &#x3D; response.meta[&#39;item&#39;] # 把响应数据数据转为字典 product_dic &#x3D; json.loads(response.text) # 获取商品名称 item[&#39;product_name&#39;] &#x3D; product_dic[&#39;wareInfo&#39;][&#39;basicInfo&#39;][&#39;name&#39;] if item[&#39;product_name&#39;]: # 获取类别id, 把 &#96;;&#96; 替换为 , item[&#39;product_category_id&#39;] &#x3D; product_dic[&#39;wareInfo&#39;][&#39;basicInfo&#39;][&#39;category&#39;].replace(&#39;;&#39;, &#39;,&#39;) # 获取店铺信息 product_shop &#x3D; jsonpath(product_dic, &#39;$..shop&#39;) if product_shop: product_shop &#x3D; product_shop[0] if product_shop is None: item[&#39;product_shop&#39;] &#x3D; &#123;&#39;name&#39;:&#39;京东自营&#39;&#125; else: item[&#39;product_shop&#39;] &#x3D; &#123; &quot;shopId&quot;: product_shop[&#39;shopId&#39;], &quot;name&quot;: product_shop[&#39;name&#39;], &quot;score&quot;: product_shop[&#39;score&#39;], &quot;url&quot;: product_shop[&#39;url&#39;], &#125; # 如果是书, 记录书的信息 if product_dic[&#39;wareInfo&#39;][&#39;basicInfo&#39;][&#39;bookInfo&#39;][&#39;display&#39;]: item[&#39;product_book_info&#39;] &#x3D; product_dic[&#39;wareInfo&#39;][&#39;basicInfo&#39;][&#39;bookInfo&#39;] # 删除display del item[&#39;book_info&#39;][&#39;display&#39;] # 获取商品选购信息 color_sizes &#x3D; jsonpath(product_dic, &#39;$..colorSize&#39;) product_option &#x3D; &#123;&#125; if color_sizes: for color_size in color_sizes[0]: title &#x3D; color_size[&#39;title&#39;] texts &#x3D; jsonpath(color_size, &#39;$..text&#39;) product_option.update(&#123;title:texts&#125;) # print(product_option) item[&#39;product_option&#39;] &#x3D; product_option # 商品图片 item[&#39;product_img_url&#39;] &#x3D; jsonpath(product_dic, &#39;$..wareImage[0].small&#39;)[0] # 构建促销信息的请求 ad_url &#x3D; &#39;https:&#x2F;&#x2F;cd.jd.com&#x2F;promotion&#x2F;v2?skuId&#x3D;&#123;&#125;&amp;area&#x3D;1_72_4137_0&amp;cat&#x3D;&#123;&#125;&#39;.format(item[&#39;product_sku_id&#39;], item[&#39;product_category_id&#39;]) yield scrapy.Request(ad_url, callback&#x3D;self.parse_ad, meta&#x3D;&#123;&#39;item&#39;: item&#125;) def parse_ad(self, response): &quot;&quot;&quot;获取商品促销&quot;&quot;&quot; item &#x3D; response.meta[&#39;item&#39;] ad_dic &#x3D; json.loads(response.body.decode(&#39;GB18030&#39;)) ad &#x3D; ad_dic[&#39;ads&#39;][0][&#39;ad&#39;] item[&#39;product_ad&#39;] &#x3D; ad # for key, value in item.items(): # print(&#39;&#123;&#125; &#x3D; &#123;&#125;&#39;.format(key, value)) # 构建平均信息请求 comments_url &#x3D; &#39;https:&#x2F;&#x2F;club.jd.com&#x2F;comment&#x2F;productCommentSummaries.action?referenceIds&#x3D;&#123;&#125;&#39;.format(item[&#39;product_sku_id&#39;]) yield scrapy.Request(comments_url, callback&#x3D;self.parse_comments, meta&#x3D;&#123;&#39;item&#39;: item&#125;) def parse_comments(self, response): &quot;&quot;&quot;解析商品评论信息&quot;&quot;&quot; item &#x3D; response.meta[&#39;item&#39;] comments_dic &#x3D; json.loads(response.text) comments &#x3D; &#123; &#39;comment_count&#39;: jsonpath(comments_dic, &#39;$..CommentCount&#39;)[0], &#39;good_rate&#39;: jsonpath(comments_dic, &#39;$..GoodRate&#39;)[0], &#39;poor_count&#39;: jsonpath(comments_dic, &#39;$..PoorCount&#39;)[0], &#125; item[&#39;product_comments&#39;] &#x3D; comments # print(item) # 构建价格请求 price_url &#x3D; &#39;https:&#x2F;&#x2F;p.3.cn&#x2F;prices&#x2F;mgets?skuIds&#x3D;J_&#123;&#125;&#39;.format(item[&#39;product_sku_id&#39;]) yield scrapy.Request(price_url, callback&#x3D;self.parse_price, meta&#x3D;&#123;&#39;item&#39;: item&#125;) def parse_price(self, response): &quot;&quot;&quot;解析价格&quot;&quot;&quot; item &#x3D; response.meta[&#39;item&#39;] item[&#39;product_price&#39;] &#x3D; json.loads(response.text)[0][&#39;p&#39;] # print(item) yield item 分布式 步骤: 修改爬虫类 在settings文件中配置scrapy_redis 写一个程序用于把MongoDB中分类信息, 放入到爬虫redis_key指定的列表中 修改爬虫类 步骤: 修改继承关系: 继承RedisSpider 指定redis_key 把重写start_requests 改为 重写 make_request_from_data 123456789101112131415from scrapy_redis.spiders import RedisSpiderimport pickle# 1. 修改继承关系: 继承RedisSpiderclass JdProductSpider(RedisSpider): name &#x3D; &#39;jd_product&#39; allowed_domains &#x3D; [&#39;jd.com&#39;, &#39;p.3.cn&#39;] # 2. 指定redis_key redis_key &#x3D; &#39;jd_product:start_category&#39; # 3. 把重写start_requests 改为 重写 make_request_from_data def make_request_from_data(self, data): # 把从Redis中读取到分类信息, 转换为字典 category &#x3D; pickle.loads(data) return scrapy.Request(category[&#39;s_category_url&#39;], self.parse, meta&#x3D;&#123;&#39;category&#39;: category&#125;) 注意: 在make_request_from_data不能使用 yield 必须使用 return 在settings文件中配置scrapy_redis 1234567891011121314# MongoDB数据库的URLMONGO_URL &#x3D; &#39;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#39;# REDIS数据链接REDIS_URL &#x3D; &#39; redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;0&#39;# 去重容器类: 用于把已爬指纹存储到基于Redis的set集合中DUPEFILTER_CLASS &#x3D; &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;# 调度器: 用于把待爬请求存储到基于Redis的队列SCHEDULER &#x3D; &quot;scrapy_redis.scheduler.Scheduler&quot;# 是不进行调度持久化:# 如果是True, 当程序结束的时候, 会保留Redis中已爬指纹和待爬的请求# 如果是False, 当程序结束的时候, 会清空Redis中已爬指纹和待爬的请求SCHEDULER_PERSIST &#x3D; True 把MongoDB中分类信息, 放入到爬虫redis_key指定的列表中 步骤: 在项目文件夹下创建 add_category_to_redis.py 实现方法 add_category_to_redis: 链接MongoDB 链接Redis 读取MongoDB中分类信息, 序列化后, 添加到商品爬虫redis_key指定的list 关闭MongoDB 在if __name__ == &#39;__main__&#39;:中调用add_category_to_redis方法 代码 123456789101112131415161718192021222324from redis import StrictRedisfrom pymongo import MongoClientimport picklefrom mall_spider.settings import MONGO_URL, REDIS_URLfrom mall_spider.spiders.jd_product import JdProductSpider# 把MongoDB中分类信息, 添加到Redis中def add_category_to_redis(): # 链接MongoDB client = MongoClient(MONGO_URL) # 链接Redis redis = StrictRedis.from_url(REDIS_URL) cursor = client['jd']['category'].find() # 读取MongoDB中分类信息, 序列化后, 添加到商品爬虫redis_key指定的list for category in cursor: redis.rpush(JdProductSpider.redis_key, pickle.dumps(category)) # 关闭MongoDB的链接 client.close()if __name__ == '__main__': add_category_to_redis() 保存商品数据步骤 在 open_spider方法, 建立MongoDB数据库连接, 获取要操作的集合 在 process_item方法, 把数据插入到MongoDB中 在close_spider方法, 关闭数据库连接 代码 1234567891011121314151617181920class ProductPipeline(object): def open_spider(self, spider): if isinstance(spider, JdProductSpider): # 建立MongoDB数据库链接 self.client = MongoClient(MONGO_URL) # 获取要操作集合 self.category = self.client['jd']['product'] def process_item(self, item, spider): if isinstance(spider, JdProductSpider): # 把数据插入到mongo中 self.category.insert_one(dict(item)) return item def close_spider(self, spider): \"\"\"关闭\"\"\" if isinstance(spider, JdProductSpider): self.client.close() 在settings.py中开启这个管道 12345ITEM_PIPELINES = &#123; 'mall_spider.pipelines.CategoryPipeline': 300, # 开启商品管道 'mall_spider.pipelines.ProductPipeline': 301,&#125; 反爬为了避免IP反爬, 我们实现随机User-Agent和代理IP的中间件 步骤: 实现随机User-Agent的中间件 实现代理IP中间件 在settings.py 文件开启, 下载器中间件 实现随机User-Agent的中间件 步骤 准备User-Agent列表 在middlewares.py中, 实现RandomUserAgent类 实现process_request方法 如果是请求是 https://cdnware.m.jd.com 开头的, 就是设置一个iPhone的user-agent 否则从User-Agent列表中随机取出一个 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import requestsimport random# 准备请求头USER_AGENTS = [ \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\", \"Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\", \"Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\", \"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\", \"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\", \"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\", \"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\", \"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\", \"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 LBBROWSER\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)\", \"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1\", \"Mozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko/20110307 Firefox/4.0b13pre\", \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko/20100101 Firefox/16.0\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11\", \"Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10\"]class RandomUserAgent(object): def process_request(self, request, spider): if request.url.startswith('https://cdnware.m.jd.com'): # 如果使用手机抓包, 获取到商品信息; 生成请求请求头 request.headers['user-agent'] = 'JD4iPhone/164880 (iPhone; iOS 12.1.2; Scale/2.00)' else: # 随机获取一个请求头, 进行设置 request.headers['user-agent'] = random.choice(USER_AGENTS) 实现代理IP中间件 步骤: 在middlewares.py中, 实现ProxyMiddleware类 实现process_request方法 \b从代理池中获取一个随机的代理IP, 需指定代理IP的协议, 和访问的域名 设置给request.meta[‘proxy’] \b实现process_exception方法 当请求出现异常的时候, 代理池哪些代理IP在本域名下是不可以用的 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849\"\"\"9.2. 实现代理IP中间件步骤: 在middlewares.py中, 实现ProxyMiddleware类 实现process_request方法 \b从代理池中获取一个随机的代理IP 设置给request.meta['proxy']\"\"\"from twisted.internet import deferfrom twisted.internet.error import TimeoutError, DNSLookupError, \\ ConnectionRefusedError, ConnectionDone, ConnectError, \\ ConnectionLost, TCPTimedOutErrorfrom twisted.web.client import ResponseFailedfrom scrapy.core.downloader.handlers.http11 import TunnelErrorclass ProxyMiddleware(object): EXCEPTIONS_TO_RETRY = (defer.TimeoutError, TimeoutError, DNSLookupError, ConnectionRefusedError, ConnectionDone, ConnectError, ConnectionLost, TCPTimedOutError, ResponseFailed, IOError, TunnelError) def process_request(self, request, spider): \"\"\" 从代理池中获取一个随机的代理IP 设置给request.meta['proxy'] \"\"\" response = requests.get('http://localhost:6868/random?protocol=https&amp;domain=jd.com') request.meta['proxy'] = response.content.decode() request.meta['dont_redirect'] = True return None def process_exception(self, request, exception, spider): if isinstance(exception, self.EXCEPTIONS_TO_RETRY): # 获取代理IP proxy = request.meta['proxy'] # 提取IP地址 ip = re.findall('https://(.+):\\d+', proxy)[0] params = &#123; 'ip': ip, 'domain': 'jd.com' &#125; requests.get('http://localhost:6868/disable_domain', params=params) # 构建请求返回 req = request.copy() req.dont_filter = True return req 在settings.py中开启上面的两个下载器中间件 12345# 配置下载器中间件DOWNLOADER_MIDDLEWARES = &#123;'mall_spider.middlewares.RandomUserAgent': 500,'mall_spider.middlewares.ProxyMiddl eware': 543,&#125; 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"http://onejane.github.io/tags/scrapy/"},{"name":"scrapy_redis","slug":"scrapy-redis","permalink":"http://onejane.github.io/tags/scrapy-redis/"},{"name":"mongo","slug":"mongo","permalink":"http://onejane.github.io/tags/mongo/"}]},{"title":"爬虫基础篇之斗鱼弹幕","slug":"爬虫基础篇之斗鱼弹幕","date":"2021-04-08T11:55:37.000Z","updated":"2021-04-09T00:01:17.101Z","comments":true,"path":"2021/04/08/爬虫基础篇之斗鱼弹幕/","link":"","permalink":"http://onejane.github.io/2021/04/08/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E6%96%97%E9%B1%BC%E5%BC%B9%E5%B9%95/","excerpt":"","text":"Socket asyncore 模块为异步socket的服务器客户端通信提供简单的接口。该模块提供了异步socket服务客户端和服务器的基础架构。 相比python原生的socket api，asyncore具备有很大的优势，asyncore对原生的socket进行封装，提供非常简洁优秀的接口，利用asyncore覆写相关需要处理的接口方法，就可以完成一个socket的网络编程，从而不需要处理复杂的socket网络状况以及多线程处理等等。 demo服务端1netcat-win32-1.12&gt;nc -l -p 9000 启动服务端 客户端telnet 127.0.0.1 9000 客户端连接到服务器 发送信息 定义类继承自asyncore.dispatcher 1class SocketClient(asyncore.dispatcher): 实现类中的回调代码 实现构造函数 调用父类方法 1asyncore.dispatcher.__init__(self) 创建 Socket 对象 1self.create_socket() 连接服务器 12address = (host,port)self.connect(address) 实现 handle_connect 回调函数 当 Socket 连接服务器成功时回调该函数 12def handle_connect(self): print(\"连接成功\") 实现 writable 回调函数 描述是否有数据需要被发送到服务器。返回值为 True 表示可写，False 表示不可写，如果不实现默认返回为 True，当返回 True 时，回调函数 handle_write 将被触发 12def writable(self): return True 实现 handle_write 回调函数 当有数据需要发送时（writable 回调函数返回True时），该函数被触发，通常情况下在该函数中编写 send 方法发送数据 1234def handle_write(self): # 内部实现对服务器发送数据的代码 # 调用 send 方法发送数据，参数是字节数据 self.send('hello world\\n'.encode('utf-8')) 实现 readable 回调函数 描述是否有数据从服务端读取。返回 True 表示有数据需要读取，False 表示没有数据需要被读取，当不实现默认返回为 True，当返回 True 时，回调函数 handle_read 将被触发 12def readable(self): return True 实现 handle_read 回调函数 当有数据需要读取时触发（readable 回调函数返回 True 时），该函数被触发，通常情况下在该函数中编写 recv 方法接收数据 12345def handle_read(self): # 主动接收数据，参数是需要接收数据的长度 # 返回的数据是字节数据 result = self.recv(1024) print(result) 实现 handle_error 回调函数 当程序运行过程发生异常时回调 1234def handle_error(self): # 编写处理错误方法 t,e,trace = sys.exc_info() self.close() 实现 handle_close 回调函数 当连接被关闭时触发 123def handle_close(self): print(\"连接关闭\") self.close() 创建对象并且执行 asyncore.loop 进入运行循环 timeout 表示一次循环所需要的时长 123client = SocketClient('127.0.0.1',9000)# 开始启动运行循环asyncore.loop(timeout=5) 抓取弹幕开发流程根据斗鱼弹幕服务器第三方接入协议v1.6.2.pdf 官方提供协议文档建立弹幕客户端开发流程。 连接初始化 使用TCP连接服务器 IP地址：openbarrage.douyutv.com 端口：8601 客户端向弹幕服务器发送登录请求，登录弹幕服务器 弹幕服务器收到客户端登录请求并完成登录后，返回登录成功消息给客户端 客户端收到登录成功消息后发送进入弹幕分组请求给弹幕服务器 弹幕服务器接受到客户端弹幕分组请求后将客户端添加到请求指定的弹幕分组中 服务过程 客户端每隔 45 秒发送心跳给弹幕服务器，弹幕服务器回复心跳信息给客户端 弹幕服务器如有广播信息，则推送给客户端，服务器消息协议 断开连接 客户端发送登出消息 客户端关闭 TCP 连接 数据包结构 消息长度:4 字节小端整数，表示整条消息(包括自身)长度(字节数)。 消息长度出现两遍，二者相同。 消息类型:2 字节小端整数，表示消息类型。取值如下: 689 客户端发送给弹幕服务器的文本格式数据 690 弹幕服务器发送给客户端的文本格式数据。 加密字段:1字节，暂时未用，默认为 0。 保留字段:1字节，暂时未用，默认为 0。 数据部分:n字节+1字节，斗鱼独创序列化文本数据，结尾必须为‘\\0’。(所有协议内容均为 UTF-8 编码) 数据包封装 对数据包进行对象化封装，对数据的封装方便以后使用，实现对象和二进制数据之间的转换 通过参数构建数据包对象 实现获取数据包长度的方法 实现获取二进制数据的方法 实现发送数据包 构建发送数据包的队列容器 1self.send_queue = Queue() 实现回调函数，判断容器中有数据就发送没有数据不发送 1234567891011121314151617def writable(self): return self.send_queue.qsize() &gt; 0def handle_write(self): # 从发送数据包队列中获取数据包对象 dp = self.send_queue.get() # 获取数据包的长度，并且发送给服务器 dp_length = dp.get_length() dp_length_data = dp_length.to_bytes(4,byteorder='little',signed=False) self.send(dp_length_data) # 发送数据包二进制数据 self.send(dp.get_bytes()) self.send_queue.task_done() pass 实现登录函数 构建登录数据包 12content = \"type@=loginreq/roomid@=&#123;&#125;/\".format(room_id)login_dp = DataPacket(DATA_PACKET_TYPE_SEND,content=content) 把数据包添加到发送数据包容器中 12# 把数据包添加到发送数据包容器中 self.send_queue.put(login_dp) 实现接收数据 构建接收数据包队列 12# 存放接收的数据包对象self.recv_queue = Queue() 读取回调函数中读取数据 读取长度 1234# 读取长度,二进制数据data_length_data = self.recv(4)# 通过二进制获取length 具体数据data_length = int.from_bytes(data_length_data,byteorder='little',signed=False) 读取内容 12# 通过数据包的长度获取数据data = self.recv(data_length) 构建数据包对象 数据包构造函数中解析二进制来构建数据包对象 12345self.type = int.from_bytes(data_bytes[4:6],byteorder='little',signed=False)self.encrypt_flag = int.from_bytes(data_bytes[6:7],byteorder='little',signed=False)self.preserve_flag = int.from_bytes(data_bytes[7:8],byteorder='little',signed=False)# 构建数据部分self.content = str(data_bytes[8:-1],encoding='utf-8') 通过二进制数据构建数据包对象 12# 通过二进制数据构建数据包对象dp = DataPacket(data_bytes=data) 把数据包放入接收数据包容器中 12# 把数据包放入接收数据包容器中self.recv_queue.put(dp) 构建处理线程专门处理接收数据包容器中数据 构建线程 1234# 构建一个专门处理接收数据包容器中的数据包的线程self.callback_thread = threading.Thread(target=self.do_callback)self.callback_thread.setDaemon(True)self.callback_thread.start() 实现回调函数处理接收的数据包 123456789101112def do_callback(self): ''' 专门负责处理接收数据包容器中的数据 :return: ''' while True: # 从接收数据包容器中获取数据包 dp = self.recv_queue.get() # 对数据进行处理 print(dp.content) pass 实现外部传入回调函数 通过外部指定回调函数实现自定义数据处理 添加参数 callback 构造函数中添加参数 123def __init__(self,host,port,callback=None): # 定义外部传入的自定义回调函数 self.callback = callback 外部传入自定义回调函数 123456789101112131415def data_callback(dp): ''' 自定义回调函数 :param dp: 数据包对象 :return: ''' print(\"data_callback:\",dp.content) passif __name__ == '__main__': client = DouyuClient('openbarrage.douyutv.com',8601,callback=data_callback) client.login_room_id(4494106) asyncore.loop(timeout=10) 在处理接收数据包的线程中调用回调函数 123456789101112def do_callback(self): ''' 专门负责处理接收数据包容器中的数据 :return: ''' while True: # 从接收数据包容器中获取数据包 dp = self.recv_queue.get() # 对数据进行处理 if self.callback is not None: self.callback(dp) self.recv_queue.task_done() 数据内容序列化与反序列化 键 key 和值 value 直接采用‘@=’分割 数组采用‘/’分割 如果 key 或者 value 中含有字符‘/’，则使用‘@S’转义 如果 key 或者 value 中含有字符‘@’，使用‘@A’转义 例子 多个键值对数据:key1@=value1/key2@=value2/key3@=value3/ 数组数据:value1/value2/value3/ 登录 123456789101112131415def login_room_id(self, room_id): # 2.客户端向弹幕服务器发送登录请求，登录弹幕服务器 self.room_id &#x3D; room_id send_data &#x3D; &#123; &quot;type&quot;: &quot;loginreq&quot;, &quot;roomid&quot;: str(room_id) &#125; # 构建登录数据包 content &#x3D; encode_content(send_data) login_dp &#x3D; DataPacket(DATA_PACKET_TYPE_SEND, content&#x3D;content) # 把数据包添加到发送数据包容器中 self.send_queue.put(login_dp) 加入弹幕分组 参看斗鱼弹幕文档,-9999 为海量弹幕 12345678910111213141516def join_room_group(self): &#39;&#39;&#39; 4.客户端收到登录成功消息后发送进入弹幕分组请求给弹幕服务器 :return: &#39;&#39;&#39; send_data &#x3D; &#123; &quot;type&quot;: &quot;joingroup&quot;, &quot;rid&quot;: str(self.room_id), &quot;gid&quot;: &#39;-9999&#39; &#125; content &#x3D; encode_content(send_data) dp &#x3D; DataPacket(type&#x3D;DATA_PACKET_TYPE_SEND, content&#x3D;content) self.send_queue.put(dp) pass 心跳机制 作用是让服务器解决假死连接问题，客户端必须每隔45秒发送一次请求，否则就会被主动断开。 实现发送心跳函数 构建心跳数据包 把数据包添加到发送数据包容器队列中 构建心跳线程 构建心跳线程 添加触发机制 添加暂停机制 12345678def send_heart_data_packet(self): # 6.客户端每隔 45 秒发送心跳给弹幕服务器，弹幕服务器回复心跳信息给客户端 send_data &#x3D; &#123; &quot;type&quot;: &quot;mrkl&quot; &#125; content &#x3D; encode_content(send_data) dp &#x3D; DataPacket(type&#x3D;DATA_PACKET_TYPE_SEND, content&#x3D;content) self.send_queue.put(dp) WebSocket以上方案已经失效，斗鱼弹幕已使用websocket实现，不过都是协议而已，基础逻辑没有变化。 通过抓包获取wss的地址及端口 查看抓包中的Messages中的二进制信息，数据格式和1.6.2保持一致。 run_forever是核心逻辑通过while循环实现自动重连，建立_job_open时调用_one_hello登录加入群组，通过_job_heartbeat持续接受心跳机制。 123456789101112131415161718192021222324252627282930313233343536373839async def run_forever(self) -&gt; None: &quot;&quot;&quot; 重写 @return: &quot;&quot;&quot; self._waiting_end &#x3D; self._loop.create_future() while not self._closed: self._logger_info(f&#39;正在启动 &#123;self._area_id&#125; 号数据连接&#39;) if self._waiting_pause is not None: self._logger_info(f&#39;暂停启动 &#123;self._area_id&#125; 号数据连接，等待 RESUME 指令&#39;) await self._waiting_pause async with self._opening_lock: if self._closed: self._logger_info(f&#39;&#123;self._area_id&#125; 号数据连接确认收到关闭信号，正在处理&#39;) break # 未成功建立数据连接，循环重试 if await self._prepare_client() and await self._job_open(): tasks &#x3D; [self._loop.create_task(i()) for i in self._funcs_task] self._task_main &#x3D; self._loop.create_task(self._job_main()) tasks.append(self._task_main) task_heartbeat &#x3D; self._loop.create_task(self._job_heartbeat()) tasks.append(task_heartbeat) else: continue _, pending &#x3D; await asyncio.wait(tasks, return_when&#x3D;asyncio.FIRST_COMPLETED) self._logger_info(f&#39;&#123;self._area_id&#125; 号数据连接异常或主动断开，正在处理剩余信息&#39;) for i in pending: if i !&#x3D; self._task_main: i.cancel() await self._job_close() if pending: await asyncio.wait(pending) self._logger_info(f&#39;&#123;self._area_id&#125; 号数据连接退出，剩余任务处理完毕&#39;) await self._conn.clean() self._waiting_end.set_result(True) 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"asyncore","slug":"asyncore","permalink":"http://onejane.github.io/tags/asyncore/"},{"name":"socket","slug":"socket","permalink":"http://onejane.github.io/tags/socket/"},{"name":"asyncio","slug":"asyncio","permalink":"http://onejane.github.io/tags/asyncio/"},{"name":"websocket","slug":"websocket","permalink":"http://onejane.github.io/tags/websocket/"}]},{"title":"爬虫基础篇之IP代理池","slug":"爬虫基础篇之IP代理池","date":"2021-03-30T08:09:50.000Z","updated":"2021-04-07T14:48:31.129Z","comments":true,"path":"2021/03/30/爬虫基础篇之IP代理池/","link":"","permalink":"http://onejane.github.io/2021/03/30/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BIP%E4%BB%A3%E7%90%86%E6%B1%A0/","excerpt":"","text":"代理池介绍由众多ip组成提供多个稳定可用代理IP的ip池。 当我们做爬虫时，最常见的反爬手段就是IP反爬，当同一个IP访问网站超出频控限制，将会被限制访问，那么代理IP池应运而生。资金充足的情况下个人建议还是付费ip代理池，比较免费ip时效性低，且难以维护。 本文将介绍通过requests库多线程抓取多个免费代理ip网站数据落库mongo后并动态维护保证IP高度可用，以API形式暴露接口获取代理IP的解决方案。 爬取流程 代理IP采集模块： 采集代理IP -&gt; 检测代理IP -&gt;如果不可用用, 直接过滤掉, 如果可用, 指定默认分数 -&gt; 存入数据库中 代理IP检测模块： 从数据库中获取所有代理IP -&gt; 检测代理IP -&gt; 如果代理IP不可用用, 就把分数-1, 如果分数为0从数据库中删除, 否则更新数据库, 如果代理IP可用, 恢复为默认分值,更新数据库 代理API模块：从数据库中高可用的代理IP给爬虫使用; 模块爬虫模块从代理IP网站上采集代理IP ,对抓取的ip进行校验(获取代理响应速度, 协议类型, 匿名类型), 并存储到数据库中。 校验模块网站上所标注的响应速度,协议类型和匿名类型是不准确的，通过httpbin.org进行检测，获取指定代理的响应速度, 支持的协议以及匿名程度。 数据库模块使用MongoDB来存储代理IP并实现对代理IP的增删改查操作。 检测模块定时从数据库读取所有的代理IP，对代理IP进行逐一检测, 开启多个协程, 以提高检测速度，如果该代理不可用, 就让这个代理分数-1, 当代理的分数到0了, 就删除该代理; 如果检测到代理可用就恢复为满分。 API模块根据协议类型和域名获取多个随机的高质量代理IP，根据代理IP不可用域名, 告诉代理池这个代理IP在该域名下不可用, 下次获取这个域名的代理IP时候, 就不会再获取这个代理IP了, 从而保证代理IP高可用性。 其他模块数据模型 代理IP的数据模型, 用于封装代理IP相关信息, 比如ip,端口号, 响应速度, 协议类型, 匿名类型,分数等。 程序入口 代理池提供一个统一的启动入口 工具模块 日志模块: 用于记录日志信息 http模块: 用于获取随机User-Agent的请求头 配置文件 用于默认代理的分数, 配置日志格式, 文件, 启动的爬虫, 检验的间隔时间 等。 实战思路1：依据流程图，逐步实现各个模块，当需要依赖其他模块时，暂停当前模块，开发其他模块功能，实现完毕再回头开发联调。 思路2：先实现不依赖其他模块的基础模块，再逐步实现具体的功能模块，比如爬虫模块, 检测模块, 代理API模块。 这里我们选择思路2实现爬虫代理IP池，因为思路1适合个人完成，不适合分工合作，且不易维护，思路跳来跳去，必须逻辑清晰。 数据模型domainsettings.py 中 定义MAX_SCORE = 50, 表示代理IP的默认最高分数 12345678910111213141516171819202122232425class Proxy(object): def __init__(self, ip, port, protocol&#x3D;-1, nick_type&#x3D;-1, speed&#x3D;-1, area&#x3D;None, score&#x3D;MAX_SCORE, disable_domains&#x3D;[]): # ip: 代理的IP地址 self.ip &#x3D; ip # port: 代理IP的端口号 self.port &#x3D; port # protocol: 代理IP支持的协议类型, http是0, https是1, https和http都支持是2，-1不可用 self.protocol &#x3D; protocol # nick_type: 代理IP的匿名程度, 高匿: 0, 匿名: 1, 透明: 2 self.nick_type &#x3D; nick_type # speed: 代理IP的响应速度, 单位s self.speed &#x3D; speed # area: 代理IP所在地区 self.area &#x3D; area # score: 代理IP的评分, 用于衡量代理的可用性; self.score &#x3D; score # 默认分值可以通过配置文件进行配置.在进行代理可用性检查的时候, 每遇到一次请求失败就减1份, 减到0的时候从池中删除.如果检查代理可用, 就恢复默认分值 # disable_domains: 不可用域名列表, 有些代理IP在某些域名下不可用, 但是在其他域名下可用 self.disable_domains &#x3D; disable_domains # 3. 提供 __str__ 方法, 返回数据字符串 def __str__(self): # 返回数据字符串 return str(self.__dict__) 日志模块log导入settings中日志配置信息,如下LOG_LEVEL = logging.DEBUG # 默认等级LOG_FMT = ‘%(asctime)s %(filename)s [line:%(lineno)d] %(levelname)s: %(message)s’ # 默认日志格式LOG_DATEFMT = ‘%Y-%m-%d %H:%M:%S’ # 默认时间格式LOG_FILENAME = ‘log.log’ # 默认日志文件名称 12345678910111213141516171819202122232425262728293031323334353637383940class Logger(object): def __init__(self): # 1. 获取一个logger对象 self._logger &#x3D; logging.getLogger() # 2. 设置format对象 self.formatter &#x3D; logging.Formatter(fmt&#x3D;LOG_FMT,datefmt&#x3D;LOG_DATEFMT) # 3. 设置日志输出 # 3.1 设置文件日志模式 self._logger.addHandler(self._get_file_handler(LOG_FILENAME)) # 3.2 设置终端日志模式 self._logger.addHandler(self._get_console_handler()) # 4. 设置日志等级 self._logger.setLevel(LOG_LEVEL) def _get_file_handler(self, filename): &#39;&#39;&#39;返回一个文件日志handler&#39;&#39;&#39; # 1. 获取一个文件日志handler filehandler &#x3D; logging.FileHandler(filename&#x3D;filename,encoding&#x3D;&quot;utf-8&quot;) # 2. 设置日志格式 filehandler.setFormatter(self.formatter) # 3. 返回 return filehandler def _get_console_handler(self): &#39;&#39;&#39;返回一个输出到终端日志handler&#39;&#39;&#39; # 1. 获取一个输出到终端日志handler console_handler &#x3D; logging.StreamHandler(sys.stdout) # 2. 设置日志格式 console_handler.setFormatter(self.formatter) # 3. 返回handler return console_handler @property def logger(self): return self._logger# 初始化并配一个logger对象，达到单例的# 使用时，直接导入logger就可以使用logger &#x3D; Logger().logger 请求模块http返回随机请求头和随机User-Agent,对抗反爬 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 1. 准备User-Agent的列表USER_AGENTS &#x3D; [ &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident&#x2F;4.0; WOW64; Trident&#x2F;4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit&#x2F;523.15 (KHTML, like Gecko, Safari&#x2F;419.3) Arora&#x2F;0.3 (Change: 287 c9dfb30)&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux; en-US) AppleWebKit&#x2F;527+ (KHTML, like Gecko, Safari&#x2F;419.3) Arora&#x2F;0.6&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko&#x2F;20070215 K-Ninja&#x2F;2.1.1&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko&#x2F;20080705 Firefox&#x2F;3.0 Kapiko&#x2F;3.0&quot;, &quot;Mozilla&#x2F;5.0 (X11; Linux i686; U;) Gecko&#x2F;20070322 Kazehakase&#x2F;0.4.5&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora&#x2F;1.9.0.8-1.fc10 Kazehakase&#x2F;0.5.6&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;535.11 (KHTML, like Gecko) Chrome&#x2F;17.0.963.56 Safari&#x2F;535.11&quot;, &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit&#x2F;535.20 (KHTML, like Gecko) Chrome&#x2F;19.0.1036.7 Safari&#x2F;535.20&quot;, &quot;Opera&#x2F;9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto&#x2F;2.9.168 Version&#x2F;11.52&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;536.11 (KHTML, like Gecko) Chrome&#x2F;20.0.1132.11 TaoBrowser&#x2F;2.0 Safari&#x2F;536.11&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.71 Safari&#x2F;537.1 LBBROWSER&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;535.11 (KHTML, like Gecko) Chrome&#x2F;17.0.963.84 Safari&#x2F;535.11 LBBROWSER&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser&#x2F;7.0.3698.400)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident&#x2F;4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 5.1) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.89 Safari&#x2F;537.1&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.89 Safari&#x2F;537.1&quot;, &quot;Mozilla&#x2F;5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit&#x2F;533.17.9 (KHTML, like Gecko) Version&#x2F;5.0.2 Mobile&#x2F;8C148 Safari&#x2F;6533.18.5&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko&#x2F;20110307 Firefox&#x2F;4.0b13pre&quot;, &quot;Mozilla&#x2F;5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko&#x2F;20100101 Firefox&#x2F;16.0&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.11 (KHTML, like Gecko) Chrome&#x2F;23.0.1271.64 Safari&#x2F;537.11&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko&#x2F;20100922 Ubuntu&#x2F;10.10 (maverick) Firefox&#x2F;3.6.10&quot;]# 实现一个方法, 获取随机User-Agent的请求头def get_request_headers(): headers &#x3D; &#123; &#39;User-Agent&#39;: random.choice(USER_AGENTS), &#39;Accept&#39;: &#39;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8&#39;, &#39;Accept-Language&#39;: &#39;en-US,en;q&#x3D;0.5&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#125; return headers 校验模块httpbin_validator 检查代理IP速度 和 匿名程度; 代理IP速度: 就是从发送请求到获取响应的时间间隔 匿名程度检查: 对 http://httpbin.org/get 或 https://httpbin.org/get 发送请求 如果 响应的origin 中有’,’分割的两个IP就是透明代理IP 如果 响应的headers 中包含 Proxy-Connection 说明是匿名代理IP 否则就是高匿代理IP 检查代理IP协议类型 如果 http://httpbin.org/get 发送请求可以成功, 说明支持http协议 如果 https://httpbin.org/get 发送请求可以成功, 说明支持https协议 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778def check_proxy(proxy): &quot;&quot;&quot; 用于检查指定 代理IP 响应速度, 匿名程度, 支持协议类型 :param proxy: 代理IP模型对象 :return: 检查后的代理IP模型对象 &quot;&quot;&quot; # 准备代理IP字典 proxies &#x3D; &#123; &#39;http&#39;:&#39;http:&#x2F;&#x2F;&#123;&#125;:&#123;&#125;&#39;.format(proxy.ip, proxy.port), &#39;https&#39;:&#39;https:&#x2F;&#x2F;&#123;&#125;:&#123;&#125;&#39;.format(proxy.ip, proxy.port), &#125; # 测试该代理IP http, http_nick_type, http_speed &#x3D; __check_http_proxies(proxies) https, https_nick_type, https_speed &#x3D; __check_http_proxies(proxies, False) # 代理IP支持的协议类型, http是0, https是1, https和http都支持是2 if http and https: proxy.protocol &#x3D; 2 proxy.nick_type &#x3D; http_nick_type proxy.speed &#x3D; http_speed elif http: proxy.protocol &#x3D; 0 proxy.nick_type &#x3D; http_nick_type proxy.speed &#x3D; http_speed elif https: proxy.protocol &#x3D; 1 proxy.nick_type &#x3D; https_nick_type proxy.speed &#x3D; https_speed else: proxy.protocol &#x3D; -1 proxy.nick_type &#x3D; -1 proxy.speed &#x3D; -1 return proxydef __check_http_proxies(proxies, is_http&#x3D;True): # 匿名类型: 高匿: 0, 匿名: 1, 透明: 2 nick_type &#x3D; -1 # 响应速度, 单位s speed &#x3D; -1 if is_http: test_url &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39; else: test_url &#x3D; &#39;https:&#x2F;&#x2F;httpbin.org&#x2F;get&#39; try: # 获取开始时间 start &#x3D; time.time() # 发送请求, 获取响应数据 response &#x3D; requests.get(test_url, headers&#x3D;get_request_headers(), proxies&#x3D;proxies, timeout&#x3D;TEST_TIMEOUT) if response.ok: # 计算响应速度 speed &#x3D; round(time.time() - start, 2) # 匿名程度 # 把响应的json字符串, 转换为字典 dic &#x3D; json.loads(response.text) # 获取来源IP: origin origin &#x3D; dic[&#39;origin&#39;] proxy_connection &#x3D; dic[&#39;headers&#39;].get(&#39;Proxy-Connection&#39;, None) if &#39;,&#39; in origin: # 1. 如果 响应的origin 中有&#39;,&#39;分割的两个IP就是透明代理IP nick_type &#x3D; 2 elif proxy_connection: # 2. 如果 响应的headers 中包含 Proxy-Connection 说明是匿名代理IP nick_type &#x3D; 1 else: # 3. 否则就是高匿代理IP nick_type &#x3D; 0 return True, nick_type, speed return False, nick_type, speed except Exception as ex: # logger.exception(ex) return False, nick_type, speed 数据库模块mongo_pool 在init中, 建立数据连接, 获取要操作的集合, 在 del 方法中关闭数据库连接 提供基础的增删改查功能 提供代理API模块使用的功能 实现查询功能: 根据条件进行查询, 可以指定查询数量, 先分数降序, 速度升序排, 保证优质的代理IP在上面. 实现根据协议类型 和 要访问网站的域名, 获取代理IP列表 实现根据协议类型 和 要访问网站的域名, 随机获取一个代理IP 实现把指定域名添加到指定IP的disable_domain列表中. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121class MongoPool(object): def __init__(self): # 1.1. 在init中, 建立数据连接 self.client &#x3D; MongoClient(MONGO_URL) # 1.2 获取要操作的集合 self.proxies &#x3D; self.client[&#39;proxies_pool&#39;][&#39;proxies&#39;] def __del__(self): # 1.3 关闭数据库连接 self.client.close() def insert_one(self, proxy): &quot;&quot;&quot;2.1 实现插入功能&quot;&quot;&quot; count &#x3D; self.proxies.count_documents(&#123;&#39;_id&#39;: proxy.ip&#125;) if count &#x3D;&#x3D; 0: # 我们使用proxy.ip作为, MongoDB中数据的主键: _id dic &#x3D; proxy.__dict__ dic[&#39;_id&#39;] &#x3D; proxy.ip self.proxies.insert_one(dic) logger.info(&#39;插入新的代理:&#123;&#125;&#39;.format(proxy)) else: logger.warning(&quot;已经存在的代理:&#123;&#125;&quot;.format(proxy)) def update_one(self, proxy): &quot;&quot;&quot;2.2 实现修改该功能&quot;&quot;&quot; self.proxies.update_one(&#123;&#39;_id&#39;: proxy.ip&#125;, &#123;&#39;$set&#39;:proxy.__dict__&#125;) def delete_one(self, proxy): &quot;&quot;&quot;2.3 实现删除代理: 根据代理的IP删除代理&quot;&quot;&quot; self.proxies.delete_one(&#123;&#39;_id&#39;: proxy.ip&#125;) logger.info(&quot;删除代理IP: &#123;&#125;&quot;.format(proxy)) def find_all(self): &quot;&quot;&quot;2.4 查询所有代理IP的功能&quot;&quot;&quot; cursor &#x3D; self.proxies.find() for item in cursor: # 删除_id这个key item.pop(&#39;_id&#39;) proxy &#x3D; Proxy(**item) yield proxy def find(self, conditions&#x3D;&#123;&#125;, count&#x3D;0): &quot;&quot;&quot; 3.1 实现查询功能: 根据条件进行查询, 可以指定查询数量, 先分数降序, 速度升序排, 保证优质的代理IP在上面. :param conditions: 查询条件字典 :param count: 限制最多取出多少个代理IP :return: 返回满足要求代理IP(Proxy对象)列表 &quot;&quot;&quot; cursor &#x3D; self.proxies.find(conditions, limit&#x3D;count).sort([ (&#39;score&#39;, pymongo.DESCENDING),(&#39;speed&#39;, pymongo.ASCENDING) ]) # 准备列表, 用于存储查询处理代理IP proxy_list &#x3D; [] # 遍历 cursor for item in cursor: item.pop(&#39;_id&#39;) proxy &#x3D; Proxy(**item) proxy_list.append(proxy) # 返回满足要求代理IP(Proxy对象)列表 return proxy_list def get_proxies(self, protocol&#x3D;None, domain&#x3D;None, count&#x3D;0, nick_type&#x3D;0): &quot;&quot;&quot; 3.2 实现根据协议类型 和 要访问网站的域名, 获取代理IP列表 :param protocol: 协议: http, https :param domain: 域名: jd.com :param count: 用于限制获取多个代理IP, 默认是获取所有的 :param nick_type: 匿名类型, 默认, 获取高匿的代理IP :return: 满足要求代理IP的列表 &quot;&quot;&quot; # 定义查询条件 conditions &#x3D; &#123;&#39;nick_type&#39;: nick_type&#125; # 根据协议, 指定查询条件 if protocol is None: # 如果没有传入协议类型, 返回支持http和https的代理IP conditions[&#39;protocol&#39;] &#x3D; 2 elif protocol.lower() &#x3D;&#x3D; &#39;http&#39;: conditions[&#39;protocol&#39;] &#x3D; &#123;&#39;$in&#39;: [0, 2]&#125; else: conditions[&#39;protocol&#39;] &#x3D; &#123;&#39;$in&#39;: [1, 2]&#125; if domain: conditions[&#39;disable_domains&#39;] &#x3D; &#123;&#39;$nin&#39;: [domain]&#125; # 满足要求代理IP的列表 return self.find(conditions, count&#x3D;count) def random_proxy(self, protocol&#x3D;None, domain&#x3D;None, count&#x3D;0, nick_type&#x3D;0): &quot;&quot;&quot; 3.3 实现根据协议类型 和 要访问网站的域名, 随机获取一个代理IP :param protocol: 协议: http, https :param domain: 域名: jd.com :param count: 用于限制获取多个代理IP, 默认是获取所有的 :param nick_type: 匿名类型, 默认, 获取高匿的代理IP :return: 满足要求的随机的一个代理IP(Proxy对象) &quot;&quot;&quot; proxy_list &#x3D; self.get_proxies(protocol&#x3D;protocol, domain&#x3D;domain, count&#x3D;count, nick_type&#x3D;nick_type) # 从proxy_list列表中, 随机取出一个代理IP返回 return random.choice(proxy_list) def disable_domain(self, ip, domain): &quot;&quot;&quot; 3.4 实现把指定域名添加到指定IP的disable_domain列表中. :param ip: IP地址 :param domain: 域名 :return: 如果返回True, 就表示添加成功了, 返回False添加失败了 &quot;&quot;&quot; # print(self.proxies.count_documents(&#123;&#39;_id&#39;: ip, &#39;disable_domains&#39;:domain&#125;)) if self.proxies.count_documents(&#123;&#39;_id&#39;: ip, &#39;disable_domains&#39;:domain&#125;) &#x3D;&#x3D; 0: # 如果disable_domains字段中没有这个域名, 才添加 self.proxies.update_one(&#123;&#39;_id&#39;:ip&#125;, &#123;&#39;$push&#39;: &#123;&#39;disable_domains&#39;: domain&#125;&#125;) return True return False 爬虫模块base_spider 在base_spider.py文件中,定义一个BaseSpider类, 继承object 提供三个类成员变量: urls: 代理IP网址的URL的列表 group_xpath: 分组XPATH, 获取包含代理IP信息标签列表的XPATH detail_xpath: 组内XPATH, 获取代理IP详情的信息XPATH, 格式为: {‘ip’:’xx’, ‘port’:’xx’, ‘area’:’xx’} 提供初始方法, 传入爬虫URL列表, 分组XPATH, 详情(组内)XPATH 对外提供一个获取代理IP的方法 遍历URL列表, 获取URL 根据发送请求, 获取页面数据 解析页面, 提取数据, 封装为Proxy对象 返回Proxy对象列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 1. 在base_spider.py文件中,定义一个BaseSpider类, 继承objectclass BaseSpider(object): # 2. 提供三个类成员变量: # urls: 代理IP网址的URL的列表 urls &#x3D; [] # group_xpath: 分组XPATH, 获取包含代理IP信息标签列表的XPATH group_xpath &#x3D; &#39;&#39; # detail_xpath: 组内XPATH, 获取代理IP详情的信息XPATH, 格式为: &#123;&#39;ip&#39;:&#39;xx&#39;, &#39;port&#39;:&#39;xx&#39;, &#39;area&#39;:&#39;xx&#39;&#125; detail_xpath &#x3D; &#123;&#125; # 3. 提供初始方法, 传入爬虫URL列表, 分组XPATH, 详情(组内)XPATH def __init__(self, urls&#x3D;[], group_xpath&#x3D;&#39;&#39;, detail_xpath&#x3D;&#123;&#125;): if urls: self.urls &#x3D; urls if group_xpath: self.group_xpath &#x3D; group_xpath if detail_xpath: self.detail_xpath &#x3D; detail_xpath def get_page_from_url(self, url): &quot;&quot;&quot;根据URL 发送请求, 获取页面数据&quot;&quot;&quot; response &#x3D; requests.get(url, headers&#x3D;get_request_headers()) print(url) print(response.status_code) return response.content def get_first_from_list(self, lis): # 如果列表中有元素就返回第一个, 否则就返回空串 return lis[0] if len(lis) !&#x3D; 0 else &#39;&#39; def get_proxies_from_page(self, page): &quot;&quot;&quot;解析页面, 提取数据, 封装为Proxy对象&quot;&quot;&quot; element &#x3D; etree.HTML(page) # 获取包含代理IP信息的标签列表 trs &#x3D; element.xpath(self.group_xpath) # 遍历trs, 获取代理IP相关信息 for tr in trs: ip &#x3D; self.get_first_from_list(tr.xpath(self.detail_xpath[&#39;ip&#39;])) port &#x3D; self.get_first_from_list(tr.xpath(self.detail_xpath[&#39;port&#39;])) area &#x3D; self.get_first_from_list(tr.xpath(self.detail_xpath[&#39;area&#39;])) proxy &#x3D; Proxy(ip, port, area&#x3D;area) # print(proxy) # 使用yield返回提取到的数据 yield proxy def get_proxies(self): # 4. 对外提供一个获取代理IP的方法 # 4.1 遍历URL列表, 获取URL for url in self.urls: # print(url) # 4.2 根据发送请求, 获取页面数据 page &#x3D; self.get_page_from_url(url) # 4.3 解析页面, 提取数据, 封装为Proxy对象 proxies &#x3D; self.get_proxies_from_page(page) # 4.4 返回Proxy对象列表 yield from proxies 具体爬虫实现proxy_spiders 实现西刺代理爬虫: http://www.xicidaili.com/nn/1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 实现ip3366代理爬虫: http://www.ip3366.net/free/?stype=1&amp;page=1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 实现快代理爬虫: https://www.kuaidaili.com/free/inha/1/ 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 实现proxylistplus代理爬虫: https://list.proxylistplus.com/Fresh-HTTP-Proxy-List-1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 实现66ip爬虫: http://www.66ip.cn/1.html 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 由于66ip网页进行js + cookie反爬, 需要重写父类的get_page_from_url方法 访问http://www.66ip.cn/1.html 时返回一堆js，并不返回具体ip信息，通过逐步增加请求头中的Cookie时发现真正生效的Cookie为_ydclearance，控制台打开Preserve log发现页面第一次1.html做了跳转，历史请求中都没有出现_ydclearance的cookie，第二次请求1.html时已经携带了_ydclearance说明该cookie已经不是服务端响应生成，而是由客户端js生成。 一开始我们访问http://www.66ip.cn/1.html 时返回一堆js，执行这段js，就是用来生成_ydclearance的。那么分析这段js本身做了加密，js中通过定义函数jp并调用后，由于qo=eval，那么等同于最终调用了eval(po)，真正js在 “po” 中。 1result &#x3D; re.findall(&#39;window.onload&#x3D;setTimeout\\(&quot;(.+?)&quot;, 200\\);\\s*(.+?)\\s*&lt;&#x2F;script&gt;&#39; ,text) 通过正则提取 jp(107) 调用函数方法, 以及函数内容 function jp(WI) { var qo, mo=&quot;&quot; ...，通过将替换eval拿到返回的真实js 12func_str &#x3D; result[0][1]func_str &#x3D; func_str.replace(&#39;eval(&quot;qo&#x3D;eval;qo(po);&quot;)&#39;, &#39;return po&#39;) 执行js并将返回作为Cookie添加到请求头中 12345context &#x3D; js2py.EvalJs()context.execute(func_str)context.execute(&#39;code &#x3D; &#123;&#125;;&#39;.format(result[0][0]))cookie_str &#x3D; re.findall(&quot;document.cookie&#x3D;&#39;(.+?); &quot;, context.code)[0]headers[&#39;Cookie&#39;] &#x3D; cookie_str 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125class XiciSpider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;https:&#x2F;&#x2F;www.xicidaili.com&#x2F;nn&#x2F;&#123;&#125;&#39;.format(i) for i in range(1, 11)] # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;ip_list&quot;]&#x2F;tr[position()&gt;1]&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[3]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[4]&#x2F;a&#x2F;text()&#39; &#125;&quot;&quot;&quot;2. 实现ip3366代理爬虫: http:&#x2F;&#x2F;www.ip3366.net&#x2F;free&#x2F;?stype&#x3D;1&amp;page&#x3D;1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath&quot;&quot;&quot;class Ip3366Spider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;http:&#x2F;&#x2F;www.ip3366.net&#x2F;free&#x2F;?stype&#x3D;&#123;&#125;&amp;page&#x3D;&#123;&#125;&#39;.format(i, j) for i in range(1, 4, 2) for j in range(1, 8)] # # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;list&quot;]&#x2F;table&#x2F;tbody&#x2F;tr&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[1]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[5]&#x2F;text()&#39; &#125;&quot;&quot;&quot;3. 实现快代理爬虫: https:&#x2F;&#x2F;www.kuaidaili.com&#x2F;free&#x2F;inha&#x2F;1&#x2F; 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath&quot;&quot;&quot;class KaiSpider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;https:&#x2F;&#x2F;www.kuaidaili.com&#x2F;free&#x2F;inha&#x2F;&#123;&#125;&#x2F;&#39;.format(i) for i in range(1, 6)] # # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;list&quot;]&#x2F;table&#x2F;tbody&#x2F;tr&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[1]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[5]&#x2F;text()&#39; &#125; # 当我们两个页面访问时间间隔太短了, 就报错了; 这是一种反爬手段. def get_page_from_url(self, url): # 随机等待1,3s time.sleep(random.uniform(1, 3)) # 调用父类的方法, 发送请求, 获取响应数据 return super().get_page_from_url(url)&quot;&quot;&quot;4. 实现proxylistplus代理爬虫: https:&#x2F;&#x2F;list.proxylistplus.com&#x2F;Fresh-HTTP-Proxy-List-1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath&quot;&quot;&quot;class ProxylistplusSpider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;https:&#x2F;&#x2F;list.proxylistplus.com&#x2F;Fresh-HTTP-Proxy-List-&#123;&#125;&#39;.format(i) for i in range(1, 7)] # # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;page&quot;]&#x2F;table[2]&#x2F;tbody&#x2F;tr[position()&gt;2]&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[3]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[5]&#x2F;text()&#39; &#125;&quot;&quot;&quot;5. 实现66ip爬虫: http:&#x2F;&#x2F;www.66ip.cn&#x2F;1.html 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 由于66ip网页进行js + cookie反爬, 需要重写父类的get_page_from_url方法&quot;&quot;&quot;class Ip66Spider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;http:&#x2F;&#x2F;www.66ip.cn&#x2F;&#123;&#125;.html&#39;.format(i) for i in range(1, 11)] # # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;main&quot;]&#x2F;div&#x2F;div[1]&#x2F;table&#x2F;tbody&#x2F;tr[position()&gt;1]&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[1]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[3]&#x2F;text()&#39; &#125; # 重写方法, 解决反爬问题 def get_page_from_url(self, url): headers &#x3D; get_request_headers() response &#x3D; requests.get(url, headers&#x3D;headers) if response.status_code &#x3D;&#x3D; 521: # 生成cookie信息, 再携带cookie发送请求 # 生成 &#96;_ydclearance&#96; cookie信息,控制台preserve log,第一个页面就是加密页面521用来做反爬跳转 # 1. 确定 _ydclearance 是从哪里来的; # 观察发现: 这个cookie在前两个页面都没有返回，说明信息不使用通过服务器响应设置过来的; 那么他就是通过js生成. # 2. 第一次发送请求的页面中, 有一个生成这个cookie的js; 执行这段js, 生成我们需要的cookie # 这段js是经过加密处理后的js, 真正js在 &quot;po&quot; 中. # 提取 &#96;jp(107)&#96; 调用函数的方法, 以及函数 result &#x3D; re.findall(&#39;window.onload&#x3D;setTimeout\\(&quot;(.+?)&quot;, 200\\);\\s*(.+?)\\s*&lt;&#x2F;script&gt; &#39;, response.content.decode(&#39;GBK&#39;)) # print(result) # 我希望执行js时候, 返回真正要执行的js # 把 &#96;eval(&quot;qo&#x3D;eval;qo(po);&quot;)&#96; 替换为 return po func_str &#x3D; result[0][1] func_str &#x3D; func_str.replace(&#39;eval(&quot;qo&#x3D;eval;qo(po);&quot;)&#39;, &#39;return po&#39;) # print(func_str) # 获取执行js的环境 context &#x3D; js2py.EvalJs() # 加载(执行) func_str context.execute(func_str) # 执行这个方法, 生成我们需要的js # code &#x3D; gv(50) context.execute(&#39;code &#x3D; &#123;&#125;;&#39;.format(result[0][0])) # 打印最终生成的代码 # print(context.code) cookie_str &#x3D; re.findall(&quot;document.cookie&#x3D;&#39;(.+?); &quot;, context.code)[0] # print(cookie_str) headers[&#39;Cookie&#39;] &#x3D; cookie_str response &#x3D; requests.get(url, headers&#x3D;headers) return response.content.decode(&#39;GBK&#39;) else: return response.content.decode(&#39;GBK&#39;) 运行爬虫模块run_spiders 创建RunSpider类 提供一个运行爬虫的run方法 根据配置文件信息, 加载爬虫, 把爬虫对象放到列表中 遍历爬虫对象列表, 获取代理, 检测代理(代理IP检测模块), 写入数据库(数据库模块) 使用异步来执行每一个爬虫任务 每隔一定的时间, 执行一次爬取任务 settings配置RUN_SPIDERS_INTERVAL作为爬虫运行时间间隔的配置, 单位为小时 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class RunSpider(object): def __init__(self): # 创建MongoPool对象 self.mongo_pool &#x3D; MongoPool() # 3.1 在init方法中创建协程池对象 self.coroutine_pool &#x3D; Pool() def get_spider_from_settings(self): &quot;&quot;&quot;根据配置文件信息, 获取爬虫对象列表.&quot;&quot;&quot; # 遍历配置文件中爬虫信息, 获取每个爬虫全类名 for full_class_name in PROXIES_SPIDERS: # core.proxy_spider.proxy_spiders.Ip66Spider # 获取模块名 和 类名 module_name, class_name &#x3D; full_class_name.rsplit(&#39;.&#39;, maxsplit&#x3D;1) # 根据模块名, 导入模块 module &#x3D; importlib.import_module(module_name) # 根据类名, 从模块中, 获取类 cls &#x3D; getattr(module, class_name) # 创建爬虫对象 spider &#x3D; cls() # print(spider) yield spider def run(self): # 2.1 根据配置文件信息, 获取爬虫对象列表. spiders &#x3D; self.get_spider_from_settings() # 2.2 遍历爬虫对象列表, 获取爬虫对象, 遍历爬虫对象的get_proxies方法, 获取代理IP for spider in spiders: # 2.5 处理异常, 防止一个爬虫内部出错了, 影响其他的爬虫. # 3.3 使用异步执行这个方法 # self.__execute_one_spider_task(spider) self.coroutine_pool.apply_async(self.__execute_one_spider_task,args&#x3D;(spider, )) # 3.4 调用协程的join方法, 让当前线程等待 协程 任务的完成. self.coroutine_pool.join() def __execute_one_spider_task(self, spider): # 3.2 把处理一个代理爬虫的代码抽到一个方法 # 用于处理一个爬虫任务的. try: # 遍历爬虫对象的get_proxies方法, 获取代理I for proxy in spider.get_proxies(): # print(proxy) # 2.3 检测代理IP(代理IP检测模块) proxy &#x3D; check_proxy(proxy) # 2.4 如果可用,写入数据库(数据库模块) # 如果speed不为-1, 就说明可用 if proxy.speed !&#x3D; -1: # 写入数据库(数据库模块) self.mongo_pool.insert_one(proxy) except Exception as ex: logger.exception(ex) @classmethod def start(cls): # 4. 使用schedule模块, 实现每隔一定的时间, 执行一次爬取任务 # 4.1 定义一个start的类方法 # 4.2 创建当前类的对象, 调用run方法 rs &#x3D; RunSpider() rs.run() # 4.3 使用schedule模块, 每隔一定的时间, 执行当前对象的run方法 # 4.3.1 修改配置文件, 增加爬虫运行时间间隔的配置, 单位为小时 schedule.every(RUN_SPIDERS_INTERVAL).hours.do(rs.run) while True: schedule.run_pending() time.sleep(1) 检测模块proxy_test 创建ProxyTester类，检查代理IP可用性, 保证代理池中代理IP基本可用 提供一个 run 方法, 用于处理检测代理IP核心逻辑 从数据库中获取所有代理IP 遍历代理IP列表 检查代理可用性 如果代理不可用, 让代理分数-1, 如果代理分数等于0就从数据库中删除该代理, 否则更新该代理IP 如果代理可用, 就恢复该代理的分数, 更新到数据库中 为了提高检查的速度, 使用异步来执行检测任务 把要检测的代理IP, 放到队列中 把检查一个代理可用性的代码, 抽取到一个方法中; 从队列中获取代理IP, 进行检查; 检查完毕, 调度队列的task_done方法 通过异步回调, 使用死循环不断执行这个方法, 开启多个一个异步任务, 来处理代理IP的检测; 可以通过配置文件指定异步数量 使用schedule模块, 每隔一定的时间, 执行一次检测任务 定义类方法 start, 用于启动检测模块 在start方法中 创建本类对象 调用run方法 每间隔一定时间, 执行一下, run方法 setting.py 文件, 检查代理IP可用性间隔时间的配置 RUN_SPIDERS_INTERVAL = 2 # 修改配置文件, 增加爬虫运行时间间隔的配置, 单位为小时TEST_PROXIES_ASYNC_COUNT = 10 # 配置检测代理IP的异步数量TEST_PROXIES_INTERVAL = 2 # 配置检查代理IP的时间间隔, 单位是小时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class ProxyTester(object): def __init__(self): # 创建操作数据库的MongoPool对象 self.mongo_pool &#x3D; MongoPool() # 3.1 在&#96;init&#96;方法, 创建队列和协程池 self.queue &#x3D; Queue() self.coroutine_pool &#x3D; Pool() def __check_callback(self, temp): self.coroutine_pool.apply_async(self.__check_one_proxy, callback&#x3D;self.__check_callback) def run(self): # 提供一个 run 方法, 用于处理检测代理IP核心逻辑 # 2.1 从数据库中获取所有代理IP proxies &#x3D; self.mongo_pool.find_all() # 2.2 遍历代理IP列表 for proxy in proxies: # 3.2 把要检测的代理IP, 放到队列中 self.queue.put(proxy) # 3.5 开启多个一个异步任务, 来处理代理IP的检测; 可以通过配置文件指定异步数量 for i in range(TEST_PROXIES_ASYNC_COUNT): # 3.4 通过异步回调, 使用死循环不断执行这个方法, self.coroutine_pool.apply_async(self.__check_one_proxy, callback&#x3D;self.__check_callback) # 让当前线程, 等待队列任务完成 self.queue.join() def __check_one_proxy(self): # 检查一个代理IP的可用性 # 3.3 把检查一个代理可用性的代码, 抽取到一个方法中; # 从队列中获取代理IP, 进行检查; 检查完毕 proxy &#x3D; self.queue.get() # 2.3 检查代理可用性 proxy &#x3D; check_proxy(proxy) # 2.4 如果代理不可用, 让代理分数-1, if proxy.speed &#x3D;&#x3D; -1: proxy.score -&#x3D; 1 # 如果代理分数等于0就从数据库中删除该代理 if proxy.score &#x3D;&#x3D; 0: self.mongo_pool.delete_one(proxy) else: # 否则更新该代理IP self.mongo_pool.update_one(proxy) else: # 2.5 如果代理可用, 就恢复该代理的分数, 更新到数据库中 proxy.score &#x3D; MAX_SCORE self.mongo_pool.update_one(proxy) # 调度队列的task_done方法 self.queue.task_done() @classmethod def start(cls): # 4.2.1 创建本类对象 proxy_tester &#x3D; cls() # 4.2.2 调用run方法 proxy_tester.run() # 4.2.3 每间隔一定时间, 执行一下, run方法 schedule.every(TEST_PROXIES_INTERVAL).hours.do(proxy_tester.run) while True: schedule.run_pending() time.sleep(1) API模块proxy_api 创建ProxyApi类，为爬虫提供高可用代理IP的服务接口 实现初始方法 初始一个Flask的Web服务 实现根据协议类型和域名, 提供随机的获取高可用代理IP的服务 可用通过 protocol 和 domain 参数对IP进行过滤 protocol: 当前请求的协议类型 domain: 当前请求域名 实现根据协议类型和域名, 提供获取多个高可用代理IP的服务 可用通过protocol 和 domain 参数对IP进行过滤 实现给指定的IP上追加不可用域名的服务 如果在获取IP的时候, 有指定域名参数, 将不在获取该IP, 从而进一步提高代理IP的可用性. 实现run方法, 用于启动Flask的WEB服务 实现start的类方法, 用于通过类名, 启动服务 settings中配置PROXIES_MAX_COUNT配置获取的代理IP最大数量; 这个越小可用性就越高; 但是随机性越差 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class ProxyApi(object): def __init__(self): # 2. 实现初始方法 # 2.1 初始一个Flask的Web服务 self.app &#x3D; Flask(__name__) # 创建MongoPool对象, 用于操作数据库 self.mongo_pool &#x3D; MongoPool() @self.app.route(&#39;&#x2F;random&#39;) def random(): &quot;&quot;&quot; localhost:6868&#x2F;random?protocol&#x3D;https&amp;domain&#x3D;jd.com 2.2 实现根据协议类型和域名, 提供随机的获取高可用代理IP的服务 可用通过 protocol 和 domain 参数对IP进行过滤 protocol: 当前请求的协议类型 domain: 当前请求域名 &quot;&quot;&quot; protocol &#x3D; request.args.get(&#39;protocol&#39;) domain &#x3D; request.args.get(&#39;domain&#39;) proxy &#x3D; self.mongo_pool.random_proxy(protocol, domain, count&#x3D;PROXIES_MAX_COUNT) if protocol: return &#39;&#123;&#125;:&#x2F;&#x2F;&#123;&#125;:&#123;&#125;&#39;.format(protocol, proxy.ip, proxy.port) else: return &#39;&#123;&#125;:&#123;&#125;&#39;.format(proxy.ip, proxy.port) @self.app.route(&#39;&#x2F;proxies&#39;) def proxies(): &quot;&quot;&quot; localhost:6868&#x2F;proxies?protocol&#x3D;https&amp;domain&#x3D;jd.com 2.3 实现根据协议类型和域名, 提供获取多个高可用代理IP的服务 可用通过protocol 和 domain 参数对IP进行过滤 实现给指定的IP上追加不可用域名的服务 &quot;&quot;&quot; # 获取协议: http&#x2F;https protocol &#x3D; request.args.get(&#39;protocol&#39;) # 域名: 如:jd.com domain &#x3D; request.args.get(&#39;domain&#39;) proxies &#x3D; self.mongo_pool.get_proxies(protocol, domain, count&#x3D;PROXIES_MAX_COUNT) # proxies 是一个 Proxy对象的列表, 但是Proxy对象不能进行json序列化, 需要转换为字典列表 # 转换为字典列表 proxies &#x3D; [proxy.__dict__ for proxy in proxies] # 返回json格式值串 return json.dumps(proxies) @self.app.route(&#39;&#x2F;disable_domain&#39;) def disable_domain(): &quot;&quot;&quot; localhost:6868&#x2F;disable_domain?ip&#x3D;120.92.174.12&amp;domain&#x3D;jd.com 2.4 如果在获取IP的时候, 有指定域名参数, 将不在获取该IP, 从而进一步提高代理IP的可用性. &quot;&quot;&quot; ip &#x3D; request.args.get(&#39;ip&#39;) domain &#x3D; request.args.get(&#39;domain&#39;) if ip is None: return &#39;请提供ip参数&#39; if domain is None: return &#39;请提供域名domain参数&#39; self.mongo_pool.disable_domain(ip, domain) return &quot;&#123;&#125; 禁用域名 &#123;&#125; 成功&quot;.format(ip, domain) def run(self): &quot;&quot;&quot;3. 实现run方法, 用于启动Flask的WEB服务&quot;&quot;&quot; self.app.run(&#39;0.0.0.0&#39;, port&#x3D;6868) @classmethod def start(cls): # 4. 实现start的类方法, 用于通过类名, 启动服务 proxy_api &#x3D; cls() proxy_api.run() 启动入口main 定义一个run方法用于启动动代理池，开启三个进程, 分别用于启动爬虫, 检测代理IP, WEB服务 定义一个列表, 用于存储要启动的进程 创建 启动爬虫 的进程, 添加到列表中 创建 启动检测 的进程, 添加到列表中 创建 启动提供API服务 的进程, 添加到列表中 遍历进程列表, 启动所有进程 遍历进程列表, 让主进程等待子进程的完成 在 if __name__ == &#39;__main__&#39;: 中调用run方法 12345678910111213141516171819202122def run(): # 1. 定义一个列表, 用于存储要启动的进程 process_list &#x3D; [] # 2. 创建 启动爬虫 的进程, 添加到列表中 process_list.append(Process(target&#x3D;RunSpider.start)) # 3. 创建 启动检测 的进程, 添加到列表中 process_list.append(Process(target&#x3D;ProxyTester.start)) # 4. 创建 启动提供API服务 的进程, 添加到列表中 process_list.append(Process(target&#x3D;ProxyApi.start)) # 5. 遍历进程列表, 启动所有进程 for process in process_list: # 设置守护进程 process.daemon &#x3D; True process.start() # 6. 遍历进程列表, 让主进程等待子进程的完成 for process in process_list: process.join()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: run() 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"requests","slug":"requests","permalink":"http://onejane.github.io/tags/requests/"},{"name":"pymongo","slug":"pymongo","permalink":"http://onejane.github.io/tags/pymongo/"},{"name":"flask","slug":"flask","permalink":"http://onejane.github.io/tags/flask/"}]},{"title":"爬虫基础篇之页面请求解析","slug":"爬虫基础篇之页面请求解析","date":"2021-03-30T08:09:50.000Z","updated":"2021-04-07T14:48:31.153Z","comments":true,"path":"2021/03/30/爬虫基础篇之页面请求解析/","link":"","permalink":"http://onejane.github.io/2021/03/30/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90/","excerpt":"","text":"CSS选择器html中为指定元素指定显示效果，比如颜色，背景，字体等不同的属性，这些样式都是通过css选择器告诉浏览器指定样式风格。 表达式 含义 #animal 获取id为animal的所有元素 .animal 获取class为animal的所有元素 a.active 获取类为active的a标签 .animal &gt; .pig 获取类animal直接子元素中类为.pig的元素 .animal .pig 获取类animal后代元素中类为.pig的元素 a[href*=”animal”] 获取包含类animal的a元素 a[href^=”http”] 获取href以http开头的a元素 a[href$=”gov.cn”] 获取href以gov.cn结尾的a元素 div[class=”animal”][ctype=”pig”] 获取多属性同时具备的元素 div &gt; a:nth-child(2) 获取div下的第二个a元素 .pig , .animal 同时选择两个class的所有元素 p:nth-last-child(1) 获取倒数第一个p元素 p:nth-child(even) p:nth-child(odd) 获取奇数偶数节点 h3 + span 获取h3 后面紧跟着的兄弟节点 span h3 ~ span 获取h3 后面所有的兄弟节点 span 实战链家目标抓取网站：https://su.lianjia.com/ershoufang/pg 抓取内容：分页抓取二手房的标题，地址，信息，关注量，标签，总价，单价等 分析 通过获取网页源代码发现所有的二手房信息都直接渲染在页面上，那么可以直接请求页面地址分析二手房源码后，通过parsel库parsel.Selector(html_data)转为我们可以使用选择器分析的对象。 通过css选择器.clear.LOGCLICKDATA拿到所有的二手房信息所在的li元素 在li元素下可以css选择器获取所有的.title a::text标题，.positionInfo a::text地址，.followInfo::text关注量等信息。 1234567891011121314selector &#x3D; parsel.Selector(html_data)lis &#x3D; selector.css(&#39;.clear.LOGCLICKDATA&#39;)for li in lis: title &#x3D; li.css(&#39;.title a::text&#39;).get() # 标题 address &#x3D; li.css(&#39;.positionInfo a::text&#39;).getall() # 地址 address &#x3D; &#39;,&#39;.join(address) houseInfo &#x3D; li.css(&#39;.houseInfo::text&#39;).get() # 信息 followInfo &#x3D; li.css(&#39;.followInfo::text&#39;).get() # 关注 tags &#x3D; li.css(&#39;.tag span::text&#39;).get() # 标签 tags &#x3D; &#39;,&#39;.join(tags) totalPrice &#x3D; li.css(&#39;.totalPrice span::text&#39;).get() + &#39;万&#39; # 总价 unitePrice &#x3D; li.css(&#39;.unitPrice span::text&#39;).get() # 单价 title_url &#x3D; li.css(&#39;.title a::attr(href)&#39;).get() # 标题 print(title, address, houseInfo, followInfo, tags, totalPrice, unitePrice, title_url, sep&#x3D;&quot;---&quot;) 爬取完成点击下一页的时候，页面url添加了路径参数pg{}，那么可以通过加该字段实现分页抓取。 猫眼电影分析目标抓取网站：https://maoyan.com/board 抓取内容：热映口碑榜的电影名，主演，上映时间等。 老规矩，查看网页源代码电影数据完整返回给前端，没有做异步请求。那么直接访问猫眼的热映口碑榜通过parsel库解析成Selector对象，开始利用css选择器分析页面字段。 通过控制台源码发现类.board-wrapper下dd元素包含了所有的电影信息，那么遍历其下的标签列表根据css选择器筛选拿到需要的数据即可。 1234567891011121314selector &#x3D; parsel.Selector(html_data)print(selector)dds &#x3D; selector.css(&#39;.board-wrapper dd&#39;)for dd in dds: title &#x3D; dd.css(&#39;.name a::attr(title)&#39;).get() star &#x3D; dd.css(&#39;.star::text&#39;).get().strip() releasetime &#x3D; dd.css(&#39;.releasetime::text&#39;).get() score &#x3D; dd.css(&#39;.score i::text&#39;).getall() score &#x3D; &#39;&#39;.join(score) print(title, star, releasetime, score) with open(&#39;maoyan.csv&#39;, mode&#x3D;&#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;, newline&#x3D;&#39;&#39;) as f: csv_write &#x3D; csv.writer(f) csv_write.writerow([title, star, releasetime, score]) 爬取完成 喜马拉雅分析目标网站：https://www.ximalaya.com/xiangsheng/9723091 抓取内容：下载当前主题的所有页面的音频文件。 老规矩，查看网页源代码发现所有的音频标签会在当前页面ur后添加音频的id跳转到一个新的页面，如：https://www.ximalaya.com/xiangsheng/9723091/45982355 点击播放后，控制台的Media出现请求的音频地址,如：https://aod.cos.tx.xmcdn.com/group31/M01/36/04/wKgJSVmC6drBDNayAh_Q8WincwI414.m4a 通过控制台搜索音频关键字段，找到返回音频地址的请求https://www.ximalaya.com/revision/play/v1/audio?id=46106992&amp;ptype=1 该请求参数由音频id和ptype=1组成，通过css选择器.sound-list li.lF_ a::attr(href)分析列表页的音频的href拿到音频id，通过css选择器.sound-list li.lF_ a::attr(title)拿到音频标题。点击下一页发现只是在原url后添加p{page}字段，综上通过open函数写入音频文件完成下载。 12345678910111213141516171819202122titles &#x3D; selector.css(&#39;.sound-list li.lF_ a::attr(title)&#39;).getall()href &#x3D; selector.css(&#39;.sound-list li.lF_ a::attr(href)&#39;).getall()# zip() 可以讲两个列表进行打包, 遍历之后 是一个元组data &#x3D; zip(titles, href)for index in data: title &#x3D; index[0] mp3_id &#x3D; index[1].split(&#39;&#x2F;&#39;)[-1] # f&#39;&#123;mp3_id&#125;&#39; &#39;&#123;&#125;&#39;.format(mp3_id) 字符串格式化方法 index_url &#x3D; f&#39;https:&#x2F;&#x2F;www.ximalaya.com&#x2F;revision&#x2F;play&#x2F;v1&#x2F;audio?id&#x3D;&#123;mp3_id&#125;&amp;ptype&#x3D;1&#39; response_1 &#x3D; requests.get(url&#x3D;index_url, headers&#x3D;headers) # 什么是json数据 字典嵌套字典 还嵌套一些列表 # json数据取值和字典取值方式是一样的 根据关键词提取内容 通俗的讲 就是根据左边的内容提取右边的内容 # print(response_1.text) mp3_url &#x3D; response_1.json()[&#39;data&#39;][&#39;src&#39;] print(title, mp3_url) # 保存数据 # 保存数据: 如果是图片&#x2F;音频&#x2F;视频 等 都是要获取它的二进制数据,要以二进制的数据保存 mp3_content &#x3D; requests.get(url&#x3D;mp3_url).content # 相对路径 with open(&#39;相声\\\\&#39; + title + &#39;.mp3&#39;, mode&#x3D;&#39;wb&#39;) as f: f.write(mp3_content) print(&#39;正在保存: &#39;, title) 爬取完成 XPATH选择器XPath (XML Path Language) 是由国际标准化组织W3C指定的，用来在 XML 和 HTML 文档中选择节点的语言。目前主流浏览器 (chrome、firefox，edge，safari) 都支持XPath语法，xpath有 1 和 2 两个版本，目前浏览器支持的是 xpath 1的语法，且比CSS选择器功能更强大。 表达式 含义 /html/body/div 选择根节点html下面的body下面的div元素，/从子节点找，//从所有子节点包括子节点的子节点中找 //div/* 所有div节点下所有元素 //*[@id=’west’] id为west的元素 //select[@class=’single_choice’] class为single_choice的select元素 //p[@class=”capital huge-city”] 多元素组合选择 //*[@multiple] 具有multiple属性的元素 //*[contains(@style,’color’)] style包含color的元素 //*[starts-with(@style,’color’)] 以style是color开头的元素，//*[ends-with(@style,’color’)]结尾元素 //div/p[2] 所有div下的第二个p标签 //p[last()] 最后一个p元素 //div/p[last()-2] 所有div下倒数第三个p元素 //option[position()&lt;=2] option类型的第1-2个元素 //*[@class=’multi_choice’]/*[position()&gt;=last()-2] 选择class属性为multi_choice的后3个子元素 //option|//h4 所有的option元素 和所有的 h4 元素 //*[@id=’china’]/.. 选择 id 为 china 的节点的父节点 //*[@id=’china’]/../../.. 上上父节点 //*[@class=’single_choice’]/following-sibling::div 选择后续节点中的div节点 等同于CSS选择器.single_choice ~ * //[@class=’single_choice’]/preceding-sibling:: 前面兄弟节点 实战新笔趣阁分析目标网站：http://www.xbiquge.la/10/10489/ 抓取内容：抓取三寸人间所有章节的文章保存。 章节列表只有小说章节信息，点击每个章节跳转到章节页面，通常xpath表达式//div[@id=&quot;info&quot;]/h1/text()拿到书籍名称，所有的章节都依赖于于id为list的div下的dl下的dd下的a标签的href属性跳转到章节页面。 拼接主域名http://www.xbiquge.la即可跳转到章节详情页面，通过xpath表达式//*[@id=&quot;content&quot;]/text()拿到详情页面小说的完整内容 1234567891011121314151617181920212223242526272829303132# 开文件流 打开一个文件 把我们数据写入到文件中去 a是追加写入 写入完第一章就继续追加写入第二章with open(book_name + &#39;.txt&#39;, &#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;)as f: f.write(book_name+&#39;\\n&#39;) # title 章节的名称 urls 每个章节的详情链接 # 遍历获取到该本书的每个章节和对应的内容详情链接 zip一次性遍历多个列表 for title,urls in zip(book_title,book_url): c_url&#x3D;&#39;http:&#x2F;&#x2F;www.xbiquge.la&#39;+urls print(title) print(c_url) # 异常处理 try: #捕捉异常 #参数1：单个章节的url:以获取到这个章节的小说内容的html源码 参数2：headers 参数3：请求等待时间3秒 titles_url &#x3D; requests.get(c_url, headers&#x3D;headers, timeout&#x3D;3).content.decode(&#39;utf-8&#39;) except: # 如果捕捉异常怎么办 请求失败那就再请求一遍 titles_url &#x3D; requests.get(c_url, headers&#x3D;headers).content.decode(&#39;utf-8&#39;) # 那我们还差一个小说文本内容对不对 那每个章节链接我们有了 # 每个章节里面的内容是不是好解决 一样xpath语法给他获取下来 # 通过xpath获取到小说文本内容 book_content &#x3D; etree.HTML(titles_url).xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;content&quot;]&#x2F;text()&#39;) f.write(title) # 先写入章节名称 f.write(&#39;\\n&#39;) # f.write不能够写列表，但可以写字符串格式（二进制）。。。 所以要for循环 for line in book_content: f.write(line) # 再写入章节对应的内容 f.write(&#39;\\n&#39;) # 每写完一章换行 一共1000多个章节 爬取完成 其实很多情况下不需要自己去分析dom节点定位css或xpath表达式，chrome已经为我们集成了插件。 JSON很多情况页面不直接返回html或xml文本元素，或者这些文本分析起来很困难的情况下，可以通过控制台中的xhr模式抓取后端请求回来的json数据，直接解析json即可拿到想要的数据。 实战拉勾分析目标网站：https://www.lagou.com/jobs/list_C%2B%2B?labelWords=&amp;fromSearch=true&amp;suginput= 抓取内容：抓取首页职位地址，公司名，规模等信息保存。 搜索C++后，打开控制台将结果中的带薪年假搜索拿到实际请求路径https://www.lagou.com/jobs/positionAjax.json?needAddtionalResult=false，该请求是post请求，参数如下 12345data &#x3D; &#123; &quot;first&quot;: &quot;true&quot;, &quot;pn&quot;: &quot;1&quot;, &quot;kd&quot;: &quot;C++&quot;&#125; 通过控制台Preview分析返回的json数据，data[&#39;content&#39;][&#39;positionResult&#39;][&#39;result&#39;]即为职位信息 不过当我们直接请求时会报dtacess deny,可能对请求头中的参数做了校验。 12345678Traceback (most recent call last): File &quot;F:&#x2F;MyProject&#x2F;CrawlerBase&#x2F;lagou&#x2F;lagou.py&quot;, line 21, in &lt;module&gt; result &#x3D; data[&#39;content&#39;][&#39;positionResult&#39;][&#39;result&#39;]KeyError: &#39;content&#39;&#123;&#39;clientIp&#39;: &#39;61.155.198.*&#39;, &#39;msg&#39;: &#39;dtaccess deny &#39;, &#39;state&#39;: 2410, &#39;status&#39;: False&#125; 我们将Cookie和User-Agent加入header后，即可以完整请求到json数据，进行数据分析。 123456789101112131415161718resp &#x3D; requests.post(api_url, headers&#x3D;headers)pprint(resp.json())data &#x3D; resp.json()result &#x3D; data[&#39;content&#39;][&#39;positionResult&#39;][&#39;result&#39;]# [print(r) for r in result]for r in result: d &#x3D; &#123; &#39;city&#39;: r[&#39;city&#39;], &#39;companyFullName&#39;: r[&#39;companyFullName&#39;], &#39;companySize&#39;: r[&#39;companySize&#39;], &#39;education&#39;: r[&#39;education&#39;], &#39;positionName&#39;: r[&#39;positionName&#39;], &#39;salary&#39;: r[&#39;salary&#39;], &#39;workYear&#39;: r[&#39;workYear&#39;] &#125; with open(&#39;拉钩职位.csv&#39;,mode&#x3D;&#39;a&#39;,encoding&#x3D;&#39;utf-8&#39;) as f: f.write(&quot;,&quot;.join(d.values())) f.write(&quot;\\n&quot;) 爬取完成 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"xpath","slug":"xpath","permalink":"http://onejane.github.io/tags/xpath/"},{"name":"css","slug":"css","permalink":"http://onejane.github.io/tags/css/"},{"name":"json","slug":"json","permalink":"http://onejane.github.io/tags/json/"}]},{"title":"爬虫基础篇之基本库的使用","slug":"爬虫基础篇之基本库的使用","date":"2021-03-28T00:18:03.000Z","updated":"2021-05-01T16:22:11.164Z","comments":true,"path":"2021/03/28/爬虫基础篇之基本库的使用/","link":"","permalink":"http://onejane.github.io/2021/03/28/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"爬虫介绍爬虫目的 大数据时代所谓的人工智能都需要建立海量基础的数据上，一切一切的分析都是一数据为基础核心，那么对于企业来说，合理采集数据是既节省成本同时间也可以完成业务分析的捷径。 企业需要大量数据进行测试，对网站或app的负载，流量，服务器的CPU进行测试，采集数据是保证大数据量业务上线正常流转的必备前提。 所有搜索引擎的底层都是一个个的自动化爬虫，在海量的互联网信息中进行分析处理收录。 各大企业都希望自己的产品搜索靠前，对于SEO来说，除了充钱，足够了解爬虫可以从原理上实现搜索引擎的工作原理，实现SEO优化。 从技术层面来说，爬虫虽不是成体系型的一种技术栈，不过技术涉及领域极光，包括html解析，js逆向，安卓底层逆向，汇编分析，反爬虫与反反爬虫的对抗等等，其实以上也属于网络安全层的一个方向，文明爬虫，技术无罪。 什么是最好的语言当之无愧强类型语言Python，毋庸置疑，一来Python的三方库种类繁多且爬虫框架日新月异，请求与解析模块成熟，且拥有很多有趣的语法糖可以快速处理数据。相对于代码量臃肿的java来说语法简单，学习曲线短，因为java需要jvm虚拟机的编译成字节码的过程，对于爬虫来讲，Python免编译即可跨平台运行，且基于C++更接近底层，性能在一定程度上领超java，故优先选择python(别跟我提php)。 当然玩到最后语言只是一种实现方式而已，只是这些路都通往罗马，哪条在实际场景中更方便到达而已。比如：安卓逆向过程hook框架中，xposed和frida是我们的首选，两者各有优劣，视不同场景而定。 Xposed是一个在andoid平台上比较成熟的hook框架，可以完美的在dalvik虚拟机上做到hook任意java方法，配置安装环境繁琐，兼容性差，无法对native层实现底层注入。 Frida是一个跨平台的hook框架，可以hook Java和native层，且不需要每次都重启手机，需要我们手动将java的语法转为frida的实现方式，无法像Xposed用于实践生产中。 爬虫路对抗现状 这是一张老图，当然现在很多网站在请求头中实现了对selenium，phantomjs底层的api监控，总之，道高一尺魔高一丈，攻防之间，其乐无穷。 实战话不多说，直接开干。鲁迅曾经说过，他在爬虫生涯中超过一半的苦难均由Windows赐予，所以我建议还是用kali或者ubuntu吧，如果嫌麻烦，就退一步用centos吧，当然你用windows出现的问题需要自行google解决，基础篇目测应该不存在，用windows可以直接跳到doutula内容。 服务器搭建这里就不聊kali或者ubuntu在虚拟机的搭建了，简单介绍一下使用vagrant创建centos虚拟机吧， 进入vagrant官网，vagrant安装好后进入镜像仓库搜索需要安装的镜像。 mkdir centos7 &amp;&amp; vagrant init centos/7 &amp;&amp; vagrant up &amp;&amp; vagrant ssh 创建并开启镜像，自动生成Vagrantfile，默认网络nat，初始配置如下 config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot; 配置NAT网络，选其一即可config.vm.network &quot;public_network&quot;, ip: &quot;192.168.0.102&quot; 配置桥接网络 yum list installed | grep openssh-server 确保安装了 openssh-server，否则yum install openssh-server vi /etc/ssh/sshd_config 并注释#PasswordAuthentication yes,打开Port,ListenAddress,PermitRootLoin,PasswordAuthentication执行service sshd restart 实现远程连接 安装nodejs并配置淘宝源npm config set registry http://registry.npm.taobao.org/ 多环境配置由于python2已经废弃维护，往后皆基于python3实战开发。进入python官网下载python 3.7.0，或者通过清华大学源下载anaconda 5.3.1会自动下载常用库。 为了避免不同项目间引用的依赖包冲突，我们将不同项目维护不同的环境。 123456789101112yum install -y wget zlib-devel gcc bzip2-devel openssl-devel libffi-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel net-tools ftp vsftpd 安装常用包mkdir &#x2F;usr&#x2F;local&#x2F;python3 由于默认centos已经有了python2，避免环境冲突，配置多环境python3wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.7.0&#x2F;Python-3.7.0.tgz 下载python3的包tar zxf Python-3.7.0.tgz 解压cd Python-3.7.0&#x2F; &amp;&amp; .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3 编译make &amp;&amp; make installvim &#x2F;etc&#x2F;profile 配置环境变量PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;export PATHsource &#x2F;etc&#x2F;profileln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3 配置软链接ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip3 12345678910pip3 install --upgrade pippip install virtualenvwrapper 安装虚拟环境vim ~&#x2F;.bashrc 配置环境变量VIRTUALENVWRAPPER_PYTHON&#x3D;&#x2F;usr&#x2F;bin&#x2F;python3export WORKON_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;python3&#x2F;venvsource ~&#x2F;.bashrc 编译mkvirtualenv --python&#x3D;&#x2F;usr&#x2F;bin&#x2F;python3 baseSpider 指定python3创建名为baseSpider环境mkvirtualenv --python&#x3D;&#x2F;usr&#x2F;bin&#x2F;python2 baseSpider2 指定python2创建名为baseSpider2环境workon baseSpider 进入baseSpider环境deactivate 退出环境 doutula这是一个表情包网站，本次就以本网站的最新表情页面作为案例。 ctrl+u获取网页源代码，发现本页面所有的表情包都以html表情直接显示在页面上，那么只需要使用requests库请求URL，parsel库来解析页面，通过xpath或者css选择器获取页面元素。 通过点击分页，该页面的url会跳转时添加page参数，从https://www.doutula.com/photo/list/变成https://www.doutula.com/photo/list/?page=2,重新向服务器发起请求。 1234import requestsbase_url &#x3D; &#39;https:&#x2F;&#x2F;www.doutula.com&#x2F;photo&#x2F;list&#x2F;&#39;response &#x3D; requests.get(url&#x3D;base_url)print(response.content) 打印出来的结果是b&#39;&lt;html&gt;\\r\\n&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;\\r\\n&lt;body bgcolor=&quot;white&quot;&gt;\\r\\n&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;\\r\\n&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;\\r\\n&lt;/body&gt;\\r\\n&lt;/html&gt;\\r\\n&#39;,说明做了反爬，可能对请求头的参数做了校验。先尝试将User-Agent加入请求头中，再次发起请求。 123456import requestsbase_url &#x3D; &#39;https:&#x2F;&#x2F;www.doutula.com&#x2F;photo&#x2F;list&#x2F;?page&#x3D;&#123;&#125;&#39;.format(1)headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&#39;&#125;response &#x3D; requests.get(url&#x3D;base_url, headers&#x3D;headers)print(response.content) 果然将页面内容完整打印出来，所有的图片地址也都明文显示在页面上。通过分析页面上的图片元素的dom节点，所有的图片节点都存在于类col-xs-6 col-sm-3的a标签下的img元素，通过xpath表达式可以取出这些元素下的属性，包括图片地址data-original，说明alt等。 12345678910111213for page in range(1,3466): print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正在爬去第&#123;&#125;页数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;.format(page)) base_url &#x3D; &#39;https:&#x2F;&#x2F;www.doutula.com&#x2F;photo&#x2F;list&#x2F;?page&#x3D;&#123;&#125;&#39;.format(page) headers &#x3D; &#123;&#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&#39;&#125; response &#x3D; requests.get(url&#x3D;base_url,headers&#x3D;headers) html_data&#x3D;response.text selector &#x3D; parsel.Selector(html_data) result_list &#x3D; selector.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;&quot;col-xs-6 col-sm-3&quot;]&#39;) for result in result_list: img_url &#x3D; result.xpath(&#39;.&#x2F;img&#x2F;@data-original&#39;).extract_first() img_title &#x3D; result.xpath(&#39;.&#x2F;img&#x2F;@alt&#39;).extract_first() print(img_url+&quot;---&quot;+img_title) 接下来在通过IO流将图片存储到本地完成基础图片爬取。 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"requests","slug":"requests","permalink":"http://onejane.github.io/tags/requests/"},{"name":"parsel","slug":"parsel","permalink":"http://onejane.github.io/tags/parsel/"}]},{"title":"爬虫基础篇之多线程实现","slug":"爬虫基础篇之多线程实现","date":"2021-03-28T00:18:03.000Z","updated":"2021-04-07T14:48:31.147Z","comments":true,"path":"2021/03/28/爬虫基础篇之多线程实现/","link":"","permalink":"http://onejane.github.io/2021/03/28/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"执行流程python并不像java这类高级语言需要将文件编译为机器码交给虚拟机执行，而是由python虚拟机一条条地将py语句解释运行，故而称之为解释型语言。 python先将py文件编译成字节码，交给字节码虚拟机后，虚拟机从编译得到的PyCodeObject对象在当前的上下文环境逐条执行字节码指令，完成整个程序的执行流程。 字节码在python虚拟机程序里对应的是PyCodeObject对象， .pyc文件是字节码在磁盘上的表现形式。 例如：在python test.py过程中会将test.py进行编译成字节码并解释执行，当test.py中加载了其他模块，如import urllib2，python会将urllib2.py进行编译成字节码，生成urllib2.pyc，并重新对字节码解释执行。加载模块时，当.py和.pyc同时存在时，优先运行.pyc文件，若.pyc文件比.py编译时间早，执行流程也会优先重新编译.py文件并更新.pyc文件。 .pyc文件通过内置模块py_compile来编译生成test.pyc,或者通过python -m test.py生成test.pyc GIL由于物理上的科技发展，各CPU厂商在核心频率上已经被多核CPU所取代，为了更有效的利用多核处理器的性能，就出现了多线程的编程技巧，又因为Python GIL的存在让Python虚拟机在进行运算时无法有效利用多核心，几乎只能单线程处理任务，所以将任务并行化，分散到多个线程或多个进程的实现和GIL本身的存在是天生冲突的矛盾。 首先，GIL不是python的特性，是实现python解析器(CPython)时的语法标准，并不是python的特性，类似的还有JPython等就没有GIL，但是CPython是大部分环境下默认的Python执行环境，自然而然CPython==python，自然而然GIL成为的python天生的缺陷。 当多核CPU出现在市场的时候，python为了支持多线程，首要解决的就是线程之间的数据完整性和数据同步性，GIL应运而生，简单粗暴的为线程加上了一把大锁，后起之库们默认都接受了这种实现方案，省去考虑额外线程间的内存锁和同步操作，导致大量的三方库都极度依赖GIL来实现线程安全。GIL这把全局排他锁，是多线程处理的致命伤，效率极底，因为python的线程就是C的一个pthread，通过操作系统的调度算法调度，为在调度过程中各线程平均利用CPU的时间，python会计算已执行的代码量，达到阈值强制释放GIL锁，触发一次操作系统的调度。 任何一个线程在唤起时可以成功获取到GIL，但是多核CPU上，release和acquire几乎没有间隔，导致其他核上的线程被唤醒时，主线程已经再次拿到GIL，导致被唤醒的其他线程只能白白浪费CPU时间，眼睁睁看着另一个线程拿个GIL快乐的执行，当达到切换时间后进入待调度状态，再次唤醒再次等待，恶性循环。 多线程方案multiprocessing一定程度弥补了thread库由于GIL锁导致低效的缺陷，完整的实现了一套thread接口，但是只是使用了多进程而本身不是多进程，原理上每个进程有自己独立的GIL，不会出现进程间的GIL争抢，但是增加了线程间数据通讯和同步的麻烦，由于不同进程间无法看到对方的数据状态，只能在主线程声明一个队列，通过队列的实现解决数据本身的问题，无疑徒增的代码的开发与维护成本。 concurrent提供了多线程ThreadPoolExecutor和多进程ProcessPoolExecutor两种并发模型。 计算密集型任务永远最多只能榨干单核CPU，如果需要提升效率，必须通过ProcessPoolExecutor fork出多个子进程来分担计算任务。 IO密集型任务CPU使用效率极低，虽然使用多线程加倍CPU使用率，但是还远远到不了饱和(100%)的地步，在单核心可以应付整体计算的前提下，自然是应该选择资源占用少的模式，也就是多线程模式。主线程是通过队列将任务传递给多个子线程的。一旦主线程将任务塞进任务队列，子线程们就会开始争抢，最终只有一个线程能抢到这个任务，并立即进行执行，执行完后将结果放进Future对象就完成了这个任务的完整执行过程。 concurrent的线程池有个重大的缺陷，那就是任务队列是无界的。如果队列的生产者任务生产的太快，而线程池消费太慢处理不过来，任务就会堆积。如果堆积一直持续下去，内存就会持续增长直到OOM，任务队列里堆积的所有任务全部彻底丢失。 主线程将任务塞进TaskQueue(普通内存队列)，拿到Future对象 唯一的管理线程从TaskQueue获取任务，塞进CallQueue(分布式跨进程队列) 子进程从CallQueue中争抢任务进行处理 子进程将处理结果塞进ResultQueue(分布式跨进程队列) 管理线程从ResultQueue中获取结果，塞进Future对象 主线程从Future对象中拿到结果 进程池模型中的跨进程队列是用multiprocessing.Queue实现的。它使用无名套接字sockerpair来完成的跨进程通信，socketpair和socket的区别就在于socketpair不需要端口，不需要走网络协议栈，通过内核的套接字读写缓冲区直接进行跨进程通信。multiprocessing.Queue是支持双工通信，数据流向是父子双向，只不过在concurrent的进程池实现中只用到了单工通信。CallQueue是从父到子，ResultQueue是从子到父。 当父进程要传递任务给子进程时，先使用pickle将任务对象进行序列化成字节数组，然后将字节数组通过socketpair的写描述符写入内核的buffer中。子进程接下来就可以从buffer中读取到字节数组，然后再使用pickle对字节数组进行反序列化来得到任务对象，这样总算可以执行任务了。同样子进程将结果传递给父进程走的也是一样的流程，只不过这里的socketpair是ResultQueue内部创建的无名套接字。 实战doutula上文讲到通过分析页面元素分页抓取doutula表情包并保存图片的的案例，由于网络请求结果返回往往比IO存储图片要快，接下来通过多线程的方式实现在IO相对较慢的前提下使用多线程处理存储图片。核心代码如下： 123456789101112131415def main(page): &quot;&quot;&quot;函数入口&quot;&quot;&quot; for page in range(1, page + 1): print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正在爬去第&#123;&#125;页数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;.format(page)) # 定义最多 max_workers 个线程的线程池来异步执行调用。如果 max_workers 为 None 或没有指定，将默认为机器处理器的个数 thread_pool &#x3D; concurrent.futures.ThreadPoolExecutor(max_workers&#x3D;3) res &#x3D; send_request(&#39;https:&#x2F;&#x2F;www.doutula.com&#x2F;photo&#x2F;list&#x2F;?page&#x3D;&#123;&#125;&#39;.format(str(page))) # 封装解析函数 src_url &#x3D; parse_data(res.text) for file, url in src_url: image_response &#x3D; send_request(url) # 提交线程请求，save_data是封装保存函数，file和image_response.content是save_data的入参 thread_pool.submit(save_data, file, image_response.content) # 关闭线程池 thread_pool.shutdown() guazi同时执行多个线程的确可以提高程序效率，但并非线程越多越好，相对计算机而言，线程越多越吃资源，成百上千个线程可能直接瘫痪。故而多线程在运行时，设置最大线程锁，设置最大线程同时允许处理任务，多线程threading使用Semaphore(无上限)或BoundedSemaphore(初始设置最大值), 如果release调用检查计数器的值是否超过了计数器最大值则出ValueError 实现并发限制。 例如：通过semaphore信号量可以利用内置计数器来控制同时运行线程的数量，启动线程(消耗信号量)内置计数器会自动减一，线程结束(释放信号量)内置计数器会自动加一；内置计数器为零，启动线程会阻塞，直到有本线程结束或者其他线程结束为止; 以下我们对瓜子二手车数据进行多线程抓取，并保存到csv中。 分析当我们访问第一页时，https://www.guazi.com/su/buy/o1 当我们访问第二页时，https://www.guazi.com/su/buy/o2 以此类推，不难得出分页数据以start_url = &#39;https://www.guazi.com/su/buy/o&#39;+str(i)形式拼接，i为页码数，根据页面控制台的Elements分析所有的数据都存在于含有类carlist clearfix js-top的ul节点下的所有li节点下，我们可以通过解析得到html代码转化为bs4库的BeautifulSoup对象，利用BeautifulSoup的api获取这些li节点的元素属性，解析拿到类型，年份，里程，售价，具体BeautifulSoup语法出门右转见中文文档。 12345678910111213141516171819202122232425def get_data(html): # 将之前抓取的html页面解析生成BeautifulSoup对象 soup &#x3D; BeautifulSoup(html, &#39;html.parser&#39;) # 调用api获取含有类carlist clearfix js-top的ul节点下的所有li节点 infos &#x3D; soup.find(&#39;ul&#39;, &#123;&#39;class&#39;: &#39;carlist clearfix js-top&#39;&#125;).find_all(&#39;li&#39;) # 打开文件开始写入 with open(&#39;.&#x2F;guazi.csv&#39;, &#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;) as f: pic_urls &#x3D; [] for info in infos: leixing &#x3D; info.find(&#39;h2&#39;).get_text() nianfen1 &#x3D; info.find(&#39;div&#39;, &#123;&#39;class&#39;: &#39;t-i&#39;&#125;).get_text() # 通过正则分割年份字符串 nianfen2 &#x3D; re.sub(r&#39;|&#39;, &#39;&#39;, nianfen1).split(&#39;|&#39;) nianfen &#x3D; nianfen2[0] licheng &#x3D; nianfen2[1] didian &#x3D; &#39;苏州&#39; shoujia &#x3D; info.find(&#39;div&#39;, &#123;&#39;class&#39;: &#39;t-price&#39;&#125;).find(&#39;p&#39;).get_text() try: yuanjia &#x3D; info.find(&#39;div&#39;, &#123;&#39;class&#39;: &#39;t-price&#39;&#125;).find(&#39;em&#39;).get_text() except AttributeError: yuanjia &#x3D; &#39;&#39; tupian &#x3D; info.find(&#39;a&#39;).find(&#39;img&#39;)[&#39;src&#39;] pic_urls.append(tupian) f.write(&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;\\n&quot;.format(leixing, nianfen, licheng, didian, shoujia, yuanjia)) return pic_urls get_data拿到所有的数据属性后，接下来通过含有信号量的多线程方式调用封装好的download_pics方法批量抓取图片。 1234567891011121314# 定义最多10个线程同时允许thread_lock &#x3D; threading.BoundedSemaphore(value&#x3D;10)def main(): n &#x3D; 0 for i in range(1,51): start_url &#x3D; &#39;https:&#x2F;&#x2F;www.guazi.com&#x2F;su&#x2F;buy&#x2F;o&#39;+str(i) html &#x3D; getHtmlText(start_url) pic_urls &#x3D; get_data(html) for url in pic_urls: n+&#x3D;1 print(&#39;正在下载第&#123;&#125;张图片&#39;.format(n)) # 上锁 避免下载同一张 thread_lock.acquire() t &#x3D; threading.Thread(target&#x3D;download_pics,args&#x3D;(url,n)) 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","permalink":"http://onejane.github.io/tags/ThreadPoolExecutor/"},{"name":"BoundedSemaphore","slug":"BoundedSemaphore","permalink":"http://onejane.github.io/tags/BoundedSemaphore/"}]},{"title":"加壳与脱壳之二代壳函数抽取","slug":"加壳与脱壳之二代壳函数抽取","date":"2021-03-25T00:07:35.000Z","updated":"2021-06-07T14:48:07.207Z","comments":true,"path":"2021/03/25/加壳与脱壳之二代壳函数抽取/","link":"","permalink":"http://onejane.github.io/2021/03/25/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E4%BA%8C%E4%BB%A3%E5%A3%B3%E5%87%BD%E6%95%B0%E6%8A%BD%E5%8F%96/","excerpt":"","text":"函数抽取宣告一代壳整体保护的结束，由此进入二代壳的时代，本文将对Dalvik和Art下函数抽取的加固方法原理介绍及实现函数抽取的代码保护方案。 Dalvik Android中实现「类方法指令抽取方式」加固方案原理解析：对dex结构简单介绍，定位函数指令地址，实现函数抽取壳的demo，对getPwd函数进行指令抽取，类被加载时重填恢复指令。 Android免Root权限通过Hook系统函数修改程序运行时内存指令逻辑：为了修改原有系统对dex加载流程，需要hook系统某些关键函数，自然可以在原有函数逻辑中添加需要自定义的逻辑功能，再添加一些恢复保护函数的填充。 源码分析实现函数抽取壳需要保证对函数恢复的时机肯定早于函数被调用的时机，不然app逻辑被破坏了，即当函数被调用时指令流必须已经被修复了，否则app逻辑被破坏导致app崩了。再选择时机，Android中实现「类方法指令抽取方式」加固方案原理解析中选择了dexFindClass函数。 对于函数来说在被调用之前，首先dex加载(dexclassloader动态加载)，对类加载的函数调用时需要进行一些准备，需要经过装载-链接-初始化，在这些加载过程中有非常多的时机供我们选择，Dalvik源代码编译生成的system/lib/libdvm.so通过ida打开，搜索文中的dexFindClass函数，获取导出的函数名可实现函数抽取。hook的时机点肯定是早于被调用的时机点，当dex被dexclassloader加载完后，需要加载dex其他类(隐式加载+显式加载)。搜索libcore库中loadClass加载一个dex中的类的流程:DexClassLoader-&gt;BaseDexClassLoader-&gt;ClassLoader的loadClass,完整体现了双亲委派的特性。 1234567891011121314151617486 protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123; &#x2F;&#x2F; 为了提高加载类效率，使用父节点加载如果已经加载直接返回，否则进行双亲委派的父节点加载487 Class&lt;?&gt; clazz &#x3D; findLoadedClass(className);488489 if (clazz &#x3D;&#x3D; null) &#123;490 try &#123;491 clazz &#x3D; parent.loadClass(className, false);492 &#125; catch (ClassNotFoundException e) &#123;493 &#x2F;&#x2F; Don&#39;t want to see this.494 &#125;495496 if (clazz &#x3D;&#x3D; null) &#123;497 clazz &#x3D; findClass(className);498 &#125;499 &#125;500501 return clazz;502 &#125; 对于使用DexClassLoader第一次加载类的parent节点是pathClassLoader或被指定的bootClassLoader,因为类只由当前的classloader加载必然是找不到的，因此进入BaseDexClassLoader的findClass实现中。 12345678910111252 protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;53 List&lt;Throwable&gt; suppressedExceptions &#x3D; new ArrayList&lt;Throwable&gt;();54 Class c &#x3D; pathList.findClass(name, suppressedExceptions);55 if (c &#x3D;&#x3D; null) &#123;56 ClassNotFoundException cnfe &#x3D; new ClassNotFoundException(&quot;Didn&#39;t find class \\&quot;&quot; + name + &quot;\\&quot; on path: &quot; + pathList);57 for (Throwable t : suppressedExceptions) &#123;58 cnfe.addSuppressed(t);59 &#125;60 throw cnfe;61 &#125;62 return c;63 &#125; 紧接着进入pathList.findClass，其中pathList是在BaseDexClassLoader构造函数中实例化化，跟着进入pathList.findClass，调用了dex.loadClassBinaryName查找类 1234567891011121314151617317 public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;318 for (Element element : dexElements) &#123;319 DexFile dex &#x3D; element.dexFile;320321 if (dex !&#x3D; null) &#123; &#x2F;&#x2F; 尝试从每个dex中遍历找到类所在的dex中并返回类所在dex322 Class clazz &#x3D; dex.loadClassBinaryName(name, definingContext, suppressed); 323 if (clazz !&#x3D; null) &#123;324 return clazz;325 &#125;326 &#125;327 &#125;328 if (dexElementsSuppressedExceptions !&#x3D; null) &#123;329 suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));330 &#125;331 return null;332 &#125; 跟着进入loadClassBinaryName,其中调用了native层实现defineClassNative 1234567891011121314151617181920214 public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) &#123;215 return defineClass(name, loader, mCookie, suppressed);216 &#125;217218 private static Class defineClass(String name, ClassLoader loader, int cookie,219 List&lt;Throwable&gt; suppressed) &#123;220 Class result &#x3D; null;221 try &#123;222 result &#x3D; defineClassNative(name, loader, cookie);223 &#125; catch (NoClassDefFoundError e) &#123;224 if (suppressed !&#x3D; null) &#123;225 suppressed.add(e);226 &#125;227 &#125; catch (ClassNotFoundException e) &#123;228 if (suppressed !&#x3D; null) &#123;229 suppressed.add(e);230 &#125;231 &#125;232 return result;233 &#125; dalvik下Full Search搜索defineClassNative，进入/dalvik/vm/native/dalvik_system_DexFile.cpp的Dalvik_dalvik_system_DexFile_defineClassNative方法，如注释中所说从一个dex文件中加载一个类 123456789101112131415161718192021222324252627282930349static void Dalvik_dalvik_system_DexFile_defineClassNative(const u4* args,350 JValue* pResult)351&#123;352 StringObject* nameObj &#x3D; (StringObject*) args[0]; &#x2F;&#x2F; 类名353 Object* loader &#x3D; (Object*) args[1]; &#x2F;&#x2F; classloader354 int cookie &#x3D; args[2]; &#x2F;&#x2F; java层cookie355 ClassObject* clazz &#x3D; NULL;356 DexOrJar* pDexOrJar &#x3D; (DexOrJar*) cookie; &#x2F;&#x2F; 将int型cookie转为DexOrJar指针357 DvmDex* pDvmDex;358 char* name;359 char* descriptor;360361 name &#x3D; dvmCreateCstrFromString(nameObj);362 descriptor &#x3D; dvmDotToDescriptor(name);363 ALOGV(&quot;--- Explicit class load &#39;%s&#39; l&#x3D;%p c&#x3D;0x%08x&quot;,364 descriptor, loader, cookie);365 free(name);366367 if (!validateCookie(cookie))368 RETURN_VOID();369370 if (pDexOrJar-&gt;isDex)371 pDvmDex &#x3D; dvmGetRawDexFileDex(pDexOrJar-&gt;pRawDexFile);372 else373 pDvmDex &#x3D; dvmGetJarFileDex(pDexOrJar-&gt;pJarFile);374375 &#x2F;* once we load something, we can&#39;t unmap the storage *&#x2F;376 pDexOrJar-&gt;okayToFree &#x3D; false;377378 clazz &#x3D; dvmDefineClass(pDvmDex, descriptor, loader); 进入dvmGetRawDexFileDex，只是取出指针中的pDvmDex 12362INLINE DvmDex* dvmGetRawDexFileDex(RawDexFile* pRawDexFile) &#123;63 return pRawDexFile-&gt;pDvmDex;64&#125; 进入dvmDefineClass 12345671413ClassObject* dvmDefineClass(DvmDex* pDvmDex, const char* descriptor,1414 Object* classLoader)1415&#123;1416 assert(pDvmDex !&#x3D; NULL);14171418 return findClassNoInit(descriptor, classLoader, pDvmDex);1419&#125; 进入findClassNoInit，首先调用了clazz = dvmLookupClass(descriptor, loader, true);对当前加载的类名进行计算查询，如没有则返回为空，对于第一次加载必然是没有的，接着进入pClassDef = dexFindClass(pDvmDex-&gt;pDexFile, descriptor);，即Android中实现「类方法指令抽取方式」加固方案原理解析中选择的时机点，并通过hook掉类被加载时的时机，对抽取函数的恢复，实现函数还原，因此必然需要早于函数执行的时机，保证app正常运行。由于有些函数符号没有导出，就不是很容易进行hook，而在libdvm.so中的dexFindClass在IDA中是被导出的，方便hook。以上就是Dalvik下函数抽取壳的简单原理。 ARTArt下实现难点：dex2oat编译流程，dex2oat是可以进行脱壳，dex2oat完成了对抽取的dex进行编译生成了oat文件，后续的函数运行中，从oat中取出函数编译生成的二进制代码来执行，因此函数对dex填充后，如果时机不对，时机在dex2oat后，自然从dex2oat后那么我们动态修改的dex中的smali指令流就不会生效，因为后面app运行调用的真正的代码就会从dex2oat编译生成的oat文件，和以前的dex无关了。因此如果希望填充回去smali指令生效要么禁用dex2oat实现阻止编译，这样对加载到内存中的dex文件进行填充始终会保持生效，要么保持dex2oat编译，但是还原代码时机要早于dex2oat就ok了，保证dex2oat再次对dex编译的时候，dex已经是一个完整dex，不会影响我们填充的代码，但是肯定dex文件存在完整的时候，可以利用dex2oat编译的流程进行脱壳，一般加壳厂商都是牺牲掉app一部分的运行效率，干掉dex2oat的过程，因为google本身提倡dex2oat就是为了提升app运行效率。 禁用dex2oat编译回到ART下DexClassLoader动态加载dex的流程，在art下搜索GenerateOatFileNoChecks，该函数完成调用dex2oat进行编译 GenerateOatFileNoChecks中调用Dex2Oat函数 12616OatFileAssistant::ResultOfAttemptToUpdate OatFileAssistant::GenerateOatFileNoChecks(617 OatFileAssistant::OatFileInfo&amp; info, CompilerFilter::Filter filter, std::string* error_msg) &#123; Dex2Oat最终调用return Exec(argv, error_msg);，Exec中调用了int status = ExecAndReturnCode(arg_vector, error_msg);,其中ExecAndReturnCode通过pid_t pid = fork();进行fork一个子进程，在子进程中调用了execve(program, &amp;args[0], envp);完成对dex2oat这个二进制程序的调用。整个流程中任意一个环节被打断，dex2oat将会被干掉，无法继续运行。 TurboDex就是干掉dex2oat为了让dex在第一次动态加载时快速加载完成，因为不干掉dex2oat，art虚拟机就会调用dex2oat对当前的dex进行编译，编译过程非常耗时，可以很大地提升dexclassloader加载dex 的效率，该项目就是通过hook了execv方法实现。 众所周知,Android中在Runtime加载一个 未优化的Dex文件 (尤其在 ART 模式)需要花费 很长的时间. 当你在App中使用 插件化框架 的时候, 首次加载插件就需要耗费很长的时间. TurboDex 就是为了解决这一问题而生, 就像是给AndroidVM开启了上帝模式, 在引入TurboDex后, 无论你加载了多大的Dex文件,都可以在毫秒级别内完成. 接下来通过hook execve实现干掉dex2oat，可以通过爱奇艺xhook的GOT进行表hook干掉dex2oat，也可以用inline库hook。 SecondShell_80项目中：hooklibc中的execve的函数，干掉dexclassloader加载dex过程中dex2oat的流程。 myexecve 123456789101112131415161718192021222324252627&#x2F;&#x2F; 系统函数(在libc库中定义)被调用进入替换原始逻辑void* *myexecve(const char *__file, char *const *__argv, char *const *__envp) &#123; LOGD(&quot;process:%d,enter execve:%s&quot;, getpid(), __file); if (strstr(__file, &quot;dex2oat&quot;)) &#123; return NULL; &#125; else &#123; return oriexecve(__file, __argv, __envp); &#125;&#125;&#x2F;&#x2F; 实现干掉dex2oat的逻辑，加载原始的dex文件void hooklibc() &#123; LOGD(&quot;go into hooklibc&quot;); &#x2F;&#x2F;7.0 命名空间限制 libc有直接权限调用 void *libc_addr &#x3D; dlopen_compat(&quot;libc.so&quot;, RTLD_NOW); void *execve_addr &#x3D; dlsym_compat(libc_addr, &quot;execve&quot;); if (execve_addr !&#x3D; NULL) &#123; &#x2F;&#x2F; 需要hook函数地址，替换的地址，保存原函数地址在自己函数逻辑中进行调用 if (ELE7EN_OK &#x3D;&#x3D; registerInlineHook((uint32_t) execve_addr, (uint32_t) myexecve, (uint32_t **) &amp;oriexecve)) &#123; if (ELE7EN_OK &#x3D;&#x3D; inlineHook((uint32_t) execve_addr)) &#123; LOGD(&quot;inlineHook execve success&quot;); &#125; else &#123; LOGD(&quot;inlineHook execve failure&quot;); &#125; &#125; &#125;&#125; 启动SecondShell_80项目，并授予sdcard权限，查看logcat，检索dex2oat FART正餐前甜点：ART下几个通用简单高效的dump内存中dex方法中找一个好时机点实现art下二代函数抽取壳对抽空函数的还原，LoadClassMembers完成对要加载的class的准备工作，准备SetSFields,SetDirectMethodsPtr,要对当前已经加载的dex内容进行修改某一个被抽空的函数，首先定位到当前函数的CodeItem的地址进行修复，这过程中出现的时机点可以hook掉。LoadMethod设置了CodeItem的偏移，ArtMethod* method = klass-&gt;GetDirectMethodUnchecked(i, image_pointer_size_);初始化了method对象，此时内容还没有被填充，ArtMethod中关键变量dex_code_item_offset，在我们class被加载完后，准备好当前class每个函数对应的ArtMethod对象，禁用掉dex2oat以后，自然类中所有的函数都在解释模式下运行，必然找到当前ArtMethod的CodeItem在内存中的偏移，进行取出一条条smali指令流解释执行。LoadMethod(self, dex_file, it, klass, method);传入的dex_file为当前的dex对象，method为当前要准备的ArtMethod对象，每个ArtMethod对象都和java层的函数一一对应，这些函数都可以被hook掉，因为都在函数被调用前执行，都能实现对其的填充。 1234567891011123305void ClassLinker::LoadMethod(const DexFile&amp; dex_file,3306 const ClassDataItemIterator&amp; it,3307 Handle&lt;mirror::Class&gt; klass,3308 ArtMethod* dst) &#123;3309 uint32_t dex_method_idx &#x3D; it.GetMemberIndex();3310 const DexFile::MethodId&amp; method_id &#x3D; dex_file.GetMethodId(dex_method_idx);3311 const char* method_name &#x3D; dex_file.StringDataByIdx(method_id.name_idx_);33123313 ScopedAssertNoThreadSuspension ants(&quot;LoadMethod&quot;);3314 dst-&gt;SetDexMethodIndex(dex_method_idx); &#x2F;&#x2F; 设置MethodIndex3315 dst-&gt;SetDeclaringClass(klass.Get()); &#x2F;&#x2F; 设置类3316 dst-&gt;SetCodeItemOffset(it.GetMethodCodeItemOffset()); &#x2F;&#x2F; 指向smali指令在内存中的偏移 如果hook了LoadMethod函数，被调用完后ArtMethod对象的CodeItemOffset就完成了设置，且第五个参数就是ArtMethod对象的指针，可以很容易取出ArtMethod参数的CodeItemOffset，定位到了当前要填充的函数的smali指令流在内存中的偏移位置，避免了大量代码解析dex在内存中的映射。 实现函数抽取壳案例用loadDex.apk和4.dex。 定位函数要抽取的位置com.kanxue.test02.TestClass.testFunc的函数置空。使用010Editor打开4.dex，方法太多了导出csv 导出的csv用010打开，检索TestClass，出现索引号1028 回过头来再看4.dex中的TestClass的位置 code_item占了32个字节 GDA查看4.dex该方法,右键-Show Hex 对应010中选中部分全部改成0，即完成函数抽取。 dex header本身对dex校验，改完后还需要修改校验头部分 python checksum.py 返回CheckSum = 0x2785815e,则修改校验头部分，使其成为一个合法的dex文件 gda再次打开该dex，完成函数抽取。 接下来完成对testFunc的填充，并正常调用testFunc中的代码。 通过hooklibc的execve禁用掉dex2oat 选中了LoadMethod函数的hook，原型是oriloadmethod，并添加了自己的逻辑。需要当testFunc被初始化时需要将原有的smali指令流利用myloadmethod填充回去， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475void hookART() &#123; LOGD(&quot;go into hookART&quot;); void *libart_addr &#x3D; dlopen_compat(&quot;&#x2F;system&#x2F;lib&#x2F;libart.so&quot;, RTLD_NOW); if (libart_addr !&#x3D; NULL) &#123; void *loadmethod_addr &#x3D; dlsym_compat(libart_addr, &quot;_ZN3art11ClassLinker10LoadMethodERKNS_7DexFileERKNS_21ClassDataItemIteratorENS_6HandleINS_6mirror5ClassEEEPNS_9ArtMethodE&quot;); if (loadmethod_addr !&#x3D; NULL) &#123; if (ELE7EN_OK &#x3D;&#x3D; registerInlineHook((uint32_t) loadmethod_addr, (uint32_t) myloadmethod, (uint32_t **) &amp;oriloadmethod)) &#123; if (ELE7EN_OK &#x3D;&#x3D; inlineHook((uint32_t) loadmethod_addr)) &#123; LOGD(&quot;inlineHook loadmethod success&quot;); &#125; else &#123; LOGD(&quot;inlineHook loadmethod failure&quot;); &#125; &#125; &#125; &#125;&#125;void *myloadmethod(void *a, void *b, void *c, void *d, void *e) &#123; LOGD(&quot;process:%d,before run loadmethod:&quot;, getpid()); struct ArtMethod *artmethod &#x3D; (struct ArtMethod *) e; struct DexFile *dexfile &#x3D; (struct DexFile *) b; LOGD(&quot;process:%d,enter loadmethod:dexfilebegin:%p,size:%d&quot;, getpid(), dexfile-&gt;begin, dexfile-&gt;size);&#x2F;&#x2F;0,57344 char dexfilepath[100] &#x3D; &#123;0&#125;; sprintf(dexfilepath, &quot;&#x2F;sdcard&#x2F;%d_%d.dex&quot;, dexfile-&gt;size, getpid()); int fd &#x3D; open(dexfilepath, O_CREAT | O_RDWR, 0666); if (fd &gt; 0) &#123; &#x2F;&#x2F; 得到dex file的起始地址和大小，可以将此刻dex dump下来，用来对比 write(fd, dexfile-&gt;begin, dexfile-&gt;size); close(fd); &#125; &#x2F;&#x2F; oriloadmethod未被调用时，artmethod未被初始化，值为空。当调用了原始的oriloadmethod关键变量被初始化好，如dex_method_index_和dex_code_item_offset_，取出artmethod void *result &#x3D; oriloadmethod(a, b, c, d, e); LOGD(&quot;process:%d,enter loadmethod:code_offset:%d,idx:%d&quot;, getpid(), artmethod-&gt;dex_code_item_offset_, artmethod-&gt;dex_method_index_); byte *code_item_addr &#x3D; static_cast&lt;byte *&gt;(dexfile-&gt;begin) + artmethod-&gt;dex_code_item_offset_; LOGD(&quot;process:%d,enter loadmethod:dexfilebegin:%p,size:%d,beforedumpcodeitem:%p&quot;, getpid(), dexfile-&gt;begin, dexfile-&gt;size, code_item_addr); &#x2F;&#x2F; 当地址为15203时，即testFunc函数(010中)，进行原有指令数组进行填充 if (artmethod-&gt;dex_method_index_ &#x3D;&#x3D; 15203) &#123;&#x2F;&#x2F;TestClass.testFunc-&gt;methodidx LOGD(&quot;process:%d,enter loadmethod:dexfilebegin:%p,size:%d,start repire method&quot;, getpid(), dexfile-&gt;begin, dexfile-&gt;size); byte *code_item_addr &#x3D; (byte *) dexfile-&gt;begin + artmethod-&gt;dex_code_item_offset_; LOGD(&quot;process:%d,enter loadmethod:dexfilebegin:%p,size:%d,beforedumpcodeitem:%p&quot;, getpid(), dexfile-&gt;begin, dexfile-&gt;size, code_item_addr); int result &#x3D; mprotect(dexfile-&gt;begin, dexfile-&gt;size, PROT_WRITE); byte *code_item_start &#x3D; static_cast&lt;byte *&gt;(code_item_addr) + 16; &#x2F;&#x2F; 16字节后才是函数填充全0的指令流 LOGD(&quot;process:%d,enter loadmethod:dexfilebegin:%p,size:%d,code_item_start:%p&quot;, getpid(), dexfile-&gt;begin, dexfile-&gt;size, code_item_start); byte inst[16] &#x3D; &#123;0x1a, 0x00, 0xed, 0x34, 0x1a, 0x01, 0x43, 0x32, 0x71, 0x20, 0x91, 0x05, 0x10, 0x00, 0x0e, 0x00&#125;; for (int i &#x3D; 0; i &lt; sizeof(inst); i++) &#123; &#x2F;&#x2F; 逐个赋值 code_item_start[i] &#x3D; inst[i]; &#125; &#x2F;&#x2F;2343-&gt;i am from com.kanxue.test02.TestClass.testFunc code_item_start[2] &#x3D; 0x43;&#x2F;&#x2F;34ed-&gt;kanxue code_item_start[3] &#x3D; 0x23; memset(dexfilepath, 0, 100); sprintf(dexfilepath, &quot;&#x2F;sdcard&#x2F;%d_%d.dex_15203_2&quot;, dexfile-&gt;size, getpid()); fd &#x3D; open(dexfilepath, O_CREAT | O_RDWR, 0666); if (fd &gt; 0) &#123; write(fd, dexfile-&gt;begin, dexfile-&gt;size); close(fd); &#125; &#125; LOGD(&quot;process:%d,after loadmethod:code_offset:%d,idx:%d&quot;, getpid(), artmethod-&gt;dex_code_item_offset_, artmethod-&gt;dex_method_index_);&#x2F;&#x2F;0,57344 return result;&#125; 将修复后的4_chouqu.dex推送到/sdcard中 通过初始化后的code_item的偏移直接定位dex在内存中地址，并进行修正，实现art下函数抽取的解决方案，并没有通过大量代码art中的头文件去解析dex结构信息。 ART下抽取壳实现","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"classloader","slug":"classloader","permalink":"http://onejane.github.io/tags/classloader/"}]},{"title":"加壳与脱壳之一代壳dex保护","slug":"加壳与脱壳之一代壳dex保护","date":"2021-03-16T12:27:25.000Z","updated":"2021-06-07T14:48:07.207Z","comments":true,"path":"2021/03/16/加壳与脱壳之一代壳dex保护/","link":"","permalink":"http://onejane.github.io/2021/03/16/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E4%B8%80%E4%BB%A3%E5%A3%B3dex%E4%BF%9D%E6%8A%A4/","excerpt":"","text":"Dalvik4.4.4dex加载源码分析虽然加壳技术有所不同，第一步依然是dump内存中dex，虽然安卓4.4后Dalvik淡出视野，但是影响深远。Dalvik系统DexClassLoader加载dex具体流程： 在libcore目录下搜索DexClassLoader源码只有一个构造函数 dexPath：需要加载的dex路径optimizedDirectory：dex优化过程中产生的odex的存放路径libraryPath：当前classloader需要加载so的路径parent：双亲委派中的当前dexclassloader的父节点设置的classloader 1234public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), libraryPath, parent);&#125; 由于只调用了父类的构造函数，我们进入父类BaseDexClassLoader封装大量的函数，真正逻辑存在BaseDexClassLoader的构造函数中实现，调用了父类的构造函数，该类存在与/libcore/libart和/libcore/libdvm，说明在安卓4.4中已经开始引入art相关逻辑。 12345public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(parent); this.pathList &#x3D; new DexPathList(this, dexPath, libraryPath, optimizedDirectory);&#125; 进入Dalvik的ClassLoader的构造函数，将当前的ClassLoader的父节点作为传入的parent。 123456ClassLoader(ClassLoader parentLoader, boolean nullAllowed) &#123; if (parentLoader &#x3D;&#x3D; null &amp;&amp; !nullAllowed) &#123; throw new NullPointerException(&quot;parentLoader &#x3D;&#x3D; null &amp;&amp; !nullAllowed&quot;); &#125; parent &#x3D; parentLoader;&#125; 再进入new DexPathList再初始化pathList实例，进入DexPathList构造函数，前面对参数校验，真正起作用this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,suppressedExceptions);,makeDexElements方法调用了loadDexFile返回的dex添加到element数组并返回数组。 loadDexFile中再度调用了DexFile.loadDex(file.getPath(), optimizedPath, 0)，该方法新建了一个DexFile对象，return new DexFile(sourcePathName, outputPathName, flags);，在Dexfile中调用了openDexFile(sourceName, outputName, flags)完成了对dex的处理，openDexFile中调用了openDexFileNative，其中又调用openDexFileNative方法,跟进openDexFileNative发现是一个使用c/c++实现的native函数，native private static int openDexFileNative。该方法处理类/libcore/dalvik/src/main/java/dalvik/system/DexFile.java中，对应的实现文件就是dalvik_system_DexFile查看方法Dalvik_dalvik_system_DexFile_openDexFileNative，其中调用了dvmRawDexFileOpen实现对dex文件的打开。 123456789if (hasDexExtension(sourceName) &#x2F;&#x2F; 对当前文件后缀的校验 &amp;&amp; dvmRawDexFileOpen(sourceName, outputName, &amp;pRawDexFile, false) &#x3D;&#x3D; 0) &#123; ALOGV(&quot;Opening DEX file &#39;%s&#39; (DEX)&quot;, sourceName); pDexOrJar &#x3D; (DexOrJar*) malloc(sizeof(DexOrJar)); pDexOrJar-&gt;isDex &#x3D; true; pDexOrJar-&gt;pRawDexFile &#x3D; pRawDexFile; pDexOrJar-&gt;pDexMemory &#x3D; NULL;&#125; 在dvmRawDexFileOpen中dexFd = open(fileName, O_RDONLY);打开dex文件，verifyMagicAndGetAdler32(dexFd, &amp;adler32) &lt; 0对dex魔术字校验，cachedName = dexOptGenerateCacheFileName(fileName, NULL);生成优化后的odex文件路径，dvmOptimizeDexFile(optFd, dexOffset, fileSize,fileName, modTime, adler32, isBootstrap);优化当前的dex，跟进发现存在于DexPrepare.cpp中的dvmOptimizeDexFile(int fd, off_t dexOffset, long dexLength,const char* fileName, u4 modWhen, u4 crc, bool isBootstrap),该方法中pid = fork();fd为打开的dex文件的id，dexLength为dex文件的大小，pid=fork()新建了子进程用于调用/bin/dexopt对当前dex文件进行优化，结果生成odex文件。bin/dexopt的main方法中传入的文件校验是dex时，调用static int fromDex(int argc, char* const argv[])首先调用dvmPrepForDexOpt对当前优化环境准备，再调用dvmContinueOptimization对当前的fd文件进行优化 123dexLength &lt; (int) sizeof(DexHeader) 字节长度判断mapAddr &#x3D; mmap(NULL, dexOffset + dexLength, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); mmap对当前dex文件的内容进行内存映射rewriteDex(((u1*) mapAddr) + dexOffset, dexLength, doVerify, doOpt, &amp;pClassLookup, NULL); 重写dex(起始地址，长度，...) 查看static bool rewriteDex(u1* addr, int len, bool doVerify, bool doOpt,DexClassLookup** ppClassLookup, DvmDex** ppDvmDex)方法参数有加载到内存中dex的起始地址，字节数。该方法中暴露出在Dalvik中脱壳点的相关函数，dvmDexFileOpenPartial函数中出现dexFileParse，参数包含起始地址和字节数。 以上即是dexclassloader在动态加载dex时Dalvik实现的逻辑处理，很多时机点都出现了加载的dex的起始地址，就是最好的脱壳时机。很多脱壳方法都是对**dvmDexFileOpenPartial和dexFileParse进行下断点或者进行hook，取出第一个参数(起始地址)和第二个参数(dex长度)，在第一次DexPrepare.cpp中，其实在mmap对dex内存映射时包含dex文件，对当前映射区域进行dump也可以脱下从文件形式加载dex，在rewriteDex**时也出现了dex文件加载的起始地址和大小，自然也是可以进行dump等等。通过Cydia、xposed、frida都可以对实现对关键时机的hook，取出前两个参数，拿到起始地址和长度，dump下来内存区域即可实现脱壳。 定制源码脱壳对新的一些加壳厂商的产品依然有效，除非厂商对这些函数进行hook修改，或者参考Dalvik修改实现自己的逻辑。进入Ubuntu 1604x64_4.4的编译环境虚拟机，tom/admin，4.4的源码为hammerhead及其驱动。通过编译源码的方式实现以下为部分脱壳点： dvmDexFileOpenPartial搜索 dvmDexFileOpenPartial 发现在/dalvik/vm/DvmDex.cpp文件中，使用Geany打开 ~/SourceCode/android-4.4.4_r1/dalvik/vm/DvmDex.cpp，找到dvmDexFileOpenPartial方法，只需要保存起始地址和大小即可。 修改int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex) 123456789101112131415#include &lt;sys&#x2F;stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;&#x2F;&#x2F;新建保存路径用于拼接脱壳app产生的dex路径，对每个脱壳的app的脱下的dex单独起名char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dvmDexFileOpenPartial.dex&quot;,len,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,addr,len); close(fd);&#125; dexFileParse搜索**dexFileParse**发现存在/dalvik/libdex/DexFile.cpp中，使用geany编辑器打开DexFile.cpp 修改DexFile* dexFileParse(const u1* data, size_t length, int flags) 123456789101112131415#include &lt;sys&#x2F;stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;&#x2F;&#x2F;新建保存路径用于拼接脱壳app产生的dex路径，对每个脱壳的app的脱下的dex单独起名char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dvmFileParse.dex&quot;,length,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,data,length); close(fd);&#125; mmap搜索 mmap 存在于/dalvik/vm/analysis/DexPrepare.cpp的中， 修改bool dvmContinueOptimization(int fd, off_t dexOffset, long dexLength, const char* fileName, u4 modWhen, u4 crc, bool isBootstrap) 1234567891011char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dvmContinueOptimization.dex&quot;,dexLength,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,mapAddr,dexOffset + dexLength); close(fd);&#125; 第一次映射到内存中需要将dex通过010Editor修正，删除64 65 78 0A前的字符。 rewriteDex搜索rewriteDex位于/dalvik/vm/analysis/DexPrepare.cpp， 修改static bool rewriteDex(u1* addr, int len, bool doVerify, bool doOpt, DexClassLookup** ppClassLookup, DvmDex** ppDvmDex) 1234567891011char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_rewriteDex.dex&quot;,len,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,addr,len); close(fd);&#125; dexSwapVerify搜索dexSwapVerify存在于/dalvik/libdex/DexSwapVerify.cpp 修改int dexSwapAndVerify(u1* addr, int len) 1234567891011char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dexSwapAndVerify.dex&quot;,len,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,addr,len); close(fd);&#125; 编译1234~&#x2F;SourceCode&#x2F;android-4.4.4_r1$ source build&#x2F;envsetup.sh~&#x2F;SourceCode&#x2F;android-4.4.4_r1$ lunch7 选择aosp_hammerhead-userdebug~&#x2F;SourceCode&#x2F;android-4.4.4_r1$ time make -j4 如果报错直接make单线程编译 生成路径~/SourceCode/android/4.4.4_r1/out/target/product/hammerhead，将boot.img,cache.img,ramdisk.img,system.img,userdata.img拷出来 adb reboot bootloaderfastboot flash system system.img 常用的img有boot,cache,ramdisk,system,userdata 安装LoadDex.apk，并把ClassLoaderTest生成的classes.dex放入/sdcard。在Activity启动的时候加载/sdcard的classes.dex的TestActivity并打印I&#39;m from TestActivity.onCreate，这就是一代壳的基本原理。 重启系统后/sdcard中已经出现一些系统中脱下的dex，启动LoadDex，grep -ril &quot;TestActivity&quot; ./*.dex 找到LoadDex中脱下的dex，gda可以看到优化后的odex的TestActivity中onCreate方法 真实案例a.apk 快递100 《百度》加固 启动后进入/sdcard , grep -ril “SplashActivity” ./*.dex b.apk 货拉拉司机版《爱加密》企业版本加固 启动后进入/sdcard , grep -ril “mvp/ui/SplashActivity” ./*.dex，内容都为null，说明用了函数抽取。 ART8.0.0InMemoryDexClassLoader源码分析加载内存中的解密字节流过程art的具体流程： 在Android 8.0中libcore搜索InMemoryDexClassLoader两个构造函数，分别加载一个或多个dex，super(dexBuffers, parent);调用了父类的构造函数。进入父类BaseDexClassLoader.java的构造函数 1234567public BaseDexClassLoader(ByteBuffer[] dexFiles, ClassLoader parent) &#123; // TODO We should support giving this a library search path maybe. // 设置parent super(parent); // 初始化DexPathList对象 this.pathList = new DexPathList(this, dexFiles);&#125; 跟进public DexPathList(ClassLoader definingContext, ByteBuffer[] dexFiles)构造函数，前几步对传参判断，紧接着对传入的so库的处理 123456this.definingContext = definingContext;// TODO It might be useful to let in-memory dex-paths have native libraries.this.nativeLibraryDirectories = Collections.emptyList();this.systemNativeLibraryDirectories = splitPaths(System.getProperty(\"java.library.path\"), true);this.nativeLibraryPathElements = makePathElements(this.systemNativeLibraryDirectories); 传入的dex只需要看this.dexElements = makeInMemoryDexElements(dexFiles, suppressedExceptions);摘除核心代码如下： 12345678910private static Element[] makeInMemoryDexElements(ByteBuffer[] dexFiles, List&lt;IOException&gt; suppressedExceptions) &#123; Element[] elements = new Element[dexFiles.length]; int elementPos = 0; for (ByteBuffer buf : dexFiles) &#123; DexFile dex = new DexFile(buf); elements[elementPos++] = new Element(dex); &#125; return elements;&#125; 进入DexFile(buf)的构造函数中，发现openInMemoryDexFile将buf在内存中打开返回了mCookie 12345DexFile(ByteBuffer buf) throws IOException &#123; mCookie = openInMemoryDexFile(buf); mInternalCookie = mCookie; mFileName = null;&#125; 查看openInMemoryDexFile方法，分别根据条件创建了两次cookie 1234567private static Object openInMemoryDexFile(ByteBuffer buf) throws IOException &#123; if (buf.isDirect()) &#123; return createCookieWithDirectBuffer(buf, buf.position(), buf.limit()); &#125; else &#123; return createCookieWithArray(buf.array(), buf.position(), buf.limit()); &#125;&#125; 分别查看createCookieWithDirectBuffer和createCookieWithArray两个方法，发现是两个native函数 12private static native Object createCookieWithDirectBuffer(ByteBuffer buf, int start, int end);private static native Object createCookieWithArray(byte[] buf, int start, int end); 在art模块中Full Search createCookieWithDirectBuffer,进入DexFile_createCookieWithDirectBuffer 12345678910111213141516171819202122static jobject DexFile_createCookieWithDirectBuffer(JNIEnv* env, jclass, &#x2F;&#x2F; 静态函数 第一个是jclass当前类 jobject buffer, &#x2F;&#x2F; 传入内存中的字节流 jint start, jint end) &#123; uint8_t* base_address &#x3D; reinterpret_cast&lt;uint8_t*&gt;(env-&gt;GetDirectBufferAddress(buffer)); if (base_address &#x3D;&#x3D; nullptr) &#123; ScopedObjectAccess soa(env); ThrowWrappedIOException(&quot;dexFileBuffer not direct&quot;); return 0; &#125; std::unique_ptr&lt;MemMap&gt; dex_mem_map(AllocateDexMemoryMap(env, start, end)); if (dex_mem_map &#x3D;&#x3D; nullptr) &#123; DCHECK(Thread::Current()-&gt;IsExceptionPending()); return 0; &#125; size_t length &#x3D; static_cast&lt;size_t&gt;(end - start); memcpy(dex_mem_map-&gt;Begin(), base_address, length); &#x2F;&#x2F; 对当前字节流进行内存拷贝memcpy，传入begin和length就是dex的起始地址，可以进行dump return CreateSingleDexFileCookie(env, std::move(dex_mem_map));&#125; createCookieWithDirectBuffer和createCookieWithArray都进行了CreateSingleDexFileCookie 12345678910static jobject CreateSingleDexFileCookie(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; data) &#123; std::unique_ptr&lt;const DexFile&gt; dex_file(CreateDexFile(env, std::move(data))); &#x2F;&#x2F; 根据传入dex文件在内存中信息创建了DexFile实例 if (dex_file.get() &#x3D;&#x3D; nullptr) &#123; DCHECK(env-&gt;ExceptionCheck()); return nullptr; &#125; std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files; dex_files.push_back(std::move(dex_file)); return ConvertDexFilesToJavaArray(env, nullptr, dex_files); &#x2F;&#x2F; 对该dex_files进行返回&#125; 通过CreateDexFile创建DexFile对象 12345678910111213141516171819202122232425static const DexFile* CreateDexFile(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; dex_mem_map) &#123; &#x2F;&#x2F; 返回dex文件在内存中映射的地址 std::string location &#x3D; StringPrintf(&quot;Anonymous-DexFile@%p-%p&quot;, dex_mem_map-&gt;Begin(), dex_mem_map-&gt;End()); std::string error_message; std::unique_ptr&lt;const DexFile&gt; dex_file(DexFile::Open(location, 0, std::move(dex_mem_map), &#x2F;* verify *&#x2F; true, &#x2F;* verify_location *&#x2F; true, &amp;error_message)); if (dex_file &#x3D;&#x3D; nullptr) &#123; ScopedObjectAccess soa(env); ThrowWrappedIOException(&quot;%s&quot;, error_message.c_str()); return nullptr; &#125; if (!dex_file-&gt;DisableWrite()) &#123; ScopedObjectAccess soa(env); ThrowWrappedIOException(&quot;Failed to make dex file read-only&quot;); return nullptr; &#125; return dex_file.release();&#125; 进入DexFile::Open，其中又调用了OpenCommon函数 1234567891011121314151617181920212223std::unique_ptr&lt;const DexFile&gt; DexFile::Open(const std::string&amp; location, &#x2F;&#x2F; 加载dex文件的路径 uint32_t location_checksum, std::unique_ptr&lt;MemMap&gt; map, &#x2F;&#x2F; 内存的映射 bool verify, bool verify_checksum, std::string* error_msg) &#123; ScopedTrace trace(std::string(&quot;Open dex file from mapped-memory &quot;) + location); CHECK(map.get() !&#x3D; nullptr); if (map-&gt;Size() &lt; sizeof(DexFile::Header)) &#123; *error_msg &#x3D; StringPrintf( &quot;DexFile: failed to open dex file &#39;%s&#39; that is too short to have a header&quot;, location.c_str()); return nullptr; &#125; std::unique_ptr&lt;DexFile&gt; dex_file &#x3D; OpenCommon(map-&gt;Begin(), map-&gt;Size(), location, location_checksum, kNoOatDexFile, verify, verify_checksum, error_msg); 进入OpenCommon函数 1234567891011121314151617std::unique_ptr&lt;DexFile&gt; DexFile::OpenCommon(const uint8_t* base, &#x2F;&#x2F; 加载dex文件的起始地址 size_t size, const std::string&amp; location, uint32_t location_checksum, const OatDexFile* oat_dex_file, bool verify, bool verify_checksum, std::string* error_msg, VerifyResult* verify_result) &#123; if (verify_result !&#x3D; nullptr) &#123; *verify_result &#x3D; VerifyResult::kVerifyNotAttempted; &#125; std::unique_ptr&lt;DexFile&gt; dex_file(new DexFile(base, size, location, location_checksum, oat_dex_file)); &#x2F;&#x2F; 创建新的DexFile实例，构造函数也包含起始地址和大小 说明InMemoryDexClassLoader在对内存中bytebuffer的dex信息进行加载流程中涉及很多函数逻辑都包含dex信息的起始地址和大小。InMemoryDexClassLoader并没有对内存中dex信息进行编译生成相应的oat文件，这是与DexClassLoader的不同。 InMemoryDexClassLoader通用脱壳点： CreateSingleDexFileCookie的data参数可以获取起始地址 CreateDexFile DexFile::Open OpenCommon DexFile::DexFile DexClassLoader加载dex源码分析DexClassLoader只有一个构造函数 1234public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), librarySearchPath, parent);&#125; 进入父类BaseDexClassLoader.java的构造函数 123456789public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(parent); this.pathList &#x3D; new DexPathList(this, dexPath, librarySearchPath, null); if (reporter !&#x3D; null) &#123; reporter.report(this.pathList.getDexPaths()); &#125;&#125; 同样的进入DexPathList的核心逻辑this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,suppressedExceptions, definingContext);,调用了makeDexElements，其中加载dex文件loadDexFile(file, optimizedDirectory, loader, elements); 12345678910private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader, Element[] elements) throws IOException &#123; if (optimizedDirectory &#x3D;&#x3D; null) &#123; return new DexFile(file, loader, elements); &#125; else &#123; String optimizedPath &#x3D; optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements); &#125;&#125; DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements)调用了5个参数的loadDex,进入loadDex函数 1234static DexFile loadDex(String sourcePathName, String outputPathName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; return new DexFile(sourcePathName, outputPathName, flags, loader, elements); &#x2F;&#x2F; 创建DexFile实例&#125; 进入DexFile五参数构造函数 123456DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; mCookie &#x3D; openDexFile(fileName, null, 0, loader, elements); mInternalCookie &#x3D; mCookie; mFileName &#x3D; fileName; &#x2F;&#x2F;System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; fileName&#x3D;&quot; + fileName);&#125; 进入openDexFile中调用了native函数private static native Object openDexFileNative(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements); 1234567return openDexFileNative(new File(sourceName).getAbsolutePath(), (outputName &#x3D;&#x3D; null) ? null : new File(outputName).getAbsolutePath(), flags, loader, elements); Full Search搜索art目录下的openDexFileNative， 123456789101112131415161718192021222324252627282930313233343536373839static jobject DexFile_openDexFileNative(JNIEnv* env, jclass, &#x2F;&#x2F; 静态函数 jstring javaSourceName, &#x2F;&#x2F; 加载的dex路径 jstring javaOutputName ATTRIBUTE_UNUSED, jint flags ATTRIBUTE_UNUSED, jobject class_loader, jobjectArray dex_elements) &#123; ScopedUtfChars sourceName(env, javaSourceName); if (sourceName.c_str() &#x3D;&#x3D; nullptr) &#123; return 0; &#125; Runtime* const runtime &#x3D; Runtime::Current(); ClassLinker* linker &#x3D; runtime-&gt;GetClassLinker(); std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files; std::vector&lt;std::string&gt; error_msgs; const OatFile* oat_file &#x3D; nullptr; &#x2F;&#x2F; 出现oat dex_files &#x3D; runtime-&gt;GetOatFileManager().OpenDexFilesFromOat(sourceName.c_str(), class_loader, dex_elements, &#x2F;*out*&#x2F; &amp;oat_file, &#x2F;*out*&#x2F; &amp;error_msgs); &#x2F;&#x2F; 调用OpenDexFilesFromOat编译生成oat流程 if (!dex_files.empty()) &#123; jlongArray array &#x3D; ConvertDexFilesToJavaArray(env, oat_file, dex_files); if (array &#x3D;&#x3D; nullptr) &#123; ScopedObjectAccess soa(env); for (auto&amp; dex_file : dex_files) &#123; if (linker-&gt;IsDexFileRegistered(soa.Self(), *dex_file)) &#123; dex_file.release(); &#125; &#125; &#125; return array; &#125; return nullptr; &#125;&#125; DexClassLoader第一次动态加载解密的dex时必然没有进行编译生成oat，查看OpenDexFilesFromOat,首先OatFileAssistant oat_file_assistant(dex_location,kRuntimeISA,!runtime-&gt;IsAotCompiler());新建了OatFileAssistant 对象，if (!oat_file_assistant.IsUpToDate())由于没有生成oat对象的，进入判断中的MakeUpToDate函数，其中调用了return GenerateOatFileNoChecks(info, target, error_msg);GenerateOatFileNoChecks最终进入调用dex2oat编译生成oat的流程 123456789if (!Dex2Oat(args, error_msg)) &#123; &#x2F;&#x2F; Manually delete the oat and vdex files. This ensures there is no garbage &#x2F;&#x2F; left over if the process unexpectedly died. vdex_file-&gt;Erase(); unlink(vdex_file_name.c_str()); oat_file-&gt;Erase(); unlink(oat_file_name.c_str()); return kUpdateFailed;&#125; Dex2Oat中准备相关二进制程序参数的相关信息，最终调用return Exec(argv, error_msg);实现dex2oat编译的过程，进入Exec中调用了ExecAndReturnCode，其中首次pid_t pid=fork()进行了进程fork，在子进程当中使用execve(program, &amp;args[0], envp);执行dex2oat实际执行流程。 说明我们在整个流程中其中某个函数进行修改或者hook都会导致dex2oat流程结束，强制结束dex2oat流程，可以让我们在DexClassLoader在加载dex时过程变的很有效率，减少dex2oat编译的流程，要想实现art下的函数抽取技术，也是要阻断dex2oat的流程。当我们阻断了dex2oat会导致openDexFileNative中 oat_file 文件无法生成，在调用OatFileManager::OpenDexFilesFromOat中进入尝试判断原始dex文件oat_file_assistant.HasOriginalDexFiles()并通过DexFile::Open进行加载dex 123456789101112131415161718if (dex_files.empty()) &#123; if (oat_file_assistant.HasOriginalDexFiles()) &#123; if (Runtime::Current()-&gt;IsDexFileFallbackEnabled()) &#123; static constexpr bool kVerifyChecksum &#x3D; true; if (!DexFile::Open( dex_location, dex_location, kVerifyChecksum, &#x2F;*out*&#x2F; &amp;error_msg, &amp;dex_files)) &#123; LOG(WARNING) &lt;&lt; error_msg; error_msgs-&gt;push_back(&quot;Failed to open dex files from &quot; + std::string(dex_location) + &quot; because: &quot; + error_msg); &#125; &#125; else &#123; error_msgs-&gt;push_back(&quot;Fallback mode disabled, skipping dex files.&quot;); &#125; &#125; else &#123; error_msgs-&gt;push_back(&quot;No original dex files found for dex location &quot; + std::string(dex_location)); &#125;&#125; 进入DexFile::Open中可看到File fd = OpenAndReadMagic(filename, &amp;magic, error_msg);到此出现了第一个脱壳点OpenAndReadMagic，此时dex还未加载到内存当中。紧接着开始判断dex魔术头，并进入DexFile::OpenFile函数 12345678910111213if (IsDexMagic(magic)) &#123; std::unique_ptr&lt;const DexFile&gt; dex_file(DexFile::OpenFile(fd.Release(), &#x2F;&#x2F; 文件描述符，可以作为脱壳点 location, &#x2F;* verify *&#x2F; true, verify_checksum, error_msg)); if (dex_file.get() !&#x3D; nullptr) &#123; dex_files-&gt;push_back(std::move(dex_file)); return true; &#125; else &#123; return false; &#125;&#125; 进入DexFile::OpenFile函数发现通过MemMap::MapFile将dex进行了内存映射 12345678map.reset(MemMap::MapFile(length, PROT_READ, MAP_PRIVATE, fd, 0, &#x2F;*low_4gb*&#x2F;false, location.c_str(), error_msg)); 再进入OpenCommon函数中，参数中也包含了dex文件的映射区域的起始地址，出现了第二个脱壳点。 12345678std::unique_ptr&lt;DexFile&gt; dex_file &#x3D; OpenCommon(map-&gt;Begin(), map-&gt;Size(), location, dex_header-&gt;checksum_, kNoOatDexFile, verify, verify_checksum, error_msg); 跟进DexFile::OpenCommon中，发现其中调用了DexFile的构造函数 12345std::unique_ptr&lt;DexFile&gt; dex_file(new DexFile(base, size, location, location_checksum, oat_dex_file)); 至此出现了第三个脱壳点DexFile::DexFile 12345DexFile::DexFile(const uint8_t* base, size_t size, const std::string&amp; location, uint32_t location_checksum, const OatDexFile* oat_dex_file) 通用脱壳点： OpenAndReadMagic OpenCommon DexFile::DexFile 通过对比：InMemoryDexClassLoader和DexClassLoader的脱壳点，发现OpenCommon是两者通用脱壳点。 定制源码脱壳DexFile::OpenCommon修改/art/runtime/dex_file.cc中DexFile::OpenCommon方法 12345678910 int pid&#x3D;getpid(); char dexfilepath[100]&#x3D;&#123;0&#125;; sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_OpenCommon.dex&quot;,(int)size,pid); int fd&#x3D;open(dexfilepath,O_CREAT|O_RDWR,666); if (fd&gt;0)&#123;int number&#x3D;write(fd,base,size);if(number&gt;0)&#123;&#125;close(fd); &#125; DexFile::DexFile修改/art/runtime/dex_file.cc中DexFile::DexFile方法 12345678910 int pid&#x3D;getpid(); char dexfilepath[100]&#x3D;&#123;0&#125;; sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_DexFile.dex&quot;,(int)size,pid); int fd&#x3D;open(dexfilepath,O_CREAT|O_RDWR,666); if (fd&gt;0)&#123;int number&#x3D;write(fd,base,size);if(number&gt;0)&#123;&#125;close(fd); &#125; 编译1234~&#x2F;Android8.0&#x2F;android-8.0.0_r1$ source build&#x2F;envsetup.sh~&#x2F;Android8.0&#x2F;android-8.0.0_r1$ lunch23 选择aosp_sailfish-userdebug~&#x2F;Android8.0&#x2F;android-8.0.0_r1$ time make -j4 如果报错直接make单线程编译 生成路径~/Android8.0/android-8.0.0_r1/out/target/product/sailfish，将boot.img,ramdisk.img,system.img,system_other.img,userdata.img,vendor.img拷出来 123456fastboot flash boot boot.imgfastboot flash vendor vendor.imgfastboot flash system_a system.imgfastboot flash system_b system_other.imgfastboot flash userdata userdata.imgfastboot reboot 安装LoadDex.apk，并把ClassLoaderTest生成的classes.dex放入/sdcard。并在设置中授予该app读写sdcard的权限。在Activity启动的时候加载/sdcard的classes.dex的TestActivity并打印I&#39;m from TestActivity.onCreate，这就是一代壳的基本原理。 重启系统后/sdcard中已经出现一些系统中脱下的dex，启动LoadDex，grep -ril &quot;TestActivity&quot; ./*.dex 找到LoadDex中脱下的dex，DexClassLoader加载的插件dex已经被dump下来，gda可以看到优化后的odex的TestActivity中onCreate方法。 真实案例a.apk 《百度》加固 启动后进入/sdcard , grep -ril “SplashActivity” ./*.dex b.apk 《爱加密》企业版本加固 启动后进入/sdcard , grep -ril “mvp/ui/SplashActivity” ./*.dex，内容都为null，说明用了函数抽取，这就是需要fart解决的问题。 以上方案都是针对于没有dex2oat的情况，实际上对于一些壳没有禁用dex2oat的编译过程，且使用dexclassloader进行编译，最终会进入dex2oat流程，这个流程也是可以进行脱壳的。 ExecAndReturnCode中调用execve(program, &amp;args[0], envp);调用dex2oat二进制程序对dex的文件加载。,dex2oat流程也可以脱壳,main函数中调用了Dex2oat,int result = static_cast&lt;int&gt;(art::Dex2oat(argc, argv));,跟进Setup()方法最后会出现对要编译dex文件的处理，如下代码对当前要编译的文件进行遍历，逐个进行注册，这个地方可以完成dex的脱壳。CompileApp也出现了DexFile对象等等非常多的流程出现Dexfile对象，都可以成为脱壳点 除了对dex加载过程中还有其他脱壳点，比如对class进行load过程中，对art method的准备阶段，甚至每个函数的执行过程中都可以进行脱壳，这就是art下众多脱壳点的原因，因为非常多的流程都可以获取到dex文件的位置信息。 Dalvik下一代壳通用解决方案 ART下一代壳通用解决方案","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"Dalvik","slug":"Dalvik","permalink":"http://onejane.github.io/tags/Dalvik/"},{"name":"ART","slug":"ART","permalink":"http://onejane.github.io/tags/ART/"}]},{"title":"Socket&Websocket&Protobuf自吐通杀","slug":"Socket&Websocket&Protobuf自吐通杀","date":"2021-03-14T10:00:50.000Z","updated":"2021-03-27T03:42:32.300Z","comments":true,"path":"2021/03/14/Socket&Websocket&Protobuf自吐通杀/","link":"","permalink":"http://onejane.github.io/2021/03/14/Socket&Websocket&Protobuf%E8%87%AA%E5%90%90%E9%80%9A%E6%9D%80/","excerpt":"","text":"Socket所有的应用层都逃不掉底层用Socket来传输,只要掌握了Socket，对上层应用就是降维打击。 新建HttpSocket项目，并在AndroidManifest.xml配置网络权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true)&#123; newHttp(); try &#123; Thread.sleep(10*1000); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125; private static void newHttp()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; String url &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&quot;; URL urlConn &#x3D; new URL(url); HttpURLConnection connection &#x3D; (HttpURLConnection)urlConn.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.connect(); int responseCode &#x3D; connection.getResponseCode(); if (responseCode &#x3D;&#x3D; HttpURLConnection.HTTP_OK) &#123; InputStream inputStream &#x3D; connection.getInputStream(); String result &#x3D; is2String(inputStream); Log.d(&quot;onejane&quot;,&quot;result&#x3D;&#x3D;&#x3D;&#x3D;&quot;+result); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private static String is2String(InputStream inputStream) throws IOException &#123; byte[] buffer &#x3D; new byte[1024]; ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream(); for (int len &#x3D; 0; (len &#x3D; inputStream.read(buffer)) &gt; 0;) &#123; baos.write(buffer, 0, len); &#125; String result &#x3D; new String(baos.toByteArray(), &quot;utf-8&quot;); System.out.println(result); return result ; &#125;&#125; 关键类定位objection -g com.onejane.httpsocket explore android heap search instances java.net.Socket 查看堆内存中是否有该实例 android hooking search classes Socket 搜索与Socket相关的类 android hooking watch class java.net.Socket 默认hook类的所有方法没有构造函数 android hooking watch class_method java.net.Socket.$init –dump-args –dump-backtrace –dump-return 手动调用hook构造函数 vim ~/.pyenv/versions/3.8.0/lib/python3.8/site-packages/objection/agent.js 输入:9211跳转到9211行，加上.concat([“$init”])，会影响objection的稳定性 将与Socket相关的类添加前缀android hooking watch class存入socket.txt objection -g com.onejane.httpsocket explore -c ~/Desktop/socket.txt 批量hook，如果崩掉，需要将崩掉的类从文本中移除 okhttp底层走的socket android hooking watch class_method java.net.AbstractPlainSocketImpl.acquireFD --dump-args --dump-backtrace --dump-return 根据hook的结果拿到java.net.SocketOutputStream.write方法就是socket写入时调用的方法，针对该方法进行hook android hooking watch class_method java.net.SocketOutputStream.write --dump-args --dump-backtrace --dump-return SocketInputStream.read的hook结果复制到010Editor，搜索1f8b,删除前面所有字符，保存为gzip,解压查看结果就是百度网页结果 socket自吐实现http与https的socket自吐，修改url地址http://www.baidu.com/为https://www.baidu.com/, 有这两个自吐，可以通杀所有协议层的收发包内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function hook_socket()&#123; Java.perform(function()&#123; console.log(&quot;hook_socket;&quot;) Java.use(&quot;java.net.SocketOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTP write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; Java.use(&quot;java.net.SocketInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTP read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; &#125;)&#125;function hook_SSLsocketandroid8()&#123; Java.perform(function()&#123; console.log(&quot;hook_SSLsocket&quot;) Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTPS write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTPS read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; &#125;)&#125;function hook_SSLsocket2android10()&#123; Java.perform(function()&#123; console.log(&quot; hook_SSLsocket2&quot;) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_write.implementation &#x3D; function(long,NS,fd,NC,bytearray,int1,int2,int3)&#123; var result &#x3D; this .SSL_write(long,NS,fd,NC,bytearray,int1,int2,int3); console.log(&quot;SSL_write(long,NS,fd,NC,bytearray,int1,int2,int3),result&#x3D;&gt;&quot;,long,NS,fd,NC,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex()); return result; &#125; Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_read.implementation &#x3D; function(long,NS,fd,NC,bytearray,int1,int2,int3)&#123; var result &#x3D; this .SSL_read(long,NS,fd,NC,bytearray,int1,int2,int3); console.log(&quot;SSL_read(long,NS,fd,NC,bytearray,int1,int2,int3),result&#x3D;&gt;&quot;,long,NS,fd,NC,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex()); return result; &#125; &#125;)&#125;function main()&#123; console.log(&quot;Main&quot;) hook_socket(); hook_SSLsocketandroid8(); &#x2F;&#x2F;hook_SSLsocket2android10();&#125;setImmediate(main) frida -UF -l hookSocket.js 使用git clone https://github.com/peiniwan/Ganhuo.git 编译源码编译安装GanHuo.apk查看代码家栏,通过010Editor获取转换后的Unicode码，即为抓包结果 Websocket虚拟机网卡切换为桥接模式:192.168.0.104 server wget https://github.com/gotify/server/releases/download/v2.0.20/gotify-linux-amd64.zip unzip gotify-linux-amd64.zip chmod +x gotify-linux-amd64 ./gotify-linux-amd64 client adb install Gotify.apk 输入server地址http://192.168.0.104 admin/admin cli wget -O gotify https://github.com/gotify/cli/releases/download/v1.2.0/gotify-cli-linux-amd64 chmod +x gotify mv gotify /usr/bin/gotify gotify init gotify push -t “my title” -p 10 “my message” 服务器向手机发送消息 hook_okhttp3_logging添加十六进制转换，在控制台中以字符串显示 123456function jhexdump(array) &#123; var ptr &#x3D; Memory.alloc(array.length); for(var i &#x3D; 0; i &lt; array.length; ++i) Memory.writeS8(ptr.add(i), array[i]); console.log(hexdump(ptr, &#123; offset: 0, length: array.length, header: false, ansi: false &#125;));&#125; 使用console.log(jhexdump(bytearry))替换console.log(“bytearray contents=&gt;”, ByteString.of(bytearry).hex()) frida -UF -l hookSocket.js 使用socket自吐依旧可以通杀抓包 pm list packages|grep -i gotify 获取包名 frida -U -f com.github.gotify -l hookSocket.js –no-pause -o gotify.log objection -g com.github.gotify explore android hooking search classes websocket 查找内存中和websocket相关的类很少，可以通过android hooking watch class * ,存入websocket.txt文件批量hook 123objection -g com.github.gotify explore -c ~&#x2F;Desktop&#x2F;gotify&#x2F;websocket.txtplugin wallbreaker objectsearch com.github.gotify.client.model.Message 获取内存中的Message对象pluginwallbreaker objectdump --fullname 0x2576 获取该对象中字段在内存中的内容 android hooking search classes websocket 发现okhttp3.WebSocket,通过hook_okhttp3_logging脚本进行hook抓包frida -U -f com.github.gotify -l hookOkhttp3.js --no-pause，logcat|grep okhttpGET 查看可以抓到ok3的websocket包 android hooking search classes com.xabber.xmpp.smack 基于xmpp协议聊天软件xabber搜索包名并批量hook android hooking watch class_method java.lang.String.toString –dump-args -dump-backtrace –dump-return hookWebSocketvim hookWebSocket.js 综合基于hook和枚举的方式抓包websocket 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384function hook_okhttp3() &#123; &#x2F;&#x2F; 1. frida Hook java层的代码必须包裹在Java.perform中，Java.perform会将Hook Java相关API准备就绪。 Java.perform(function () &#123; Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;okhttp3logging.dex.dex&quot;).load(); &#x2F;&#x2F; 只修改了这一句，换句话说，只是使用不同的拦截器对象。 var MyInterceptor &#x3D; Java.use(&quot;com.roysue.octolesson2ok3.okhttp3Logging&quot;); var MyInterceptorObj &#x3D; MyInterceptor.$new(); var Builder &#x3D; Java.use(&quot;okhttp3.OkHttpClient$Builder&quot;); console.log(Builder); Builder.build.implementation &#x3D; function () &#123; this.networkInterceptors().add(MyInterceptorObj); console.log(&quot;hook Build.build successfully !&quot;) return this.build(); &#125;; console.log(&quot;hooking_okhttp3...&quot;); &#125;);&#125;function EnumerateClient()&#123; Java.perform(function()&#123; &#x2F;&#x2F;Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;r0gson.dex&quot;).load(); &#x2F;&#x2F;const gson &#x3D; Java.use(&#39;com.r0ysue.gson.Gson&#39;); var gson2 &#x3D; Java.use(&#39;com.google.gson.Gson&#39;); &#x2F;&#x2F; 加载包含CurlInterceptor拦截器的DEX Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;myok2curl.dex&quot;).load(); console.log(&quot;loading dex successful!&quot;) const curlInterceptor &#x3D; Java.use(&quot;com.moczul.ok2curl.CurlInterceptor&quot;); const loggable &#x3D; Java.use(&quot;com.moczul.ok2curl.logger.Loggable&quot;); var Log &#x3D; Java.use(&quot;android.util.Log&quot;); var TAG &#x3D; &quot;okhttpGETcurl&quot;; &#x2F;&#x2F;注册类————一个实现了所需接口的类 var MyLogClass &#x3D; Java.registerClass(&#123; name: &quot;okhttp3.MyLogClass&quot;, implements: [loggable], methods: &#123; log: function (MyMessage) &#123; Log.v(TAG, MyMessage); &#125;&#125; &#125;); const mylog &#x3D; MyLogClass.$new(); &#x2F;&#x2F; 得到所需拦截器对象 var curlInter &#x3D; curlInterceptor.$new(mylog); &#x2F;&#x2F; 加载包含logging-interceptor拦截器的DEX Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;okhttplogging.dex&quot;).load(); var MyInterceptor &#x3D; Java.use(&quot;com.r0ysue.learnokhttp.okhttp3Logging&quot;); var MyInterceptorObj &#x3D; MyInterceptor.$new(); Java.choose(&quot;okhttp3.OkHttpClient&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;1. found instance:&quot;,instance) console.log(&quot;2. instance.interceptors():&quot;,instance.interceptors().$className) console.log(&quot;3. instance._interceptors:&quot;,instance._interceptors.value.$className) &#x2F;&#x2F;console.log(&quot;4. interceptors:&quot;,gson2.$new().toJson(instance.interceptors())) console.log(&quot;5. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(instance.interceptors().toArray())) var newInter &#x3D; Java.use(&quot;java.util.ArrayList&quot;).$new(); newInter.addAll(instance.interceptors()); console.log(&quot;6. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(newInter.toArray())); console.log(&quot;7. interceptors:&quot;,newInter.$className); newInter.add(MyInterceptorObj); newInter.add(curlInter); instance._interceptors.value &#x3D; newInter; &#125;,onComplete:function()&#123; console.log(&quot;Search complete!&quot;) &#125; &#125;) &#125;)&#125;function main()&#123; hook_okhttp3(); EnumerateClient(); &#125;setImmediate(main) OkHttpLogger-Fridafrida -UF -l OkHttpLogger-Frida/okhttp_poker.js 抓包websocket Protobuf直播/弹幕协议Protobuf逆向分析，手把手教你使用ProtoBuf，通过gRPC服务在Android上进行网络请求 服务端192.168.0.102 官方教程 123456789101112131415161718192021systemctl stop firewalld.service systemctl disable firewalld.servicesetenforce 0/etc/selinux/config 修改为SELINUX=disabledtar -zxvf jdk-8u60-linux-x64.tar.gzmv jdk1.8.0_60/ /usr/local/tar -zxf apache-maven-3.6.3-bin.tar.gz -C /usr/local/vim /etc/profileJAVA_HOME=/usr/local/jdk1.8.0_60JRE_HOME=$JAVA_HOME/jreMAVEN_HOME=/usr/local/apache-maven-3.6.3PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin::$MAVEN_HOME/binCLASSPATH=:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/dt.jarexport JAVA_HOME JRE_HOME PATH CLASSPATH MAVEN_HOMEsource /etc/profilegit clone -b v1.36.1 https://github.com/grpc/grpc-javagit checkout -b v1.32.1 避免无法连接国外仓库ggcd grpc-java/examples./gradlew installDist./build/install/examples/bin/hello-world-server 启动server端口在50051./build/install/examples/bin/hello-world-client 通过HelloRequest发送Hello World 客户端192.168.0.104 git clone https://github.com/xuexiangjys/Protobuf-gRPC-Android.git ，其中helloworld.proto通过protoc编译生成HelloReply.java 手动编译，idea中安装GenProtobuf将binary进行encode和decode wget https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-linux-x86_64.zip unzip protoc-3.13.0-linux-x86_64.zip as-Tools-Configure GenProtobuf 右键hellooworld.proto点击quick gen protobuf here 实现手动编译，生成的编译代码使用了大量的google的protobuf基础库 安装启动Protobuf-gRPC-Android，保证服务端和客户端互相ping通，可以通过nc 192.168.0.102 50052 给服务端发送数据，服务端使用nc -l 50052接收，如果互通消息就可以收到，否则使用NPS将服务端的50051端口服务映射到指定服务器ip的指定端口(需要在服务端安装nps客户端，在nps服务端配置该nps客户端)。 如果没有响应，ps -ef|grep protobuf 获取到进程id后，logcat|grep -i 22916 查看log，退出重进gRPC-普通请求按钮，输入服务端ip，端口及内容发送请求。 1234567adb shellps -ef|grep protobuf 获取包名.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64 启动frida serverpyenv local 3.8.0objection -g com.xuexiang.protobufdemo exploreandroid hooking search classes protobuf 将打印出的类前面加上android hooking watch class,存入hook_list.txtobjection -g com.xuexiang.protobufdemo explore -c &#x2F;root&#x2F;Desktop&#x2F;hook_list.txt 实现批量hook，点击发送请求，从请求找寻找调用到的protobuf类相关方法 关注打印出来的几个函数： com.google.protobuf.WireFormat.makeTagcom.google.protobuf.CodedOutputStream$OutputStreamEncoder.write([B, int, int)com.google.protobuf.CodedInputStream.readTag()com.google.protobuf.WireFormat.getTagFieldNumber(int)com.google.protobuf.Utf8.encode(java.lang.CharSequence, [B, int, int)com.google.protobuf.CodedInputStream.newInstance([B, int, int, boolean) 1android hooking watch class_method com.google.protobuf.Utf8.encode --dump-args --dump-backtrace --dump-return 同理，makeTag的调用栈也是从用户代码中的writeTo调用而来。 frida -UF -l hookSocket.js -o protobuf.txt 通杀自吐打印出protubuf的包数据 12plugin wallbreaker objectsearch com.xuexiang.protobufdemo.HelloReplyplugin wallbreaker objectdump --fullname 0x22ea 内存漫游的源码 Protobuf协议逆向和仿真&amp;举个栗子 抓包+逆向app分析protobuf -Protobuf协议解析文档-某音弹幕","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"Socket","slug":"Socket","permalink":"http://onejane.github.io/tags/Socket/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://onejane.github.io/tags/WebSocket/"},{"name":"Protobuf","slug":"Protobuf","permalink":"http://onejane.github.io/tags/Protobuf/"},{"name":"XMPP","slug":"XMPP","permalink":"http://onejane.github.io/tags/XMPP/"}]},{"title":"Spring-Cloud-Alibaba","slug":"Spring-Cloud-Alibaba","date":"2021-03-11T08:03:07.000Z","updated":"2021-03-16T13:56:30.893Z","comments":true,"path":"2021/03/11/Spring-Cloud-Alibaba/","link":"","permalink":"http://onejane.github.io/2021/03/11/Spring-Cloud-Alibaba/","excerpt":"","text":"SpringCloudAlibabaSpring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。 依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。 Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。 Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。 Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。 Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。 Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 虚拟机安装virtualbox 6 vagrant安装好后进入镜像仓库搜索需要安装的镜像 mkdir centos7 &amp;&amp; vagrant init centos/7 &amp;&amp; vagrant up &amp;&amp; vagrant ssh 创建并开启镜像，修改网络桥接 如果太慢，进入centos/7仓库下载，手动加载vagrant box add centos/7 CentOS-7-x86_64-Vagrant-2004_01.VirtualBox.box vim Vagrantfile 修改配置并重启vagrant reload，保存虚拟机与主机可ping通，sudo passwd root 设置root权限 12# config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot; host-onlyconfig.vm.network &quot;public_network&quot; 桥接 安装nodejs并配置淘宝源npm config set registry http://registry.npm.taobao.org/ 安装docker 1234567891011121314151617sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-enginesudo yum install -y yum-utilssudo yum-config-manager \\ --add-repo \\ https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.reposudo yum install -y docker-ce docker-ce-cli containerd.ioyum list docker-ce --showduplicates | sort -rsudo systemctl start dockersudo docker imagessudo systemctl enable docker 镜像加速器 12345678sudo mkdir -p &#x2F;etc&#x2F;dockersudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;3gki6pei.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker mysql 12345678910docker run -p 3306:3306 --name mysql \\-v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysal \\-v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql \\-e MYSQL_ROOT_PASSWORD&#x3D;root \\-d mysql:5.7docker exec -it mysql &#x2F;bin&#x2F;bashmysql -uroot -prootuse mysql;alter user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;root&#39;;flush privileges; vi /mydata/mysql/conf/my.cnf 修改编码配置 1234567891011[client]default-character-set&#x3D;utf8[mysql]default-character-set&#x3D;utf8[mysqld]init_connect&#x3D;&#39;SET collation_connection &#x3D; utf8_unicode_ci&#39;init_connect&#x3D;&#39;SET NAMES utf8&#39;character-set-server&#x3D;utf8collation-server&#x3D;utf8_unicode_ciskip-character-set-client-handshakeskip-name-resolve docker restart mysql &amp;&amp; cat /etc/mysql/my.cnf &amp;&amp; docker update mysql –restart=always redis vi /mydata/redis/conf/redis.conf 配置appendonly yes持久化硬盘 12345docker run -p 6379:6379 --name redis -v &#x2F;mydata&#x2F;redis&#x2F;data:&#x2F;data \\-v &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf \\-d redis:3.2 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf --appendonly yesdocker exec -it redis redis-clidocker update redis --restart&#x3D;always maven 123456789101112131415161718&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt; &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt;&lt;&#x2F;mirror&gt; &lt;profile&gt; &lt;id&gt;jdk18&lt;&#x2F;id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt; &lt;jdk&gt;1.8&lt;&#x2F;jdk&gt; &lt;&#x2F;activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;&#x2F;maven.compiler.compilerVersion&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;profile&gt; idea安装lombok，mybatisX插件 vscode安装Auto Close Tag,Auto Rename Tag,Chinese,Eslint,HTML CSS Support,HTML Snippets,JavaScript(ES6),Live Server,open in browser,Vetur,Vue 2 Snippets插件 git配置 12345git config --global user.name &quot;username&quot; &#x2F;&#x2F;（名字） # 配置邮箱git config --global user.email &quot;username@email.com&quot; &#x2F;&#x2F;(注册账号时用的邮箱)ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; 进入git bash生成公私钥cat ~&#x2F;.ssh&#x2F;id_rsa.pubssh -T git@gitee.com 测试是否成功即可 Nacos注册中心新建Spring Initializr作为provider项目jdk1.8并导入Web中的Spring Web和Spring Cloud Routing的OpenFeign组件，设置-Xmx100m 启动Application使用最大内存 启动nacos-server-1.3.1.zip访问nacos 修改依赖如下 123456789101112131415161718192021222324252627282930313233343536373839&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;&#x2F;spring-cloud.version&gt; &lt;spring-cloud-alibaba.version&gt;2.1.0.RELEASE&lt;&#x2F;spring-cloud-alibaba.version&gt;&lt;&#x2F;properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt; 添加application.yml配置 123456789spring: application: name: provider cloud: nacos: discovery: server-addr: 127.0.0.1:8848server: port: 8000 ProviderApplication启动类添加@EnableDiscoveryClient,启动后在nacos控制台查看已经上线的服务 Nacos配置中心默认配置读取application.properties添加配置 12user.name&#x3D;onejaneuser.age&#x3D;20 Controller实现读取 123456789101112@RestController@RequestMapping(&quot;test&quot;)public class UserController &#123; @Value(&quot;$&#123;user.name&#125;&quot;) private String name; @Value(&quot;$&#123;user.age&#125;&quot;) private Integer age; @RequestMapping(&quot;&#x2F;user&quot;) public void test()&#123; System.out.println(name+&quot;:&quot;+age); &#125;&#125; Nacos配置项目添加config依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; Provider项目创建bootstrap.properties 12spring.application.name&#x3D;providerspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848 Nacos中配置provider.properties，默认规则，取public命名空间的应用名.properties，类型为Properties，相同与application.properties时优先使用配置中心的配置。 12user.name&#x3D;onejane1user.age&#x3D;23 多环境配置配置命名空间provider，命名空间ID为f7d49148-09a8-4ca1-8a40-c52e9cb627b5，在该命名空间下配置provider.properties，Group为prod 12user.name&#x3D;onejane2user.age&#x3D;23 配置bootstrap.properties 1234spring.application.name&#x3D;providerspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848spring.cloud.nacos.config.namespace&#x3D;f7d49148-09a8-4ca1-8a40-c52e9cb627b5spring.cloud.nacos.config.group&#x3D;prod 命名空间，用于配置隔离，默认新增的所有配置都在public空间。 1、开发，测试，生产：利用命名空间来做环境隔离。在bootstrap.properties；配置spring.cloud.nacos.config.namespace需要使用哪个命名空间下的配置 2、每一个微服务之间互相隔离配置，每一个微服务都创建自己的命名空间，只加载自己命名空间下的所有配置 每个微服务创建自己的命名空间，使用配置分组区分环境，dev，test，prod 多文件配置在Nacos中provider微服务命名空间配置datasource.yml 123456spring: datasource: username: root password: root url: jdbc:mysql:&#x2F;&#x2F;172.20.1.185:3306&#x2F;user driver-class-name: com.mysql.jdbc.Driver 配置mybatis.yml 12345mybatis-plus: mapper-locations: classpath:&#x2F;mapper&#x2F;**&#x2F;*.xml global-config: db-config: id-type: auto 配置service.yml 123456789spring: application: name: provider cloud: nacos: discovery: server-addr: 127.0.0.1:8848 server: port: 7000 注释application.yml中所有配置并在bootstrap.properties中实现多文件配置 1234567891011121314151617spring.application.name&#x3D;providerspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848spring.cloud.nacos.config.namespace&#x3D;f7d49148-09a8-4ca1-8a40-c52e9cb627b5spring.cloud.nacos.config.group&#x3D;prodspring.cloud.nacos.config.ext-config[0].data-id&#x3D;datasource.ymlspring.cloud.nacos.config.ext-config[0].group&#x3D;devspring.cloud.nacos.config.ext-config[0].refresh&#x3D;truespring.cloud.nacos.config.ext-config[1].data-id&#x3D;mybatis.ymlspring.cloud.nacos.config.ext-config[1].group&#x3D;devspring.cloud.nacos.config.ext-config[1].refresh&#x3D;truespring.cloud.nacos.config.ext-config[2].data-id&#x3D;other.ymlspring.cloud.nacos.config.ext-config[2].group&#x3D;devspring.cloud.nacos.config.ext-config[2].refresh&#x3D;true Mybatis-Plus持久化引入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;3.2.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.17&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;version&gt;1.18.8&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 配置数据源 123456789101112131415spring: datasource: username: root password: root url: jdbc:mysql:&#x2F;&#x2F;172.20.1.185:3306&#x2F;user driver-class-name: com.mysql.jdbc.Driver jackson: date-format: yyyy-MM-dd HH:mm:ss # 输出日期自动转换mybatis-plus: mapper-locations: classpath:&#x2F;mapper&#x2F;**&#x2F;*.xml global-config: db-config: id-type: auto logic-delete-value: 1 # 逻辑删除 logic-not-delete-value: 0 配置扫描包 1@MapperScan(&quot;com.onejane.demo.provider.dao&quot;) 添加实体类 123456789101112131415@Data@TableName(&quot;user_info&quot;)public class UserInfoEntity implements Serializable &#123; private static final long serialVersionUID &#x3D; 1L; @TableId private Long id; private String name; private Long age; &#x2F;** * 是否显示[0-不显示，1显示] 用于逻辑删除 *&#x2F; @TableLogic(value &#x3D; &quot;1&quot;,delval &#x3D; &quot;0&quot;) private Integer status;&#125; 逻辑删除实现 1234567@AutowiredUserInfoSerivce userInfoSerivce;@RequestMapping(&quot;&#x2F;delete&quot;)public R delete(Long[] ids)&#123; userInfoSerivce.removeByIds(Arrays.asList(ids)); return R.ok();&#125; 分页查询实现 1234567891011121314151617181920public interface UserInfoSerivce extends IService&lt;UserInfoEntity&gt; &#123; PageUtils queryPage(Map&lt;String, Object&gt; params);&#125;@Service(&quot;userInfoService&quot;)public class UserInfoServiceImpl extends ServiceImpl&lt;UserInfoDao, UserInfoEntity&gt; implements UserInfoSerivce &#123; @Override public PageUtils queryPage(Map&lt;String, Object&gt; params) &#123; IPage&lt;UserInfoEntity&gt; page &#x3D; this.page( new Query&lt;UserInfoEntity&gt;().getPage(params), new QueryWrapper&lt;UserInfoEntity&gt;() ); return new PageUtils(page); &#125;&#125;@RequestMapping(&quot;&#x2F;list&quot;)public R list(@RequestParam Map&lt;String, Object&gt; params)&#123; PageUtils page &#x3D; userInfoSerivce.queryPage(params); return R.ok().put(&quot;page&quot;, page);&#125; 分页配置 12345678910111213141516@Configuration@EnableTransactionManagement &#x2F;&#x2F;开启事务@MapperScan(&quot;com.onejane.demo.provider.dao&quot;)public class MyBatisConfig &#123; &#x2F;&#x2F;引入分页插件 @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor paginationInterceptor &#x3D; new PaginationInterceptor(); &#x2F;&#x2F; 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false paginationInterceptor.setOverflow(true); &#x2F;&#x2F; 设置最大单页限制数量，默认 500 条，-1 不受限制 paginationInterceptor.setLimit(1000); return paginationInterceptor; &#125;&#125; Feign远程调用新建Spring Initializr作为consumer项目jdk1.8并导入Web中的Spring Web和Spring Cloud Routing的OpenFeign组件，设置-Xmx100m 启动Application使用最大内存 provider提供api，启动类配置@EnableDiscoveryClient后启动应用 consumer中引入nacos依赖 123456789101112131415161718192021222324252627282930313233&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;&#x2F;spring-cloud.version&gt; &lt;spring-cloud-alibaba.version&gt;2.1.0.RELEASE&lt;&#x2F;spring-cloud-alibaba.version&gt;&lt;&#x2F;properties&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt; Member作为consumer获取feign调用，定义feign方法 1234567@FeignClient(&quot;provider&quot;)public interface ProviderFeignService &#123; @RequestMapping(&quot;&#x2F;test&#x2F;list&quot;) public void test();&#125; consumer在控制器中申请远程调用，并在启动类中开启feign调用@EnableFeignClients(basePackages = &quot;com.onejane.demo.consumer.feign&quot;)并将consumer加入nacos注册中心@EnableDiscoveryClient 12345@FeignClient(&quot;provider&quot;)public interface ProviderFeignService &#123; @RequestMapping(&quot;&#x2F;test&#x2F;user&quot;) public void test();&#125; 在application.yml中配置nacos 123456789spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 application: name: consumerserver: port: 7000 开启feign远程调用 12345678910@RestController@RequestMapping(&quot;test&quot;)public class UserInfoController &#123; @Autowired ProviderFeignService providerFeignService; @RequestMapping(&quot;&#x2F;user&quot;) public void test()&#123; providerFeignService.test(); &#125;&#125; Gateway网关修改provider项目新增server.servlet.context-path: /provider 新建Spring Initializr作为网关项目项目jdk1.8并导入Spring Cloud Routing的Gateway组件 pom依赖修改 12345678910&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;&#x2F;spring-cloud.version&gt;&lt;&#x2F;properties&gt; application.properties添加配置 123spring.cloud.nacos.discovery.server-addr&#x3D;127.0.0.1:8848spring.application.name&#x3D;gatewayserver.port&#x3D;88 在nacos中配置微服务命名空间gateway,ID为7601cb5a-a9dd-43d8-a1b9-a37952674df2，添加配置文件gateway.yml 123spring: application: name: gateway bootstrap.properties配置命名空间 123spring.application.name&#x3D;gatewayspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848spring.cloud.nacos.config.namespace&#x3D;7601cb5a-a9dd-43d8-a1b9-a37952674df2 application.yml中添加网关配置，访问http://localhost:88/?url=qq 则跳转到https://www.qq.com?url=qq， 访问http://localhost:88/?url=baidu 则跳转到https://www.baidu.com?url=baidu 123456789101112131415161718192021222324spring: cloud: gateway: routes: - id: test_route uri: https:&#x2F;&#x2F;www.baidu.com predicates: - Query&#x3D;url,baidu - id: qq_route uri: https:&#x2F;&#x2F;www.qq.com predicates: - Query&#x3D;url,qq - id: provider_route uri: lb:&#x2F;&#x2F;provider predicates: - Path&#x3D;&#x2F;api&#x2F;provider&#x2F;** filters: - RewritePath&#x3D;&#x2F;api&#x2F;(?&lt;segment&gt;.*),&#x2F;$\\&#123;segment&#125; application: name: gateway# http:&#x2F;&#x2F;localhost:88&#x2F;api&#x2F;provider&#x2F;test&#x2F;user &#x3D;&#x3D;&gt; http:&#x2F;&#x2F;localhost:8000&#x2F;provider&#x2F;test&#x2F;user 在启动类中配置@EnableDiscoveryClient，并过滤掉数据库配置@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) 跨域12345678910111213141516171819@Configurationpublic class GulimallCorsConfiguration &#123; @Bean public CorsWebFilter corsWebFilter()&#123; UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource(); CorsConfiguration corsConfiguration &#x3D; new CorsConfiguration(); &#x2F;&#x2F;1、配置跨域 corsConfiguration.addAllowedHeader(&quot;*&quot;); corsConfiguration.addAllowedMethod(&quot;*&quot;); corsConfiguration.addAllowedOrigin(&quot;*&quot;); corsConfiguration.setAllowCredentials(true); source.registerCorsConfiguration(&quot;&#x2F;**&quot;,corsConfiguration); return new CorsWebFilter(source); &#125;&#125; 阿里云oss引入阿里云oss依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alicloud-oss&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; application.yml配置阿里云AccessKey 12345678spring: cloud: alicloud: access-key: *** secret-key: *** oss: endpoint: oss-cn-beijing.aliyuncs.com bucket: onejane-opencv 上传图片一般先通过服务端签名后前端直传 JSR303通过自定义校验，分组校验及全局校验实现对Spring MVC入参的参数校验。 加入validation依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;&#x2F;groupId&gt; &lt;artifactId&gt;validation-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0.1.Final&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 加入校验注解 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;** * 品牌id *&#x2F;@NotNull(message &#x3D; &quot;修改必须指定品牌id&quot;,groups &#x3D; &#123;UpdateGroup.class&#125;)@Null(message &#x3D; &quot;新增不能指定id&quot;,groups &#x3D; &#123;AddGroup.class&#125;)@TableIdprivate Long brandId;&#x2F;** * 品牌名 *&#x2F;@NotBlank(message &#x3D; &quot;品牌名必须提交&quot;,groups &#x3D; &#123;AddGroup.class,UpdateGroup.class&#125;)private String name;&#x2F;** * 品牌logo地址 *&#x2F;@NotBlank(groups &#x3D; &#123;AddGroup.class&#125;)@URL(message &#x3D; &quot;logo必须是一个合法的url地址&quot;,groups&#x3D;&#123;AddGroup.class,UpdateGroup.class&#125;)private String logo;&#x2F;** * 介绍 *&#x2F;private String descript;&#x2F;** * 显示状态[0-不显示；1-显示] *&#x2F;@NotNull(groups &#x3D; &#123;AddGroup.class, UpdateStatusGroup.class&#125;)@ListValue(vals&#x3D;&#123;0,1&#125;,groups &#x3D; &#123;AddGroup.class, UpdateStatusGroup.class&#125;)private Integer showStatus;&#x2F;** * 检索首字母 *&#x2F;@NotEmpty(groups&#x3D;&#123;AddGroup.class&#125;)@Pattern(regexp&#x3D;&quot;^[a-zA-Z]$&quot;,message &#x3D; &quot;检索首字母必须是一个字母&quot;,groups&#x3D;&#123;AddGroup.class, UpdateGroup.class&#125;)private String firstLetter;&#x2F;** * 排序 *&#x2F;@NotNull(groups&#x3D;&#123;AddGroup.class&#125;)@Min(value &#x3D; 0,message &#x3D; &quot;排序必须大于等于0&quot;,groups&#x3D;&#123;AddGroup.class,UpdateGroup.class&#125;)private Integer sort; 建立分组校验类 123public interface AddGroup &#123;&#125;public interface UpdateGroup &#123;&#125;public interface UpdateStatusGroup &#123;&#125; 自定义异常注解 12345678910111213@Documented@Constraint(validatedBy &#x3D; &#123; ListValueConstraintValidator.class &#125;)@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)@Retention(RUNTIME)public @interface ListValue &#123; String message() default &quot;&#123;com.onejane.demo.provider.valid.ListValue.message&#125;&quot;; Class&lt;?&gt;[] groups() default &#123; &#125;; Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;; int[] vals() default &#123; &#125;;&#125; 自定义异常实现 12345678910111213141516171819202122232425262728public class ListValueConstraintValidator implements ConstraintValidator&lt;ListValue,Integer&gt; &#123; private Set&lt;Integer&gt; set &#x3D; new HashSet&lt;&gt;(); &#x2F;&#x2F;初始化方法 @Override public void initialize(ListValue constraintAnnotation) &#123; int[] vals &#x3D; constraintAnnotation.vals(); for (int val : vals) &#123; set.add(val); &#125; &#125; &#x2F;&#x2F;判断是否校验成功 &#x2F;** * * @param value 需要校验的值 * @param context * @return *&#x2F; @Override public boolean isValid(Integer value, ConstraintValidatorContext context) &#123; return set.contains(value); &#125;&#125; 控制器层加入字段校验配置 12345678910111213141516171819202122232425262728293031323334353637@RequestMapping(&quot;&#x2F;save&quot;)public R save(@Validated(&#123;AddGroup.class&#125;) @RequestBody BrandEntity brand&#x2F;*,BindingResult result*&#x2F;)&#123;&#x2F;&#x2F; if(result.hasErrors())&#123;&#x2F;&#x2F; Map&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F; &#x2F;&#x2F;1、获取校验的错误结果&#x2F;&#x2F; result.getFieldErrors().forEach((item)-&gt;&#123;&#x2F;&#x2F; &#x2F;&#x2F;FieldError 获取到错误提示&#x2F;&#x2F; String message &#x3D; item.getDefaultMessage();&#x2F;&#x2F; &#x2F;&#x2F;获取错误的属性的名字&#x2F;&#x2F; String field &#x3D; item.getField();&#x2F;&#x2F; map.put(field,message);&#x2F;&#x2F; &#125;);&#x2F;&#x2F;&#x2F;&#x2F; return R.error(400,&quot;提交的数据不合法&quot;).put(&quot;data&quot;,map);&#x2F;&#x2F; &#125;else &#123;&#x2F;&#x2F; 为避免每次请求都判断异常输出，通过ExceptionControllerAdvice实现全局异常控制 brandService.save(brand); return R.ok();&#125;&#x2F;** * 修改 *&#x2F;@RequestMapping(&quot;&#x2F;update&quot;)public R update(@Validated(UpdateGroup.class) @RequestBody BrandEntity brand)&#123; brandService.updateById(brand); return R.ok();&#125;&#x2F;** * 修改状态 *&#x2F;@RequestMapping(&quot;&#x2F;update&#x2F;status&quot;)public R updateStatus(@Validated(UpdateStatusGroup.class) @RequestBody BrandEntity brand)&#123; brandService.updateById(brand); return R.ok();&#125; 全局异常控制配置 123456789101112131415161718192021222324252627@Slf4j&#x2F;&#x2F;@ResponseBody&#x2F;&#x2F;@ControllerAdvice(basePackages &#x3D; &quot;com.onejane.demo.provider.controller&quot;)@RestControllerAdvice(basePackages &#x3D; &quot;com.onejane.demo.provider.controller&quot;)public class ExceptionControllerAdvice &#123; @ExceptionHandler(value&#x3D; MethodArgumentNotValidException.class) public R handleVaildException(MethodArgumentNotValidException e)&#123; log.error(&quot;数据校验出现问题&#123;&#125;，异常类型：&#123;&#125;&quot;,e.getMessage(),e.getClass()); BindingResult bindingResult &#x3D; e.getBindingResult(); Map&lt;String,String&gt; errorMap &#x3D; new HashMap&lt;&gt;(); bindingResult.getFieldErrors().forEach((fieldError)-&gt;&#123; errorMap.put(fieldError.getField(),fieldError.getDefaultMessage()); &#125;); return R.error(BizCodeEnume.VAILD_EXCEPTION.getCode(),BizCodeEnume.VAILD_EXCEPTION.getMsg()).put(&quot;data&quot;,errorMap); &#125; @ExceptionHandler(value &#x3D; Throwable.class) public R handleException(Throwable throwable)&#123; log.error(&quot;错误：&quot;,throwable); return R.error(BizCodeEnume.UNKNOW_EXCEPTION.getCode(),BizCodeEnume.UNKNOW_EXCEPTION.getMsg()); &#125;&#125;","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"nacos","slug":"nacos","permalink":"http://onejane.github.io/tags/nacos/"},{"name":"feign","slug":"feign","permalink":"http://onejane.github.io/tags/feign/"},{"name":"gateway","slug":"gateway","permalink":"http://onejane.github.io/tags/gateway/"},{"name":"sentinel","slug":"sentinel","permalink":"http://onejane.github.io/tags/sentinel/"}]},{"title":"HttpURLConnection&OK3&Retrofit自吐通杀","slug":"HttpURLConnection&OK3&Retrofit自吐通杀","date":"2021-03-01T17:28:26.000Z","updated":"2021-03-14T06:36:19.311Z","comments":true,"path":"2021/03/02/HttpURLConnection&OK3&Retrofit自吐通杀/","link":"","permalink":"http://onejane.github.io/2021/03/02/HttpURLConnection&OK3&Retrofit%E8%87%AA%E5%90%90%E9%80%9A%E6%9D%80/","excerpt":"","text":"HttpURLConnectionadb install -r -t network-debug.apk 启动frida 12adb shell .&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64 内存漫游 123456pyenv local 3.8.0objection -g com.example.network explore -P ~&#x2F;.objection&#x2F;pluginsandroid hooking list classes 查看所有可hook的类android hooking search classes URLandroid hooking watch class java.net.URL 由于hookURL类遗漏构造函数需要手动hook $initandroid hooking watch class_method java.net.URL.$init --dump-args --dump-backtrace --dump-return hook构造函数并打印 点击HTTP图片获取按钮，实现自吐第一步，并拿到上层实现类HttpURLConnectionImpl 123android hooking search classes HttpURLConnectionImplandroid hooking watch class com.android.okhttp.internal.huc.HttpURLConnectionImpl hook类所有方法并打印方法android hooking watch class_method com.android.okhttp.internal.huc.HttpURLConnectionImpl.setRequestProperty --dump-args --dump-backtrace --dump-return hook类指定方法并打印出入参及调用栈 点击HTTP图片获取按钮，实现自吐第二步 plugin wallbreaker objectsearch com.android.okhttp.internal.huc.HttpURLConnectionImpl 存在多个实例说明每次点击生成新的对象且不释放 plugin wallbreaker objectdump –fullname 0x2972 打印其中一个对象在内存中的结构 android heap search instances com.android.okhttp.internal.huc.HttpURLConnectionImpl 获取内存中的实例地址 android heap execute 0x21e6 defaultUserAgent 手动调用defaultUserAgent 自吐frida -U -f com.cz.babySister -l hook_HttpUrlConnection.js --no-pause 12345678910111213141516171819202122232425262728function hook_HttpUrlConnection()&#123; Java.perform(function()&#123; &#x2F;&#x2F; java.net.URL.URL ($init) (得到URL) Java.use(&quot;java.net.URL&quot;).$init.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (str)&#123; var result &#x3D; this.$init(str) console.log(&quot;result , str &#x3D;&gt; &quot;,result,str); return result; &#125; &#x2F;&#x2F;HttpURLConnection setRequestProperty 得到各种请求头、属性等，不能hook抽象类HttpURLConnection，只能hook抽象类的实现类HttpURLConnectionImpl Java.use(&quot;com.android.okhttp.internal.huc.HttpURLConnectionImpl&quot;).setRequestProperty.implementation &#x3D; function(str1,str2)&#123; var result &#x3D; this.setRequestProperty(str1,str2); console.log(&quot;.setRequestProperty result,str1,str2-&gt;&quot;,result,str1,str2); return result; &#125; Java.use(&quot;com.android.okhttp.internal.huc.HttpURLConnectionImpl&quot;).setRequestMethod.implementation &#x3D; function(str1)&#123; var result &#x3D; this.setRequestMethod(str1); console.log(&quot;.setRequestMethod result,str1,str2-&gt;&quot;,result,str1); return result; &#125; &#125;)&#125;setImmediate(hook_HttpUrlConnection) OkHttp3搭建抓包环境默认创建Okhttp框架帮我们默认所有配置，因此无法自定义添加用户拦截器。 as新建Ok3Demo项目，创建页面button布局 12345678910111213141516171819&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot; android:gravity&#x3D;&quot;center|center_horizontal|center_vertical&quot; tools:context&#x3D;&quot;.MainActivity&quot;&gt; &lt;Button android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:gravity&#x3D;&quot;center|center_horizontal|center_vertical&quot; android:id&#x3D;&quot;@+id&#x2F;mybtn&quot; android:text&#x3D;&quot;发送请求&quot; android:textSize&#x3D;&quot;45sp&quot;&gt; &lt;&#x2F;Button&gt;&lt;&#x2F;LinearLayout&gt; build.gradle引入ok3依赖 12&#x2F;&#x2F; 增加对Okhttp3的依赖implementation(&quot;com.squareup.okhttp3:okhttp:3.12.0&quot;) AndroidManifest.xml配置网络权限 12&lt;!-- 申请网络请求权限 --&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt; 创建异步请求线程，在RealCall.newRealCall()中，创建了一个新的RealCall对象，RealCall对象是Okhttp3.Call接口的一个实现，也是Okhttp3中Call的唯一实现。它表示一个等待执行的请求，它只能被执行一次，但实际上，到这一步，请求依然可以被取消。因此只有Hook 了execute()和enqueue(new Callback())才能真正保证每个从Okhttp出去的请求都能被Hook到 1234567891011121314151617181920212223242526272829303132public class example &#123; &#x2F;&#x2F; TAG即为日志打印时的标签 private static String TAG &#x3D; &quot;learnokhttp&quot;; &#x2F;&#x2F; 新建一个Okhttp客户端 OkHttpClient client &#x3D; new OkHttpClient(); void run(String url) throws IOException &#123; &#x2F;&#x2F; 构造request Request request &#x3D; new Request.Builder() .url(url) .build(); &#x2F;&#x2F; 发起异步请求 client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; call.cancel(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#x2F;&#x2F;打印输出 Log.d(TAG, response.body().string()); &#125; &#125; ); &#125;&#125; MainActivity中调用网络请求线程 12345678910111213141516171819202122232425262728public class MainActivity extends AppCompatActivity &#123; private static String TAG &#x3D; &quot;learnokhttp&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#x2F;&#x2F; 定位发送请求按钮 Button btn &#x3D; findViewById(R.id.mybtn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#x2F;&#x2F; 访问百度首页 String requestUrl &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;; example myexample &#x3D; new example(); try &#123; myexample.run(requestUrl); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 建造者(Builder)模式新建LoggingInterceptor类，实现Interceptor接口，这代表它是一个拦截器，接下来实现intercept方法，我们的拦截器会打印URL和请求headers 123456789101112131415class LoggingInterceptor implements Interceptor &#123; &#x2F;&#x2F; TAG即为日志打印时的标签 private static String TAG &#x3D; &quot;learnokhttp&quot;; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Request request &#x3D; chain.request(); Log.i(TAG, &quot;请求URL：&quot;+String.valueOf(request.url())+&quot;\\n&quot;); Log.i(TAG, &quot;请求headers：&quot;+&quot;\\n&quot;+String.valueOf(request.headers())+&quot;\\n&quot;); Response response &#x3D; chain.proceed(request); return response; &#125;&#125; 拦截器是Okhttp中重要的一个概念，Okhttp通过Interceptor来完成监控管理、重写和重试请求。Okhttp本身存在五大拦截器，每个网络请求，不管是GET还是PUT/POST或者其他，都必须经过这五大拦截器。拦截器可以对request做出一定修改，同时对返回的Response做出一定修改，因此Interceptor是一个绝佳的Hook点，可以同时打印输出请求和相应。 自定义配置所有参数 1234567&#x2F;&#x2F; 此为原先的clientOkHttpClient client &#x3D; new OkHttpClient();&#x2F;&#x2F; 基于原先的client创建新的clientOkHttpClient newClient &#x3D; client.newBuilder() .addNetworkInterceptor(new LoggingInterceptor()) .build(); 将example中代码转移到MainActivity中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MainActivity extends AppCompatActivity &#123; private static String TAG &#x3D; &quot;learnokhttp&quot;; public static final String requestUrl &#x3D; &quot;http:&#x2F;&#x2F;www.kuaidi100.com&#x2F;query?type&#x3D;yuantong&amp;postid&#x3D;11111111111&quot;; &#x2F;&#x2F; 全局只使用这一个拦截器 public static final OkHttpClient client &#x3D; new OkHttpClient.Builder() .addNetworkInterceptor(new LoggingInterceptor()) .build(); Request request &#x3D; new Request.Builder() .url(requestUrl) .build(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#x2F;&#x2F; 定位发送请求按钮 Button btn &#x3D; findViewById(R.id.mybtn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#x2F;&#x2F; 发起异步请求 client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; call.cancel(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#x2F;&#x2F;打印输出 Log.d(TAG, response.body().string()); &#125; &#125; ); &#125; &#125;); &#125;&#125; hookadb shell &amp;&amp; ./data/local/tmp/fs128arm64 启动frida pyenv local 3.8.0 切换python环境 objection -g com.onejane.ok3demo explore -P ~/.objection/plugins 加载所有插件，点击发送请求并开启内存漫游 12345plugin wallbreaker classsearch OkHttpClient 内存搜索OkHttpClient类plugin wallbreaker classdump --fullname okhttp3.OkHttpClient 打印该类结构plugin wallbreaker objectsearch okhttp3.OkHttpClient 获取该类的内存地址plugin wallbreaker objectdump --fullname 0x2592 打印内存中该地址的类结构plugin wallbreaker objectsearch okhttp3.OkHttpClient 内存中存在多个OkHttpClient,默认不回收对象实例 okhttp3Logging新增okhttp3Logging类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171public final class okhttp3Logging implements Interceptor &#123; private static final String TAG &#x3D; &quot;okhttpGET&quot;; private static final Charset UTF8 &#x3D; Charset.forName(&quot;UTF-8&quot;); @Override public Response intercept(Chain chain) throws IOException &#123; Request request &#x3D; chain.request(); RequestBody requestBody &#x3D; request.body(); boolean hasRequestBody &#x3D; requestBody !&#x3D; null; Connection connection &#x3D; chain.connection(); String requestStartMessage &#x3D; &quot;--&gt; &quot; + request.method() + &#39; &#39; + request.url(); Log.e(TAG, requestStartMessage); if (hasRequestBody) &#123; &#x2F;&#x2F; Request body headers are only present when installed as a network interceptor. Force &#x2F;&#x2F; them to be included (when available) so there values are known. if (requestBody.contentType() !&#x3D; null) &#123; Log.e(TAG, &quot;Content-Type: &quot; + requestBody.contentType()); &#125; if (requestBody.contentLength() !&#x3D; -1) &#123; Log.e(TAG, &quot;Content-Length: &quot; + requestBody.contentLength()); &#125; &#125; Headers headers &#x3D; request.headers(); for (int i &#x3D; 0, count &#x3D; headers.size(); i &lt; count; i++) &#123; String name &#x3D; headers.name(i); &#x2F;&#x2F; Skip headers from the request body as they are explicitly logged above. if (!&quot;Content-Type&quot;.equalsIgnoreCase(name) &amp;&amp; !&quot;Content-Length&quot;.equalsIgnoreCase(name)) &#123; Log.e(TAG, name + &quot;: &quot; + headers.value(i)); &#125; &#125; if (!hasRequestBody) &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method()); &#125; else if (bodyHasUnknownEncoding(request.headers())) &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (encoded body omitted)&quot;); &#125; else &#123; Buffer buffer &#x3D; new Buffer(); requestBody.writeTo(buffer); Charset charset &#x3D; UTF8; MediaType contentType &#x3D; requestBody.contentType(); if (contentType !&#x3D; null) &#123; charset &#x3D; contentType.charset(UTF8); &#125; Log.e(TAG, &quot;&quot;); if (isPlaintext(buffer)) &#123; Log.e(TAG, buffer.readString(charset)); Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (&quot; + requestBody.contentLength() + &quot;-byte body)&quot;); &#125; else &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (binary &quot; + requestBody.contentLength() + &quot;-byte body omitted)&quot;); &#125; &#125; long startNs &#x3D; System.nanoTime(); Response response; try &#123; response &#x3D; chain.proceed(request); &#125; catch (Exception e) &#123; Log.e(TAG, &quot;&lt;-- HTTP FAILED: &quot; + e); throw e; &#125; long tookMs &#x3D; TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs); ResponseBody responseBody &#x3D; response.body(); long contentLength &#x3D; responseBody.contentLength(); String bodySize &#x3D; contentLength !&#x3D; -1 ? contentLength + &quot;-byte&quot; : &quot;unknown-length&quot;; Log.e(TAG, &quot;&lt;-- &quot; + response.code() + (response.message().isEmpty() ? &quot;&quot; : &#39; &#39; + response.message()) + &#39; &#39; + response.request().url() + &quot; (&quot; + tookMs + &quot;ms&quot; + (&quot;, &quot; + bodySize + &quot; body:&quot; + &quot;&quot;) + &#39;)&#39;); Headers myheaders &#x3D; response.headers(); for (int i &#x3D; 0, count &#x3D; myheaders.size(); i &lt; count; i++) &#123; Log.e(TAG, myheaders.name(i) + &quot;: &quot; + myheaders.value(i)); &#125; if (!HttpHeaders.hasBody(response)) &#123; Log.e(TAG, &quot;&lt;-- END HTTP&quot;); &#125; else if (bodyHasUnknownEncoding(response.headers())) &#123; Log.e(TAG, &quot;&lt;-- END HTTP (encoded body omitted)&quot;); &#125; else &#123; BufferedSource source &#x3D; responseBody.source(); source.request(Long.MAX_VALUE); &#x2F;&#x2F; Buffer the entire body. Buffer buffer &#x3D; source.buffer(); Long gzippedLength &#x3D; null; if (&quot;gzip&quot;.equalsIgnoreCase(myheaders.get(&quot;Content-Encoding&quot;))) &#123; gzippedLength &#x3D; buffer.size(); GzipSource gzippedResponseBody &#x3D; null; try &#123; gzippedResponseBody &#x3D; new GzipSource(buffer.clone()); buffer &#x3D; new Buffer(); buffer.writeAll(gzippedResponseBody); &#125; finally &#123; if (gzippedResponseBody !&#x3D; null) &#123; gzippedResponseBody.close(); &#125; &#125; &#125; Charset charset &#x3D; UTF8; MediaType contentType &#x3D; responseBody.contentType(); if (contentType !&#x3D; null) &#123; charset &#x3D; contentType.charset(UTF8); &#125; if (!isPlaintext(buffer)) &#123; Log.e(TAG, &quot;&quot;); Log.e(TAG, &quot;&lt;-- END HTTP (binary &quot; + buffer.size() + &quot;-byte body omitted)&quot;); return response; &#125; if (contentLength !&#x3D; 0) &#123; Log.e(TAG, &quot;&quot;); Log.e(TAG, buffer.clone().readString(charset)); &#125; if (gzippedLength !&#x3D; null) &#123; Log.e(TAG, &quot;&lt;-- END HTTP (&quot; + buffer.size() + &quot;-byte, &quot; + gzippedLength + &quot;-gzipped-byte body)&quot;); &#125; else &#123; Log.e(TAG, &quot;&lt;-- END HTTP (&quot; + buffer.size() + &quot;-byte body)&quot;); &#125; &#125; return response; &#125; &#x2F;** * Returns true if the body in question probably contains human readable text. Uses a small sample * of code points to detect unicode control characters commonly used in binary file signatures. *&#x2F; static boolean isPlaintext(Buffer buffer) &#123; try &#123; Buffer prefix &#x3D; new Buffer(); long byteCount &#x3D; buffer.size() &lt; 64 ? buffer.size() : 64; buffer.copyTo(prefix, 0, byteCount); for (int i &#x3D; 0; i &lt; 16; i++) &#123; if (prefix.exhausted()) &#123; break; &#125; int codePoint &#x3D; prefix.readUtf8CodePoint(); if (Character.isISOControl(codePoint) &amp;&amp; !Character.isWhitespace(codePoint)) &#123; return false; &#125; &#125; return true; &#125; catch (EOFException e) &#123; return false; &#x2F;&#x2F; Truncated UTF-8 sequence. &#125; &#125; private boolean bodyHasUnknownEncoding(Headers myheaders) &#123; String contentEncoding &#x3D; myheaders.get(&quot;Content-Encoding&quot;); return contentEncoding !&#x3D; null &amp;&amp; !contentEncoding.equalsIgnoreCase(&quot;identity&quot;) &amp;&amp; !contentEncoding.equalsIgnoreCase(&quot;gzip&quot;); &#125;&#125; 打包编译后取出dex改名为okhttp3logging.dex，push到/data/locol/tmp目录下 编写frida进行hook,frida -U -f com.onejane.ok3demo -l hookOkhttp3.js --no-pause并通过adb logcat 查看系统log 123456789101112131415161718function hook_okhttp3_logging() &#123; &#x2F;&#x2F; 1. frida Hook java层的代码必须包裹在Java.perform中，Java.perform会将Hook Java相关API准备就绪。 Java.perform(function () &#123; Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;okhttp3logging.dex&quot;).load(); &#x2F;&#x2F; 只修改了这一句，换句话说，只是使用不同的拦截器对象。 var MyInterceptor &#x3D; Java.use(&quot;com.onejane.ok3demo.okhttp3Logging&quot;); var MyInterceptorObj &#x3D; MyInterceptor.$new(); var Builder &#x3D; Java.use(&quot;okhttp3.OkHttpClient$Builder&quot;); console.log(Builder); Builder.build.implementation &#x3D; function () &#123; this.networkInterceptors().add(MyInterceptorObj); return this.build(); &#125;; console.log(&quot;hook_okhttp3...&quot;); &#125;);&#125; Retrofitgit clone https://github.com/peiniwan/Ganhuo.git 编译源码编译安装apk 修改build.gradle,buildscript.repositories和allprojects.repositories添加google() 1classpath &#39;com.android.tools.build:gradle:3.5.3&#39; frida -U -f ganhuo.ly.com.ganhuo -l hookOkhttp3.js --no-pause 调用hook_okhttp3_logging()通过adb logcat查看后台log git clone https://github.com/siyujie/OkHttpLogger-Frida.git 获取Frida 实现拦截okhttp的脚本，首先将 okhttpfind.dex 拷贝到 /data/local/tmp/ 目录下，执行命令启动frida -UF -l okhttp_poker.js -f ganhuo.ly.com.ganhuo --no-pause 可追加 -o [output filepath]保存到文件 原理： 由于所有使用的okhttp框架的App发出的请求都是通过RealCall.java发出的，那么我们可以hook此类拿到request和response, 也可以缓存下来每一个请求的call对象，进行再次请求，所以选择了此处进行hook。 find前新增check，根据特征类寻找是否使用了okhttp3库，如果没有特征类，则说明没有使用okhttp; 找到特征类，说明使用了okhttp的库，并打印出是否被混淆。 12345&#96;find()&#96; 要等完全启动并执行过网络请求后再进行调用,检查是否使用了Okhttp &amp; 是否可能被混淆 &amp; 寻找okhttp3关键类及函数 &#96;switchLoader(\\&quot;okhttp3.OkHttpClient\\&quot;)&#96; 参数：静态分析到的okhttpclient类名&#96;hold()&#96; 要等完全启动再进行调用,开启HOOK拦截&#96;history()&#96; 打印可重新发送的请求&#96;resend(index)&#96; 重新发送请求 baseUrl自吐 Hook RetrofitUtils 中的new Retrofit.Builder().baseUrl(baseurl)的baseUrl 12345objection -g ganhuo.ly.com.ganhuo exploreandroid hooking search classes retrofitandroid hooking list class_methods retrofit2.Retrofitandroid hooking list class_methods retrofit2.Retrofit$Builder 发现只有baseUrl()无参构造，可能在app启动时就执行了baseUrl(baseurl)objection -g ganhuo.ly.com.ganhuo explore --startup-command &quot;android hooking list class_methods retrofit2.Retrofit$Builder&quot; 没有反应 通过编写frida脚本实现hook有参构造baseUrl 12345678910111213141516function hookbaseurl()&#123; Java.perform(function()&#123; Java.use(&quot;retrofit2.Retrofit$Builder&quot;).baseUrl.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(str)&#123; var result &#x3D; this.baseUrl(str) console.log(&quot;result1,str&#x3D;&gt;&quot;,result,str) return result &#125; Java.use(&quot;retrofit2.Retrofit$Builder&quot;).baseUrl.overload(&#39;okhttp3.HttpUrl&#39;).implementation &#x3D; function(str)&#123; var result &#x3D; this.baseUrl(str) console.log(&quot;result2,str&#x3D;&gt;&quot;,result,str) return result &#125; &#125;)&#125;setImmediate(hookbaseurl)","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"okhttp3","slug":"okhttp3","permalink":"http://onejane.github.io/tags/okhttp3/"},{"name":"HttpURLConnection","slug":"HttpURLConnection","permalink":"http://onejane.github.io/tags/HttpURLConnection/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://onejane.github.io/tags/Retrofit/"}]},{"title":"强大的脚本","slug":"强大的脚本","date":"2021-02-22T07:48:20.000Z","updated":"2021-05-29T04:02:17.222Z","comments":true,"path":"2021/02/22/强大的脚本/","link":"","permalink":"http://onejane.github.io/2021/02/22/%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%84%9A%E6%9C%AC/","excerpt":"","text":"Python合并多dex1234567891011121314151617181920import os, sys# python3.7 merge_dex.py .&#x2F;file&#x2F; livedex 反编译成java文件if __name__ &#x3D;&#x3D; &quot;__main__&quot;: if len(sys.argv) &lt; 3 : print(&quot;start error&quot;) sys.exit() print(sys.argv[1], sys.argv[2]) path &#x3D; sys.argv[1] #文件夹目录files&#x3D; os.listdir(path) #得到文件夹下的所有文件名称s &#x3D; []for file in files: #遍历文件夹 if file.find(&quot;dex&quot;) &gt; 0: ## 查找dex 文件 sh &#x3D; &#39;jadx -j 1 -r -d &#39; + sys.argv[2] + &quot; &quot; + path + file print(sh) os.system(sh) 集合排列组合12345678910111213141516171819productType = [1, 2, 3]goodType = [4, 5]energyType = [6, 7]productGoodEnergyType = [[1,2,3],[4,5],[6, 7]]# 多个集合随机有序排列,同itertools.product(*productGoodEnergyType)for newValue in itertools.product(productType,goodType,energyType): print(newValue)# 按组合个数进行无序组合print(list(itertools.permutations(productType))) for productTypeIndex in range(1, len(productType) + 1): # 单个集合按指定个数随机有序排列 productTypeTter1 = itertools.combinations(productType, productTypeIndex) print(list(productTypeTter1)) # 单个集合按指定个数随机无序组合 productTypeTter2 = itertools.permutations(productType, productTypeIndex) print(list(productTypeTter2)) 多集合组合 拿到集合的组合 根据这些组合进行分组笛卡尔积 1234567891011121314151617181920212223242526272829def combine(big_dict): # Cn1+Cn2+...+Cnn # Cmn&#x3D;m!&#x2F;n!*(m-n)! keys &#x3D; list(big_dict.keys()) # 获取keyList combine_key_list &#x3D; [] # key值 排列组合 valueList &#x3D; [] # 将key替换为值 for i in range(1, len(keys) + 1): iter &#x3D; itertools.combinations(keys, i) # [(&#39;a&#39;,), (&#39;b&#39;,), (&#39;c&#39;,), (&#39;a&#39;, &#39;b&#39;), (&#39;a&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)] combine_key_list.extend(list(iter)) # key的所有组合 以list形式加入列表 for m in combine_key_list: # [[[1, 2, 3]], [[4, 5]], [[6, 7, 8, 9]], [[1, 2, 3], [4, 5]], [[1, 2, 3], [6, 7, 8, 9]], [[4, 5], [6, 7, 8, 9]], [[1, 2, 3], [4, 5], [6, 7, 8, 9]]] valueList.append([big_dict.get(n) for n in m if n in keys]) # key所有组合转value组合 以object形式加入列表 param_list &#x3D; [] for index, value in enumerate(valueList): # list转为索引序列 search_type_key &#x3D; list(combine_key_list[index]) # 根据当前值对应key for item in itertools.product(*value): # 集合中n个集合n组笛卡尔积 params &#x3D; dict(zip(search_type_key, list(item))) param_list.append(urlencode(params)) print(param_list)d &#x3D; &#123; &#39;a&#39;: [1,2,3], &#39;b&#39;: [4,5], &#39;c&#39;: [6,7,8,9],&#125;combine(d) 格式转换转str 1234t &#x3D; (1,2)l &#x3D; [3,4]print(&#39;,&#39;.join(map(str, t)) if isinstance(t,tuple) else t)print(&#39;,&#39;.join(map(str, l)) if isinstance(l,list) else l) 转dict 1print(dict(zip(productType,goodType))) 转list 12def flatten(li): return sum(([x] if not isinstance(x, list) else flatten(x) for x in li), []) 字典key替换 1param_dict[&#39;area&#39;] &#x3D; param_dict.pop(&#39;ownerProvince&#39;)+&#39;-&#39;+param_dict.pop(&#39;ownerCity&#39;) Mongo123456import pymongoclient &#x3D; pymongo.MongoClient(settings.get(&#39;MONGO_URI&#39;))[settings.get(&#39;MONGO_DB&#39;)]client[&#39;MUsedCar&#39;].create_index([(&quot;url&quot;, 1)], unique&#x3D;True)client[&#39;MUsedCar&#39;].insert(dict(&#123;&#39;url&#39;:used_car_url+urlencode(param_dict)&#125;))for doc in client[&#39;MUsedCarParams&#39;].find(): print(doc[&#39;params&#39;]) 爬虫url12param_dict &#x3D; dict(parse.parse_qsl(parse.unquote(doc[&#39;params&#39;]))) url解码并转为字典urlencode(param_dict) 字典转url编码 Javaidea生成注释文档File =&gt; setting =&gt; editor =&gt; File and Code Templates 12345&quot;&quot;&quot;@author: onejane@time: $&#123;DATE&#125; $&#123;TIME&#125;@desc:&quot;&quot;&quot; File =&gt; Setting=&gt; Editor=&gt; Live Templates 输入onejane代码提示直接回车即可 Tools-Generate JavaDoc 12zh_CN-tag ProjectDetails:a:&quot;项目详情:&quot; -tag update:a:&quot;项目更改:&quot; -tag CreateDate:a:&quot;创建时间:&quot; -encoding UTF-8 -charset UTF-8 lambda多个分组多列求和1234567Function&lt;MotoEssayShowDailyContextInfoDTO, List&lt;Object&gt;&gt; keyExtractor &#x3D; wr -&gt; Arrays.&lt;Object&gt;asList(wr.getBusinessDate(), wr.getContext());List&lt;MotoEssayShowDailyContextInfoDTO&gt; showDailyContextInfoDTOS &#x3D; infoByCondition.stream().collect(Collectors.groupingBy(keyExtractor, Collectors.reducing((sum, s) -&gt; new MotoEssayShowDailyContextInfoDTO(s.getBusinessDate(), s.getContext(), sum.getExposureArticleNum() + s.getExposureArticleNum(), sum.getExposureNum() + s.getExposureNum(), sum.getClickNum() + s.getClickNum(), sum.getDetailClickNum() + s.getDetailClickNum(), sum.getDuration() + s.getDuration(), sum.getFinish() + s.getFinish())))).entrySet().stream().map(c -&gt; c.getValue().get()).collect(Collectors.toList()); 分组排序1showDailyContextInfoDTOS.stream().collect(Collectors.groupingBy(o -&gt; o.getBusinessDate(), TreeMap::new,Collectors.toList())); Git多仓库12git remote set-url --add origin git@github.com:OneJane&#x2F;CrawlerBase.gitgit push origin --all git remote add origin &#x67;&#x69;&#116;&#x40;&#x67;&#105;&#x74;&#101;&#101;&#x2e;&#x63;&#x6f;&#x6d;:OneJane/picture.git 初始化后建立git库 版本回退12git refloggit reset --hard 版本号 大仓库提交1git config http.postBuffer 524288000 不行就使用git替代https地址 合并不同提交历史1git pull origin master --allow-unrelated-histories 恢复被删分支12git refloggit branch f&#x2F;wj-0419-5924 bcd2e64 Mongo更新批量将字段更新成字符串 1234db.getCollection(&#39;alimama&#39;).find(&#123;&#125;).forEach(function(x)&#123; db.getCollection(&#39;alimama&#39;).updateOne( &#123;_id: x._id&#125;, &#123;$set:&#123;income_rate: String(x.income_rate)&#125;&#125;)&#125;) 批量新增字段 1db.getCollection(&#39;taobao&#39;).update(&#123;&#125;, &#123;$set: &#123;&#39;name&#39;:&quot;taobao&quot;&#125;&#125;, &#123;multi: true&#125;); 批量修改字段名 1db.getCollection(&#39;long_link&#39;).update(&#123;&#125;, &#123;&quot;$rename&quot;:&#123;&quot;long_link&quot;:&quot;orientPlanLinkUrl&quot;&#125;&#125;, false, true) 查询返回指定字段id 1db.getCollection(&#39;alimama&#39;).find(&#123;&#125;,&#123;_id:0,id:1&#125;) 按照url分组查询并倒序 1db.getCollection(&#39;conditions&#39;).aggregate([&#123;$group : &#123;_id : &quot;$url&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;,&#123; $sort : &#123; num_tutorial: -1 &#125; &#125;]) 模糊查询 1db.getCollection(&#39;conditions&#39;).find(&#123;&#39;url&#39;:&#123;&#39;$regex&#39;:&#39;https:*&#39;&#125;&#125;).count() 导出 sublime 中ctrl+h 进行 {“_id”:.:”(.)”}\\n 替换为 $1\\n 1mongoexport -h 172.20.0.186:27017 -d jddmoto -c mbrand -o mbrand.json --type json -f url Mysqllocate1SELECT GROUP_CONCAT(a.n_id), COUNT(a.&#96;n_id&#96;) FROM &#96;motor_business_essay&#96; a, &#96;motor_business_essay_ext&#96; b where locate(&#39;&quot;img&quot;:&quot;&quot;&#39;,a.c_short_vod_info) Linux删除大文件123df -hlsof | grep deleted 查询内存中持续删除的进程kill -9 id windows新增复制文件路径.regUTF-8-BOM编码 1234567891011121314151617181920Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\*\\shell\\copypath]@&#x3D;&quot;复制文件路径到剪贴板&quot;[HKEY_CLASSES_ROOT\\*\\shell\\copypath\\command]@&#x3D;&quot;cmd &#x2F;c echo %1 | clip&quot;[HKEY_CLASSES_ROOT\\*\\shell\\copypathwithquote]@&#x3D;&quot;复制文件路径到剪贴板(带引号)&quot;[HKEY_CLASSES_ROOT\\*\\shell\\copypathwithquote\\command]@&#x3D;&quot;cmd &#x2F;c echo \\&quot;%1\\&quot; | clip&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypath]@&#x3D;&quot;复制文件夹路径到剪贴板&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypath\\command]@&#x3D;&quot;cmd &#x2F;c echo %1 | clip&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypathwithquote]@&#x3D;&quot;复制文件夹路径到剪贴板(带引号)&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypathwithquote\\command]@&#x3D;&quot;cmd &#x2F;c echo \\&quot;%1\\&quot; | clip&quot;","categories":[{"name":"脚本","slug":"脚本","permalink":"http://onejane.github.io/categories/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"python","slug":"python","permalink":"http://onejane.github.io/tags/python/"}]},{"title":"加壳与脱壳之分类技术","slug":"加壳与脱壳之分类技术","date":"2021-02-21T09:16:27.000Z","updated":"2021-06-07T14:48:07.265Z","comments":true,"path":"2021/02/21/加壳与脱壳之分类技术/","link":"","permalink":"http://onejane.github.io/2021/02/21/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%88%86%E7%B1%BB%E6%8A%80%E6%9C%AF/","excerpt":"","text":"历代加壳技术分类动态加载是用到的时候再去加载，也叫懒加载，是dex加壳，插件化，热更新的基础，避免发布新版本需要用户全量更新app，快速迭代，提升用户体验。比如阿里的AndFix和HotFix，腾讯的tinker，美团的Robust等热修复框架的基础。动态加载的dex不具有生命周期特征，APP中的Activity，Service等组件无法正常工作，只能完成一般函数的调用。需要对ClassLoader进行修正，APP才能够正常运行，有反射替换和反射插入两种修正手段，这是加壳app必然要做的一步。 第一代壳:dex加密 Dex字符串加密 资源加密 对抗反编译 反调试 自定义 DexClass Loader 由于是dex整体保护，在内存中映射是整体连续的，通过定位起始地址将app完整脱下来 第二代壳:dex抽取与加固 对抗第一代壳常见的脱壳法 Dex method代码抽取到外部(通常企业版) Dex动态加载 So加密 首先dex整体保护，其次对关键函数进行抽取(dump内存区域中dex关键类为空)进行so加密，对抗第一代壳常用脱壳法(从关键hook点dump dex) 第三代壳:dex动态解密与混淆 Dex method代码动态解密 So代码膨胀混淆 对抗之前出现的所有脱壳法 对抗第二代壳的一个通用脱壳工具DexHunter(通过遍历dex所有类进行加载初始化，将内存中dex完整恢复),dex中method动态解密，指定函数只有被调用时才执行，dex在内存中始终不是完整的状态 第四代壳:vmp壳目前仍然是smali指令级别的vmp，未来将出现arm指令级别vmp 加壳技术分析dex加固 dex整体加固:文件加载（监控app访问文件的记录）和内存加载（对内存dex的解密直接动态加载） 函数抽取:在函数粒度完成代码的保护：dump下dex的关键函数体置空 VMP和Dex2C:JAVA函数 Native化。vmp-&gt;逆向分析解释器找到取址译码 dex整体加固dex整体加壳是基础防护，所有加壳的app必然都有，关键在于怎么区分函数抽取，vmp以及dex2c甚至多种技术混合的混合型壳。 文件加载:定位解密文件是关键 内存加载:加载时机和内存起始地址是关键 通用方案:dex打开和优化的流程以及产出的odex、dex2oat编译的流程和生成的oat文件等等 函数抽取 类加载和函数执行前的流程解密 函数执行中动态自解密 方案：关注被抽取的函数的执行流程是关键！定位被抽取的函数的恢复时机即可。 获取到保护的dex后,函数体的内容是无效的,注意这里说的是无效,而不是无意义,有的app壳后函数依然是有意义的,但不是我们想要的。f5查看函数体全部为空，则表现为函数抽取。 VMP定位解释器是关键，找到映射关系便可恢复。 获取到保护的dex后,函数的属性由java属性变为 Native,典型的有数字的 onCreate函数 Native化JNI函数。vmp壳的核心就是dalvik虚拟机的解释器原理。 若所有vmp保护的函数都有自己的解释器则so必然很大，所以必然共享一个解释器，vmp化的函数注册地址一致或者函数逻辑相似。 MainActivity动态注册地址在d3dec3f1,TestActivity地址一致，说明vmp保护。 参考vmp加壳方案之ADVMP，vmp对每一种smali指令处理，保护了函数后函数属性发生改变，因为解释器一般是用JNI实现，java易被反编译，故没用java实现，基本由c实现，防止快速定位到解释器的取址译码和执行的流程会加ollvm混淆保护之类。 Dex2c基础是编译原理，进行了等价语义转换，彻底还原难度巨大。 方案：关注JNI相关的api调用是关键，也是分析VMP和dex2c保护的函数的逻辑的关键。 获取到保护的dex后保护的函数属性有java变成native，dcc保护后所有java属性的函数变成jni函数，只能看到类名和参数。核心原理与编译原理相关，传统编译原理是编译器经过词法分析语法分析生成二进制代码，dex2c中生成结果是c、c++文件，经过ndk编译器最终编译为so,每一个函数基本编译成一个c/c++文件，ubuntu中编译最终生成一个so。 dex2c核心对指定java函数进行语义分析生成各个不同的c/c++代码编译为相应so，自然dex2c保护的函数逻辑不一致，自然注册地址不同。 MainActivity的地址在7ba61b17c0，TestActivity地址在7ba61ac604，说明dex2c保护。 dcc_out.apk在lib下编译生成了so文件中,jni函数静态注册都存放于so文件中，使用IDA v7打开libnc.so，搜索java就可以找到所有jni函数。 dcc_out编译于项目LoadDex,新增FirstActivity，SecondActivity MainActivity.java 12345678910111213141516171819202122static&#123; try &#123; System.loadLibrary(&quot;nc&quot;); &#125; catch (UnsatisfiedLinkError e) &#123; e.printStackTrace(); &#125;&#125;setContentView(R.layout.activity_main);Button mybutton01&#x3D;findViewById(R.id.button01);mybutton01.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; context.startActivity(new Intent(context,FirstActivity.class)); &#125;&#125;);Button mybutton02&#x3D;findViewById(R.id.button02);mybutton02.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; context.startActivity(new Intent(context,SecondActivity.class)); &#125;&#125;); AndroidManifest.xml 12&lt;activity android:name&#x3D;&quot;.FirstActivity&quot;&gt;&lt;&#x2F;activity&gt;&lt;activity android:name&#x3D;&quot;.SecondActivity&quot;&gt;&lt;&#x2F;activity&gt; activity_main.xml 12345678910111213141516171819202122232425&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot; android:id&#x3D;&quot;@+id&#x2F;LinearLayout1&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;button01&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center_horizontal&quot; android:text&#x3D;&quot;FirstActivity&quot; &#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;button02&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center_horizontal&quot; android:text&#x3D;&quot;SecondActivity&quot; &#x2F;&gt;&lt;&#x2F;LinearLayout&gt; dcc_ollvm.apk 在dex2c过程中加入了ollvm，在ida中打开so，jni找不到。 参考dex2c加壳方案之dcc 1234git clone https:&#x2F;&#x2F;github.com&#x2F;amimo&#x2F;dcc.gitpyenv local 3.8.5 &amp;&amp; cd dcc &amp;&amp; pip install -r requirements.txtvim filter.txt 添加.*onejane*. 编译函数名含有onejane的函数python dcc.py dcc.apk -o dcc_out.apk 加固app VMP和dex2c是高级防护 VMP:定位解释器是关键,找到映射关系便可恢复 dex2c:基础是编译原理,进行了等价语义转换,彻底还原难度巨大: 通用分类技术:关注JNI相关的ap调用是关键,也是分析VMP和dex2c保护的函数的逻辑的关键。 混合型壳多种加固技术混合使用,比如先将原有smal指令流使用VMP或dex2c保护,构建object数组传递给jni函数进行调用，然后再经过函数抽取进一步保护 区分apk保护技术 是否Native化 函数体无效 函数抽取类壳 否 是 vmp壳 是 native化 Dex2c壳 是 native化 so加固 基于init、 init_array以及JNI_Onload函数的加壳 基于自定义linker的加壳 IDA快捷键 空格键 反汇编窗口切换文本跟图形 ESC 退到上一个操作地址 F5 C伪代码 alt+t 搜索文本 一二三代壳和加壳技术分类识别","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"fart","slug":"fart","permalink":"http://onejane.github.io/tags/fart/"},{"name":"vmp","slug":"vmp","permalink":"http://onejane.github.io/tags/vmp/"},{"name":"dex2c","slug":"dex2c","permalink":"http://onejane.github.io/tags/dex2c/"}]},{"title":"主动调用java及native层","slug":"主动调用java及native层","date":"2021-02-16T15:27:08.000Z","updated":"2021-07-01T18:30:50.046Z","comments":true,"path":"2021/02/16/主动调用java及native层/","link":"","permalink":"http://onejane.github.io/2021/02/16/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8java%E5%8F%8Anative%E5%B1%82/","excerpt":"","text":"examplefrida-server-linuxfrida-python修改examples中rpc.py 12345678910111213141516171819# -*- coding: utf-8 -*-from __future__ import print_functionimport fridaimport timesession &#x3D; frida.attach(&quot;mousepad&quot;)script &#x3D; session.create_script(&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; hello: function () &#123; return &#39;Hello&#39;; &#125;, failPlease: function () &#123; return &#39;oops&#39;; &#125;&#125;;&quot;&quot;&quot;)script.load()api &#x3D; script.exportsprint(&quot;api.hello() &#x3D;&gt;&quot;, api.hello())print(&quot;api.fail_please() &#x3D;&gt;&quot;,api.fail_please()) 7z x frida-server-14.2.12-linux-x86_64.xz &amp;&amp; chmod 777 frida-server-14.2.12-linux-x86_64 &amp;&amp; ./frida-server-14.2.12-linux-x86_64 启动linux的frida server 通过netstat -tuulp可以查询被frida-server listen的27042端口 echo 123&gt;1.txt &amp;&amp; mousepad 1.txt 记事本打开1.txt,ps aux|grep -i mousepad查看该进程 python rpc.py 查看rpc attach mousepad引用打印结果 python-binding里连接frida-server的非标准端口: ./fs1428arm64 -l 0.0.0.0:6666import fridadevice = frida.get_device_manager().add_remote_device(‘192.168.1.101:6666’)print(device.name,devie.type,device.id) frida-python修改examples中bytecode.py 1234567891011121314system_session &#x3D; frida.attach(0)bytecode &#x3D; system_session.compile_script(name&#x3D;&quot;bytecode-example&quot;, source&#x3D;&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; listThreads: function () &#123; return Process.enumerateThreadsSync(); &#125;&#125;;&quot;&quot;&quot;)session &#x3D; frida.attach(&quot;mousepad&quot;)script &#x3D; session.create_script_from_bytes(bytecode)script.load()api &#x3D; script.exportsprint(&quot;api.list_threads() &#x3D;&gt;&quot;, api.list_threads()) python bytecode.py 查看rpc 编译生成的thread列表 frida-server-androidfrida-python修改examples中rpc.py 1234567891011121314151617181920device &#x3D; frida.get_usb_device()#device &#x3D; frida.get_device_manager.add_remote_device(&quot;192.168.0.2:8888&quot;) # 基于远程ip的集群pid &#x3D; device.spawn([&quot;com.android.settings&quot;])device.resume(pid)time.sleep(1)session &#x3D; device.attach(pid)script &#x3D; session.create_script(&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; hello: function () &#123; return &#39;Hello&#39;; &#125;, failPlease: function () &#123; return &#39;oops&#39;; &#125;&#125;;&quot;&quot;&quot;)script.load()api &#x3D; script.exportsprint(&quot;api.hello() &#x3D;&gt;&quot;, api.hello())print(&quot;api.fail_please() &#x3D;&gt;&quot;,api.fail_please()) ./fs1428arm64 pyenv local 3.8.5 &amp;&amp; python rpc.py 自启动进程查看rpc attach pid引用打印结果 frida-python修改examples中detached.py 1234567891011121314151617181920def on_detached(): print(&quot;on_detached&quot;)def on_detached_with_reason(reason): print(&quot;on_detached_with_reason:&quot;, reason)def on_detached_with_varargs(*args): print(&quot;on_detached_with_varargs:&quot;, args)device &#x3D; frida.get_usb_device()#device &#x3D; frida.get_device_manager.add_remote_device(&quot;192.168.0.2:8888&quot;) # 基于远程ip的集群pid &#x3D; device.spawn([&quot;com.android.settings&quot;])device.resume(pid)time.sleep(1)session &#x3D; device.attach(pid)print(&quot;attached&quot;)session.on(&#39;detached&#39;, on_detached)session.on(&#39;detached&#39;, on_detached_with_reason)session.on(&#39;detached&#39;, on_detached_with_varargs)sys.stdin.read() ./fs1428arm64 pyenv local 3.8.5 &amp;&amp; python detached.py 自启动进程detach进程后捕获进程退出打印log frida-python修改examples中crash_reporting.py 123456789101112131415def on_process_crashed(crash): print(&quot;on_process_crashed&quot;) print(&quot;\\tcrash:&quot;, crash)def on_detached(reason, crash): print(&quot;on_detached()&quot;) print(&quot;\\treason:&quot;, reason) print(&quot;\\tcrash:&quot;, crash)device &#x3D; frida.get_usb_device()device.on(&#39;process-crashed&#39;, on_process_crashed)session &#x3D; device.attach(&quot;com.android.settings&quot;)session.on(&#39;detached&#39;, on_detached)print(&quot;[*] Ready&quot;)sys.stdin.read() ./fs1428arm64 pyenv local 3.8.5 &amp;&amp; python crash_reporting.py 进程运行中detach进程后捕获进程退出打印log 当需要hook一个app的子进程时，调用child_gating.py在子进程创建时创建脚本打印内容。 argv = [“/bin/sh”, “-c”, “cat /etc/hosts”] # 在bullhead中/system/bin/sh frida-python修改examples中bytecode.py 1234567891011121314151617181920device &#x3D; frida.get_usb_device()#device &#x3D; frida.get_device_manager.add_remote_device(&quot;192.168.0.2:8888&quot;) # 基于远程ip的集群pid &#x3D; device.spawn([&quot;com.hd.zhibo&quot;])device.resume(pid)time.sleep(1)system_session &#x3D; device.attach(0)bytecode &#x3D; system_session.compile_script(name&#x3D;&quot;bytecode-example&quot;, source&#x3D;&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; listThreads: function () &#123; return Process.enumerateThreadsSync(); &#125;&#125;;&quot;&quot;&quot;)session &#x3D; device.attach(pid)script &#x3D; session.create_script_from_bytes(bytecode)script.load()api &#x3D; script.exportsprint(&quot;api.list_threads() &#x3D;&gt;&quot;, api.list_threads()) python bytecode.py 查看rpc 编译生成的thread列表 DEXDump:js暴露3个export api(memorydump,switchmode,scandex)，在py层调用三个api进行交互 Zentracer:使用替换js中字符串(MATCHREGEX,BLACKREGEX)将黑白名单传输给js文件，将js文件直接加载通过send将信息传输给py端 java层主动调用pyenv 升级123456789pyenv versionsgit clone https:&#x2F;&#x2F;github.com&#x2F;pyenv&#x2F;pyenv-update.git $(pyenv root)&#x2F;plugins&#x2F;pyenv-updatepyenv updatepyenv install 3.8.6pip install objection 安装最新版objection和fridafrida -UF Frida 查看版本Frida.heapSizeScript 查看运行环境使用的是QJS 项目Httpsocketlibssl库的抓包导出表与符号表 1234567objection -g com.roysue.httpsocket.explorememory list modules 搜索libssl.somemory list exports libssl.so --json &#x2F;root&#x2F;Desktop&#x2F;libssl.so.json 通过json文件查看导出函数表memory list exports libcrypto.so --json &#x2F;root&#x2F;Desktop&#x2F;libcrypto.so.json frida-trace -UF -I libssl.so 指定模块trace自动化导出表查看经过了哪里frida-trace -U -f com.roysue.Httpsocket -I libssl.so 容易崩frida-trace -U -f com.roysue.Httpsocket -I libcrypto.so 自动生成的hook在当前目录的__handlers__下 尝试通过frida实现hook所有so的导出表和符号表frida -U -f com.roysue.httpsocket -l traceNative.js --no-pause 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109function writeSomething(path, contents) &#123; var fopen_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fopen&quot;); var fputs_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fputs&quot;); var fclose_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fclose&quot;); &#x2F;&#x2F;console.log(&quot;fopen&#x3D;&gt;&quot;,fopen_addr,&quot; fputs&#x3D;&gt;&quot;,fputs_addr,&quot; fclose&#x3D;&gt;&quot;,fclose_addr); var fopen &#x3D; new NativeFunction(fopen_addr, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]) var fputs &#x3D; new NativeFunction(fputs_addr, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]) var fclose &#x3D; new NativeFunction(fclose_addr, &quot;int&quot;, [&quot;pointer&quot;]) &#x2F;&#x2F;console.log(path,contents) var fileName &#x3D; Memory.allocUtf8String(path); var mode &#x3D; Memory.allocUtf8String(&quot;a+&quot;); var fp &#x3D; fopen(fileName, mode); var contentHello &#x3D; Memory.allocUtf8String(contents); var ret &#x3D; fputs(contentHello, fp) fclose(fp);&#125;&#x2F;&#x2F; 枚举出所有导出函数和内部符号，找到关键函数存在的so，动态注册无效，名称和native可以完全不一样function traceNativeExport()&#123; var modules &#x3D; Process.enumerateModules(); for(var i &#x3D; 0;i&lt;modules.length;i++)&#123; var module &#x3D; modules[i]; if(module.name.indexOf(&quot;libssl.so&quot;)&lt;0)&#123; continue; &#125; &#x2F;&#x2F; 枚举so所有导出表 var exports &#x3D; module.enumerateExports(); for(var j &#x3D; 0;j&lt;exports.length;j++)&#123; &#x2F;&#x2F;console.log(&quot;module name is &#x3D;&gt;&quot;,module.name,&quot; symbol name is &#x3D;&gt;&quot;,exports[j].name) &#x2F;&#x2F;var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;so&#x2F;&quot;+module.name+&quot;.txt&quot; &#x2F;&#x2F; 通过objection -g com.roysue.httpsocket explore 中env拿到的filesDirectory地址 &#x2F;&#x2F;var path &#x3D; &quot;&#x2F;data&#x2F;data&#x2F;com.roysue.d0so2&#x2F;cache&#x2F;&quot;+module.name+&quot;.txt&quot; &#x2F;&#x2F;writeSomething(path,&quot;type: &quot;+exports[j].type+&quot; function name :&quot;+exports[j].name+&quot; address : &quot;+exports[j].address+&quot; offset &#x3D;&gt; 0x&quot;+(exports[j].address - module[i].address)+&quot;\\n&quot;) &#x2F;&#x2F; 把所有包含SSL_write的函数全部hook上 if(exports[j].name.indexOf(&quot;SSL_write&quot;)&gt;&#x3D;0)&#123; attach(exports[j].name,exports[j].address); &#125; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;set&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;send&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;recv&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#125; &#125;&#125;function attach(name,address)&#123; console.log(&quot;attaching &quot;,name); Interceptor.attach(address,&#123; onEnter:function(args)&#123; console.log(&quot;Entering &#x3D;&gt; &quot; ,name) console.log(&quot;args[0] &#x3D;&gt; &quot;,hexdump(args[0]) ) &#x2F;&#x2F; console.log(&quot;args[1] &#x3D;&gt; &quot;,args[1].readCString()) &#x2F;&#x2F; console.log(&quot;args[2] &#x3D;&gt; &quot;,args[2]) &#125;,onLeave:function(retval)&#123; &#x2F;&#x2F;console.log(&quot;retval is &#x3D;&gt; &quot;,retval) &#125; &#125;)&#125;&#x2F;&#x2F; 枚举符号表function traceNativeSymbol()&#123; var modules &#x3D; Process.enumerateModules(); for(var i &#x3D; 0;i&lt;modules.length;i++)&#123; var module &#x3D; modules[i]; &#x2F;&#x2F; console.log(JSON.stringify(modules)) if(module.name.indexOf(&quot;linker64&quot;)&lt;0)&#123; continue; &#125; var exports &#x3D; module.enumerateSymbols(); console.log(JSON.stringify(exports)) for(var j &#x3D; 0;j&lt;exports.length;j++)&#123; if(exports[j] &#x3D;&#x3D; null)&#123; continue; &#125; console.log(&quot;module name is &#x3D;&gt;&quot;,module.name,&quot; symbol name is &#x3D;&gt;&quot;,exports[j].name) var path &#x3D; &quot;&#x2F;data&#x2F;data&#x2F;com.roysue.d0so2&#x2F;cache&#x2F;&quot;+module.name+&quot;Symbol.txt&quot; writeSomething(path,&quot;type: &quot;+exports[j].type+&quot; function name :&quot;+exports[j].name+&quot; address : &quot;+exports[j].address+&quot; offset &#x3D;&gt; 0x&quot;+(exports[j].address - module[i].address)+&quot;\\n&quot;) &#125; &#125;&#125;function main()&#123; console.log(&quot;Entering main&quot;) traceNativeExport(); &#x2F;&#x2F;traceNativeSymbol();&#125;setImmediate(main) git clone https://github.com/BigFaceCat2017/frida_ssl_logger.git python ssl_logger.py -U -f com.roysue.httpsocket -p capture.pcap 抓包ssl保存到pcap中使用wireshark查看 libc去除httpSocket.js中traceNativeExport对libssl.so的过滤，frida -UF -l traceNative.js,trace后的结果到/data/data/com.roysue.d0so2/cache中cat libs.so.txt|grep open frida -UF -l traceNativelibc.js -o trace.txt frida -U -f com.ss.android.auto -l traceNativelibc.js -o trace.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126function writeSomething(path, contents) &#123; var fopen_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fopen&quot;); var fputs_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fputs&quot;); var fclose_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fclose&quot;); &#x2F;&#x2F;console.log(&quot;fopen&#x3D;&gt;&quot;,fopen_addr,&quot; fputs&#x3D;&gt;&quot;,fputs_addr,&quot; fclose&#x3D;&gt;&quot;,fclose_addr); var fopen &#x3D; new NativeFunction(fopen_addr, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]) var fputs &#x3D; new NativeFunction(fputs_addr, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]) var fclose &#x3D; new NativeFunction(fclose_addr, &quot;int&quot;, [&quot;pointer&quot;]) &#x2F;&#x2F;console.log(path,contents) var fileName &#x3D; Memory.allocUtf8String(path); var mode &#x3D; Memory.allocUtf8String(&quot;a+&quot;); var fp &#x3D; fopen(fileName, mode); var contentHello &#x3D; Memory.allocUtf8String(contents); var ret &#x3D; fputs(contentHello, fp) fclose(fp);&#125;function traceNativeExport()&#123; var modules &#x3D; Process.enumerateModules(); for(var i &#x3D; 0;i&lt;modules.length;i++)&#123; var module &#x3D; modules[i]; if(module.name.indexOf(&quot;libc.so&quot;)&lt;0)&#123; continue; &#125; var exports &#x3D; module.enumerateExports(); for(var j &#x3D; 0;j&lt;exports.length;j++)&#123; &#x2F;&#x2F;console.log(&quot;module name is &#x3D;&gt;&quot;,module.name,&quot; symbol name is &#x3D;&gt;&quot;,exports[j].name) &#x2F;&#x2F;var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;so&#x2F;&quot;+module.name+&quot;.txt&quot; &#x2F;&#x2F; var path &#x3D; &quot;&#x2F;data&#x2F;data&#x2F;com.roysue.d0so2&#x2F;cache&#x2F;&quot;+module.name+&quot;.txt&quot; &#x2F;&#x2F; writeSomething(path,&quot;type: &quot;+exports[j].type+&quot; function name :&quot;+exports[j].name+&quot; address : &quot;+exports[j].address+&quot; offset &#x3D;&gt; 0x&quot;+ ( exports[j].address.sub(modules[i].base) )+&quot;\\n&quot;) &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;strto&quot;)&gt;&#x3D;0)continue; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;strco&quot;)&gt;&#x3D;0)continue; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;_l&quot;)&gt;&#x3D;0)continue; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;pthread&quot;)&gt;&#x3D;0)continue; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;socket&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; fopen fputs fputc fclose &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#x2F;&#x2F; 过反调试,一般反调试都有单独创建线程 if(exports[j].name.indexOf(&quot;pthread_create&quot;)&gt;&#x3D;0)&#123; attach(exports[j].name,exports[j].address); &#125; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;read&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; man read &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;write&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;send&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;recv&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#125; &#125;&#125;function attach(name,address)&#123; console.log(&quot;attaching &quot;,name); Interceptor.attach(address,&#123; onEnter:function(args)&#123; console.log(&quot;Entering &#x3D;&gt; &quot; ,name) &#x2F;&#x2F; console.log(&quot;args[0] &#x3D;&gt; &quot;,args[0].readCString() ) &#x2F;&#x2F; console.log(&quot;args[1] &#x3D;&gt; &quot;,args[1].readCString()) &#x2F;&#x2F; console.log( hexdump(args[1])) console.log(&quot;args[2] &#x3D;&gt; &quot;,args[2]) &#x2F;&#x2F; 打印调用栈 &#x2F;&#x2F; console.log(&#39;R0YSUE called from:\\n&#39; +Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&#39;\\n&#39;) + &#39;\\n&#39;); &#125;,onLeave:function(retval)&#123; console.log(&quot;exit &#x3D;&gt; &quot;,name) &#x2F;&#x2F; console.log(&quot;retval is &#x3D;&gt; &quot;,retval.readCString()) &#125; &#125;)&#125;function traceNativeSymbol()&#123; var modules &#x3D; Process.enumerateModules(); &#x2F;&#x2F; console.log(JSON.stringify(modules)) for(var i &#x3D; 0;i&lt;modules.length;i++)&#123; var module &#x3D; modules[i]; &#x2F;&#x2F; console.log(JSON.stringify(modules)) &#x2F;&#x2F; if(module.name.indexOf(&quot;linker64&quot;)&lt;0)&#123; &#x2F;&#x2F; continue; &#x2F;&#x2F; &#125; var exports &#x3D; module.enumerateSymbols(); &#x2F;&#x2F; console.log(JSON.stringify(exports)) for(var j &#x3D; 0;j&lt;exports.length;j++)&#123; &#x2F;&#x2F; console.log(&quot;module name is &#x3D;&gt;&quot;,module.name,&quot; symbol name is &#x3D;&gt;&quot;,exports[j].name) var path &#x3D; &quot;&#x2F;data&#x2F;data&#x2F;com.roysue.d0so2&#x2F;cache&#x2F;&quot;+module.name+&quot;Symbol.txt&quot; writeSomething(path,&quot;type: &quot;+exports[j].type+&quot; function name :&quot;+exports[j].name+&quot; address : &quot;+exports[j].address+&quot; offset &#x3D;&gt; 0x&quot;+ ( exports[j].address.sub(modules[i].base) )+&quot;\\n&quot;) &#125; &#125;&#125;function main()&#123; console.log(&quot;Entering main&quot;) traceNativeExport(); &#x2F;&#x2F; traceNativeSymbol();&#125;setImmediate(main) Unicorn 在 Android 的应用 项目d0so2123objection -g com.roysue.d0so2 explore -s &quot;android hooking watch class_method com.roysue.d0so2.MainActivity.sI3 --dump-args --dump-backtrace --dump-return&quot;memory list modules 查找native-lib为libnative-lib.somemory list exports libnative-lib.so 只能找到静态注册的stringFromJNI1，stringFromJNI1，但是找不到动态注册的sI3 git clone https://github.com/lasting-yang/frida_hook_libart.githttps://github.com/lasting-yang/frida_hook_libart.git 1frida -U --no-pause -f com.roysue.d0so2 -l hook_RegisterNatives.js 找到动态注册的类和原名 其中0x7612a10454绝对地址减去0x7612a01000模块地址，得到0xf454函数地址 1memory list exports libnative-lib.so 搜索0x7612a10454 将函数名复制到http://demangler.com/ 进行解码得到原函数名 1android hooking watch class_method com.rosyue.d0so2.MainActivity.sI3() --dump-args --dump-backtrace --dump-return frida实现hook动态注册函数，frida -UF -l hookNative.js 12345678910111213141516171819202122232425262728function hook_native()&#123; var libnative_addr &#x3D; Module.findBaseAddress(&#39;libnative-lib.so&#39;); console.log(&quot;libnative_addr is &#x3D;&gt; &quot;,libnative_addr) var stringfromJNI3 &#x3D; libnative_addr.add(0xf454); console.log(&quot;stringfromJNI3 address is &#x3D;&gt;&quot;,stringfromJNI3); var stringfromJNI3_2 &#x3D; Module.findExportByName(&#39;libnative-lib.so&#39;, &quot;_Z14stringFromJNI3P7_JNIEnvP7_jclassP8_jstring&quot;) console.log(&quot;stringfromJNI3_2 address is &#x3D;&gt;&quot;,stringfromJNI3_2); Interceptor.attach(stringfromJNI3_2,&#123; onEnter:function(args)&#123; console.log(&quot;jnienv pointer &#x3D;&gt;&quot;,args[0]) console.log(&quot;jobj pointer &#x3D;&gt;&quot;,args[1]) console.log(&quot;jstring pointer&#x3D;&gt;&quot;,Java.vm.getEnv().getStringUtfChars(args[2], null).readCString() ) &#125;,onLeave:function(retval)&#123; console.log(&quot;retval is &#x3D;&gt;&quot;,Java.vm.getEnv().getStringUtfChars(retval, null).readCString()) console.log(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;) &#125; &#125;)&#125;function main()&#123; hook_native()&#125;setImmediate(main) 项目 demoso1Android JNI(一)——NDK与JNI基础 Android逆向新手答疑解惑篇——JNI与动态注册 pyenv 3.8.0 123456objection -g com.example.demoso1 exploreandroid hooking search classes com.example.demoso1 打印包名下所有的类android hooking list class_methods com.example.demoso1.MainActivity 打印类下所有方法android hooking watch class com.example.demoso1.MainActivityandroid hooking watch class_method com.example.demoso1.MainActivity.method02 --dump-args --dump-backtrace --dump-return objection -N -h 192.168.0.105 -p 8888 -g com.example.demoso1 explore method01在native层的静态方法，method02是native层的动态方法 123456789101112131415161718192021222324252627282930313233343536var MainActivityHandle &#x3D; null; &#x2F;&#x2F; 实例调用的性能优化(将instance缓存起来反复调用)Java.perform(function()&#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) Java.choose(&quot;com.example.demoso1.MainActivity&quot;,&#123; onMatch:function(instance)&#123; MainActivityHandle &#x3D; instance; &#125;,onComplete()&#123;&#125; &#125;) console.log(&quot;MainActivityHandle is &#x3D;&gt; &quot;,MainActivityHandle)&#125;) function fridamethod01(plaintext)&#123; var result; &#x2F;&#x2F; method01 是 静态方法，使用Java.use Java.perform(function()&#123; var MainActivity &#x3D; Java.use(&quot;com.example.demoso1.MainActivity&quot;); var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) result &#x3D; MainActivity.method01(javaString.$new(plaintext)) &#125;) return result;&#125;function fridamethod02(ciphertext)&#123; var result; Java.perform(function()&#123; &#x2F;&#x2F; method02 是 动态方法，使用Java.choose var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) &#x2F;&#x2F; Java.choose(&quot;com.example.demoso1.MainActivity&quot;,&#123; &#x2F;&#x2F; onMatch:function(instance)&#123; &#x2F;&#x2F; MainActivityHandle &#x3D; instance.method02(javaString.$new(ciphertext)); &#x2F;&#x2F; &#125;,onComplete()&#123;&#125; &#x2F;&#x2F; &#125;) result &#x3D; MainActivityHandle.method02(javaString.$new(ciphertext)) &#125;) return result;&#125; hook主机中 ./fs128arm64 -l 0.0.0.0:8888frida -H 192.168.0.105:8888 -F -l hookandinvoke.js 手机ipobjection -N -h 192.168.0.105 -p 8888 -g com.example.demoso1 explore 远程objection连接 123456HTTP 每次都是新连接 速度慢RPC 是 TCP流，速度快rpc.exports&#x3D;&#123; fridamethod01:fridamethod01, fridamethod02:fridamethod02,&#125; rpc调用curl -s -X POST “http://127.0.0.1:5000/encrypt&quot; -H “Content-Type: application/json” -d ‘{“data”: “roysue”}’ curl -s -X POST “http://127.0.0.1:5000/decrypt&quot; -H “Content-Type: application/json” -d ‘{“data”: “47fcda3822cd10a8e2f667fa49da783f”}’ 123456789101112131415device &#x3D; frida.get_device_manager().add_remote_device(&quot;192.168.0.105:8888&quot;)# 启动&#96;demo01&#96;这个apppid &#x3D; device.spawn([&quot;com.example.demoso1&quot;])device.resume(pid)time.sleep(1)session &#x3D; device.attach(pid)# 加载脚本with open(&quot;hookandinvoke.js&quot;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot; , my_message_handler) #调用错误处理script.load()print(script.exports.fridamethod01(&quot;roysue&quot;))print(script.exports.fridamethod02(&quot;47fcda3822cd10a8e2f667fa49da783f&quot;)) python hookandinvoke.py 压测http并发性能https://github.com/JoeDog/siege 压测 apt install siege https://www.jianshu.com/p/74c465ff136f 1siege -c5 -r10 \"http://127.0.0.1:5000/encrypt POST &lt;./iloveroysue.json \" nps 内网穿透客户端：linux_arm64_client.tar.gz 因为n5x是kali nethunter系统，chmod 777 * &amp;&amp; ./npc，启动npc 服务端：https://ehang-io.github.io/nps/#/run 添加隧道，端口映射 add_remote_device 修改远程地址，将手机ip和kali主机ip暴露公网调用，通过siege压测 device = frida.get_device_manager().add_remote_device(“192.168.0.105:8888”) 手机ip linux_arm64_client.tar.gz device = frida.get_device_manager().add_remote_device(“118.126.66.193:58888”) npc和frida都在手机上，新增客户端，启动npc，手机ip公网映射添加隧道58888目标8888 siege -c5 -r10 “http://127.0.0.1:5000/encrypt POST &lt;./iloveroysue.json “ 启动py脚本 linux_amd64_client.tar.gz device = frida.get_device_manager().add_remote_device(“118.126.66.193:48888”) npc在kali上，新增客户端，启动npc，配置隧道服务端口55000目标5000端口，手机ip公网映射48888目标192.168.0.105:8888 siege -c5 -r10 “http://118.126.66.193:55000/encrypt POST &lt;./iloveroysue.json “ 启动py脚本 Native层主动调用demoso1基于https://www.jianshu.com/p/0390f598c34c 12objection -g com.example.demoso1 explorememory list exports libnative-lib.so 查看导出函数，静态函数直接搜索 _Z8method01P7_JNIEnvP7_jclassP8_jstring 通过搜索http://demangler.com/ 拿到原函数名 或者通过https://github.com/lasting-yang/frida_hook_libart.git frida -U -f com.example.demoso1 -l hook_RegisterNatives.js –no-pause 查看原始方法名 修改hook_RegisterNatives，添加hookMethod01和invokemethod02 123456789101112131415161718192021222324252627282930313233343536373839在hook_RegisterNatives方法中添加 if(name.indexOf(&quot;method01&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F;hookmethod(fnPtr_ptr); &#x2F;&#x2F;replacehook(fnPtr_ptr); method01addr &#x3D; fnPtr_ptr; &#125;else if (name.indexOf(&quot;method02&quot;)&gt;&#x3D;0)&#123; method02addr &#x3D; fnPtr_ptr; method02 &#x3D; new NativeFunction(method02addr,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;pointer&#39;,&#39;pointer&#39;]); &#125;else&#123; continue; &#125;新增invokemethod01function invokemethod01(contents)&#123; console.log(&quot;ENV&#x3D;&gt;&quot;,ENV) console.log(&quot;JCLZ&#x3D;&gt;&quot;,JCLZ); console.log(&quot;method01_addr is &#x3D;&gt;&quot;,method01addr) var method01 &#x3D; new NativeFunction(method01addr,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;pointer&#39;,&#39;pointer&#39;]); var NewStringUTF &#x3D; new NativeFunction(addrNewStringUTF,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;pointer&#39;]) var result &#x3D; null; Java.perform(function()&#123; console.log(&quot;Java.vm.getEnv()&quot;,Java.vm.getEnv()) var JSTRING &#x3D; NewStringUTF(Java.vm.getEnv(),Memory.allocUtf8String(contents)) result &#x3D; method01(Java.vm.getEnv(),JSTRING,JSTRING); console.log(&quot;result is &#x3D;&gt;&quot;,result) console.log(&quot;result is &quot;,Java.vm.getEnv().getStringUtfChars(result, null).readCString()) result &#x3D; Java.vm.getEnv().getStringUtfChars(result, null).readCString(); &#125;) return result;&#125;新增invokemethod02function invokemethod02(contents)&#123; var result &#x3D; null; Java.perform(function()&#123; var JSTRING &#x3D; NewStringUTF(Java.vm.getEnv(),Memory.allocUtf8String(contents)) result &#x3D; method02(Java.vm.getEnv(),JSTRING,JSTRING); result &#x3D; Java.vm.getEnv().getStringUtfChars(result, null).readCString(); &#125;) return result;&#125; jni 获取类(jclass)的方式 1.需要new 一个对象时需要jclass.2.需要调用这个对象的方法或者属性时需要jclass.3.jclass 不需要释放. 12345获取对象类jclass GetObjectClass_(JNIEnv* jni, jobject object) &#123; jclass c = jni-&gt;GetObjectClass(object); return c;&#125; 12直接找到类名jclass long_cls &#x3D; env-&gt;FindClass(&quot;java&#x2F;lang&#x2F;Long&quot;); rpc1234rpc.exports &#x3D; &#123; invoke1:invokemethod01, &#x2F;&#x2F; 导出名不可以有大写字母或者下划线 invoke2:invokemethod02&#125;; init.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import timeimport fridafrom flask import Flask, jsonify, requestimport jsondef my_message_handler(message , payload): #定义错误处理 print(message) print(payload)# 连接安卓机上的frida-server#device &#x3D; frida.get_device_manager().add_remote_device(&quot;192.168.0.3:8888&quot;)#device &#x3D; frida.get_device_manager().add_remote_device(&quot;118.126.66.193:58888&quot;)device &#x3D; frida.get_device_manager().add_remote_device(&quot;192.168.0.105:8888&quot;)#device &#x3D; frida.get_usb_device()# 启动&#96;demo01&#96;这个apppid &#x3D; device.spawn([&quot;com.example.demoso1&quot;])session &#x3D; device.attach(pid)# 加载脚本with open(&quot;hook_RegisterNatives.js&quot;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot; , my_message_handler) #调用错误处理script.load()time.sleep(3)device.resume(pid)time.sleep(3)print(script.exports.invoke1(&quot;onejane&quot;))print(script.exports.invoke2(&quot;c6138f96658ce0cb845bdab0f9616273&quot;))# 脚本会持续运行等待输入#input()app &#x3D; Flask(__name__)@app.route(&#39;&#x2F;encrypt&#39;, methods&#x3D;[&#39;POST&#39;])#url加密def encrypt_class(): data &#x3D; request.get_data() json_data &#x3D; json.loads(data.decode(&quot;utf-8&quot;)) postdata &#x3D; json_data.get(&quot;data&quot;) #print(postdata) res &#x3D; script.exports.invoke1(postdata) return res @app.route(&#39;&#x2F;decrypt&#39;, methods&#x3D;[&#39;POST&#39;])#data解密def decrypt_class(): data &#x3D; request.get_data() json_data &#x3D; json.loads(data.decode(&quot;utf-8&quot;)) postdata &#x3D; json_data.get(&quot;data&quot;) res &#x3D; script.exports.invoke2(postdata) return res if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.run() 端口usb连接，主机连接adb, ./fs128arm64 -l 0.0.0.0:8888 启动frida server 脱离apk7z x demoso1/app/build/outputs/apk/debug/app-debug.apk cp lib/arm64-v8a/libnative-lib.so 到 /data/app/libnative-lib.so 并赋予最高权限 adb push libnative-lib.so /data/app 12345678910frida -U -f com.android.settings -l hook_RegisterNatives.js --no-pauseobjection -g com.android.settings explore memory list modules 可以看到libnative-lib.so已经被加载memory list exports libnative-lib.so 找到两个函数名_Z8method01P7_JNIEnvP7_jclassP8_jstring，_Z8method02P7_JNIEnvP8_jobjectP8_jstringvar modulelibnative &#x3D; Module.load(&quot;&#x2F;data&#x2F;app&#x2F;libnative-lib.so&quot;) &#x2F;&#x2F; 加载somethod01addr &#x3D; modulelibnative.findExportByName(&quot;_Z8method01P7_JNIEnvP7_jclassP8_jstring&quot;)method02addr &#x3D; modulelibnative.findExportByName(&quot;_Z8method02P7_JNIEnvP8_jobjectP8_jstring&quot;)修改init.py中pid &#x3D; device.spawn([&quot;com.android.settings&quot;]) RPC（TCP） 远快于 HTTP,手机暴露frida-server，它是一个TCP，效率很高 自吐算法摘要adb install HookTestDemo.apk jadx-gui HookTestDemo.apk frida -UF -l hookEvent.js 所有点击事件hook，发现所有触发类都是MainActivity 普通方法123456789101112131415161718case R.id.putong &#x2F;*&#123;ENCODED_INT: 2131165291&#125;*&#x2F;: toastPrint(Utils.getCalc(2000, 2000) + BuildConfig.FLAVOR); toastPrint(new Money.innerClass(&quot;资源吧&quot;, 666).outPrint()); return;static class innerClass &#123; private String name; private int num; public innerClass(String name2, int num2) &#123; this.name &#x3D; name2; this.num &#x3D; num2; &#125; public String outPrint() &#123; return &quot;内部类被调用&quot; + this.name + &quot;: &quot; + this.num; &#125;&#125; objection探索一波，枚举不准的话，延迟加载，每个按钮都点一次触发类 1234567objection -g com.xiaojianbang.app explore -P ~&#x2F;.objection&#x2F;plugins android hooking search classes com.xiaojianbang.app 找不到Money类android hooking list classes cat ~&#x2F;.objection&#x2F;objection.log | grep -i &quot;com.xiaojianbang.app&quot;plugin wallbreaker classdump --fullname com.xiaojianbang.app.Moneyandroid heap search instances com.xiaojianbang.app.MainActivity.&#x2F;fs1426arm64 hook主动调用内部类 12345678910111213141516171819202122232425262728293031323334var MainActivity &#x3D; null;Java.perform(function () &#123; Java.choose(&quot;com.xiaojianbang.app.MainActivity&quot;, &#123; onMatch: function (instanse) &#123; MainActivity &#x3D; instanse; console.log(&quot;found instance &#x3D;&gt; &quot;, MainActivity); &#125;, onComplete: function () &#123; console.log(&quot;search completed!&quot;) &#125; &#125;)&#125;)function showToast(string) &#123; Java.perform(function () &#123; &#x2F;&#x2F; UI thread 注入 var Toast &#x3D; Java.use(&#39;android.widget.Toast&#39;); var currentApplication &#x3D; Java.use(&#39;android.app.ActivityThread&#39;).currentApplication(); var context &#x3D; currentApplication.getApplicationContext(); &#x2F;&#x2F; 在线程上运行指定的函数 Java.scheduleOnMainThread(function () &#123; Toast.makeText(context, string, Toast.LENGTH_LONG.value).show(); &#125;) &#125;)&#125;function invokeNormal() &#123; Java.perform(function () &#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) &#x2F;&#x2F; 静态内部函数 var MoneyInnerClass &#x3D; Java.use(&quot;com.xiaojianbang.app.Money$innerClass&quot;).$new(javaString.$new(&quot;J&quot;), 666).outPrint(); console.log(&quot;result &#x3D;&gt;&quot;, MoneyInnerClass) showToast(javaString.$new(MoneyInnerClass)) &#125;)&#125; frida -UF -l hookxjb.js [Pixel::HookTestDemo]-&gt; result =&gt; 内部类被调用J: 666 构造实例方法1234567891011case R.id.gouzao &#x2F;*&#123;ENCODED_INT: 2131165257&#125;*&#x2F;: if (money &#x3D;&#x3D; null) &#123; money &#x3D; new Money(&quot;美元&quot;, 1000); &#125; toastPrint(&quot;money: &quot; + money.getInfo()); toastPrint(Utils.getMoney().getInfo()); toastPrint(new Money().name()); public String name() &#123; return &quot;my name is xiaojianbang&quot;;&#125; frida -UF -l hookxjb.js invokeInit() 1234567function invokeInit() &#123; Java.perform(function () &#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) var MoneyName &#x3D; Java.use(&quot;com.xiaojianbang.app.Money&quot;).$new().name(); showToast(javaString.$new(MoneyName)) &#125;)&#125; 重载方法1234567891011121314151617case R.id.chongzai &#x2F;*&#123;ENCODED_INT: 2131165233&#125;*&#x2F;: toastPrint(Utils.test(666)); toastPrint(Utils.test()); toastPrint(Utils.test(new Money(&quot;港币&quot;, 7000))); toastPrint(new Money() &#123; &#x2F;* class com.xiaojianbang.app.MainActivity.AnonymousClass1 *&#x2F; @Override &#x2F;&#x2F; com.xiaojianbang.app.Money public String getInfo() &#123; return &quot;匿名类被调用&quot;; &#125; &#125;.getInfo()); return;public static String test(int num) &#123; return &quot;www.zygx8.com &quot; + num;&#125; android hooking list class_methods com.xiaojianbang.app.Utils 1234567function invokeOverload() &#123; Java.perform(function () &#123; &#x2F;&#x2F; 静态重载方法 var result &#x3D; Java.use(&quot;com.xiaojianbang.app.Utils&quot;).test(666); console.log(&quot;invoke overload result is &#x3D;&gt; &quot;, result); &#125;)&#125; frida -UF -l hookxjb.js invokeOverload() 对象参数123456789101112131415case R.id.duixiang &#x2F;*&#123;ENCODED_INT: 2131165247&#125;*&#x2F;: toastPrint(Utils.test(new Money(&quot;美元&quot;, 200))); toastPrint(new Utils().myPrint(new String[]&#123;&quot;资源共享吧&quot;, &quot;官网&quot;, &quot;:&quot;, &quot;www.zygx8.com&quot;&#125;)); return;public static String test(Money money) &#123; return money.getInfo();&#125;public String myPrint(String[] strArr) &#123; StringBuilder sb &#x3D; new StringBuilder(); for (String str : strArr) &#123; sb.append(str); &#125; return sb.toString();&#125; frida -UF -l hookxjb.js invokeOverload() 1234567891011121314function invokeObject() &#123; Java.perform(function () &#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) var newMoney &#x3D; Java.use(&quot;com.xiaojianbang.app.Money&quot;).$new(javaString.$new(&quot;dollar&quot;), 200); var result &#x3D; Java.use(&quot;com.xiaojianbang.app.Utils&quot;).test(newMoney); showToast(javaString.$new(result)) var StringArray &#x3D; Java.array(&quot;java.lang.String&quot;, [javaString.$new(&quot;J &quot;), javaString.$new(&quot;you are the &quot;), javaString.$new(&quot;best &quot;)]) var result &#x3D; Java.use(&quot;com.xiaojianbang.app.Utils&quot;).$new().myPrint(StringArray); showToast(javaString.$new(result)) &#125;)&#125; Native12345678case R.id.helloFromC &#x2F;*&#123;ENCODED_INT: 2131165260&#125;*&#x2F;: toastPrint(NativeHelper.helloFromC()); return;case R.id.add &#x2F;*&#123;ENCODED_INT: 2131165218&#125;*&#x2F;: toastPrint(NativeHelper.add(5, 6, 7) + BuildConfig.FLAVOR); return; public static native String helloFromC(); public static native int add(int i, int i2, int i3); frida -UF -l hookxjb.js invokeNative() 123456789101112function invokeNative() &#123; Java.perform(function () &#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) var result &#x3D; Java.use(&quot;com.xiaojianbang.app.NativeHelper&quot;).helloFromC(); showToast(javaString.$new(result)); result &#x3D; Java.use(&quot;com.xiaojianbang.app.NativeHelper&quot;).add(100, 200, 300); showToast(javaString.$new(String(result))); &#125;)&#125; MD512345678case R.id.JavaMD5 &#x2F;*&#123;ENCODED_INT: 2131165191&#125;*&#x2F;: toastPrint(MD5.md5_1(&quot;xiaojianbang&quot;)); return;public static String md5_1(String args) throws Exception &#123; MessageDigest md &#x3D; MessageDigest.getInstance(&quot;MD5&quot;, &quot;BC&quot;); md.update(args.getBytes()); return Utils.byteToHexString(md.digest());&#125; hook类java.security.MessageDigest中所有的方法包括md5 12345678910111213141516171819202122232425262728function hookMD5() &#123; Java.perform(function () &#123; var targetClassMethod &#x3D; &quot;java.security.MessageDigest.getInstance&quot; var delim &#x3D; targetClassMethod.lastIndexOf(&quot;.&quot;); if (delim &#x3D;&#x3D;&#x3D; -1) return; var targetClass &#x3D; targetClassMethod.slice(0, delim) var targetMethod &#x3D; targetClassMethod.slice(delim + 1, targetClassMethod.length) var hook &#x3D; Java.use(targetClass); var overloadCount &#x3D; hook[targetMethod].overloads.length; var overloadCount &#x3D; hook[targetMethod].overloads.length; for (var i &#x3D; 0; i &lt; overloadCount; i++) &#123; hook[targetMethod].overloads[i].implementation &#x3D; function () &#123; console.warn(&quot;\\n*** entered &quot; + targetClassMethod); &#x2F;&#x2F; print args if (arguments.length &gt;&#x3D; 0) &#123; for (var j &#x3D; 0; j &lt; arguments.length; j++) &#123; console.log(&quot;arg[&quot; + j + &quot;]: &quot; + arguments[j]); &#125; &#125; var retval &#x3D; this[targetMethod].apply(this, arguments); console.log(&quot;\\nretval: &quot; + retval); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return retval; &#125; &#125; &#125;)&#125; IDA从入门到理解 某加固系统运行信息获取frida 脚本 unidbg学习笔记 浅谈渗透江湖之细水柔情 领悟Frida的精髓_0512newCodeAndProject.zip","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"rpc","slug":"rpc","permalink":"http://onejane.github.io/tags/rpc/"},{"name":"so","slug":"so","permalink":"http://onejane.github.io/tags/so/"}]},{"title":"基于内存漫游定位分析","slug":"基于内存漫游定位分析","date":"2021-02-12T13:54:40.000Z","updated":"2021-06-07T14:48:07.275Z","comments":true,"path":"2021/02/12/基于内存漫游定位分析/","link":"","permalink":"http://onejane.github.io/2021/02/12/%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E6%BC%AB%E6%B8%B8%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90/","excerpt":"","text":"三板斧： 先hook、看参数和返回值，利用命令行定位 再利用命令行/写代码构造参数、主动调用 最后规模化利用PYTHON配RPC导出结果 基于内存漫游定位案例一adb install -r -t movetv.apk 移动tv onejane/123456,-r强制升级，-t允许装debug版本 jadx打开发现com.tecent.StubShell加壳，找不到MainActivity 123456pyenv local 3.8.0adb shell.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64objection -g com.cz.babySister exploreandroid hooking search classes com.wrapper.proxyapplicationandroid hooking watch class com.wrapper.proxyapplication.WrapperProxyApplication 该类在启动则被调用，attach将无法hook Frida附加app的两种模式： SPAWN：创建进程时就hook，有壳的话就不行 ATTACH：应用运行过程中hook，有壳也是ok 分析123android hooking list activitiesandroid intent launch_activity com.cz.babySister.activity.LoginActivity 指定启动Activityps -ef|grep baby 进程一直自动启动 objection -d -g com.cz.babySister explore --startup-command &quot;android hooking watch class com.wrapper.proxyapplication.WrapperProxyApplication&quot; 开启debug -d 由于该app会自动后台启动 需要在前台启动时立即使用objection漫游 批量hookandroid hooking search classes com.wrapper.proxyapplication 枚举包中所有类 12345com.wrapper.proxyapplication.CustomerClassLoadercom.wrapper.proxyapplication.MultiDexcom.wrapper.proxyapplication.MultiDex$V19com.wrapper.proxyapplication.Utilcom.wrapper.proxyapplication.WrapperProxyApplication 如何使用objection去批量hook和trace？ 把~/.objection/objection.log删掉； 到objection界面中运行android hooking list classes，列出所有的类； 对新生成的~/.objection/objection.log文件进行过滤，比如只关心http相关的。cat objection.log|grep -i http 将输出结果保存到一个excel列中，前面补全android hooking watch class xxxxx，另存为文本文件 加载这个文件：objection -g com.android.settings explore -c “2.txt” ，这样一下子就hook上了几千个相关类的所有方法及其所有重载。 如果trace感兴趣的方法也是同理，android hooking search methods * ，会打印出所有的方法。 vim hooklist.txt 12345android hooking watch class com.wrapper.proxyapplication.CustomerClassLoaderandroid hooking watch class com.wrapper.proxyapplication.MultiDexandroid hooking watch class com.wrapper.proxyapplication.MultiDex$V19android hooking watch class com.wrapper.proxyapplication.Utilandroid hooking watch class com.wrapper.proxyapplication.WrapperProxyApplication objection -g com.cz.babySister explore -c “hooklist.txt” 批量hook android hooking list class_methods com.wrapper.proxyapplication.Util 枚举类中所有方法 Zentraceradb shell &amp;&amp; top 根据负载查看包名 java.net.HttpUrlConnection 1234objection -g com.cz.babySister explore --startup-command &quot;android hooking watch class java.net.HttpURLConnection&quot;jobs listjobs kill idandroid hooking watch class_method java.net.HttpURLConnection.getFollowRedirects --dump-args 登录发现堆栈来自于com.cz.babySister.c.a.a 通过jadx搜索com.cz.babySister.c.a.a所在类，通过android hooking watch class com.cz.babySister.c.a进行trace类 通过android hooking watch class_method com.cz.babySister.c.a.a --dump-args --dump-backtrace --dump-return 进行trace方法 什么叫trace？hook多了就成了trace 系统框架是不可能被混淆的，基于枚举的内存漫游定位思路的含义是：怀疑你使用了什么框架API、怀疑你经过了哪个包哪处地方、就去那里埋伏起来，等待经过。 针对混淆后的okhttp3,通过Frida实现的拦截okhttp脚本 ./data/local/tmp/fs1428arm64 cd ZenTracer &amp;&amp; proxychains pip install PyQt5 &amp;&amp; python ZenTracer.py 报错：Could not load the Qt platform plugin “xcb” in “” even though it was found 1export QT_DEBUG_PLUGINS&#x3D;1 python ZenTracer.py ldd libqxcb.so 查看具体哪个so文件为not found apt install libxcb-util1 libxcb-xinerama0 Action-Match RegEx Action-Start 启动trace,登录trace保存为json thunar . 打开当前目录 查看babySister查看json 极端情况：Match RegEx 填写com.cz.babySister主包名，trace所有的方法 1234objection -g com.cz.babySister exploreandroid hooking search classes com.cz.babySistercat ~&#x2F;.objection&#x2F;objection.log|grep com.cz.babySister 拿到所有的类 在前面添加命令 android hooking watch class保存到classes.txt中objection -g com.cz.babySister explore -c classes.txt 实现批量hook 案例二adb install xes.apk 123456objection -g com.xes.jazhanghui.activity explore -P ~&#x2F;.objection&#x2F;plugins 启动objection加载所有插件android hooking search classes okhttp3android hooking list class_methods okhttp3.OkHttpClientandroid heap search instances okhttp3.OkHttpClient 找到对象实例plugin wallbreaker objectsearch okhttp3.OkHttpClient 拿到ok3对象的地址，如混淆在jadx中找到ok3的类注释中的renameplugin wallbreaker objectdump --fullname 0x37d2 分析adb push okhttplogging.dex /data/local/tmp adb push myok2curl.dex /data/local/tmp cd ~/Desktop/frida-agent-example &amp;&amp; npm run watch frida -UF -l hookOkhttp3.js 通过adb logcat | grep “okhttpGet”查看log 原生：离解释器更近：安卓原生就是dex被libart.so来解释、linux原生就是CPU直接解释的机器码 123ps -e |grep -i chromeobjection -g com.android.chrome explorememory list modules 发现dex被libart.so加载解析执行 脱壳frida_fart 12cd frida_fart &amp;&amp; adb push lib&#x2F;* &#x2F;data&#x2F;local&#x2F;tmpcd &#x2F;data&#x2F;local&#x2F;tmp&#x2F; &amp;&amp; cp fart* &#x2F;data&#x2F;app &amp;&amp; cd &#x2F;data&#x2F;app &amp;&amp; chmod 777 fart* 加权限 修改源码dex保存路径：var savepath = “/sdcard/com.cz.babySister.activity/“; 1234mkdir &#x2F;sdcard&#x2F;com.cz.babySister.activity&#x2F; frida -U -f com.cz.babySister -l frida_fart_reflection.js --no-pausefrida -UF -l frida_fart_reflection.jsfrida -U -f com.cz.babySister -l frida_fart_hook.js --no-pause 基于安卓8，生成dex frida-dexdump 核心原理：进程级别的内存漫游 cd ~/.objection/plugins/dexdump &amp;&amp; python main.py 自动脱壳(前台运行的学而思app) cd com.xes.jazhanghui.activity &amp;&amp; grep -ril “okhttp3.OkHttpClient” * du -h * 查看文件最大的dex使用jadx打开 objection -g com.xes.jazhanghui.activity explore -P ~/.objection/plugins android hooking list activities 在jadx中查找到dex包含com.xes.jazhanghui.activity.mvp.live.activity.LiveMainActivity 同理：脱壳移动TV，grep -ril “MainActivity” *,grep -ril “LoginActivity” *,找到唯一入口dex 案例三adb install 免费电影院v2.1.0_210.apk 分析静态：通过jadx搜索OkHttpClient,或者apktool d 免费电影院v2.1.0_210.apk &amp;&amp; grep -ril &quot;OkHttpClient&quot; * 动态： 12345cat smali&#x2F;فمضﺝ&#x2F;ﻙﺫتك$ﺯﺵتﻝ.smali拿到.class public Lفمضﺝ&#x2F;ﻙﺫتك;类名objection -g com.singleman.freevideo explore -P &#x2F;root&#x2F;.objection&#x2F;plugins 点击登录调用ok3plugin wallbreaker objectsearch فمضﺝ.ﻙﺫتكplugin wallbreaker objectdump --fullname 0x2452 查看该类是否ok3Client，获取其中List&lt;Interceptor&gt;地址，用wallbreaker dump下来class为Collections$UnmodifiableRandomAccessList 即为OkHttpClient类 在hookOkhttp3.js中实现hook 12345678910111213141516171819202122Java.choose(&quot;فمضﺝ.ﻙﺫتك&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;1. found instance:&quot;,instance) &#x2F;&#x2F;console.log(&quot;2. instance.interceptors():&quot;,instance.interceptors().$className) console.log(&quot;3. instance._interceptors:&quot;,instance.ﻭﻍﺫﻉ.value.$className) &#x2F;&#x2F;console.log(&quot;4. interceptors:&quot;,gson2.$new().toJson(instance.interceptors())) console.log(&quot;5. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(instance.ﻭﻍﺫﻉ.value.toArray())) &#x2F;* var newInter &#x3D; Java.use(&quot;java.util.ArrayList&quot;).$new(); newInter.addAll(instance.interceptors()); console.log(&quot;6. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(newInter.toArray())); console.log(&quot;7. interceptors:&quot;,newInter.$className); newInter.add(MyInterceptorObj); newInter.add(curlInter); instance._interceptors.value &#x3D; newInter; *&#x2F; &#125;,onComplete:function()&#123; console.log(&quot;Search complete!&quot;) &#125;&#125;) 案例四1234567adb install 中国移动7.0.0.apkadb shell 打开app前台运行，top查看包名ps -ef|grep greenpm -l | grep green 查看包名pyenv local 3.9.0.&#x2F;fs14216arm64objection -g com.greenpoint.android.mc10086.activity explore 该样本是多进程 1234cat &#x2F;proc&#x2F;11929&#x2F;status 发现该进程被子进程进行attach了，TracerPid: 11958frida -U -f com.greenpoint.android.mc10086.activity 因为frida比子进程快，attch后没有释放父进程%resume 会直接挂掉Process terminatedfrida -UF 报双进程错unable to access process with pid 13250 due to system restrictions; wget hluda-server-14.2.16-android-arm64 12345.&#x2F;hluda14216arm64frida -U -f com.greenpoint.android.mc10086.activity%resumeproxychains git clone https:&#x2F;&#x2F;github.com&#x2F;r0ysue&#x2F;r0tracer.gitfrida -U -f com.greenpoint.android.mc10086.activity -l r0tracer.js -o cmcc.txt frida是app进程启动时spawn注入比任何程序都快，注入成功就dettach掉，trace id为父进程，子进程就可以回头调试主进程。frida server和脚本是进程间通信，即socket通信。 用objection不管是spawn还是attach都失败的双进程，frida命令的话可以先不加--no-pause，然后手动%resume就可以使用hluda进行hook上了。 基于Frida的Hook案例一adb install -r -t junior.apk 开启远程调用frida -UF -l demo.js 像素显示dip2px123456789101112131415161718objection -g com.example.junior explore -P ~&#x2F;.objection&#x2F;plugins 加载所有插件android hooking list activities 查看用于展示的界面android intent launch_activity com.example.junior.CalculatorActivity 启动计算器界面cat objection.log | grep com.example.junior.util.Utilsandroid hooking list class_methods com.example.junior.util.Utils 打印来中所有可hook的函数android hooking watch class_method com.example.junior.util.Utils.dip2px --dump-args --dump-return --dump-backtrace hook方法并打印像素显示出入参与调用栈function main() &#123; Java.perform(function () &#123;&#x2F;&#x2F;只要是java的代码都要跑在Java.perform里面 console.log(&quot;Entering Hook!&quot;) Java.use(&quot;com.example.junior.util.Utils&quot;).dip2px.implementation &#x3D; function (context, float) &#123; &#x2F;&#x2F;return null; var result &#x3D; this.dip2px(context, 100) console.log(&quot;context,float,result &#x3D;&#x3D;&gt; &quot;, context, float, result); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return 26; &#125; &#125;)&#125; 分辨率显示setTexthook用不上Java.choose的，hook函数时不分动静态 123456789101112131415161718192021222324252627282930android intent launch_activity com.example.junior.ScreenActivity cat objection.log|grep -i android.widget.TextViewandroid hooking list class_methods android.widget.TextView 打印来中所有可hook的函数android hooking watch class_method android.widget.TextView.setText --dump-args --dump-backtrace --dump-return hook公共方法setTextandroid heap search instances com.example.junior.ScreenActivity 搜索activity类内存地址android heap execute 0x6f72 showScreenInfo 主动调用该类的指定方法，frida端hook自动执行function Screen() &#123; Java.perform(function () &#123; &#x2F;&#x2F; 重载 Java.use(&quot;android.widget.TextView&quot;).setText.overload(&#39;java.lang.CharSequence&#39;).implementation &#x3D; function (text) &#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;); var newString &#x3D; javaString.$new(&quot;onejane&quot;) var result &#x3D; null; var realText &#x3D; String(text); console.log(&quot;real text is &#x3D;&#x3D;&gt; &quot;,realText); if (realText.indexOf(&quot;junior&quot;) &gt;&#x3D; 0) &#123; var result &#x3D; this.setText(newString); console.log(&quot;text,result &#x3D;&#x3D;&gt; &quot;, newString, result); &#125; else &#123; var result &#x3D; this.setText(text); console.log(&quot;text,result &#x3D;&#x3D;&gt; &quot;, text, result); &#125; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return result; &#125; &#125;)&#125; 计算器123456789101112131415161718192021222324cat objection.log|grep -i com.example.junior.util.Arithandroid hooking list class_methods com.example.junior.util.Arith 查看Arith类有哪些hook的方法android hooking watch class_method com.example.junior.util.Arith.sub --dump-args --dump-backtrace --dump-return hook静态方法subfunction Equals()&#123; Java.perform(function()&#123; Java.use(&quot;java.lang.String&quot;).equals.implementation &#x3D; function(obj)&#123; var result &#x3D; this.equals(obj); console.log(&quot;obj,result &#x3D;&#x3D;&gt; &quot;,obj,result); return result; &#125; &#125;)&#125;function sub()&#123; Java.perform(function()&#123; Java.use(&quot;com.example.junior.util.Arith&quot;).sub.overload(&#39;java.lang.String&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function(str1,str2)&#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) var result &#x3D; this.sub(str1,javaString.$new(&quot;2&quot;)); &#x2F;&#x2F; 本质上属于主动调用构造函数 console.log(&quot;str1,str2,result&#x3D;&#x3D;&gt;&quot;,str1,str2,result) return javaString.$new(&quot;10&quot;); &#125; &#125;)&#125; 静态变量运行junior的计算器 12plugin wallbreaker classsearch Arith 内存漫游搜索Arith类plugin wallbreaker classdump --fullname com.example.junior.util.Arith 将Arith类dump发现有静态变量 通过frida获取静态变量DEF_DIV_SCALE并修改值为20，内存中的静态变量DEF_DIV_SCALE即变为20 123456789function staticField()&#123; Java.perform(function()&#123; var divscale &#x3D; Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value; console.log(&quot;divscale1 is &#x3D;&gt;&quot;,divscale); Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value&#x3D;20; divscale &#x3D; Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value; console.log(&quot;divscale2 is &#x3D;&gt;&quot;,divscale); &#125;)&#125; 静态主动调用frida -UF -l demo.js主动调用Arith.add方法 123456function operate()&#123; Java.perform(function()&#123; var Arith &#x3D; Java.use(&quot;com.example.junior.util.Arith&quot;); console.log(&quot;addResult is &#x3D;&gt;&quot;,Arith.add(&quot;1&quot;,&quot;1&quot;)); &#125;)&#125; plugin wallbreaker classsearch Build 搜索含有Build的类 plugin wallbreaker classdump --fullname android.os.Build 将Build类dump下来 123456789function fingerPrint()&#123; Java.perform(function()&#123; var Build &#x3D; Java.use(&quot;android.os.Build&quot;); console.log(Build.DEVICE.value,Build.ID.value,Build.MODEL.value,Build.SERIAL.value); Build.SERIAL.value &#x3D; &#39;F123456&#39;; console.log(Build.SERIAL.value,Build.getSerial()); &#x2F;&#x2F; 若app无权限getSerial()，换设置重新主动调用 console.log(&#39;sdk is &#39;,Build.getString(&quot;ro.build.version.sdk&quot;)); &#125;)&#125; 动态变量plugin wallbreaker objectsearch com.example.junior.CalculatorActivity 获取该类地址 plugin wallbreaker objectdump 0x1eea 计算1+2=3后查看该类的动态变量 寻找CalculatorActivity实例，通过frida动态hook，通过修改showText值时内存中变量变为123 12345678910111213function dynamicField()&#123; Java.perform(function()&#123; Java.choose(&quot;com.example.junior.CalculatorActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance &#x3D;&gt;&quot;,instance); console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.showText.value) instance.showText.value &#x3D; &quot;123&quot; &#125;,onComplete:function()&#123; console.log(&#39;Search complete&#39;) &#125; &#125;) &#125;)&#125; 动态主动调用动态调用有参函数，计算机显示666，打印666 12345678910111213function dynamic()&#123; Java.perform(function()&#123; Java.choose(&quot;com.example.junior.CalculatorActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance &#x3D;&gt;&quot;,instance); console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.clear(&quot;666&quot;)) console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.showText.value) &#125;,onComplete:function()&#123; console.log(&#39;Search complete&#39;) &#125; &#125;) &#125;)&#125; RPC调用12345678910111213141516171819import frida# device&#x3D;frida.get_device_manager().add_remote_device(&#39;192.168.0.100:5555&#39;) 远程连接.&#x2F;fs128arm64 -l 0.0.0.0:5555,可定义多个device实现批量自动化群控device &#x3D; frida.get_usb_device()### attachpid&#x3D;device.get_frontmost_application().pid # 若双进程保护，指定pid进行hooksession &#x3D; device.attach(pid)### spawn #pid &#x3D; device.spawn([&quot;com.example.junior&quot;])#device.resume(pid)#time.sleep(1)#session &#x3D; device.attach(pid)with open(&quot;demo.js&quot;) as f: script &#x3D; session.create_script(f.read())script.load()input() 键盘操作input keyevent 4 表示后退 1234567function subcommand()&#123; Java.perform(function()&#123; &#x2F;&#x2F; adb input api var process &#x3D; Java.use(&#39;java.lang.Runtime&#39;).getRuntime().exec(&#39;input keyevent 4&#39;); console.log(&#39;subcommand success process is &#39;, process) &#125;)&#125; 循环调用 demo.js中导出指定方法 123rpc.exports &#x3D; &#123; subcommand: subcommand&#125; demo.py中开启循环 1234567command &#x3D; &quot;&quot;while 1 &#x3D;&#x3D; 1: command &#x3D; input(&quot;Enter command:\\n1: Exit\\n2: Call secret function\\nchoice:&quot;) if command &#x3D;&#x3D; &quot;1&quot;: break elif command &#x3D;&#x3D; &quot;2&quot;: # 在这里调用，可以设置多个条件判断 script.exports.subcommand() 输入2对当前进程持续后退 案例二利用nps实现启动了frida-server和nps-client的device的内网穿透，真正意义上实现批量自动化群控 案例三利用ssr通过nps内网穿透实现4G作为出口ip代理供request/scrapy调用 objection和frida不可同时hook一个函数, hook Non-ASCII 对于有些混淆后不可见或乱码的函数名，可以先编码打印出来, 再用编码后的字符串去 hook. 123456789101112131415161718192021Java.perform( function x() &#123; var targetClass &#x3D; &quot;com.example.hooktest.MainActivity&quot;; var hookCls &#x3D; Java.use(targetClass); var methods &#x3D; hookCls.class.getDeclaredMethods(); for (var i in methods) &#123; console.log(methods[i].toString()); console.log(encodeURIComponent(methods[i].toString().replace(&#x2F;^.*?\\.([^\\s\\.\\(\\)]+)\\(.*?$&#x2F;, &quot;$1&quot;))); &#125; hookCls[decodeURIComponent(&quot;%D6%8F&quot;)] .implementation &#x3D; function (x) &#123; console.log(&quot;original call: fun(&quot; + x + &quot;)&quot;); var result &#x3D; this[decodeURIComponent(&quot;%D6%8F&quot;)](900); return result; &#125; &#125;) hook Intent MainActivity中Intent intent2 = new Intent(this, Class.forName(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;));我们通过frida打印Intent 参考资料： Android App 保护那些事儿 （一） Android App 保护那些事儿 (二) frida dexclassloader 从三道题目入手入门frida Frida 入门小练习 举杯邀Frida，对影成三题 Null混淆 Android 字符串及字典混淆开源实现 资源压缩 Android微信逆向–实现发朋友圈动态 微信朋友圈分析 实用FRIDA进阶：脱壳、自动化、高频问题","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"加壳与脱壳之基本原理","slug":"加壳与脱壳之基本原理","date":"2021-02-04T02:39:05.000Z","updated":"2021-06-07T14:48:07.270Z","comments":true,"path":"2021/02/04/加壳与脱壳之基本原理/","link":"","permalink":"http://onejane.github.io/2021/02/04/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","excerpt":"","text":"逆向基本流程 使用自动化检测工具检测apk是否加壳，或者借助一些反编译工具依靠经验推断是否加壳 GDA3.85 或者 常见so文件 《娜迦》企业版本加固 libedog.so 《娜迦》免费版本加固 libddog.so 《梆梆》企业版本加固 libDexHelper.so 《梆梆》免费版本加固 libsecexe.so 《爱加密》企业版本加固 ijiami.ajm 《爱加密》免费版本加固 libexec.so 《通付盾》加固 libegis.so 《360》加固 libprotectClass.so，libjiagu.so 《百度》加固 libbaiduprotect.so 《阿里》加固 libmobisec.so 《腾讯》加固 libtup.so 《盛大》加固 libapssec.so 《瑞星》加固 librsprotect.so 《网秦》加固 nqdata 《国信灵通》加固 libnqshield.so 《apkprotect》加固 apkprotect 《几维安全》加固 libkwscmm.so，libkwscr.so，libkwslinker.so 《UU安全》加固 libuusafe.jar.so，libuusafe.so，libuusafeempty.so 几维安全 lib/armeabi-v7a/libkwscmm.so，lib/armeabi-v7a/libkwscr.so，lib/armeabi-v7a/libkwslinker.so UU安全 assets/libuusafe.jar.so，assets/libuusafe.so，lib/armeabi/libuusafeempty.so 如果apk加壳，则需要首先对apk进行脱壳 使用jeb，jadx，apktool等反编译工具对apk进行反编译 如果反编译工具打不开，使用010Editor把文件魔术字修复前8个字节 64 65 78 0A 30 33 35 00 dex.035. 再使用jadx反编译 grep -ril “MainAcitvity” ./*.txt 找到对应dex前缀名 先依据静态分析中得到的关键字字符串，关键api调用等方法快速定位需要分析的关键函数和流程 如果依据简单的字符串，关键api无法快速定位，则apk可能使用了字符串加密，反射调用等手段，此时可以结合hook，动态调试等 定位到关键函数后，再根据是java实现还是jni实现进一步分析 类加载基本原理JVM类加载器 Bootstrap ClassLoader（引导类加载器） C/C++代码实现的加载器,用于加载指定的JDK的核心类库,比如java. lang、java.utI等这些系统类。Java虚拟机的启动就是通过 Bootstrap,该 Classloader在java里无法获取,负责加载/lib下的类。 Extensions Classloader(拓展类加载器) Java中的实现类为 Extclassloader,提供了除了系统类之外的额外功能,可以在java里获取,负责加载/lib/ext下的类 Application ClassLoader(应用程序类加载器) Java中的实现类为 AppClassLoader,是与我们接触对多的类加载器,开发人员写的代码默认就是由它来加载, ClassLoader.getSystemClassLoader返回的就是它。 可以自定义类加载器，只需要通过java.lang.ClassLoader来实现自己的类加载器。 加载顺序：Bootstrap ClassLoader-&gt;Extensions Classloader-&gt;Application ClassLoader 双亲委派 如果一个类加载器收到了类加载请求,它并不会自己先去加载,而是把这个请求委托给父类的加载器去执行,如果父类加载器还存在其父类加载器,则进一步向上委托,依次递归,请求最终将到达顶层的启动类加载器,如果父类加载器可以完成类加载任务,就成功返回,倘若父类加载器无法完成此加载任务,子加载器才会尝试自己去加载。 1)避免重复加载,如果已经加载过一次class,可以直接读取已经加载的class 2)更加安全,无法自定义类来替代系统的类,可以防止核心API库被随意篡改 Android类加载器加载时机： 隐式加载：创建类的实例，访问类的静态变量，或者为静态变量赋值，调用类的静态方法，使用反射方式来强制创建某个类或接口对应的java.lang.Class对象，初始化某个类的子类 显式加载：使用LoadClass()加载，使用forName()加载 加载过程： 装载：查找和导入Class文件 链接：其中解析步骤是可以选择的（a）检查：检查载入的class文件数据的正确性（b）准备：给类的静态变量分配存储空间（c）解析：将符号引用转成直接引用 初始化：即调用&lt;clinit&gt;函数，对静态变量，静态代码块执行初始化工作 ClassLoader继承关系 ClassLoader:抽象类；BootClassLoader:预加载常用类，单例模式。与Java中的BootClassLoader不同，它并不是由C/C++代码实现，而是由Java实现的；BaseDexClassLoader是PathClassLoader、DexClassLoader、InMemoryDexClassLoader的父类，类加载的主要逻辑都是在BaseDexClassLoader完成的。SecureClassLoader继承了抽象类ClassLoader，拓展了ClassLoader类加入了权限方面的功能，加强了安全性，其子类URLClassLoader是用URL路径从jar文件中加载类和资源。其中重点关注的是PathClassLoader和DexClassLoader。PathClassLoader是Android默认使用的类加载器，一个apk中的Activity等类便是在其中加载。DexClassLoader可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更灵活，是实现插件化、热修复以及dex加壳的重点。 DexClassLoader方法参数 dexPath:目标所在的apk或者jar文件的路径，装载器将从路径中寻找指定的目标类。dexOutputDir:由于dex 文件在APK或者 jar文件中，所以在装载前面前先要从里面解压出dex文件，这个路径就是dex文件存放的路径，在 android系统中，一个应用程序对应一个linux用户id ,应用程序只对自己的数据目录有写的权限，所以我们存放在这个路径中。libPath :目标类中使用的C/C++库。parent：该装载器的父装载器，一般为当前执行类的装载器。 Android8.0新引入InMemoryDexClassLoader，用于直接从内存中加载dex。 http://androidxref.com/8.0.0_r4/ 搜索位于libcore中的Definition的DexClassLoader 、PathClassLoader、 InmemoryDexClassLoader查看源码。 ClassLoaderTest新建项目ClassLoaderTest验证类加载器的加载顺序 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); testClassLoader(); &#125; /** * I/kanxue: thisClassLoader:dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/base.apk\"],nativeLibraryDirectories=[/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/lib/x86, /system/lib, /system/product/lib]]] * I/kanxue: this:dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/base.apk\"],nativeLibraryDirectories=[/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/lib/x86, /system/lib, /system/product/lib]]]===java.lang.BootClassLoader@232d58a * I/kanxue: root:java.lang.BootClassLoader@232d58a * */ public void testClassLoader()&#123; ClassLoader thisClassLoader=MainActivity.class.getClassLoader(); Log.i(\"kanxue\",\"thisClassLoader:\"+thisClassLoader); ClassLoader tmpClassLoader = null; ClassLoader parentClassLoader=thisClassLoader.getParent(); while (parentClassLoader!=null)&#123; Log.i(\"kanxue\",\"this:\"+thisClassLoader+\"===\"+parentClassLoader); tmpClassLoader=parentClassLoader.getParent(); thisClassLoader=parentClassLoader; parentClassLoader=tmpClassLoader; &#125; Log.i(\"kanxue\",\"root:\"+thisClassLoader); &#125;&#125; LoadDex通过DexClassLoader实现一个动态加载的dex插件 在ClassLoaderTest项目中打印log 12345public class TestDexClass &#123; public void testFunc()&#123; Log.i(\"kanxue\",\"I'm from com.onejane.classloadertest.TestDexClass.testFunc\"); &#125;&#125; 通过build生成ClassLoaderTest\\app\\build\\outputs\\apk\\debug\\app-debug.apk, apktool d -s app-debug.apk保留并抽取出classes.dex adb push classes.dex /sdcard 创建LoadDex空白Android项目，加载调用位于dex下com.onejane.classloadertest.TestDexClass 在AndroidManifest.xml中添加读写权限 12&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt; 新增application配置android:requestLegacyExternalStorage=”true” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context = this.getApplicationContext(); /** * Android 10 sdk30 无法获取sdcard权限，通过获取当前app的cache目录 * if(!getExternalCacheDir().exists()) getExternalCacheDir().mkdirs(); * testDexClassLoader(context,getExternalCacheDir().getAbsolutePath()+\"/classes.dex\"); * 再将TestDexClass所在的adb push classes.dex /sdcard/Android/data/com.onejane.loaddex/cache/ */ // 若sdk30需要sdcard，通过requestMyPermissions动态获取读写权限 testDexClassLoader(context,\"/sdcard/classes.dex\"); &#125; private void requestMyPermissions() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; //没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(\"kanxue\", \"requestMyPermissions: 有写SD权限\"); &#125; if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; //没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(\"kanxue\", \"requestMyPermissions: 有读SD权限\"); &#125; &#125; // 可应对app热更新bug修复 public void testDexClassLoader(Context context, String dexfilepath)&#123; // 存放dex文件 File optFile = context.getDir(\"opt_dex\",0); // 存放依赖的so文件 File libFile = context.getDir(\"lib_path\",0); ClassLoader parentClassLoader=MainActivity.class.getClassLoader(); Log.i(\"kanxue\",parentClassLoader.toString()); //PathClassLoader ClassLoader tmpClassLoader=context.getClassLoader(); Log.i(\"kanxue\",tmpClassLoader.toString()); // PathClassLoader requestMyPermissions(); DexClassLoader dexClassLoader = new DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity.class.getClassLoader()); Class&lt;?&gt; clazz=null; try&#123; clazz=dexClassLoader.loadClass(\"com.onejane.classloadertest.TestDexClass\"); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; if(clazz!=null)&#123; try &#123; Method testFuncMethod=clazz.getDeclaredMethod(\"testFunc\"); Object obj = clazz.newInstance(); testFuncMethod.invoke(obj); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 利用外部dex下发热修复bug，用户无感知更新。 APP启动流程由发起进程通过binder进程间通信告知system_server进程启动指定的app，system_server通过socket方式与安卓孵化器进程进行通信，告诉孵化器进程启动指定app，由进程fork产生新的进程真正进入ActivityThread.main()，在此之前一直处于安卓的framework中。 ActivityThread是单例模式，在app整个进程的生命周期中，只存在一个实例，http://androidxref.com/8.0.0_r4/ 搜索位于frameworks中的ActivityThread 调用静态函数currentActivityThread获取当前进程中的ActivityThread实例，进而可以获取ActivityThread的重要变量,如mPackages 1234public static ActivityThread currentActivityThread() &#123; return sCurrentActivityThread;&#125;final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages &#x3D; new ArrayMap&lt;&gt;(); 其中LoadedApk中有加载app组件的PathClassLoader,即mClassLoader 通过反射获取app进程中单例ActivityThread，其中的sCurrentActivityThread静态变量用于全局保存创建的ActivityThread实例，同时还提供了currentActivityThread()静态函数用于获取当前虚拟机创建的ActivityThread实例。 反射拿到ActivityThread中的 mPackages的ArrayMap，通过当前app包名获取LoadedApk。 最后通过LoadedApk获取mClassLoader-&gt;PathClassLoader。 PathClassLoader: app运行过程中用于加载四大组件类的ClassLoader **ActivityThread.main()**函数是java中的入口main函数,这里会启动主消息循环，并创建ActivityThread实例，之后调用thread.attach(false)完成一系列初始化准备工作，并完成全局静态变量sCurrentActivityThread的初始化。之后主线程进入消息循环，等待接收来自系统的消息。当收到系统发送来的bindapplication的进程间调用时，调用函数handleBindApplication来处理该请求。 12345678910111213141516171819202122private void handleBindApplication(AppBindData data) &#123; &#x2F;&#x2F;step 1: 创建LoadedApk对象 data.info &#x3D; getPackageInfoNoCheck(data.appInfo, data.compatInfo); ... &#x2F;&#x2F;step 2: 创建ContextImpl对象; final ContextImpl appContext &#x3D; ContextImpl.createAppContext(this, data.info); &#x2F;&#x2F;step 3: 创建Instrumentation mInstrumentation &#x3D; new Instrumentation(); &#x2F;&#x2F;step 4: 创建Application对象;在makeApplication函数中调用了newApplication，真正执行app代码。在该函数中又调用了app.attach(context)，在attach函数中调用了Application.attachBaseContext函数 Application app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication &#x3D; app; &#x2F;&#x2F;step 5: 安装providers List&lt;ProviderInfo&gt; providers &#x3D; data.providers; installContentProviders(app, providers); &#x2F;&#x2F;step 6: 执行Application.Create回调 mInstrumentation.callApplicationOnCreate(app); ...&#125; 在 handleBindApplication函数中第一次进入了app的代码世界，该函数功能是启动一个application，并把系统收集的apk组件等相关信息绑定到application里，在创建完application对象后，接着调用了application的attachBaseContext方法，之后调用了application的onCreate函数。由此可以发现，app的Application类中的attachBaseContext和onCreate这两个函数是最先获取执行权进行代码执行的。这也是为什么各家的加固工具的主要逻辑都是通过替换app入口Application，并自实现这两个函数，在这两个函数中进行加密dex释放以及执行权交付的原因。 APP运行流程 无壳：PathClassLoader加载自身app自身dex，包括app声明的Application及所有其他类信息 加壳：PathClassLoader只加载壳自身代码，不包含app自身真正代码。首先进入壳的application的attachBaseContext，解密原始dex，再完成执行权的交付。 DexClassLoader加载的类是没有组件生命周期的，也就是说即使DexClassLoader通过对APK的动态加载完成了对组件类的加载，当系统启动该组件时，依然会出现加载类失败的异常，因为插件没有组件相关的类，如一些activity或service，若只用DexClassLoader进行动态加载，系统PathClassLoader无法找到相关组件信息，app将直接崩溃。所以如何解决动态加载dex中的生命周期成为加壳厂商首先需要解决的问题！！！ 在项目ClassLoaderTest中新建TestActivity ，并将build的apk中的classes.dex取出，adb push classes.dex /sdcard 12345678public class TestActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#x2F;&#x2F; adb push classes.dex &#x2F;sdcard Log.i(&quot;kanxue&quot;,&quot;I&#39;m from TestActivity.onCreate&quot;); &#125;&#125; 在项目LoadDex中，配置AndroidManifest.xml&lt;activity android:name=&quot;com.onejane.classloadertest.TestActivity&quot;&gt;&lt;/activity&gt;,在MainActivity中新增方法，并启动运行 123456789101112131415161718192021222324252627protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context &#x3D; this.getApplicationContext(); startTestActivity(context,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;);&#125;public void startTestActivity(Context context,String dexfilepath)&#123; &#x2F;&#x2F; 存放dex文件 File optFile &#x3D; context.getDir(&quot;opt_dex&quot;,0); &#x2F;&#x2F; 存放依赖的so文件 File libFile &#x3D; context.getDir(&quot;lib_path&quot;,0); ClassLoader parentClassLoader&#x3D;MainActivity.class.getClassLoader(); Log.i(&quot;kanxue&quot;,parentClassLoader.toString()); &#x2F;&#x2F;PathClassLoader ClassLoader tmpClassLoader&#x3D;context.getClassLoader(); Log.i(&quot;kanxue&quot;,tmpClassLoader.toString()); &#x2F;&#x2F; PathClassLoader requestMyPermissions(); DexClassLoader dexClassLoader &#x3D; new DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity.class.getClassLoader()); Class&lt;?&gt; clazz&#x3D;null; try&#123; clazz&#x3D;dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; if(clazz!&#x3D;null)&#123; context.startActivity(new Intent(context,clazz)); &#125;&#125; 启动app将报错ClassNotFoundException: Didn’t find class “com.onejane.classloadertest.TestActivity” 说明组件相关的Activity由mClassLoader-&gt;PathClassLoader加载了，虽然获取到非空TestActivity，却无法找到启动的目标Activity。 方案一反射替换，替换系统组件类加载器mClassLoader为我们的DexClassLoader，同时设置DexClassLoader的parent为系统组件类加载器PathClassLoader； 修改LoadDex项目的MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context &#x3D; this.getApplicationContext(); startTestActivityReplaceMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;); &#125; private void requestMyPermissions() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有写SD权限&quot;); &#125; if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有读SD权限&quot;); &#125; &#125; public void replaceClassloader(ClassLoader classloader)&#123; try &#123; Class&lt;?&gt; ActivityThreadClazz&#x3D;classloader.loadClass(&quot;android.app.ActivityThread&quot;); &#x2F;&#x2F; 获取静态函数currentActivityThread Method currentActivityThreadMethod&#x3D; ActivityThreadClazz.getDeclaredMethod(&quot;currentActivityThread&quot;); currentActivityThreadMethod.setAccessible(true); Object activityThreadObj&#x3D;currentActivityThreadMethod.invoke(null); &#x2F;&#x2F; 获取ActivityThread对象 &#x2F;&#x2F;final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages &#x3D; new ArrayMap&lt;&gt;(); Field mPackagesField&#x3D;ActivityThreadClazz.getDeclaredField(&quot;mPackages&quot;); &#x2F;&#x2F; 获取ActivityThread对象的ArrayMap的Field mPackagesField.setAccessible(true); ArrayMap mPackagesObj&#x3D; (ArrayMap) mPackagesField.get(activityThreadObj); &#x2F;&#x2F; 通过Field获取mPackages实例 WeakReference wr&#x3D; (WeakReference) mPackagesObj.get(this.getPackageName()); &#x2F;&#x2F; 从ArrayMap中获取LoadApk Object loadedApkObj&#x3D;wr.get(); Class LoadedApkClazz&#x3D;classloader.loadClass(&quot;android.app.LoadedApk&quot;); &#x2F;&#x2F;private ClassLoader mClassLoader; Field mClassLoaderField&#x3D;LoadedApkClazz.getDeclaredField(&quot;mClassLoader&quot;); mClassLoaderField.setAccessible(true); mClassLoaderField.set(loadedApkObj,classloader); &#x2F;&#x2F; 将LoadApk(mClassLoader)替换为我们的DexClassLoader &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; &#125; public void startTestActivityReplaceMethod(Context context,String dexfilepath)&#123; &#x2F;&#x2F; 存放dex文件 File optFile &#x3D; context.getDir(&quot;opt_dex&quot;,0); &#x2F;&#x2F; 存放依赖的so文件 File libFile &#x3D; context.getDir(&quot;lib_path&quot;,0); requestMyPermissions(); DexClassLoader dexClassLoader &#x3D; new DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity.class.getClassLoader()); replaceClassloader(dexClassLoader); Class&lt;?&gt; clazz&#x3D;null; try&#123; clazz&#x3D;dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; if(clazz!&#x3D;null)&#123; context.startActivity(new Intent(context,clazz)); &#125; &#125;&#125; 方案二打破原有的双亲关系，在系统组件类加载器和BootClassLoader的中间插入我们自己的DexClassLoader即可 修改ClassLoaderTest中的TestActivity类继承自Activity 123456789public class TestActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState);&#x2F;&#x2F; setContentView(R.layout.activity_main); &#x2F;&#x2F; adb push classes.dex &#x2F;sdcard Log.i(&quot;kanxue&quot;,&quot;I&#39;m from TestActivity.onCreate&quot;); &#125;&#125; 修改LoadDex中的MainActivity继承Activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context &#x3D; this.getApplicationContext(); &#x2F;&#x2F; 若sdk30需要sdcard，通过requestMyPermissions动态获取读写权限&#x2F;&#x2F; testDexClassLoader(context,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;);&#x2F;&#x2F; startTestActivityReplaceMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;); startTestActivityInsertMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;); &#125; private void requestMyPermissions() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有写SD权限&quot;); &#125; if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有读SD权限&quot;); &#125; &#125; public void startTestActivityInsertMethod(Context context,String dexfilepath)&#123; File optfile&#x3D;context.getDir(&quot;opt_dex&quot;,0); File libfile&#x3D;context.getDir(&quot;lib_path&quot;,0); requestMyPermissions(); ClassLoader pathClassloader&#x3D;MainActivity.class.getClassLoader(); ClassLoader bootClassloader&#x3D;MainActivity.class.getClassLoader().getParent(); &#x2F;&#x2F; 设置自定义dexClassLoader父ClassLoader为bootClassloader DexClassLoader dexClassLoader&#x3D;new DexClassLoader(dexfilepath,optfile.getAbsolutePath(),libfile.getAbsolutePath(),bootClassloader); try &#123; Field parentField&#x3D;ClassLoader.class.getDeclaredField(&quot;parent&quot;); parentField.setAccessible(true); &#x2F;&#x2F; 设置pathClassLoader父ClassLoader为自定义dexClassLoader parentField.set(pathClassloader,dexClassLoader); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; ClassLoader tmpClassloader&#x3D;pathClassloader; ClassLoader parentClassloader&#x3D;pathClassloader.getParent(); while(parentClassloader!&#x3D;null)&#123; Log.i(&quot;kanxue&quot;,&quot;this:&quot;+tmpClassloader+&quot;--parent:&quot;+parentClassloader); tmpClassloader&#x3D;parentClassloader; parentClassloader&#x3D;parentClassloader.getParent(); &#125; Log.i(&quot;kanxue&quot;,&quot;root:&quot;+tmpClassloader); Class&lt;?&gt; clazz&#x3D;null; try &#123; clazz &#x3D; dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; context.startActivity(new Intent(context,clazz)); &#125;&#125; 以上都是基于文件形式的外部加载，Android 8.0引入InMemoryDexClassLoader实现从内存中直接加载字节流，更加安全，不能通过文件监控形式达到脱壳目的，需要从进程内存中扣出这块完整的dex实现脱壳。 部分app在AndroidManifest.xml中没有声明application，加固厂商只需要添加一个application，在自己的application中完成classloader的替换。 部分app在AndroidManifest.xml中已经声明application，加固需要一个代理的application，壳的application不仅需要完成解密dex以及classloader相关修复，还需要完成解密dex后原app的application的attachBaseContext和onCreate函数调用。 逆向分析和脱壳的意义 ClassLoader和动态加载 加壳APP运行流程和ClassLoader修正","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"classloader","slug":"classloader","permalink":"http://onejane.github.io/tags/classloader/"}]},{"title":"猿人学之访问逻辑罗生门","slug":"猿人学之访问逻辑罗生门","date":"2021-02-03T05:25:34.000Z","updated":"2021-05-01T07:40:47.295Z","comments":true,"path":"2021/02/03/猿人学之访问逻辑罗生门/","link":"","permalink":"http://onejane.github.io/2021/02/03/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8B%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91%E7%BD%97%E7%94%9F%E9%97%A8/","excerpt":"","text":"题目http://match.yuanrenxue.com/match/3 抓取下列5页商标的数据，并将出现频率最高的申请号填入答案中 抓包 分析http://match.yuanrenxue.com/match/3 请求原始网页后请求一堆js/css,并没有携带cookie和特殊的返回 http://match.yuanrenxue.com/logo 每次请求页数的时候都会先请求logo并set了一个cookie，说明cookie是从服务器返回的 http://match.yuanrenxue.com/api/match/3 请求返回页面json数据，携带logo返回的cookie 没有带cookie不能访问http://match.yuanrenxue.com/api/match/3 使用请求头加引号.py 将fiddler的请求头包上 请求头加引号.py 123456789101112131415161718import reold_headers ='''Connection: keep-aliveAccept: application/json, text/javascript, */*; q=0.01X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36Referer: http://match.yuanrenxue.com/match/3Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: sessionid=7ly07o9fclh1llfsposkhh9jqvujxkth'''pattern = '^(.*?):[\\s]*(.*?)$'headers = \"\"for line in old_headers.splitlines(): headers += (re.sub(pattern,'\\'\\\\1\\': \\'\\\\2\\',',line)) + '\\n'print(headers[:-2]) 加上cookie使用python请求抓取返回一堆js代码，因为cookie是由服务器生成的，所以这一段返回的js没有意义 12345678910111213headers = &#123; 'Connection': 'keep-alive', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'X-Requested-With': 'XMLHttpRequest', 'User-Agent': 'yuanrenxue.project', 'Referer': 'http://match.yuanrenxue.com/match/3', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Cookie': 'sessionid=7ly07o9fclh1llfsposkhh9jqvujxkth'&#125;url = 'http://match.yuanrenxue.com/api/match/3'res = requests.get(url=url, headers=headers)print(res.text) 爬虫规律：请求完logo后再请求api则正常返回，同理请求第二页 1234567891011121314151617session = requests.session()headers = &#123; 'Connection': 'keep-alive', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'X-Requested-With': 'XMLHttpRequest', 'User-Agent': 'yuanrenxue.project', 'Referer': 'http://match.yuanrenxue.com/match/3', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9'&#125;session.headers = headersurl_logo = 'http://match.yuanrenxue.com/logo'res = session.post(url_logo)print(res, res.cookies)url = 'http://match.yuanrenxue.com/api/match/3?page=1'res = session.get(url=url)print(res.text)","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"猿人学之js混淆动态cookie","slug":"猿人学之js混淆动态cookie","date":"2021-02-03T02:19:32.000Z","updated":"2021-05-01T07:40:47.362Z","comments":true,"path":"2021/02/03/猿人学之js混淆动态cookie/","link":"","permalink":"http://onejane.github.io/2021/02/03/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8Bjs%E6%B7%B7%E6%B7%86%E5%8A%A8%E6%80%81cookie/","excerpt":"","text":"题目http://match.yuanrenxue.com/match/2 提取全部5页发布日热度的值，计算所有值的加和,并提交答案 抓包chrome无痕模式通过抓包获取所有请求 第一个match/2不携带cookie并返回一串js代码 第二个match/2最早携带cookie并返回html页面，且并没有在请求头set-cookie,说明cookie是本地生成，而非服务器生成带到前端的，那么第一个match/2返回的js很可能就会生成cookie 1Cookie m&#x3D;dd5572e825610043a17c791d1eadc601|1607590427000 第三个api/match/2携带cookie返回页面请求json数据 分析使用ob混淆专解测试版V0.1反混淆第一个match/2返回的js代码去掉script标签 将解析完的js放到notepad++中进行js format，查找eval，setInterval，document等函数或者cookie等关键字符串。 123456789101112131415161718function V(Y, Z, a0) &#123; // 空参数 M(); return Z ? a0 ? H(Z, Y) : y(Z, Y) : a0 ? T(Y) : U(Y); &#125; // Y=X()时间戳，Z无用 function W(Y, Z) &#123; // 获取cookie document[\"cookie\"] = \"m\" + M() + \"=\" + V(Y) + \"|\" + Y + \"; path=/\"; // 带上cookie重新刷新页面返回真实网页并发送ajax请求获取json数据 location[\"reload\"](); &#125; // 时间戳 function X(Y, Z) &#123; return Date[\"parse\"](new Date()); &#125; // 最先执行js W(X()); 查看W和V中的M(),都没有传参数 1234567891011121314151617181920212223242526272829303132333435function M(Y, Z) &#123; // 只定义函数并无更新值 var a2 = B(this, function () &#123; var a5 = &#123; \"JLTiy\": \"return /\\\" + this + \\\"/\", \"uynWF\": \"^([^ ]+( +[^ ]+)+)+[^ ]&#125;\" &#125;; var a7 = function () &#123; var a8 = a7[\"constructor\"](a5[\"JLTiy\"])()[\"compile\"](a5[\"uynWF\"]); return !a8[\"test\"](a2); &#125;; return a7(); &#125;); // 未传参 未改变全局变量 无返回 a2(); // 未传参 未改变全局变量 无返回 K(); qz = [10, 99, 111, 110, 115, 111, 108, 101, 32, 61, 32, 110, 101, 119, 32, 79, 98, 106, 101, 99, 116, 40, 41, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 115, 41, 32, 123, 10, 32, 32, 32, 32, 119, 104, 105, 108, 101, 32, 40, 49, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 40, 105, 61, 48, 59, 105, 60, 49, 49, 48, 48, 48, 48, 48, 59, 105, 43, 43, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 104, 105, 115, 116, 111, 114, 121, 46, 112, 117, 115, 104, 83, 116, 97, 116, 101, 40, 48, 44, 48, 44, 105, 41, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 10, 125, 10, 99, 111, 110, 115, 111, 108, 101, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 91, 111, 98, 106, 101, 99, 116, 32, 79, 98, 106, 101, 99, 116, 93, 39, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 402, 32, 116, 111, 83, 116, 114, 105, 110, 103, 40, 41, 32, 123, 32, 91, 110, 97, 116, 105, 118, 101, 32, 99, 111, 100, 101, 93, 32, 125, 39, 10]; eval(L(qz)); try &#123; if (global) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); &#125; else &#123; while (1) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); debugger; &#125; &#125; &#125; catch (a5) &#123; return navigator[\"vendorSub\"]; &#125; &#125; 通过WT-JS查看L(qz)，并没有对cookie进行影响 1234567function L(Y, Z) &#123; let a0 = \"\"; for (let a1 = 0; a1 &lt; Y[\"length\"]; a1++) &#123; a0 += String[\"fromCharCode\"](Y[a1]); &#125; return a0;&#125; navigator[“vendorSub”]放到console返回””,得出M()结论不返回或者返回””,也没修改变量参数 去除无用首行(function $c(k) {和尾行})(); 去除最先执行W(X()); 去除W内的location“reload”; 将document[“cookie”] =改为return 去除无用setInterval(M(), 500); 去除W函数无用Z,M()为null也可以去除 删除无返回js，因为会报test未定义 12345678910111213141516// 无返回 var a2 = B(this, function () &#123; var a5 = &#123; \"JLTiy\": \"return /\\\" + this + \\\"/\", \"uynWF\": \"^([^ ]+( +[^ ]+)+)+[^ ]&#125;\" &#125;; var a7 = function () &#123; var a8 = a7[\"constructor\"](a5[\"JLTiy\"])()[\"compile\"](a5[\"uynWF\"]); return !a8[\"test\"](a2); &#125;; return a7();&#125;);// 未传参 未改变全局变量 无返回a2(); 新增var navigator = {}; 使用鬼鬼调试工具，执行W(X()); 核心js如下2.js 1234567891011121314151617181920212223242526272829303132333435363738var navigator = &#123;&#125;;function M(Y, Z) &#123; // 未传参 未改变全局变量 无返回 K(); qz = [10, 99, 111, 110, 115, 111, 108, 101, 32, 61, 32, 110, 101, 119, 32, 79, 98, 106, 101, 99, 116, 40, 41, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 115, 41, 32, 123, 10, 32, 32, 32, 32, 119, 104, 105, 108, 101, 32, 40, 49, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 40, 105, 61, 48, 59, 105, 60, 49, 49, 48, 48, 48, 48, 48, 59, 105, 43, 43, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 104, 105, 115, 116, 111, 114, 121, 46, 112, 117, 115, 104, 83, 116, 97, 116, 101, 40, 48, 44, 48, 44, 105, 41, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 10, 125, 10, 99, 111, 110, 115, 111, 108, 101, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 91, 111, 98, 106, 101, 99, 116, 32, 79, 98, 106, 101, 99, 116, 93, 39, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 402, 32, 116, 111, 83, 116, 114, 105, 110, 103, 40, 41, 32, 123, 32, 91, 110, 97, 116, 105, 118, 101, 32, 99, 111, 100, 101, 93, 32, 125, 39, 10]; eval(L(qz)); try &#123; if (global) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); &#125; else &#123; while (1) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); debugger; &#125; &#125; &#125; catch (a5) &#123; return navigator[\"vendorSub\"]; &#125;&#125;function V(Y, Z, a0) &#123; // 空参数 M(); return Z ? a0 ? H(Z, Y) : y(Z, Y) : a0 ? T(Y) : U(Y);&#125;// Y=X()时间戳，Z无用function W(Y) &#123; return \"m\" + \"=\" + V(Y) + \"|\" + Y;&#125;function X(Y, Z) &#123; return Date[\"parse\"](new Date());&#125;function request() &#123; return W(X());&#125; 爬虫123456789101112131415161718192021222324252627282930313233import requestsimport execjsimport timedef get_page(page_num,param): url = \"http://match.yuanrenxue.com/api/match/2?page=&#123;&#125;\".format(page_num) headers = &#123; 'Host': 'match.yuanrenxue.com', 'Referer':'http://match.yuanrenxue.com/match/2', 'User-Agent':'yuanrenxue.project', 'X-Requested-With':'XMLHttpRequest', 'Cookie': param &#125; resonse = requests.get(url=url,headers=headers) return resonse.json()def calculate_m_value(): with open(r'2.js',encoding='utf-8',mode='r') as f: JsData = f.read() psd = execjs.compile(JsData).call('request') psd = psd.replace('丨','%E4%B8%A8') print('this request parameters is :',psd) return psdif __name__ == '__main__': sum_num = 0 for page_num in range(1,6): res = get_page(page_num,calculate_m_value()) data = [__['value'] for __ in res['data']] print(data) sum_num+=sum(data) time.sleep(1) print('the answer is :',sum_num)","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"猿人学之js混淆源码乱码","slug":"猿人学之js混淆源码乱码","date":"2021-02-01T03:18:17.000Z","updated":"2021-05-01T07:40:47.337Z","comments":true,"path":"2021/02/01/猿人学之js混淆源码乱码/","link":"","permalink":"http://onejane.github.io/2021/02/01/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8Bjs%E6%B7%B7%E6%B7%86%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/","excerpt":"","text":"题目http://match.yuanrenxue.com/match/1抓取所有（5页）机票的价格，并计算所有机票价格的平均值，填入答案。 抓包打开控制台开始抓包，出现无限debugger循环,可以通过Never pause here或Fiddler过掉。 方案一：在第2行选中右键Never pause here 方案二：通过查看该debug的js名为uzt.js，本地创建uzt.js并修改其中的jsFiddler的AutoResponder下，选中Enable automatic reaponses 和Unmatched requests passthrough 通过翻页获取请求参数得其中1607516709为秒时间戳，即time.time() 12page: 2m: 3ddf4f4e72bd84562a0e0104d425a791丨1607657864 分析查看网页源码，搜索丨中文竖线，抠出js 通过notepad++插件进行js格式化后得到核心代码 修改得m的计算方式 12345request = function () &#123; var timestamp = Date.parse(new Date()) + 100000000; var m = oo0O0(timestamp.toString()) + window.f; m = m + '丨' + timestamp / 1000 &#125;; 扣出oo0O0方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function oo0O0(mw) &#123; window.b = ''; for (var i = 0, len = window.a.length; i &lt; len; i++) &#123; console.log(window.a[i]); window.b += String[document.e + document.g](window.a[i][document.f + document.h]() - i - window.c) &#125; var U = ['W5r5W6VdIHZcT8kU', 'WQ8CWRaxWQirAW==']; var J = function (o, E) &#123; o = o - 0x0; var N = U[o]; if (J['bSSGte'] === undefined) &#123; var Y = function (w) &#123; var m = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=', T = String(w)['replace'](/=+$/, ''); var A = ''; for (var C = 0x0, b, W, l = 0x0; W = T['charAt'](l++); ~W &amp;&amp; (b = C % 0x4 ? b * 0x40 + W : W, C++ % 0x4) ? A += String['fromCharCode'](0xff &amp; b &gt;&gt; (-0x2 * C &amp; 0x6)) : 0x0) &#123; W = m['indexOf'](W) &#125; return A &#125;; var t = function (w, m) &#123; var T = [], A = 0x0, C, b = '', W = ''; w = Y(w); for (var R = 0x0, v = w['length']; R &lt; v; R++) &#123; W += '%' + ('00' + w['charCodeAt'](R)['toString'](0x10))['slice'](-0x2) &#125; w = decodeURIComponent(W); var l; for (l = 0x0; l &lt; 0x100; l++) &#123; T[l] = l &#125; for (l = 0x0; l &lt; 0x100; l++) &#123; A = (A + T[l] + m['charCodeAt'](l % m['length'])) % 0x100, C = T[l], T[l] = T[A], T[A] = C &#125; l = 0x0, A = 0x0; for (var L = 0x0; L &lt; w['length']; L++) &#123; l = (l + 0x1) % 0x100, A = (A + T[l]) % 0x100, C = T[l], T[l] = T[A], T[A] = C, b += String['fromCharCode'](w['charCodeAt'](L) ^ T[(T[l] + T[A]) % 0x100]) &#125; return b &#125;; J['luAabU'] = t, J['qlVPZg'] = &#123;&#125;, J['bSSGte'] = !![] &#125; var H = J['qlVPZg'][o]; return H === undefined ? (J['TUDBIJ'] === undefined &amp;&amp; (J['TUDBIJ'] = !![]), N = J['luAabU'](N, E), J['qlVPZg'][o] = N) : N = H, N &#125;; eval(atob(window['b'])[J('0x0', ']dQW')](J('0x1', 'GTu!'), '\\x27' + mw + '\\x27')); return ''&#125; 由于返回是个空字符串，则oo0O0(timestamp.toString())=‘’，m=window.f，查看源码得知window.f只有一个，那么f作为全局变量可能在oo0O0中被修改 1eval(atob(window[&#39;b&#39;])[J(&#39;0x0&#39;, &#39;]dQW&#39;)](J(&#39;0x1&#39;, &#39;GTu!&#39;), &#39;\\x27&#39; + mw + &#39;\\x27&#39;)); atob是解码使用 base-64 编码的字符串的函数，通过console中获取atob(window[‘b’]) 通过WT-JS加载计算f=hex_md5(mwqqppz) 报错未定义，mwqqppz可能是被其他地方替换或者加密来的 查看J(‘0x0’, ‘]dQW’)方法返回值，在console中执行J方法 1234var U = ['W5r5W6VdIHZcT8kU', 'WQ8CWRaxWQirAW=='];var J = function (o, E) &#123; ...&#125; 拼接得到eval(atob(window[&#39;b&#39;])[replace](&#39;mwqqppz&#39;, &#39;\\x27&#39; + mw + &#39;\\x27&#39;)); 搜索\\bmw\\b,发现mw为function oo0O0的参数，即时间戳 所以f=hex_md5(timestamp),在WT-JS中添加js，atob(window[‘b’])获取window.f 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210var hexcase = 0;var b64pad = \"\";var chrsz = 16;function hex_md5(a) &#123; return binl2hex(core_md5(str2binl(a), a.length * chrsz))&#125;function b64_md5(a) &#123; return binl2b64(core_md5(str2binl(a), a.length * chrsz))&#125;function str_md5(a) &#123; return binl2str(core_md5(str2binl(a), a.length * chrsz))&#125;function hex_hmac_md5(a, b) &#123; return binl2hex(core_hmac_md5(a, b))&#125;function b64_hmac_md5(a, b) &#123; return binl2b64(core_hmac_md5(a, b))&#125;function str_hmac_md5(a, b) &#123; return binl2str(core_hmac_md5(a, b))&#125;function md5_vm_test() &#123; return hex_md5(\"abc\") == \"900150983cd24fb0d6963f7d28e17f72\"&#125;function core_md5(p, k) &#123; p[k &gt;&gt; 5] |= 128 &lt;&lt; ((k) % 32); p[(((k + 64) &gt;&gt;&gt; 9) &lt;&lt; 4) + 14] = k; var o = 1732584193; var n = -271733879; var m = -1732584194; var l = 271733878; for (var g = 0; g &lt; p.length; g += 16) &#123; var j = o; var h = n; var f = m; var e = l; o = md5_ff(o, n, m, l, p[g + 0], 7, -680976936); l = md5_ff(l, o, n, m, p[g + 1], 12, -389564586); m = md5_ff(m, l, o, n, p[g + 2], 17, 606105819); n = md5_ff(n, m, l, o, p[g + 3], 22, -1044525330); o = md5_ff(o, n, m, l, p[g + 4], 7, -176418897); l = md5_ff(l, o, n, m, p[g + 5], 12, 1200080426); m = md5_ff(m, l, o, n, p[g + 6], 17, -1473231341); n = md5_ff(n, m, l, o, p[g + 7], 22, -45705983); o = md5_ff(o, n, m, l, p[g + 8], 7, 1770035416); l = md5_ff(l, o, n, m, p[g + 9], 12, -1958414417); m = md5_ff(m, l, o, n, p[g + 10], 17, -42063); n = md5_ff(n, m, l, o, p[g + 11], 22, -1990404162); o = md5_ff(o, n, m, l, p[g + 12], 7, 1804660682); l = md5_ff(l, o, n, m, p[g + 13], 12, -40341101); m = md5_ff(m, l, o, n, p[g + 14], 17, -1502002290); n = md5_ff(n, m, l, o, p[g + 15], 22, 1236535329); o = md5_gg(o, n, m, l, p[g + 1], 5, -165796510); l = md5_gg(l, o, n, m, p[g + 6], 9, -1069501632); m = md5_gg(m, l, o, n, p[g + 11], 14, 643717713); n = md5_gg(n, m, l, o, p[g + 0], 20, -373897302); o = md5_gg(o, n, m, l, p[g + 5], 5, -701558691); l = md5_gg(l, o, n, m, p[g + 10], 9, 38016083); m = md5_gg(m, l, o, n, p[g + 15], 14, -660478335); n = md5_gg(n, m, l, o, p[g + 4], 20, -405537848); o = md5_gg(o, n, m, l, p[g + 9], 5, 568446438); l = md5_gg(l, o, n, m, p[g + 14], 9, -1019803690); m = md5_gg(m, l, o, n, p[g + 3], 14, -187363961); n = md5_gg(n, m, l, o, p[g + 8], 20, 1163531501); o = md5_gg(o, n, m, l, p[g + 13], 5, -1444681467); l = md5_gg(l, o, n, m, p[g + 2], 9, -51403784); m = md5_gg(m, l, o, n, p[g + 7], 14, 1735328473); n = md5_gg(n, m, l, o, p[g + 12], 20, -1921207734); o = md5_hh(o, n, m, l, p[g + 5], 4, -378558); l = md5_hh(l, o, n, m, p[g + 8], 11, -2022574463); m = md5_hh(m, l, o, n, p[g + 11], 16, 1839030562); n = md5_hh(n, m, l, o, p[g + 14], 23, -35309556); o = md5_hh(o, n, m, l, p[g + 1], 4, -1530992060); l = md5_hh(l, o, n, m, p[g + 4], 11, 1272893353); m = md5_hh(m, l, o, n, p[g + 7], 16, -155497632); n = md5_hh(n, m, l, o, p[g + 10], 23, -1094730640); o = md5_hh(o, n, m, l, p[g + 13], 4, 681279174); l = md5_hh(l, o, n, m, p[g + 0], 11, -358537222); m = md5_hh(m, l, o, n, p[g + 3], 16, -722881979); n = md5_hh(n, m, l, o, p[g + 6], 23, 76029189); o = md5_hh(o, n, m, l, p[g + 9], 4, -640364487); l = md5_hh(l, o, n, m, p[g + 12], 11, -421815835); m = md5_hh(m, l, o, n, p[g + 15], 16, 530742520); n = md5_hh(n, m, l, o, p[g + 2], 23, -995338651); o = md5_ii(o, n, m, l, p[g + 0], 6, -198630844); l = md5_ii(l, o, n, m, p[g + 7], 10, 11261161415); m = md5_ii(m, l, o, n, p[g + 14], 15, -1416354905); n = md5_ii(n, m, l, o, p[g + 5], 21, -57434055); o = md5_ii(o, n, m, l, p[g + 12], 6, 1700485571); l = md5_ii(l, o, n, m, p[g + 3], 10, -1894446606); m = md5_ii(m, l, o, n, p[g + 10], 15, -1051523); n = md5_ii(n, m, l, o, p[g + 1], 21, -2054922799); o = md5_ii(o, n, m, l, p[g + 8], 6, 1873313359); l = md5_ii(l, o, n, m, p[g + 15], 10, -30611744); m = md5_ii(m, l, o, n, p[g + 6], 15, -1560198380); n = md5_ii(n, m, l, o, p[g + 13], 21, 1309151649); o = md5_ii(o, n, m, l, p[g + 4], 6, -145523070); l = md5_ii(l, o, n, m, p[g + 11], 10, -1120210379); m = md5_ii(m, l, o, n, p[g + 2], 15, 718787259); n = md5_ii(n, m, l, o, p[g + 9], 21, -343485551); o = safe_add(o, j); n = safe_add(n, h); m = safe_add(m, f); l = safe_add(l, e) &#125; return Array(o, n, m, l)&#125;function md5_cmn(h, e, d, c, g, f) &#123; return safe_add(bit_rol(safe_add(safe_add(e, h), safe_add(c, f)), g), d)&#125;function md5_ff(g, f, k, j, e, i, h) &#123; return md5_cmn((f &amp; k) | ((~f) &amp; j), g, f, e, i, h)&#125;function md5_gg(g, f, k, j, e, i, h) &#123; return md5_cmn((f &amp; j) | (k &amp; (~j)), g, f, e, i, h)&#125;function md5_hh(g, f, k, j, e, i, h) &#123; return md5_cmn(f ^ k ^ j, g, f, e, i, h)&#125;function md5_ii(g, f, k, j, e, i, h) &#123; return md5_cmn(k ^ (f | (~j)), g, f, e, i, h)&#125;function core_hmac_md5(c, f) &#123; var e = str2binl(c); if (e.length &gt; 16) &#123; e = core_md5(e, c.length * chrsz) &#125; var a = Array(16), d = Array(16); for (var b = 0; b &lt; 16; b++) &#123; a[b] = e[b] ^ 909522486; d[b] = e[b] ^ 1549556828 &#125; var g = core_md5(a.concat(str2binl(f)), 512 + f.length * chrsz); return core_md5(d.concat(g), 512 + 128)&#125;function safe_add(a, d) &#123; var c = (a &amp; 65535) + (d &amp; 65535); var b = (a &gt;&gt; 16) + (d &gt;&gt; 16) + (c &gt;&gt; 16); return (b &lt;&lt; 16) | (c &amp; 65535)&#125;function bit_rol(a, b) &#123; return (a &lt;&lt; b) | (a &gt;&gt;&gt; (32 - b))&#125;function str2binl(d) &#123; var c = Array(); var a = (1 &lt;&lt; chrsz) - 1; for (var b = 0; b &lt; d.length * chrsz; b += chrsz) &#123; c[b &gt;&gt; 5] |= (d.charCodeAt(b / chrsz) &amp; a) &lt;&lt; (b % 32) &#125; return c&#125;function binl2str(c) &#123; var d = \"\"; var a = (1 &lt;&lt; chrsz) - 1; for (var b = 0; b &lt; c.length * 32; b += chrsz) &#123; d += String.fromCharCode((c[b &gt;&gt; 5] &gt;&gt;&gt; (b % 32)) &amp; a) &#125; return d&#125;function binl2hex(c) &#123; var b = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\"; var d = \"\"; for (var a = 0; a &lt; c.length * 4; a++) &#123; d += b.charAt((c[a &gt;&gt; 2] &gt;&gt; ((a % 4) * 8 + 4)) &amp; 15) + b.charAt((c[a &gt;&gt; 2] &gt;&gt; ((a % 4) * 8)) &amp; 15) &#125; return d&#125;function binl2b64(d) &#123; var c = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; var f = \"\"; for (var b = 0; b &lt; d.length * 4; b += 3) &#123; var e = (((d[b &gt;&gt; 2] &gt;&gt; 8 * (b % 4)) &amp; 255) &lt;&lt; 16) | (((d[b + 1 &gt;&gt; 2] &gt;&gt; 8 * ((b + 1) % 4)) &amp; 255) &lt;&lt; 8) | ((d[b + 2 &gt;&gt; 2] &gt;&gt; 8 * ((b + 2) % 4)) &amp; 255); for (var a = 0; a &lt; 4; a++) &#123; if (b * 8 + a * 6 &gt; d.length * 32) &#123; f += b64pad &#125; else &#123; f += c.charAt((e &gt;&gt; 6 * (3 - a)) &amp; 63) &#125; &#125; &#125; return f&#125;;function get_m_value() &#123; //var timestamp = Date.parse(new Date()) + 100000000; timestamp = '1607657864000' f = hex_md5(timestamp) return f;&#125; 以上获取m=window.f的值 爬虫pip3 install PyExecJS 123456789101112131415161718192021222324252627282930313233343536import timeimport execjsimport requestsdef get_page(page_num,parameters): url = 'http://match.yuanrenxue.com/api/match/1?page=&#123;&#125;&amp;m=&#123;&#125;'.format(page_num,parameters) headers = &#123; 'Host': 'match.yuanrenxue.com', 'Referer': 'http://match.yuanrenxue.com/match/1', 'User-Agent': 'yuanrenxue.project', 'X-Requested-With': 'XMLHttpRequest', 'Cookie': 'qpfccr=true; Hm_lvt_c99546cf032aaa5a679230de9a95c7db=1607556997,1607557857; Hm_lpvt_c99546cf032aaa5a679230de9a95c7db=1607557857; no-alert=true' &#125; response = requests.get(url=url,headers=headers) return response.json()def calculate_m_value(): with open(r'1.js',encoding='utf-8',mode='r') as f: JsData = f.read() psd = execjs.compile(JsData).call('request') psd = psd.replace('丨','%E4%B8%A8') print('this request parameters is :',psd) return psdif __name__ == '__main__': sum_num = 0 index_num = 0 for page_num in range(1,6): res = get_page(page_num,calculate_m_value()) data = [__['value'] for __ in res['data']] print(data) sum_num+=sum(data) index_num += len(data) time.sleep(1) average = sum_num/index_num print('the answer is :',average) 1.js中获取param的函数如下 12345678function request() &#123; var timestamp = Date.parse(new Date()) + 100000000; // timestamp = '1607657864000' f = hex_md5(timestamp+'') var m = f; m = m + '丨' + timestamp / 1000 return m;&#125;","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"博客搭建","slug":"博客搭建","date":"2021-01-31T14:51:49.000Z","updated":"2021-04-27T19:15:44.271Z","comments":true,"path":"2021/01/31/博客搭建/","link":"","permalink":"http://onejane.github.io/2021/01/31/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Hexo12345678https://nodejs.org/download/release/v10.15.3/ 安装nodenpm install -g cnpm --registry=https://registry.npm.taobao.orgnpm config set registry https://registry.npm.taobao.org npm install -g hexo@4.1.1npm install -g hexo-cli@1.3.0 hexo init blog cd blog npm install Melody12345678910111213set http_proxy=http://127.0.0.1:1080set https_proxy=https://127.0.0.1:1080git clone -b master https://github.com/Molunerfinn/hexo-theme-melody themes/melodynpm install hexo-renderer-pug hexo-renderer-styluscp themes\\melody\\_config.yml themes\\melody\\melody.yml 通过git pull 即可更新melodynpm i --save hexo-wordcountnpm i hexo-deployer-git --save 使用git bashnpm install --save-dev gulp@3.9.1npm install -g gulp@3.9.1npm install gulp-imagemin@3.1.1 --savenpm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify --save blog\\package.json 12345\"scripts\": &#123; \"build\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d &amp; git add * &amp; git commit -m 'deploy' &amp; git push origin master\", \"test\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo s\", \"dev\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\" &#125; 通过npm run build 即可自动打包上传发布http://onejane.gitee.io/ 新建Onajane公开项目，hexo d后启用服务的Gitee Pages 新建picture公开项目，上传图片后启动服务的Gitee Pages图床服务，http://onejane.gitee.io/picture/avatar.jpg blog_config.yml 1234567891011121314151617title: Jsubtitle: '朝花夕拾'description: '逆向,爬虫'keywords:author: Jlanguage: zh-Hanstimezone: 'Hongkong'url: https://gitee.com/OneJanetheme: melodypost_asset_folder: true # npm install https://github.com/CodeFalling/hexo-asset-image --save 上传图片到博客deploy: type: git repo: gitee: https://gitee.com/OneJane/OneJane.git github: git@github.com:OneJane/OneJane.github.io.git branch: master message: gitee 评论https://leancloud.cn/dashboard/applist.html#/apps 新建应用获取AppID,AppKey 123456789101112valine: enable: true # if you want use valine,please set this value is true appId: cWLsquGr5PNi33OWXNhzerep-gzGzoHsz # leancloud application app id appKey: S35phfCSbm8dAG9LpOc5rjm3 # leancloud application app key notify: false # valine mail notify (true/false) https://github.com/xCss/Valine/wiki verify: false # valine verify code (true/false) recordip: false # whether record commentor's ip (true/false) pageSize: 10 # comment list page size avatar: mm # gravatar style https://valine.js.org/#/avatar lang: zh-cn # i18n: zh-cn/en placeholder: 一起来吹牛逼好吗！ # valine comment input placeholder(like: Please leave your footprints ) guest_info: nick,mail,link #valine comment header inf 分享123sharejs: enable: true disabled_sites: google,facebook 搜索本地 npm install hexo-generator-search –save 12345local_search: enable: true # or false labels: input_placeholder: Search for Posts hits_empty: \"We didn't find any results for the search: $&#123;query&#125;\" # if there are no result 头像1avatar: http://onejane.gitee.io/picture/avatar.jpg # 网站 Logo 导航菜单1234567891011121314151617181920hexo new page tags修改source/tags/index.md---title: 标签date: 2018-01-05 00:00:00type: \"tags\"---hexo new page categories修改source/categories/index.md---title: 分类date: 2018-01-05 00:00:00type: \"categories\"---修改_config.ymlmenu: 主页: / 归档: /archives 标签: /tags 分类: /categories 自动节选123auto_excerpt: enable: true length: 150 顶部图12top_img_height: 80 top_img: http://onejane.gitee.io/picture/hacker.jpg 在_config.yml和文章中使用 打赏1234567QR_code: - itemlist: img: http://onejane.gitee.io/picture/alipay.png text: 支付宝打赏 - itemlist: img: http://onejane.gitee.io/picture/wx.png text: 微信打赏 广告/音乐播放器123adv: enable: true info: &lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"center\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=572547816&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt; Follow1234follow: enable: true url: 'https://gitee.com/OneJane/' text: 'Follow Me' 友链123links_title: 友链 # 配置友链的标题文字links: OneJane: http://onejane.gitee.io/ 目录1234toc: enable: true # or false number: true # or false. 版本v1.5.6新增 在文章头部加入toc_number: true 页脚1footer_custom_text: Hi, welcome to my &lt;a href=http://onejane.gitee.io/\"&gt;blog&lt;/a&gt;! 配置成hitokoto则是随机的谚语 点击特效1fireworks: true 彩带123456canvas_ribbon: enable: true size: 150 alpha: 0.6 zIndex: -1 click_to_change: false 阅读密码npm install –save hexo-blog-encrypt 123文中标题填入password: blogJmessage: 请联系微信：codewj，获取本文密码 分析baiduhttps://tongji.baidu.com/sc-web/10000134724/home/site/index?from=3 新增网站后，获取hm.src = “https://hm.baidu.com/hm.js?***&quot;;作为百度id googlehttps://analytics.google.com/analytics/web/#/a111479568p260655414/admin 创建媒体资源-显示高级选项-创建 Universal Analytics 媒体资源，创建好后进入媒体资源设置获取跟踪ID,UA开头的就是谷歌id 12baidu_analytics: ***google_analytics: ***","categories":[{"name":"生活","slug":"生活","permalink":"http://onejane.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://onejane.github.io/tags/hexo/"}]},{"title":"逆向环境搭建","slug":"逆向环境搭建","date":"2021-01-31T03:20:05.000Z","updated":"2021-06-07T14:48:07.293Z","comments":true,"path":"2021/01/31/逆向环境搭建/","link":"","permalink":"http://onejane.github.io/2021/01/31/%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"刷机https://developers.google.com/android/images#angler 开机键+音量减 进入recovery PixelES文件浏览器 查看系统文件 玩逆向必备一台真机，那么非谷歌亲儿子莫属，模拟器缺失native/so层，属于精简版系统，故还是真机香呀。 官网下载pixel 8.1.0镜像，建议刷OPM1.171019.011版本安卓8.1.0 12adb reboot bootloader 或 按住音量向下键和开机键 进入fastboot状态cd sailfish-opm4.171019.021.p1-factory-0bcf4315/sailfish-opm4.171019.021.p1 &amp;&amp; flash-all.sh 开始刷机 设置-关于手机-版本号8下点击-进入开发者模式，进入系统-高级-打开开发者选项-USB调试 123456adb push Magisk-v20.4.zip /sdcard adb push magisk-riru-v21.3.zip /sdcard/Download 使用magisk模块安装并重启adb push magisk-EdXposed-SandHook-v0.4.5.1_beta.4463.-release.zip /sdcard/Download 使用magisk模块安装并重启adb install EdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apk 安装xposedadb push MagiskHidePropsConf-v5.3.4.zip /sdcard/Download adb install JustTrustMePlus-debug.apk 用于结合xposed突破SSL Pinning抓包限制 twrp作为第三方刷机工具，刷入Magisk，nethunter等魔改系统。 fastboot flash recovery twrp-3.3.0-0-angler.img 12345678adb reboot bootloaderfastboot boot twrp-3.4.0-0-sailfish.img 进入recovery modeinstall Magisk-v20.4.zipadb install MagiskManager-v7.5.1.apksettings put global captive_portal_http_url https://www.google.cn/generate_204 去除wifi上的×settings put global captive_portal_https_url https://www.google.cn/generate_204settings put global ntp_server 1.hk.pool.ntp.org 修改时区reboot linux下载最新的platform-tools刷机的时候，fastboot会报各种unknow command或接近的错误，把fastboot文件替换成随着aosp一起编译出来的即可,使用自行编译的fastboot即可。 123rm ~&#x2F;Android&#x2F;Sdk&#x2F;platform-tools&#x2F;fastbootcp fastboot810r1 fastbootfastboot --version 通过wifi连接adb可实现群控adb -s 192.168.0.104:5555 install com.ttxapps.wifiadb_2.1.3-810031745_minAPI15(nodpi)_apkmirror.com.apk 安装apk adb connect 192.168.0.104:5555 使用adb连接手机 termux adb -s 192.168.0.104:5555 install com.termux_92.apk adb被禁时在app端使用命令行操作 pkg update &amp;&amp; pkg install htop 在app端安装管理进程的包 xdebuggable &amp;&amp; XAppDebug启动EdXposed,搜索xdebuggable 和XAppDebug模块并安装开启debug apk(需要借助ssr科学上网) ro.debuggable adb push MagiskHidePropsConf-v5.3.4.zip /sdcard/Download 并通过Magisk Manager-模块-下载-安装MagiskHidePropsConf-v5.3.4.zip reboot-adb shell-props 123456789101112131415161718192021222324252627282930313233343536373839404142434445461 - Edit device fingerprint2 - Force BASIC key attestation3 - Device simulation (disabled)4 - Edit MagiskHide props5 - Add&#x2F;edit custom props6 - Delete prop values7 - Script settings8 - Collect logsu - Perform module update checkr - Reset all options&#x2F;settingsb - Reboot devicee - ExitSee the module readme or thesupport thread @ XDA for details.Enter your desired option: 41 - ro.debuggable2 - ro.secure3 - ro.build.type4 - ro.build.tags5 - ro.bootmode6 - ro.boot.modea - Change all propsb - Go back to main menue - ExitPick several options at once byseparating inputs with a comma.Example: 1,3,4See the module readme or thesupport thread @ XDA for details.Enter your desired option: 1You currently have the safe value set.Are you sure you want to change it to 1?Enter y(es), n(o) or e(xit): yDo you want to reboot now (y&#x2F;n)?Enter y(es), n(o) or e(xit): y getprop ro.debuggable 即可查看1,开启全局可调式 Pixel XLlineageos,twrp 12345678910111213141516171819adb reboot bootloader fastboot boot twrp-3.4.0-0-marlin.img 进入twrp「TWRP主界面」-&gt;「Wipe」-&gt;「Format Data」 输入yes「Adavanced Wipe」-&gt; 勾选「Dalvik &#x2F; ART Cache」、「Cache」、「System」、「Data」、「Internal Storage」（切勿勾选到「Vendor」） -&gt; 划过滑动条确认擦除 「TWRP主界面」-&gt;「Advanced」-&gt;「ADB Sideload」（划过滑条即可） 勾选双清adb sideload lineage-17.1-20201028-nightly-marlin-signed.zip 重启设置-关于手机-版本号-8次打开开发者选项设置-系统-高级-开发者选项-Android 调试adb install MagiskManager-v7.5.1.apkadb install EdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apkadb push magisk-riru-v21.3.zip &#x2F;sdcard&#x2F;Downloadadb push MagiskHidePropsConf-v5.3.4.zip &#x2F;sdcard&#x2F;Downloadadb push EdXposed-SandHook-v0.4.6.2.4529.-release.zip &#x2F;sdcard&#x2F;Downloadadb reboot bootloaderfastboot boot twrp-3.4.0-0-marlin.img「TWRP主界面」-&gt;「Advanced」-&gt;「ADB Sideload」（划过滑条即可）adb sideload Magisk-v20.4.zip 重启通过Magisk模块新增选择下载目录，安装riru，MagiskHidePropsConf，EdXposedadb install JustTrustMePlus-debug.apk marlin,SR5-SuperSU-v2.82-SR5-20171001224502.zip,xposed-v89-sdk25-arm64.zip,XposedInstaller_3.1.5 12345678adb reboot bootloader .&#x2F;flash-all.bat设置-关于手机-版本号-8次打开开发者选项设置-系统-高级-开发者选项-Android 调试adb install XposedInstaller_3.1.5.apkfastboot boot twrp-3.4.0-0-marlin.imginstall SR5-SuperSU-v2.82-SR5-20171001224502.zip,xposed-v89-sdk25-arm64.zipadb push timeadjust.sh &#x2F;data&#x2F;local&#x2F;tmp &amp;&amp; sh timeadjust.sh Nexus 6P12345678910111213141516171819adb reboot bootloaderfastboot devicesfastboot erase cache 如出现&lt; waiting for any device &gt;，插拔usbfastboot erase userdatafastboot flashing unlockfastboot flash bootloader .\\bootloader-angler-angler-03.68.imgfastboot reboot-bootloaderfastboot flash radio .\\radio-angler-angler-03.81.imgfastboot reboot-bootloaderfastboot flash vendor .\\image-angler-n2g48c\\vendor.imgfastboot reboot-bootloaderfastboot flash system .\\image-angler-n2g48c\\system.imgfastboot flash boot .\\image-angler-n2g48c\\boot.imgfastboot flash recovery recovery.imgfastboot erase cachefastboot erase userdatafastboot flash cache cache.imgfastboot flash userdata userdata.imgfastboot flashing lock 设置-关于手机-版本号8下点击-进入开发者模式-打开开发者选项 adb push UPDATE-SuperSU-v2.79-20161211114519.zip /sdcard adb push xposed-v89-sdk25-arm64.zip /sdcard rom:https://dl.google.com/dl/android/aosp/angler-n2g48c-factory-6a21e528.zip 解压得到angler-n2g48c-factory-6a21e528\\angler-n2g48c\\image-angler-n2g48c superSu:https://download.chainfire.eu/1016/SuperSU/UPDATE-SuperSU-v2.79-20161211114519.zip xposed安卓7.1对应sdk:https://dl-xda.xposed.info/framework/sdk25/arm64/xposed-v89-sdk25-arm64.zip xposed apk:https://dl.xda-cdn.com/4/3/9/3/0/8/2/XposedInstaller_3.1.5.apk?key=4Rkip9MZy_4KitcodXSxBw&amp;ts=1598862686 twrp:https://dl.twrp.me/angler/twrp-3.4.0-0-angler.img Kali NetHunter12345678910111213141516171819202122232425wget https:&#x2F;&#x2F;dl.google.com&#x2F;dl&#x2F;android&#x2F;aosp&#x2F;angler-opm1.171019.011-factory-39448337.zipadb kill-serveradb start-serveradb reboot bootloader.&#x2F;flash-all.sh 如报错替换fastboot,which fastboot,使用fastboot8.1.0r1,开启开发者选项，打开USB调试 https:&#x2F;&#x2F;www.kali.org&#x2F;kali-nethunter&#x2F;https:&#x2F;&#x2F;www.offensive-security.com&#x2F;kali-linux-nethunter-download&#x2F;Nexus 6P Oreo (ZIP)adb push SR5-SuperSU-v2.82-SR5-20171001224502.zip &#x2F;sdcard&#x2F;adb push nethunter-2021.1-angler-oreo-kalifs-full.zip &#x2F;sdcard&#x2F;adb push timeadjust.sh &#x2F;sdcard&#x2F;adb reboot bootloaderfastboot flash recovery twrp-3.4.0-0-angler.img刷完之后按音量向下键，选择Recovery mode，按电源键进入，进入Recovery之后，选择Install→SR5-SuperSU-v2.82-SR5-20171001224502.zip开始刷机。再次进入recovery，把nethunter-2020.2-pre3-angler-oreo-kalifs-full.zip.torrent刷进去，中间解压Kali rootfs的过程，会至多25分钟连接wifish timeadjust.sh 同步时间，reboot刷机结束后进入系统首次也要先点击Nethunter的应用，申请的所有权限都给，左侧导航进入Kali Chroot Manager，点击START KALI CHROOT，只要初始化这一次，后续无论如何重启都会出现如图所示的Everything is fine and Chroot has been started!。点开Nethunter终端这款App，选择KALI，进入Kali系统apt update升级系统中的软件库信息apt install neofetch htop jnettop点开Nethunter进入标左侧签KeX Manager，点击“SETUP LOCAL SERVER”，会要求输入一个连接密码和显示密码，输入和确认即可，然后点击“START SERVER”开启服务器。点开“Nethunter KeX”这个App，在密码那一栏输入密码之后，点击“Connect”进行连接，即可直接进入Kali Nethunter操作系统的桌面。 搭配QtScrcpy就可以在电脑上观看手机屏幕上的内容，或者通过usb一拖四实现鼠标键盘完全电脑操作。该系统自动集成了java,BurpSuite2020.06,charles,python3,python。 vnc点开Nethunter这个app 切换到Kali Chroot Manager,START KALI CHROOT 切换到Kali Services，将SSH启动并且勾选Start at Boot，这样就拥有了sshd 切换到Kex Manage–SETUP LOCAL SERVER 设置好密码后–取消Localhost Only–START SERVER–OPEN KEX CLIENT 打开VNC Viewer,通过NetHunter 终端查看ip地址，显示器为1，开启VNC登录 通过一拖四的typec转USB，连接键盘鼠标，将Nexus 6p变成一台kali电脑。 Nexus1234567891011121314151617adb reboot bootloaderfastboot oem unlockfastboot erase cache 如出现&lt; waiting for any device &gt;，插拔usbfastboot erase userdatafastboot flash bootloader .\\bootloader-hammerhead-hhz20h.imgfastboot flash radio .\\radio-hammerhead-m8974a-2.0.50.2.30.imgfastboot reboot-bootloadercd .\\image-hammerhead-m4b30z\\fastboot flash recovery recovery.imgfastboot flash boot boot.imgfastboot flash system system.imgfastboot flash userdata userdata.imgfastboot erase cachefastboot erase userdatafastboot flash cache cache.imgfastboot flash userdata userdata.imgfastboot reboot 设置-关于手机-版本号8下点击-进入开发者模式-打开开发者选项 adb push UPDATE-SuperSU-v2.79-20161211114519.zip /sdcard adb push .\\xposed-v89-sdk23-arm.zip /sdcard 1234567adb reboot bootloaderfastboot flash recovery twrp-3.4.0-0-hammerhead.img 然后进入recovery modeadb install .\\XposedInstaller_3.1.5.apk 安装Xposedadb shelladb shell 输入su获取超级用户权限chmod 711 &#x2F;data&#x2F;user&#x2F;0&#x2F;de.robv.android.xposed.installerreboot 安装完毕 小米 Mix 2打开开发者选项-usb调试 -设备解锁状态-绑定账号和设备 adb reboot bootloader 解锁bootloader，执行miflash_unlock.exe EdXposed-SandHook-v0.4.6.2.4529.-release.zip twrp-3.3.1-1-chiron.img 12345678910111213adb reboot bootloaderfastboot flash recovery twrp-3.3.1-1-chiron.imgfastboot boot twrp-3.3.1-1-chiron.imgadb push lineage-17.0-chiron.zip 不能有中文进入twrp后清除Cache，System，Data分区install lineage-17.0-chiron.zipinstall Magisk-v20.4.zipadb install MagiskManager-v7.5.1.apk adb install EdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apk在magisk中安装adb push magisk-riru-v21.3.zip &#x2F;sdcard&#x2F;Downloadadb push MagiskHidePropsConf-v5.3.4.zip &#x2F;sdcard&#x2F;Downloadadb push EdXposed-SandHook-v0.4.6.2.4529.-release.zip &#x2F;sdcard&#x2F;Download 小米6我的设备-全部参数-双击8次MIUI版本-开发者选项 更多设置-开发者选项-usb调试 -设备解锁状态-绑定账号和设备 解锁bootloader，执行miflash_unlock.exe https://download.lineageos.org/sagit lineage-17.1-20201022-nightly-sagit-signed.zip twrp-3.3.1-2-sagit.img fw_sagit_miui_MI6Global_V10.4.1.0.PCAMIXM_38edd1584c_9.0.zip 12345678910111213adb reboot bootloader 重启到引导系统fastboot flash recovery twrp-3.3.1-2-sagit.imgfastboot reboot 执行完命令马上长按音量+ 清除数据fastboot reboot 重启进入 TWRP ，执行完命令马上长按音量+，滑动开始「TWRP主界面」-&gt;「Wipe」-&gt;「Format Data」 输入yes「Adavanced Wipe」-&gt; 勾选「Dalvik &#x2F; ART Cache」、「Cache」、「System」、「Data」、「Internal Storage」（切勿勾选到「Vendor」） -&gt; 划过滑动条确认擦除 「TWRP主界面」-&gt;「Advanced」-&gt;「ADB Sideload」（划过滑条即可）adb sideload fw_sagit_miui_MI6Global_V10.4.1.0.PCAMIXM_38edd1584c_9.0.zip 刷完后手机会自动退出 ADB Sideload「TWRP主界面」-&gt;「Advanced」-&gt;「ADB Sideload」（划过滑条即可）adb sideload lineage-17.1-20201105-nightly-sagit-signed.zip 刷完后手机会自动退出 ADB Sideload重启按住音量+ 进入twrpinstall Magisk-v20.4.zip 重启adb install MagiskManager-v7.5.1.apk 设置-关于手机-版本号-8次打开开发者选项 设置-系统-高级-开发者选项-Android 调试 123456adb install EdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apk在magisk中安装adb push magisk-riru-v21.3.zip &#x2F;sdcard&#x2F;Downloadadb push MagiskHidePropsConf-v5.3.4.zip &#x2F;sdcard&#x2F;Downloadadb push EdXposed-SandHook-v0.4.6.2.4529.-release.zip &#x2F;sdcard&#x2F;Downloadadb install JustTrustMePlus-debug.apk Genymotion安装全程开全局代理，安装nexus 5x 8.0network mode选择Bridge或者在virtualbox中修改网络为桥接，如virtualbox网络连接里没有桥接网卡选择修改D:\\VirtualBox\\drivers\\network\\netlwf\\VBoxNetLwf.infsettings-system-Languages&amp;input-Languages-Add a language-简体中文 adb 无法连接genymotion怎么办？ 修改genymotion的settings，Use custom Android SDK tools为本地android sdk路径adb kill-server + adb start-server 重启adb安装wifiadb后即可，默认可以连接192网段，配置桥接，可adb connect 192.168.0.104:5555 arm桥接 uname -a i686 查看cpu架构为x86 32位 不支持arm，需要安装arm桥，直接将 Genymotion-ARM-Translation_for_8.0.zip拖入nexus 5x 8.0, 进行安装adb reboot 即可安装带有arm的so的apk Kali别用Windows了，鲁迅曾经说过，他在逆向生涯中超过一半的苦难均由Windows赐予。 vmware安装文件 秘钥：YC34H-6WWDK-085MQ-JYPNX-NZRA2 kali-linux-2020.4-vmware-amd64.7z种子，使用vmware打开vmx文件，配置6g内存，80g磁盘存储，网络适配选择桥接到本地网卡(虚拟网络编辑器)，默认账密：kali/kali，sudo passwd root 修改密码123456 重启后使用root登录，android-studio-ide-201.7042882-linux.tar.gz安装包~/.cache/vmware/drag_and_drop 定期删除拷贝的文件缓存 基本配置12345678apt update;apt install htop jnettop tmux iotopdpkg-reconfigure tzdata 选择Asia-Shanghai apt update 更新自动同步时间apt install xfonts-intl-chinese 装中文字体apt-get install ttf-wqy-microhei# nano /etc/ssh/sshd_config 开启sshdPermitRootLogin yes# /etc/init.d/ssh start 常用软件1234567tar zxf android-studio-ide-201.7042882-linux.tar.gzcd ~/Desktop/android-studio/bin &amp;&amp; ./studio.sh 启动android studioctrl+shift+t 当前窗口新建终端vim ~/.zshrcexport PATH=\"/root/Android/Sdk/platform-tools:$PATH\" 加入环境变量exec \"$SHELL\"dpkg -i code_1.52.1-1608136922_amd64.deb 安装vscode as若报错To build this project, accept the SDK license agreements and install the missing components？ 执行/root/Android/Sdk/tools/bin/sdkmanager –licenses Android设备投屏 NodeJs jadx-1.2.0.zip多dex打开，修改jadx-gui中set DEFAULT_JVM_OPTS=&quot;-Xms512M&quot; &quot;-Xmx8g&quot;,加入zshrc的环境变量中export PATH=&quot;/root/Android/Sdk/ndk-bundle:/root/Android/Sdk/platform-tools:${JAVA_HOME}/bin:$PATH:/root/Desktop/charles/bin:/root/Desktop/jadx-1.2.0/bin:$NDK_HOME&quot; 123curl -fsSL https://deb.nodesource.com/setup_14.x | bash -apt-get install -y nodejsnpm install --save @types/frida-gum frida代码提示 jeb-pro-3.19.1.202005071620_pwd_ilbtcdnwiuypbzeo_.7z 运行./jeb_linux.sh，输入密码：ilbtcdnwiuypbzeo，进入界面点击Manual Key Generation中间按钮获取LICENSE DATA，运行jebKeygen.py 获取license key后输入到界面的key中，continue Kali Linux里的as4的DDMS启动失败，原因是要用as自带的jre来启动，直接./monitor用的是Kali系统的jdk，版本太高了ln -s /root/Desktop/android-studio/jre/ /root/Android/Sdk/tools/lib/monitor-x86_64/,然后通过~/Android/Sdk/tools/monitor打开ddms vim ~/.bashrc &amp;&amp; source ~/.bashrc export PATH=$PATH:/root/Android/Sdk/platform-tools jdk1.8 123456789101112apt-get remove openjdk-11-jre-headless:amd64apt-get remove openjdk-11-jre:amd64tar zxf jdk-8u191-linux-x64.tar.gz -C &#x2F;opt&#x2F;jdkvim ~&#x2F;.zshrcexport JAVA_HOME&#x3D;&#x2F;opt&#x2F;jdkexport CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;libexport PATH&#x3D;&quot;&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;ndk-bundle:&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;platform-tools:$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH&quot;source ~&#x2F;.zshrcupdate-alternatives --install &#x2F;usr&#x2F;bin&#x2F;java java &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;java 1update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;javac javac &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;javac 1update-alternatives --set java &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;javaupdate-alternatives --set javac &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;javac nexus 5x 安装流程 twrp-&gt;SuperSu-&gt; nethunter kali nethunter下载nexus 5x nethunter，使用投屏可变成一个迷你的linux渗透系统，通过twrp进行install ，sh userinit.sh 同步时间 tab smali与java代码转换 ctrl+b 下断点（注意这个必须在smali代码界面才有用） esc 回退上一级引用 activity_main.xml中配置的view组件：jeb中以十六进制存在于代码中，利用计算器的程序员模式转为十进制，jadx将该十进制存入resources.arsc，gda有APK入口直接进入MainActivity，同样以十六进制存入代码中。 科学上网dpkg -i electron-ssr-0.2.6.deb 卸载使用-r，查询使用-l ,失败缺少包，经过https://pkgs.org/ 查找所缺的包并安装 123456apt --fix-broken installapt-get install gconf2dpkg -i libdbusmenu-gtk4_18.10.20180917_bzr492+repack1-2_amd64.deb dpkg -i libindicator7_0.5.0-4_amd64.deb dpkg -i libappindicator1_0.4.92-8_amd64.debdpkg -i electron-ssr-0.2.6.deb 启动electron-ssr的pac模式即可vim /etc/proxychains4.conf 通过右键复制SSR服务器订阅代理设置 1http 127.0.0.1 12333 基本命令 getprop ro.product.cpu.abi 判断系统cpu版本 虚拟机一般都是x86 dumpsys meminfo pid 查看进程占用内存映射的信息 cat /proc/pid/maps 进程加载的so cat /proc/pid/maps | grep -i libart.so 所有java代码通过libart.so解析，脱壳机的关键 dumpsys activity top 显示当前的Activity，显示View Hierarchy，看view的类信息 dumpsys package com.soviet.hook4crawler 查看运行包信息 pm list packages 查看所有安装的包 pyenv环境对python不同包(frida,objection…)多版本管理 全套安装最新版本：proxychains pip install objection 3.8.512345678910111213ctrl+alt+t 新建终端git clone https://github.com/pyenv/pyenv.git ~/.pyenv 安装pyenv，python全版本随意切echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' &gt;&gt; ~/.zshrcecho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' &gt;&gt; ~/.zshrcecho -e 'if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\\n eval \"$(pyenv init -)\"\\nfi' &gt;&gt; ~/.zshrcexec \"$SHELL\"apt-get update; apt-get install --no-install-recommends make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-devPYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pyenv install 3.8.5 使用代理访问，不然会报错you can specify \"--disable-ipv6\".pyenv local 3.8.5python -Vpyenv local system 切换原系统pyenvpip install frida-toolsproxychains4 pip install objection==1.9.5 针对指定frida版本的objection，通过pypi中查找frida release日期稍后一点版本的objection即可7x x frida-server-14.2.8-android-arm64.xz 123456adb push frida-server-14.2.8-android-arm64 /data/local/tmpmv frida-server-14.2.8-android-arm64 fs1428arm64 改名fs1428arm64,防止反调试chmod 777 fs1428arm64 加权./fs1428arm64frida-ps -Uandroid hooking list classes 3.8.0123456PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pyenv install 3.8.0 pyenv local 3.8.0 PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pip install frida==12.8.0PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pip install frida-tools==5.3.0PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pip install objection==1.8.4objection -g com.android.settings explore 7z x frida-server-12.8.0-android-arm64 12345adb push frida-server-12.8.0-android-arm64 /data/local/tmpmv frida-server-12.8.0-android-arm64 fs128arm64 改名防止反调试chmod 777 frida-server-12.8.0-android-arm64objection -g com.android.settings exploreandroid hooking list classes 特定版本frida 按照这个顺序，在装objection的时候，就会直接Requirement already satisfied，不会再去下载新的frida来安装了。 123pip install frida&#x3D;&#x3D;12.8.0 pip install frida-tools&#x3D;&#x3D;5.3.0 pip install objection&#x3D;&#x3D;1.8.4 frida开发环境 pyenv local 3.8.0 &amp;&amp; ./fs128arm64 git clone https://github.com/oleavr/frida-agent-example.git cd frida-agent-example/ npm install 使用VSCode等IDE打开此工程，在agent下编写typescript，会有智能提示。 npm run watch会监控代码修改自动编译生成js文件 frida -UF -l demo.js usb连接手机保存将自动调用demo.js 进行hook Java.perform(function(){console.log(&quot;frida hook&quot;)}) frida -UF -l demo.js –runtime=v8 使用v8引擎 Java.perform(()=&gt;{console.log(&quot;Hello World&quot;)}) frida-ps -U 查看所有进程 frida -H 192.168.0.100:5555 -f com.ttxapps.wifiadb -l demo.js –runtime=v8 远程hook,-l指定脚本 frida -Uf com.android.settings -l demo.js –runtime=v8 –no-pause 经过usb主动启动应用调用demo.js,-f是spawn模式,–no-pause直接加载应用，没有的话需要%resume启动主线程 frida -UF –runtime=v8 -e “Java.perform(()=&gt;{console.log(‘Hello World’)})” -o /root/log.txt 直接执行脚本写入文件 远程连接 ./fs128arm64 -v -l 0.0.0.0:8888 指定端口启动frida，默认端口27042 frida-ps -H 192.168.0.8:8888 指定-U表示usb,-H表示主机ip frida -H 192.168.0.8:8888 -F 指定-H表示主机ip，-F表示前台应用，输入frida即可查看Frida信息 cd frida-agent-example/ &amp;&amp; npm install &amp;&amp; npm run watch &amp;&amp; frida -H 192.168.0.8:8888 -F -l agent/demo.js 远程调用js脚本 1234567Java.perform(()&#x3D;&gt;&#123;console.log(&quot;Hello World&quot;)&#125;) function main()&#123; Java.perform(function()&#123; console.log(&quot;hello&quot;) &#125;)&#125;setImmediate(main) 远程调用 12345678910111213import fridadevice &#x3D; frida.get_usb_device() print(device.get_frontmost_application())#pid &#x3D; device.spawn([&quot;com.onejane.demo02&quot;])pid&#x3D;device.get_frontmost_application().pid # 若双进程保护，指定pid进行hook print(device.enumerate_processes()) # 枚举所有进程print(device.enumerate_applications()) # 枚举所有包名# device.resume(pid)# time.sleep(1)session &#x3D; device.attach(pid) with open(&quot;demo.js&quot;) as f: script &#x3D; session.create_script(f.read())script.load() plugins 1234proxychains git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;FRIDA-DEXDump ~&#x2F;Downloads&#x2F;FRIDA-DEXDump 脱壳mv ~&#x2F;Downloads&#x2F;FRIDA-DEXDump&#x2F;frida_dexdump ~&#x2F;.objection&#x2F;plugins&#x2F;dexdump 在plugins子目录插件下必须有__init__.pyproxychains git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;Wallbreaker ~&#x2F;.objection&#x2F;plugins&#x2F;Wallbreaker 内存漫游objection -N -h 192.168.0.8 -p 8888 -g com.android.settings explore -P ~&#x2F;.objection&#x2F;plugins 远程连接批量加载插件 卸载pip uninstall frida pip uninstall frida-tools pip uninstall objection","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"kali","slug":"kali","permalink":"http://onejane.github.io/tags/kali/"},{"name":"xposed","slug":"xposed","permalink":"http://onejane.github.io/tags/xposed/"}]}],"categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"},{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"},{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"},{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"},{"name":"脚本","slug":"脚本","permalink":"http://onejane.github.io/categories/%E8%84%9A%E6%9C%AC/"},{"name":"生活","slug":"生活","permalink":"http://onejane.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"FART","slug":"FART","permalink":"http://onejane.github.io/tags/FART/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://onejane.github.io/tags/elasticsearch/"},{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"kali","slug":"kali","permalink":"http://onejane.github.io/tags/kali/"},{"name":"redis","slug":"redis","permalink":"http://onejane.github.io/tags/redis/"},{"name":"ssl","slug":"ssl","permalink":"http://onejane.github.io/tags/ssl/"},{"name":"aosp","slug":"aosp","permalink":"http://onejane.github.io/tags/aosp/"},{"name":"xposed","slug":"xposed","permalink":"http://onejane.github.io/tags/xposed/"},{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"},{"name":"scrapy","slug":"scrapy","permalink":"http://onejane.github.io/tags/scrapy/"},{"name":"fart","slug":"fart","permalink":"http://onejane.github.io/tags/fart/"},{"name":"postern","slug":"postern","permalink":"http://onejane.github.io/tags/postern/"},{"name":"charles","slug":"charles","permalink":"http://onejane.github.io/tags/charles/"},{"name":"youpk","slug":"youpk","permalink":"http://onejane.github.io/tags/youpk/"},{"name":"dexdump","slug":"dexdump","permalink":"http://onejane.github.io/tags/dexdump/"},{"name":"selenium","slug":"selenium","permalink":"http://onejane.github.io/tags/selenium/"},{"name":"wallbreaker","slug":"wallbreaker","permalink":"http://onejane.github.io/tags/wallbreaker/"},{"name":"scrapy_redis","slug":"scrapy-redis","permalink":"http://onejane.github.io/tags/scrapy-redis/"},{"name":"mongo","slug":"mongo","permalink":"http://onejane.github.io/tags/mongo/"},{"name":"asyncore","slug":"asyncore","permalink":"http://onejane.github.io/tags/asyncore/"},{"name":"socket","slug":"socket","permalink":"http://onejane.github.io/tags/socket/"},{"name":"asyncio","slug":"asyncio","permalink":"http://onejane.github.io/tags/asyncio/"},{"name":"websocket","slug":"websocket","permalink":"http://onejane.github.io/tags/websocket/"},{"name":"requests","slug":"requests","permalink":"http://onejane.github.io/tags/requests/"},{"name":"pymongo","slug":"pymongo","permalink":"http://onejane.github.io/tags/pymongo/"},{"name":"flask","slug":"flask","permalink":"http://onejane.github.io/tags/flask/"},{"name":"xpath","slug":"xpath","permalink":"http://onejane.github.io/tags/xpath/"},{"name":"css","slug":"css","permalink":"http://onejane.github.io/tags/css/"},{"name":"json","slug":"json","permalink":"http://onejane.github.io/tags/json/"},{"name":"parsel","slug":"parsel","permalink":"http://onejane.github.io/tags/parsel/"},{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","permalink":"http://onejane.github.io/tags/ThreadPoolExecutor/"},{"name":"BoundedSemaphore","slug":"BoundedSemaphore","permalink":"http://onejane.github.io/tags/BoundedSemaphore/"},{"name":"classloader","slug":"classloader","permalink":"http://onejane.github.io/tags/classloader/"},{"name":"Dalvik","slug":"Dalvik","permalink":"http://onejane.github.io/tags/Dalvik/"},{"name":"ART","slug":"ART","permalink":"http://onejane.github.io/tags/ART/"},{"name":"Socket","slug":"Socket","permalink":"http://onejane.github.io/tags/Socket/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://onejane.github.io/tags/WebSocket/"},{"name":"Protobuf","slug":"Protobuf","permalink":"http://onejane.github.io/tags/Protobuf/"},{"name":"XMPP","slug":"XMPP","permalink":"http://onejane.github.io/tags/XMPP/"},{"name":"nacos","slug":"nacos","permalink":"http://onejane.github.io/tags/nacos/"},{"name":"feign","slug":"feign","permalink":"http://onejane.github.io/tags/feign/"},{"name":"gateway","slug":"gateway","permalink":"http://onejane.github.io/tags/gateway/"},{"name":"sentinel","slug":"sentinel","permalink":"http://onejane.github.io/tags/sentinel/"},{"name":"okhttp3","slug":"okhttp3","permalink":"http://onejane.github.io/tags/okhttp3/"},{"name":"HttpURLConnection","slug":"HttpURLConnection","permalink":"http://onejane.github.io/tags/HttpURLConnection/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://onejane.github.io/tags/Retrofit/"},{"name":"python","slug":"python","permalink":"http://onejane.github.io/tags/python/"},{"name":"vmp","slug":"vmp","permalink":"http://onejane.github.io/tags/vmp/"},{"name":"dex2c","slug":"dex2c","permalink":"http://onejane.github.io/tags/dex2c/"},{"name":"rpc","slug":"rpc","permalink":"http://onejane.github.io/tags/rpc/"},{"name":"so","slug":"so","permalink":"http://onejane.github.io/tags/so/"},{"name":"hexo","slug":"hexo","permalink":"http://onejane.github.io/tags/hexo/"}]}