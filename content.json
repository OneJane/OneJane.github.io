{"meta":{"title":"万物皆可逆向","subtitle":"朝花夕拾","description":"逆向,爬虫","author":"J","url":"http://onejane.github.io","root":"/"},"pages":[{"title":"404","date":"2021-01-30T10:32:36.000Z","updated":"2021-01-30T10:33:01.911Z","comments":true,"path":"/404.html","permalink":"http://onejane.github.io/404.html","excerpt":"","text":"var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }"},{"title":"分类","date":"2021-01-30T07:34:23.000Z","updated":"2021-01-30T08:30:40.321Z","comments":true,"path":"categories/index.html","permalink":"http://onejane.github.io/categories/index.html","excerpt":"","text":"var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }"},{"title":"标签","date":"2021-01-30T07:34:05.000Z","updated":"2021-01-30T08:00:59.817Z","comments":true,"path":"tags/index.html","permalink":"http://onejane.github.io/tags/index.html","excerpt":"","text":"var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }"}],"posts":[{"title":"抓包对抗","slug":"抓包对抗","date":"2022-10-25T13:31:08.000Z","updated":"2022-11-19T02:45:22.818Z","comments":true,"path":"2022/10/25/抓包对抗/","link":"","permalink":"http://onejane.github.io/2022/10/25/%E6%8A%93%E5%8C%85%E5%AF%B9%E6%8A%97/","excerpt":"","text":"服务端校验客户端案例：爱奇艺 平时我们碰到的HTTP和HTTPS都在应用层，SOCKS在会话层，TCP和UDP在传输层，IP在网络层。 HTTP未加密主要有这些不足 通信使用明文(不加密),内容可能会被窃听 不验证通信方的身份,因此有可能遭遇伪装 DNS劫持-&gt;GFW翻墙 无法证明报文的完整性,所以有可能已遭篡改 运营商劫持-&gt;弹窗广告 HTTP+加密+认证+完整性保护=HTTPS，是身披SSL的HTTP。 通信加密：HTTP协议中没有加密机制，但可以通过和SSL( Secure Socket Layer,安全套接层)或TLS( Transport Layer Security，安全层传输协议)的组合使用，加密HTTP的通信内容。用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为Https(HTTP Secure,超文本传输安全协议) 内容加密：客户端需要对HTTP报文内容进行加密处理后再发送请求。为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。有一点必须引起注意,由于该方式不同于SSL或TLS将整个通信线路加密处理,所以内容仍有被篡改的风险。 如下图： 客户端发起https请求将SSL协议给服务端 服务端从CA机构申请一份CA证书(包括服务端公钥和签名)给客户端 客户端读取CA证书明文信息，采用同样hash函数计算拿到信息摘要，用系统自带的CA证书的公钥解密签名(签名由CA的私钥加密)，对比证书中的信息摘要，一致则可信，再取出服务端的公钥去加密客户端生成随机数作为秘钥生成密文发给服务端 服务端用自己私钥解密拿到秘钥随机数 以上是非对称加密过程，后续服务端和客户端通讯过程就是通过该秘钥进行通讯，整个过程都是对称加密了。 对称加密 ： 加密和解密数据使用同一个密钥。这种加密方式的特点是速度很快，常见对称加密的算法有 AES； 非对称加密： 加密和解密使用不同的密钥，这两个密钥形成有且仅有唯一的配对，叫公钥和私钥。数据用公钥加密后必须用私钥解密，数据用私钥加密后必须用公钥解密。一般来说私钥自己保留好，把公钥公开给别人（一般公钥不会单独出现，而是会写进证书中），让别人拿自己的公钥加密数据后发给自己，这样只有自己才能解密。 这种加密方式的特点是速度慢，CPU 开销大，常见非对称加密算法有 RSA。 一般情况下使用HTTP都是能抓到包的, 但是使用HTTPS会抓不到包？现在的HTTPS都是基于TLS协议的, 它的特点就是需要确认传输双方的身份。确认了身份之后再传输数据, 以上就是HTTPS避免中间人攻击的手段。 Charles，Fiddler，BurpSuite代理都是通过给wifi设置http代理的方式进行抓包，HTTPS是包裹在SSL协议里的HTTP，APP-Charles客户端校验服务端，Charles-服务器是服务端校验客户端，不使用charles证书校验失败所有https请求报错400 Bad Request,No required SSL certificate was sent。 使用了服务端的证书访问服务端校验客户端的请求原理就是中间人攻击，而中间人攻击的关键就是截获服务器返回的证书并伪造证书发送给客户端骗取信任，所以在应用层拦截抓包，所以会被很轻易的检测到和绕过的。 123456789101112131415public static boolean isWifiProxy(Context context) &#123; final boolean IS_ICS_OR_LATER &#x3D; Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.ICE_CREAM_SANDWICH; String proxyAddress; int proxyPort; if (IS_ICS_OR_LATER) &#123; proxyAddress &#x3D; System.getProperty(&quot;http.proxyHost&quot;); &#x2F;&#x2F;获取代理主机 String portStr &#x3D; System.getProperty(&quot;http.proxyPort&quot;); &#x2F;&#x2F;获取代理端口 proxyPort &#x3D; Integer.parseInt((portStr !&#x3D; null ? portStr : &quot;-1&quot;)); &#125; else &#123; proxyAddress &#x3D; android.net.Proxy.getHost(context); proxyPort &#x3D; android.net.Proxy.getPort(context); &#125; Log.i(&quot;代理信息&quot;,&quot;proxyAddress :&quot;+proxyAddress + &quot;prot : &quot; proxyPort&quot;) return (!TextUtils.isEmpty(proxyAddress)) &amp;&amp; (proxyPort !&#x3D; -1);&#125; 这两个API来查看当前系统是否挂了http代理，或者发起请求时OkHttpClient okHttpClient = new OkHttpClient.Builder(). proxy(Proxy.NO_PROXY). build();直接设置禁止代理，会很轻松的让你的抓包失效。 趣充：设置no proxy防抓包，校验到直接强退APP，我们通过hook将这个函数替换掉即可。 12345678910111213141516function replaceKill()&#123; &#x2F;&#x2F; 替换掉崩掉时的内容，打印崩掉时的参数和pid，不执行崩掉的逻辑，让程序不要崩 console.log(&quot;Preventing from killing ...&quot;) var kill_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;kill&quot;); &#x2F;&#x2F; var kill &#x3D; new NativeFunction(kill_addr,&quot;int&quot;,[&#39;int&#39;,&#39;int&#39;]); Interceptor.replace(kill_addr,new NativeCallback(function(arg0,arg1)&#123; console.log(&quot;arg0&#x3D;&gt; &quot;,arg0) console.log(&quot;arg1&#x3D;&gt; &quot;,arg1) &#125;,&quot;int&quot;,[&#39;int&#39;,&#39;int&#39;]))&#125;function main()&#123; replaceKill()&#125;setImmediate(main); 所以我们需要换一种方式来设置代理postern，本质在tcp的传输层抓包。就是设置vpn代理，vpn是属于网络层的，设置了vpn后，你的手机上ifconfig后会多一个接口，等于加了一个虚拟网卡，所有的流量都会从这走。应用层和传输层的请求都可以拿到，还不会被上面提及的两个api所检测。 ip route show table 0|grep default 手机路由表第一条降维打击网络层,任何api都必须经过路由解析http。 不过App依旧可以通过判断java.net.NetworkInterface.getName()是否等于tun0或ppp0 或者 android.net.ConnectivityManager.getNetworkCapabilities来判断是否存在VPN抓包，可以通过grep -ril &quot;vpn&quot;反编译后的dex中找到所有关于vpn的函数。 通过objection hook以上的类方法 12345678910111213141516171819202122232425function hook_vpn() &#123; Java.perform(function () &#123; var String &#x3D; Java.use(&quot;java.lang.String&quot;); var NetworkInterface &#x3D; Java.use(&quot;java.net.NetworkInterface&quot;); NetworkInterface.getName.implementation &#x3D; funciont() &#123; var name &#x3D; this.getName(); console.log(&quot;name: &quot; + name); if (name &#x3D;&#x3D; &quot;tun0&quot;) &#123; var result &#x3D; String.$new(&quot;rmnet_data0&quot;) console.log(&quot;hook result:&quot; + result) return result; &#125; else &#123; return name; &#125; &#125; var ConnectivityManager &#x3D; Java.use(&quot;android.net.ConnectivityManager&quot;) ConnectivityManager.getNetworkCapabilities.implementation &#x3D; function (args) &#123; var result &#x3D; this.getNetworkCapabilities(args); console.log(&quot;vpn result: &quot; + result) return null &#125; &#125;)&#125;setImmediate(hook_vpn); 将检测抓包的函数给hook掉不就拦不住我抓包的步伐了嘛！ 不过回过头来，为什么客户端这么容易被欺骗呢？原因就是过于依赖证书的校验合法性！市面上大部分的应用在校验证书是否过期，服务器证书域名与服务器实际域名是否匹配，证书链的完整校验都做的不够好，即时在完整校验了整个证书链体系时，中间人攻击依旧可以在终端手动添加信任根证书的方式发送请求，这也正是抓包软件在抓取HTTPS协议数据前，要求在终端安装证书的原因，确保证书通过客户端的证书链校验。以下可以将证书放到根目录，获取最高权限。 安卓8 1234567cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o remount,rw &#x2F;mount -o remount,rw &#x2F;systemchmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o remount,ro &#x2F;mount -o remount,ro &#x2F;system 安卓7 1234567cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o rw,remount &#x2F;systemmount -o rw,remount &#x2F;chmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o ro,remount &#x2F;systemmount -o ro,remount &#x2F; 安卓10 Move_Certificates-v1.9 直接面具插件安排，重启即可 客户端校验服务端那么FaceBook/Twitter这些大厂是如何做到防止Charles/Fiddler等抓包工具中间人攻击的呢？SSL-Pinning！原理是HTTPS建立时与服务端返回的证书比对一致性，进而识别出中间人攻击后直接在客户端侧中止连接。 证书锁定：开发时就将服务端证书一块打包到客户端里，不接受操作系统或浏览器内置的CA根证书对应的任何证书，通过这种授权方式，保障了APP与服务端通信的唯一性和安全性。但是CA签发证书都存在有效期问题，所以缺点是在证书续期后需要将证书重新内置到APP中。 公钥锁定：提取证书中的公钥并内置到客户端中，通过与服务器对比公钥值来验证连接的正确性。制作证书密钥时，公钥在证书的续期前后都可以保持不变（即密钥对不变），所以可以避免证书有效期问题，一般推荐这种做法。 不过由于客户端会做两个证书间的一次性校验，那么就通过hook的方式将此次校验的结果返回true或者干脆不让其做校验，或者Xposed安装JustTrustMe插件，该插件将各种已知的HTTP请求库中用于校验证书的API进行hook并不论是否可信证书都返回正常状态。 123objection -g com.ophone.reader.ui explore 咪咕阅读android sslpinning disable 需要在启动时运行objection -g com.ophone.reader.ui explore -s &quot;android sslpinning disable&quot; 登录页面触发解绑定，如果崩溃 git clone https://github.com/WooyunDota/DroidSSLUnpinning.gitfrida -U -f com.ninemax.ncsearchnew -l ObjectionUnpinningPlus/hooks.js –no-pause 123456789101112131415161718192021222324252627Java.perform(function() &#123; var array_list &#x3D; Java.use(&quot;java.util.ArrayList&quot;); var ApiClient &#x3D; Java.use(&#39;com.android.org.conscrypt.TrustManagerImpl&#39;); ApiClient.checkTrustedRecursive.implementation &#x3D; function(a1, a2, a3, a4, a5, a6) &#123; &#x2F;&#x2F; console.log(&#39;Bypassing SSL Pinning&#39;); var k &#x3D; array_list.$new(); return k; &#125;&#125;, 0);&#x2F;&#x2F;过证书绑定 ssl pinning 对证书在代码中进行额外校验，function hook_ssl() &#123; &#x2F;&#x2F; hook ssl 调用栈 Java.perform(function() &#123; var ClassName &#x3D; &quot;com.android.org.conscrypt.Platform&quot;; var Platform &#x3D; Java.use(ClassName); var targetMethod &#x3D; &quot;checkServerTrusted&quot;; var len &#x3D; Platform[targetMethod].overloads.length; console.log(len); for(var i &#x3D; 0; i&lt;len; ++i) &#123; Platform[targetMethod].overloads[i].implementation &#x3D; function () &#123; console.log(&quot;class:&quot;, ClassName, &quot;target:&quot;, targetMethod, &quot;i:&quot;, i, arguments); printStack(ClassName + &quot;.&quot; + targetMethod); &#125; &#125; &#125;);&#125; 双向校验SSL pinning实际上是客户端锁定服务器端的证书, 在要与服务器进行交互的时候, 服务器端会将CA证书发送给客户端, 客户端会调用函数对服务器端的证书进行校验, 与本地的服务器端证书(存放在\\\\asset目录或\\res\\raw下)进行比对。 而双向校验是添加了客户端向服务器发送CA证书, 服务器端对客户端的证书进行校验的部分。 客户端和服务端同时检验数据的加密和解密 客户端发起HTTPS请求，将SSL协议信息发送给服务端。 服务端去CA机构申请来一份CA证书，在前面提过，证书里面有服务端公钥和签名。将CA证书发送给客户端 客户端发送自己的客户端证书给服务端，证书里面有客户端的公钥，并发送支持的对称加密方案给服务端，供其选择 服务端选择完加密方案后，按照加密方案完成刚才得到的公钥去加密 客户端用自己的私钥去解密选好的加密方案，客户端生成一个随机数（密钥），用刚才等到的服务端公钥去加密这个随机数形成密文，发送给服务端。 服务端和客户端在后续通讯过程中就使用这个密钥进行通信了。和之前的非对称加密不同，这里开始就是一种对称加密的方式 SoulCharlessoul在登录时报错400 No required SSL certificate was sent，缺少证书，需要在charles中安装客户端证书获取服务器信任。 FridaSocket本质：收发包的接口，一条跑着RAW DATA的通道，纯binary，为了方便使用TCP或UDP而抽象出来作为网络中连接的两端。应用领域SSL+HTTP，SMPT/POP/IMAP，Protobuf等。Socket是传输控制层接口，WebSocket是应用层协议用来创建一种双向通信（全双工）的协议 ,来弥补HTTP协议在持久通信能力上的不足。 常用frida抓包，详情见某摩托的逆向分析 123456789101112131415161718192021222324252627git clone https:&#x2F;&#x2F;github.com&#x2F;siyujie&#x2F;OkHttpLogger-Frida.git adb push okhttpfind.dex &#x2F;data&#x2F;local&#x2F;tmp frida -U -l okhttp_poker.js -f com.motoband --no-pause find() 查看是否使用okhttp并查看混淆结果，将Find Result下的内容复制到okhttp_poker.js开头，替换原有混淆类名 hold()git clone https:&#x2F;&#x2F;github.com&#x2F;BigFaceCat2017&#x2F;frida_ssl_logger.git 解决IP的问题; 适配Windows; andriod高版本适配； iOS&#x2F;macOS适配； 自实现ssl的适配； 适配socket的监控 新增对IP&#x2F;dns的监控 新增对应用列表的显示 python ssl_logger.py -U -f com.qiyi.video &gt;&gt; iqiyi.txt python ssl_logger.py -U -v com.iqiyi.video -p iqiyi.pcapgit clone https:&#x2F;&#x2F;github.com&#x2F;r0ysue&#x2F;r0capture.git 仅限安卓平台，测试安卓7、8、9、10、11、12 可用 ； 无视所有证书校验或绑定，不用考虑任何证书的事情； 通杀TCP&#x2F;IP四层模型中的应用层中的全部协议； 通杀协议包括：Http,WebSocket,Ftp,Xmpp,Imap,Smtp,Protobuf等等、以及它们的SSL版本； 通杀所有应用层框架，包括HttpUrlConnection、Okhttp1&#x2F;3&#x2F;4、Retrofit&#x2F;Volley等等； 无视加固，不管是整体壳还是二代壳或VMP，不用考虑加固的事情； frida -U -f com.motoband -l script.js --no-pause -o motoband.txt python r0capture.py -U -f com.motoband -v python r0capture.py -U -f com.motoband -v -p motoband.pcap python r0capture.py -U -f com.motoband -v &gt;&gt;motoband.txt Hook Socket12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function hook_socket()&#123; Java.perform(function()&#123; console.log(&quot;hook_socket;&quot;) Java.use(&quot;java.net.SocketOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTP write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; Java.use(&quot;java.net.SocketInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTP read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; &#125;)&#125;function hook_SSLsocketandroid8()&#123; Java.perform(function()&#123; console.log(&quot;hook_SSLsocket&quot;) Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTPS write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTPS read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; &#125;)&#125;function hook_SSLsocket2android10()&#123; Java.perform(function()&#123; console.log(&quot; hook_SSLsocket2&quot;) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_write.implementation &#x3D; function(long,NS,fd,NC,bytearray,int1,int2,int3)&#123; var result &#x3D; this .SSL_write(long,NS,fd,NC,bytearray,int1,int2,int3); console.log(&quot;SSL_write(long,NS,fd,NC,bytearray,int1,int2,int3),result&#x3D;&gt;&quot;,long,NS,fd,NC,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex()); return result; &#125; Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_read.implementation &#x3D; function(long,NS,fd,NC,bytearray,int1,int2,int3)&#123; var result &#x3D; this .SSL_read(long,NS,fd,NC,bytearray,int1,int2,int3); console.log(&quot;SSL_read(long,NS,fd,NC,bytearray,int1,int2,int3),result&#x3D;&gt;&quot;,long,NS,fd,NC,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex()); return result; &#125; &#125;)&#125;function main()&#123; console.log(&quot;Main&quot;) hook_socket(); hook_SSLsocketandroid8(); &#x2F;&#x2F;hook_SSLsocket2android10();&#125;setImmediate(main) Hook KeyStore123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function printStack(str_tag) &#123; var Exception&#x3D; Java.use(&quot;java.lang.Exception&quot;); var ins &#x3D; Exception.$new(&quot;Exception&quot;); var straces &#x3D; ins.getStackTrace(); if (undefined &#x3D;&#x3D; straces || null &#x3D;&#x3D; straces) &#123; return; &#125; console.log(&quot;&#x3D;&#x3D;&quot; + str_tag + &quot; Stack strat &#x3D;&#x3D;&#x3D;&quot;); console.log(&quot;&quot;); for (var i &#x3D; 0; i &lt; straces.length; i++) &#123; var str &#x3D; &quot; &quot; + straces[i].toString(); console.log(str); &#125; console.log(&quot;&quot;); console.log(&quot;&#x3D;&#x3D;&#x3D;&quot; + str_tag + &quot; Stack end &#x3D;&#x3D;&#x3D;\\r\\n&quot;); Exception.$dispose(); &#125;&#x2F;&#x2F;过客户端校验服务器function hook_KeyStore_load() &#123; &#x2F;&#x2F; hook证书 自吐证书密码和内容保存在sdcard中 Java.perform(function () &#123; var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); var myArray&#x3D;new Array(1024); var i &#x3D; 0 for (i &#x3D; 0; i &lt; myArray.length; i++) &#123; myArray[i]&#x3D; 0x0; &#125; var buffer &#x3D; Java.array(&#39;byte&#39;,myArray); var StringClass &#x3D; Java.use(&quot;java.lang.String&quot;); var KeyStore &#x3D; Java.use(&quot;java.security.KeyStore&quot;); KeyStore.load.overload(&#39;java.security.KeyStore$LoadStoreParameter&#39;).implementation &#x3D; function (arg0) &#123; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(&quot;KeyStore.load1:&quot;, arg0); this.load(arg0); &#125;; KeyStore.load.overload(&#39;java.io.InputStream&#39;, &#39;[C&#39;).implementation &#x3D; function (arg0, arg1) &#123; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(&quot;KeyStore.load2:&quot;, arg0, arg1 ? StringClass.$new(arg1) : null); if (arg0)&#123; var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(&quot;&#x2F;sdcard&#x2F;Download&quot;+ String(arg0)+&quot;.p12&quot;); var out &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); var r; while( (r &#x3D; arg0.read(buffer)) &gt; 0)&#123; out.write(buffer,0,r) &#125; console.log(&quot;save success!&quot;) out.close() &#125; this.load(arg0, arg1); &#125;; console.log(&quot;hook_KeyStore_load...&quot;); &#125;);&#125;&#x2F;&#x2F;过证书绑定 ssl pinning 对证书在代码中进行额外校验，function hook_ssl() &#123; &#x2F;&#x2F; hook ssl 调用栈 Java.perform(function() &#123; var ClassName &#x3D; &quot;com.android.org.conscrypt.Platform&quot;; var Platform &#x3D; Java.use(ClassName); var targetMethod &#x3D; &quot;checkServerTrusted&quot;; var len &#x3D; Platform[targetMethod].overloads.length; console.log(len); for(var i &#x3D; 0; i&lt;len; ++i) &#123; Platform[targetMethod].overloads[i].implementation &#x3D; function () &#123; console.log(&quot;class:&quot;, ClassName, &quot;target:&quot;, targetMethod, &quot;i:&quot;, i, arguments); printStack(ClassName + &quot;.&quot; + targetMethod); &#125; &#125; &#125;);&#125; 开启hook 123frida -U -f cn.soulapp.android -l ssl.js 通过attach进行hook公钥加解密的框架层api，打印密码用于解开证书用%resume 重新启动frida -U -f cn.soulapp.android -l ssl.js --no-pause 通过spawn进行hook，证书公钥发送给服务器，从服务器获取session用私钥进行解密的api进行hook，属于自吐，查看terminal中的密码 &#125;%2R+\\OSsjpP!w%X 或者通过反编译拿到证书加载的位置，关键词PKCS12 第二个红框中的load函数的第二个参数其实就是证书的密钥, 追根溯源, 我们可以知道v1参数是下图中调用的函数的返回值。 功能就是传递p0参数, 也就是说p0参数就是证书安装密码。想获取这个密码, 关键在于Auto_getValue函数。到这一步, 只要跟进Null_getStorePassword函数看看就好了。跟进去发现调用了native层的函数, 查看init函数中具体加载的是哪个so文件。 用IDA反编译soul-netsdk之后, 搜索字符串”getStorePassword”, 就定位到函数getStorePassword上了, F5之后, 获得伪代码和密钥 抓包1234567897z x soul_channel_soul.apktree -NCfhl|grep -i p12 找到证书位置tree -NCfhl|grep -i bks或者objection -g cn.soulapp.android explore 如果报错查看frida的客户端和服务端版本是否匹配android hooking watch class_method java.io.File$init --dump-args 如果找不到文件exit并干掉app后objection -g cn.soulapp.android explore --start-command &quot;android hooking watch class_method java.io.File$init --dump-args&quot;du -h assets&#x2F;client.p12file assets&#x2F;client.p12thunar . 在windows上找到后双击导入私钥需要密码即刚才hook到的&#125;%2R+\\OSsjpP!w%X 该证书的内容即可以全部显示 安装证书 导入charles - Proxy- SSL Proxying Settings 添加客户端证书 启动ssl抓包，Charles将对任意服务器发送该客户端证书，意味着用app访问所有的服务器，后续关闭客户端证书的soulapp.cn，否则会误认为请求来自于soul， 测试登录 fiddler中可以使用openssl将.p12格式的证书转换成.cer/.der格式的证书。(.der和.cer格式的证书仅有文件头和文件尾不同) 下面的命令实现了证书的格式转换, .p12-&gt;.pem-&gt;.cer, 在生成.pem格式的证书之后, 需要输入证书的密码, 也就是我们上面逆向获取的证书密码，也就是我们上面逆向获取的证书密码。最后将ClientCertificate.cer移动到之前Fiddler弹窗出现的目录下, 也就是\\Fiddler4下。 12345# 将.p12证书转换成.pem格式$ openssl pkcs12 -in client.p12 -out ClientCertificate.pem -nodesEnter Import Password:# 将.pem证书转换成.cer格式$ x509 -outform der -in ClientCertificate.pem -out ClientCertificate.cer 趣充frida -U -f com.whwy.equchong -l hook_keystore.js –no-pause -o quchong.txt 证书位置和密钥在KeyStore.load2后的/sdcard/Download 将p12证书拷贝出来，下载kse_5.4.4_all.deb，dpkg -i kse_2.4.4_all.deb，启动keystore explore打开p12证书，输入密码即可查看证书内容 右键-export-export key pair-输入密码 保存为p12，设置密码123456 charles-SSL Proxying Settings-Client Certificate-Import P12-导入导出的p12证书，密码为123456，Host Port配*表示所有发出去的包都用这个证书 启动Postern，配置charles抓包，重新注册获取验证码，依旧拿不到结果是，查看socket后的端口9443，在charles中配置9443端口，即可拿到完整加密请求结果 滴答启动charles抓包，发送验证码，查看OverView 证书绑定校验失败：Client closed the connection before a request was made.Possibly the SSL certificate was rejected.You may need to configure your browser or application to trust the Charles Root Certificate.See SSL Proxyinf in the Help menu. Android SSL证书设置和锁定(SSL/TLS Pinning)查看安卓设置-加密与凭据-信任的凭据 frida -U -f cn.ticktick.task -l quchong.js –no-pause 执行hook_ssl() 失败 objection -g cn.ticktick.task explore -s “android sslpinning disable” 失败 git clone https://github.com/WooyunDota/DroidSSLUnpinning.git frida -U -f cn.ticktick.task -l hooks.js –no-pause 失败 1234objection -g cn.ticktick.task explore -s &quot;android hooking watch class_method java.io.File.$init --dump-args --dump-backtrace --dump-return&quot; 打开证书文件就初始化这个文件，hook该类,发送验证码plugin wallbreaker classdump z1.gplugin wallbreaker objectsearch z1.g plugin wallbreaker objectdump --fullname 0x24e6 123cd OkHttpLogger-Frida &amp;&amp; frida -U -f cn.ticktick.task -l okhttp_poker.js %resumefind() 失败则不是ok3混淆,那么就是ok1 https://square.github.io/okhttp/4.x/okhttp/okhttp3/-certificate-pinner/ 1234567891011android hooking list class_methods z1.g 其中有z1.g.a,在CertificatePinner中被混淆的function killCertificatePinner()&#123; Java.perform(function()&#123; console.log(Beginning killCertificatePinner !...) Java.use(z1.g).a.implementation &#x3D; function(str,list)&#123; console.log(called z1.g.a ~) return ; &#125; &#125;)&#125;frida -U -f cn.ticktick.task -l quchong.js --no-pause 发送注册短信过掉z1.g.a的ok1中的证书 多重证书绑定咪咕视频登录抓包，SSL handshake with client failed: An unknown issue occurred processing the certificate (certificate_unknown)从抓包发现证书 绑定,可能客户端只信任信任的公钥签名，不信任就不允许，停止客户端访问的证书绑定。客户端发了，我们已经绕过了校验，把自己公钥发给charles，charles用自己私钥解开客户端的公钥发现不正常的结果。 123456dumpsys activity top 查看包名 com.ophone.reader.uiobjection -g com.ophone.reader.ui exploreandroid sslpinning disable 需要在启动时运行objection -g com.ophone.reader.ui explore -s &quot;android sslpinning disable&quot; 在点我登录页面触发解绑定，如果崩溃objection -g com.ophone.reader.ui explore 在点我登录时开始漫游android sslpinning disable 解绑定后再获取验证码，再抓包 证书绑定的逻辑没有hook掉：”at com.bangcle.andjni.JniLib.cL(Native Method)” → 只有逆代码来过证书绑定 1python r0capture.py -U com.ophone.reader.ui -v -p migu.pcap 关闭postern抓包,获取验证码没有更新log，说明没有一些底层的框架 通过wireshark查看migu.pcap结果，发现也没有关键性信息，抓包也抓不到。 123456python r0capture.py -U -f com.ophone.reader.ui -v 尝试导出证书frida -U -f com.ophone.reader.ui -l script.js --no-pauseadb shell 查看sdcard&#x2F;Download下的证书adb pull &#x2F;sdcard&#x2F;Download&#x2F;ophone 下的证书导入到Charles的SSL Proxying Settings中，打开postern抓包objection -g com.ophone.reader.ui explore 在点我登录时开始漫游android sslpinning disable 解绑定后再获取验证码抓包即可获取passport.migu.cn:8443的包信息 SSL handshake with server failed - Remote host terminated the handshakeThe remote SSL server rejected the connection. The server may require a specific certificate or cipher not supported by Charles. 过客户端证书后发现更多证书绑定,Frida.Android.Practice 1objection -g com.ophone.reader.ui explore -s &quot;android sslpinning disable&quot; git clone https://github.com/WooyunDota/DroidSSLUnpinning.git 1frida -U -f com.ophone.reader.ui -l hooks.js --no-pause 抓发送验证码包依旧有请求失败 FRIDA 使用经验交流分享，git clone https://github.com/deathmemory/FridaContainer.git 1234cd utils&#x2F;androidfrida -U -f com.ophone.reader.ui -l multi_unpinning.js --no-pauseobjection -g com.ophone.reader.ui explore -s &quot;android hooking watch class_method java.io.File.\\$init --dump-args --dump-backtrace --dump-return&quot; 查看证书frida -U -f com.ophone.reader.ui -l trace.js --no-pause -o ophone.txt 修改trace.js中traceClass(&quot;java.io.File&quot;),在traceClass中修改targets&#x3D;[]只trace init方法,在traceMethod中打开调用栈android.util.log，发送验证码后查看文件,搜索cacert查看调用栈 北京银行1234python r0capture.py -U -f com.bankofbeijing.mobilebanking -v.&#x2F;hluda-server-14.2.1-android-arm64frida -U -f com.bankofbeijing.mobilebanking -l script.js --no-pause -o bjbank.txtfrida -U -f com.bankofbeijing.mobilebanking -l trace.js --no-pause -o bjbank2.txt 打开traceClass(&quot;java.security.KeyStore$PrivateKeyEntry&quot;) 加固厂商自定义开发的证书绑定对抗很难被攻克。终极解决方案就是修改安卓底层aosp源码，将发送请求时打印log后，重编译成镜像刷机，比如项目crypto_filter_aosp，让整个系统都变成一个抓包工具。 参考： HTTPS防抓包策略与对抗方法总结 服务端客户端双向认证 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"chales","slug":"chales","permalink":"http://onejane.github.io/tags/chales/"}]},{"title":"调试与反调试","slug":"调试与反调试","date":"2022-10-19T08:08:14.000Z","updated":"2022-10-20T14:38:45.586Z","comments":true,"path":"2022/10/19/调试与反调试/","link":"","permalink":"http://onejane.github.io/2022/10/19/%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 ANDROID调试检测技术汇总1. IDA调试端口检测原理： 调试器远程调试时，会占用一些固定的端口号。 做法： 读取/proc/net/tcp，查找IDA远程调试所用的23946端口，若发现说明进程正在被IDA调试。 （也可以运行netstat -apn结果中搜索23946端口） 1234567891011121314151617181920void CheckPort23946ByTcp()&#123; FILE* pfile&#x3D;NULL; char buf[0x1000]&#x3D;&#123;0&#125;; &#x2F;&#x2F; 执行命令 char* strCatTcp&#x3D; &quot;cat &#x2F;proc&#x2F;net&#x2F;tcp |grep :5D8A&quot;; &#x2F;&#x2F;char* strNetstat&#x3D;&quot;netstat |grep :23946&quot;; pfile&#x3D;popen(strCatTcp,&quot;r&quot;); if(NULL&#x3D;&#x3D;pfile) &#123; LOGA(&quot;CheckPort23946ByTcp popen打开命令失败!\\n&quot;); return; &#125; &#x2F;&#x2F; 获取结果 while(fgets(buf,sizeof(buf),pfile)) &#123; &#x2F;&#x2F; 执行到这里，判定为调试状态 LOGA(&quot;执行cat &#x2F;proc&#x2F;net&#x2F;tcp |grep :5D8A的结果:\\n&quot;); LOGB(&quot;%s&quot;,buf); &#125;&#x2F;&#x2F;while pclose(pfile); &#125; 2. 调试器进程名检测原理：远程调试要在手机中运行android_server gdbserver gdb等进程。 做法： 遍历进程，查找固定的进程名，找到说明调试器在运行。 1234567891011121314151617181920212223242526272829void SearchObjProcess() &#123; FILE* pfile&#x3D;NULL; char buf[0x1000]&#x3D;&#123;0&#125;; &#x2F;&#x2F; 执行命令 &#x2F;&#x2F;pfile&#x3D;popen(&quot;ps | awk &#39;&#123;print $9&#125;&#39;&quot;,&quot;r&quot;); &#x2F;&#x2F; 部分不支持awk命令 pfile&#x3D;popen(&quot;ps&quot;,&quot;r&quot;); if(NULL&#x3D;&#x3D;pfile) &#123; LOGA(&quot;SearchObjProcess popen打开命令失败!\\n&quot;); return; &#125; &#x2F;&#x2F; 获取结果 LOGA(&quot;popen方案:\\n&quot;); while(fgets(buf,sizeof(buf),pfile)) &#123; &#x2F;&#x2F; 打印进程 LOGB(&quot;遍历进程:%s\\n&quot;,buf); &#x2F;&#x2F; 查找子串 char* strA&#x3D;NULL,strB&#x3D;NULL,strC&#x3D;NULL,strD&#x3D;NULL; strA&#x3D;strstr(buf,&quot;android_server&quot;); strB&#x3D;strstr(buf,&quot;gdbserver&quot;); strC&#x3D;strstr(buf,&quot;gdb&quot;); strD&#x3D;strstr(buf,&quot;fuwu&quot;); if(strA || strB ||strC || strD) &#123; &#x2F;&#x2F; 执行到这里，判定为调试状态 LOGB(&quot;发现目标进程:%s\\n&quot;,buf); &#125;&#x2F;&#x2F;if &#125;&#x2F;&#x2F;while pclose(pfile); &#125; 3 父进程名检测原理： 有的时候不使用apk附加调试的方法进行逆向，而是写一个.out可执行文件直接加载so进行 调试，这样程序的父进程名和正常启动apk的父进程名是不一样的。 测试发现： （1）正常启动的apk程序：父进程是zygote （2）调试启动的apk程序：在AS中用LLDB调试发现父进程还是zygote （3）附加调试的apk程序：父进程是zygote （4）vs远程调试 用可执行文件加载so:父进程名为gdbserver 结论：父进程名非zygote的，判定为调试状态。 读取/proc/pid/cmdline，查看内容是否为zygote 123456789101112131415161718192021222324252627282930void CheckParents() &#123; &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;&#x2F; 设置buf char strPpidCmdline[0x100]&#x3D;&#123;0&#125;; snprintf(strPpidCmdline, sizeof(strPpidCmdline), &quot;&#x2F;proc&#x2F;%d&#x2F;cmdl ine&quot;, getppid()); &#x2F;&#x2F; 打开文件 int file&#x3D;open(strPpidCmdline,O_RDONLY); if(file&lt;0) &#123; LOGA(&quot;CheckParents open错误!\\n&quot;); return; &#125; &#x2F;&#x2F; 文件内容读入内存 memset(strPpidCmdline,0,sizeof(strPpidCmdline)); ssize_t ret&#x3D;read(file,strPpidCmdline,sizeof(strPpidCmdline)); if(-1&#x3D;&#x3D;ret) &#123; LOGA(&quot;CheckParents read错误!\\n&quot;); return; &#125; &#x2F;&#x2F; 没找到返回0 char sRet&#x3D;strstr(strPpidCmdline,&quot;zygote&quot;); if(NULL&#x3D;&#x3D;sRet) &#123; &#x2F;&#x2F; 执行到这里，判定为调试状态 LOGA(&quot;父进程cmdline没有zygote子串!\\n&quot;); return; &#125; int i&#x3D;0; return; &#125; 4 自身进程名检测原理： 和上条一样，也是写个.out加载so来脱壳的场景， 正常进程名一般是apk的com.xxx这样的格式。 代码： 略 5 apk线程检测原理： 同样.out加载so来脱壳的场景， 正常apk进程一般会有十几个线程在运行(比如会有jdwp线程)， 自己写可执行文件加载so一般只有一个线程， 可以根据这个差异来进行调试环境检测。 123456789101112131415161718192021222324252627282930void CheckTaskCount()&#123; char buf[0x100]&#x3D;&#123;0&#125;; char* str&#x3D;&quot;&#x2F;proc&#x2F;%d&#x2F;task&quot;; snprintf(buf,sizeof(buf),str,getpid()); &#x2F;&#x2F; 打开目录: DIR* pdir &#x3D; opendir(buf); if (!pdir) &#123; perror(&quot;CheckTaskCount open() fail.\\n&quot;); return; &#125; &#x2F;&#x2F; 查看目录下文件个数: struct dirent* pde&#x3D;NULL; int Count&#x3D;0; while ((pde &#x3D; readdir(pdir))) &#123; &#x2F;&#x2F; 字符过滤 if ((pde-&gt;d_name[0] &lt;&#x3D; &#39;9&#39;) &amp;&amp; (pde-&gt;d_name[0] &gt;&#x3D; &#39;0&#39;)) &#123; ++Count; LOGB(&quot;%d 线程名称:%s\\n&quot;,Count,pde-&gt;d_name); &#125; &#125; LOGB(&quot;线程个数为：%d&quot;,Count); if(1&gt;&#x3D;Count) &#123; &#x2F;&#x2F; 此处判定为调试状态. LOGA(&quot;调试状态!\\n&quot;); &#125; int i&#x3D;0; return; &#125; 6 apk进程fd文件检测原理： 根据/proc/pid/fd/路径下文件的个数差异，判断进程状态。 （apk启动的进程和非apk启动的进程fd数量不一样） （apk的debug启动和正常启动，进程fd数量也不一样） 代码： 略 7 安卓系统自带调试检测函数// android.os.Debug.isDebuggerConnected(); 原理： 分析android自带调试检测函数isDebuggerConnected()在native的实现， 尝试在native使用。 做法： （1）dalvik模式下: 找到进程中libdvm.so中的dvmDbgIsDebuggerConnected()函数， 调用他就能得知程序是否被调试。 dlopen(/system/lib/libdvm.so) dlsym(_Z25dvmDbgIsDebuggerConnectedv) （2）art模式下： art模式下，结果存放在libart.so中的全局变量gDebuggerActive中， 符号名为_ZN3art3Dbg15gDebuggerActiveE。 但是貌似新版本android不允许使用非ndk原生库，dlopen(libart.so)会失败。 所以无法用dalvik那样的方法了。 有一种麻烦的方法，手动在内存中搜索libart模块，然后手工寻找该全局变量符号。 1234567891011121314151617181920212223242526&#x2F;&#x2F; 只写了dalvik的代码，art的就不写了 typedef unsigned char wbool; typedef wbool (*PPP)(); void NativeIsDBGConnected() &#123; void* Handle&#x3D;NULL; Handle&#x3D;dlopen(&quot;&#x2F;system&#x2F;lib&#x2F;libdvm.so&quot;, RTLD_LAZY); if(NULL&#x3D;&#x3D;Handle) &#123; LOGA(&quot;dlopen打开libdvm.so失败!\\n&quot;); return; &#125; PPP Fun &#x3D; (PPP)dlsym(Handle, &quot;_Z25dvmDbgIsDebuggerConnectedv&quot;); if(NULL&#x3D;&#x3D;Fun) &#123; LOGA(&quot;dlsym获取_Z25dvmDbgIsDebuggerConnectedv失败!\\n&quot;); return; &#125; else &#123; wbool ret &#x3D; Fun(); if(1&#x3D;&#x3D;ret) &#123; &#x2F;&#x2F; 此处判定为调试模式 LOGA(&quot;dalvikm模式，调试状态!\\n&quot;); return; &#125; &#125; return; &#125; 8 ptrace检测原理： 每个进程同时刻只能被1个调试进程ptrace，再次p自己会失败。 做法： 1 主动ptrace自己,根据返回值判断自己是否被调试了。 2 或者多进程ptrace。 123456789101112&#x2F;&#x2F; 单线程ptrace void ptraceCheck() &#123; &#x2F;&#x2F; ptrace如果被调试返回值为-1，如果正常运行，返回值为0 int iRet&#x3D;ptrace(PTRACE_TRACEME, 0, 0, 0); if(-1 &#x3D;&#x3D; iRet) &#123; LOGA(&quot;ptrace失败，进程正在被调试\\n&quot;); return; &#125; else &#123; LOGB(&quot;ptrace的返回值为:%d\\n&quot;,iRet); return; &#125; &#125; 9 函数hash值检测原理： so文件中函数的指令是固定，但是如果被下了软件断点，指令就会发生改变(断点地址被改 写为bkpt断点指令)，可以计算内存中一段指令的hash值进行校验，检测函数是否被修改或 被下断点。 代码： 略 10 断点指令检测原理： 上面说了，如果函数被下软件断点，则断点地址会被改写为bkpt指令， 可以在函数体中搜索bkpt指令来检测软件断点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x2F;&#x2F; IDA 6.8 断点扫描 &#x2F;&#x2F; 参数1：函数首地址 参数2：函数size typedef uint8_t u8; typedef uint32_t u32; void checkbkpt(u8* addr,u32 size)&#123; &#x2F;&#x2F; 结果 u32 uRet&#x3D;0; &#x2F;&#x2F; 断点指令 &#x2F;&#x2F; u8 armBkpt[4]&#x3D;&#123;0xf0,0x01,0xf0,0xe7&#125;; &#x2F;&#x2F; u8 thumbBkpt[2]&#x3D;&#123;0x10,0xde&#125;; u8 armBkpt[4]&#x3D;&#123;0&#125;; armBkpt[0]&#x3D;0xf0; armBkpt[1]&#x3D;0x01; armBkpt[2]&#x3D;0xf0; armBkpt[3]&#x3D;0xe7; u8 thumbBkpt[2]&#x3D;&#123;0&#125;; thumbBkpt[0]&#x3D;0x10; thumbBkpt[1]&#x3D;0xde; &#x2F;&#x2F; 判断模式 int mode&#x3D;(u32)addr%2; if(1&#x3D;&#x3D;mode) &#123; LOGA(&quot;checkbkpt:(thumb mode)该地址为thumb模式\\n&quot;); u8* start&#x3D;(u8*)((u32)addr-1); u8* end&#x3D;(u8*)((u32)start+size); &#x2F;&#x2F; 遍历对比 while(1) &#123; if(start &gt;&#x3D; end) &#123; uRet&#x3D;0; LOGA(&quot;checkbkpt:(no find bkpt)没有发现断点.\\n&quot;); break; &#125; if( 0&#x3D;&#x3D;memcmp(start,thumbBkpt,2) ) &#123; uRet&#x3D;1; LOGA(&quot;checkbkpt:(find it)发现断点.\\n&quot;); break; &#125; start&#x3D;start+2; &#125;&#x2F;&#x2F;while &#125;&#x2F;&#x2F;if else &#123; LOGA(&quot;checkbkpt:(arm mode)该地址为arm模式\\n&quot;); u8* start&#x3D;(u8*)addr; u8* end&#x3D;(u8*)((u32)start+size); &#x2F;&#x2F; 遍历对比 while(1) &#123; if (start &gt;&#x3D; end) &#123; uRet &#x3D; 0; LOGA(&quot;checkbkpt:(no find)没有发现断点.\\n&quot;); break; &#125; if (0 &#x3D;&#x3D; memcmp(start,armBkpt , 4))&#123; uRet &#x3D; 1; LOGA(&quot;checkbkpt:(find it)发现断点.\\n&quot;); break; &#125; start &#x3D; start + 4; &#125;&#x2F;&#x2F;while &#125;&#x2F;&#x2F;else return; &#125; 11 系统源码修改检测原理： 安卓native下最流行的反调试方案是读取进程的status或stat来检测tracepid，原理是调试状 态下的进程tracepid不为0。 对于这种调试检测手段，最彻底的绕过方式是修改系统源码后重新编译，让tracepid永远为 0。 对抗这种bypass手段，我们可以创建一个子进程，让子进程主动ptrace自身设为调试状态， 此时正常情况下，子进程的tracepid应该不为0。此时我们检测子进程的tracepid是否为0， 如果为0说明源码被修改了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788bool checkSystem() &#123; &#x2F;&#x2F; 建立管道 int pipefd[2]; if (-1 &#x3D;&#x3D; pipe(pipefd)) &#123; LOGA(&quot;pipe() error.\\n&quot;); return false; &#125; &#x2F;&#x2F; 创建子进程 pid_t pid &#x3D; fork(); LOGB(&quot;father pid is: %d\\n&quot;,getpid()); LOGB(&quot;child pid is: %d\\n&quot;,pid); &#x2F;&#x2F; for失败 if(0 &gt; pid) &#123; LOGA(&quot;fork() error.\\n&quot;); return false; &#125; &#x2F;&#x2F; 子进程程序 int childTracePid&#x3D;0; if ( 0 &#x3D;&#x3D; pid ) &#123; int iRet &#x3D; ptrace(PTRACE_TRACEME, 0, 0, 0); if (-1 &#x3D;&#x3D; iRet) &#123; LOGA(&quot;child ptrace failed.\\n&quot;); exit(0); &#125; LOGA(&quot;%s ptrace succeed.\\n&quot;); &#x2F;&#x2F; 获取tracepid char pathbuf[0x100] &#x3D; &#123;0&#125;; char readbuf[100] &#x3D; &#123;0&#125;; sprintf(pathbuf, &quot;&#x2F;proc&#x2F;%d&#x2F;status&quot;, getpid()); int fd &#x3D; openat(NULL, pathbuf, O_RDONLY); if (-1 &#x3D;&#x3D; fd) &#123; LOGA(&quot;openat failed.\\n&quot;); &#125; read(fd, readbuf, 100); close(fd); uint8_t *start &#x3D; (uint8_t *) readbuf; uint8_t des[100] &#x3D; &#123;0x54, 0x72, 0x61, 0x63, 0x65, 0x72, 0x5 0, 0x69, 0x64, 0x3A,0x09&#125;; int i &#x3D; 100; bool flag&#x3D; false; while (--i) &#123; if( 0&#x3D;&#x3D;memcmp(start,des,10)) &#123; start&#x3D;start+11; childTracePid&#x3D;atoi((char*)start); flag&#x3D; true; break; &#125;else &#123; start&#x3D;start+1; flag&#x3D; false; &#125; &#125;&#x2F;&#x2F;while if(false&#x3D;&#x3D;flag) &#123; LOGA(&quot;get tracepid failed.\\n&quot;); return false; &#125; &#x2F;&#x2F; 向管道写入数据 close(pipefd[0]); &#x2F;&#x2F; 关闭管道读端 write(pipefd[1], (void*)&amp;childTracePid,4); &#x2F;&#x2F; 向管道写端写入 数据 close(pipefd[1]); &#x2F;&#x2F; 写完关闭管道写 端 LOGA(&quot;child succeed, Finish.\\n&quot;); exit(0); &#125; else &#123; &#x2F;&#x2F; 父进程程序 LOGA(&quot;开始等待子进程.\\n&quot;); waitpid(pid,NULL,NULL); &#x2F;&#x2F; 等待子进程 结束 int buf2 &#x3D; 0; close(pipefd[1]); &#x2F;&#x2F; 关闭写端 read(pipefd[0], (void*)&amp;buf2, 4); &#x2F;&#x2F; 从读端读取 数据到buf close(pipefd[0]); &#x2F;&#x2F; 关闭读端 LOGB(&quot;子进程传递的内容为:%d\\n&quot;, buf2); &#x2F;&#x2F; 输出内容 &#x2F;&#x2F; 判断子进程ptarce后的tracepid if(0 &#x3D;&#x3D; buf2) &#123; LOGA(&quot;源码被修改了.\\n&quot;); &#125;else&#123; LOGA(&quot;源码没有被修改.\\n&quot;); &#125; return true; &#125; &#125; void smain() &#123; bool bRet&#x3D;checkSystem(); if(true&#x3D;&#x3D;bRet) LOGA(&quot;check succeed.\\n&quot;); else LOGA(&quot;check failed.\\n&quot;); LOGB(&quot;main Finish pid:%d\\n&quot;,getpid()); return; &#125; 12 单步调试陷阱原理：调试器从下断点到执行断点的过程分析： 1 保存：保存目标处指令 2 替换：目标处指令替换为断点指令 3 命中断点：命中断点指令(引发中断 或者说发出信号) 4 收到信号：调试器收到信号后，执行调试器注册的信号处理函数。 5 恢复：调试器处理函数恢复保存的指令 6 回退：回退PC寄存器 7 控制权回归程序. 主动设置断点指令/注册信号处理函数的反调试方案: 1 在函数中写入断点指令 2 在代码中注册断点信号处理函数 3 程序执行到断点指令，发出信号 分两种情况： (1)非调试状态 进入自己注册的函数，NOP指令替换断点指令，回退PC后正常指令。 (执行断点发出信号—进入处理信号函数—NOP替换断点—退回PC) (2)调试状态 进入调试器的断点处理流程，他会恢复目标处指令失败，然后回退PC，进入死循环。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!cpp char dynamic_ccode[] &#x3D; &#123;0x1f,0xb4, &#x2F;&#x2F;push &#123;r0-r4&#125; 0x01,0xde, &#x2F;&#x2F;breakpoint 0x1f,0xbc, &#x2F;&#x2F;pop &#123;r0-r4&#125; 0xf7,0x46&#125;;&#x2F;&#x2F;mov pc,lr char *g_addr &#x3D; 0; void my_sigtrap(int sig)&#123; char change_bkp[] &#x3D; &#123;0x00,0x46&#125;; &#x2F;&#x2F;mov r0,r0 memcpy(g_addr+2,change_bkp,2); __clear_cache((void*)g_addr,(void*)(g_addr+8)); &#x2F;&#x2F; need to clea r cache LOGI(&quot;chang bpk to nop\\n&quot;); &#125; void anti4()&#123;&#x2F;&#x2F;SIGTRAP int ret,size; char *addr,*tmpaddr; signal(SIGTRAP,my_sigtrap); addr &#x3D; (char*)malloc(PAGESIZE*2); memset(addr,0,PAGESIZE*2); g_addr &#x3D; (char *)(((int) addr + PAGESIZE-1) &amp; ~(PAGESIZE-1)); LOGI(&quot;addr: %p ,g_addr : %p\\n&quot;,addr,g_addr); ret &#x3D; mprotect(g_addr,PAGESIZE,PROT_READ|PROT_WRITE|PROT_EXEC); if(ret!&#x3D;0) &#123; LOGI(&quot;mprotect error\\n&quot;); return ; &#125; size &#x3D; 8; memcpy(g_addr,dynamic_ccode,size); __clear_cache((void*)g_addr,(void*)(g_addr+size)); &#x2F;&#x2F; need to c lear cache __asm__(&quot;push &#123;r0-r4,lr&#125;\\n\\t&quot; &quot;mov r0,pc\\n\\t&quot; &#x2F;&#x2F;此时pc指向后两条指令 &quot;add r0,r0,#4\\n\\t&quot;&#x2F;&#x2F;+4 是的lr 地址为 pop&#123;r0-r5&#125; &quot;mov lr,r0\\n\\t&quot; &quot;mov pc,%0\\n\\t&quot; &quot;pop &#123;r0-r5&#125;\\n\\t&quot; &quot;mov lr,r5\\n\\t&quot; &#x2F;&#x2F;恢复lr : :&quot;r&quot;(g_addr) :); LOGI(&quot;hi, i&#39;m here\\n&quot;); free(addr); &#125; 13 利用IDA先截获信号特性的检测原理： IDA会首先截获信号，导致进程无法接收到信号，导致不会执行信号处理函数。将关键流程 放在信号处理函数中，如果没有执行，就是被调试状态。 123456789101112131415161718192021222324#include &lt;stdio.h&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; void myhandler(int sig) &#123; &#x2F;&#x2F;signal(5, myhandler); printf(&quot;myhandler.\\n&quot;); return; &#125; int g_ret &#x3D; 0; int main(int argc, char **argv) &#123; &#x2F;&#x2F; 设置SIGTRAP信号的处理函数为myhandler() g_ret &#x3D; (int)signal(SIGTRAP, myhandler); if ( (int)SIG_ERR &#x3D;&#x3D; g_ret ) &#123; printf(&quot;signal ret value is SIG_ERR.\\n&quot;); &#125; &#x2F;&#x2F; 打印signal的返回值(原处理函数地址) printf(&quot;signal ret value is %x\\n&quot;,(unsigned char*)g_ret); &#x2F;&#x2F; 主动给自己进程发送SIGTRAP信号 raise(SIGTRAP); raise(SIGTRAP); raise(SIGTRAP); kill(getpid(), SIGTRAP); printf(&quot;main.\\n&quot;); return 0; &#125; 14 利用IDA解析缺陷反调试原理： IDA采用递归下降算法来反汇编指令，而该算法最大的缺点在于它无法处理间接代码路径， 无法识别动态算出来的跳转。而arm架构下由于存在arm和thumb指令集，就涉及到指令集 切换，IDA在某些情况下无法智能识别arm和thumb指令，进一步导致无法进行伪代码还原。 在IDA动态调试时，仍然存在该问题，若在指令识别错误的地点写入断点，有可能使得调试 器崩溃。（ 可能写断点 ,不知道写ARM还是THUMB ,造成的崩溃） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#if(JUDGE_THUMB) #define GETPC_KILL_IDAF5_SKATEBOARD \\__asm __volatile( \\&quot;mov r0,pc \\n\\t&quot; \\&quot;adds r0,0x9 \\n\\t&quot; \\&quot;push &#123;r0&#125; \\n\\t&quot; \\&quot;pop &#123;r0&#125; \\n\\t&quot; \\&quot;bx r0 \\n\\t&quot; \\\\&quot;.byte 0x00 \\n\\t&quot; \\&quot;.byte 0xBF \\n\\t&quot; \\ \\ &quot;.byte 0x00 \\n\\t&quot; \\ &quot;.byte 0xBF \\n\\t&quot; \\ \\ &quot;.byte 0x00 \\n\\t&quot; \\ &quot;.byte 0xBF \\n\\t&quot; \\ :::&quot;r0&quot; \\ ); #else #define GETPC_KILL_IDAF5_SKATEBOARD \\__asm __volatile( \\ &quot;mov r0,pc \\n\\t&quot; \\ &quot;add r0,0x10 \\n\\t&quot; \\ &quot;push &#123;r0&#125; \\n\\t&quot; \\ &quot;pop &#123;r0&#125; \\n\\t&quot; \\&quot;bx r0 \\n\\t&quot; \\&quot;.int 0xE1A00000 \\n\\t&quot; \\ &quot;.int 0xE1A00000 \\n\\t&quot; \\ &quot;.int 0xE1A00000 \\n\\t&quot; \\ &quot;.int 0xE1A00000 \\n\\t&quot; \\ :::&quot;r0&quot; \\ ); #endif &#x2F;&#x2F; 常量标签版本 #if(JUDGE_THUMB) #define IDAF5_CONST_1_2 \\ __asm __volatile( \\ &quot;b T1 \\n\\t&quot; \\&quot;T2: \\n\\t&quot; \\ &quot;adds r0,1 \\n\\t&quot; \\ &quot;bx r0 \\n\\t&quot; \\ &quot;T1: \\n\\t&quot; \\ &quot;mov r0,pc \\n\\t&quot; \\ &quot;b T2 \\n\\t&quot; \\ :::&quot;r0&quot; \\ ); #else #define IDAF5_CONST_1_2 \\ __asm __volatile( \\ &quot;b T1 \\n\\t&quot; \\ &quot;T2: \\n\\t&quot; \\ &quot;bx r0 \\n\\t&quot; \\ &quot;T1: \\n\\t&quot; \\ &quot;mov r0,pc \\n\\t&quot; \\ &quot;b T2 \\n\\t&quot; \\ :::&quot;r0&quot; \\ ); #endif 15 五种代码执行时间检测第一类： 原理： 一段代码，在a处获取一下时间，运行一段后，再在b处获取下时间， 然后通过(b时间­a时间)求时间差,正常情况下这个时间差会非常小， 如果这个时间差比较大，说明正在被单步调试。 做法： 五个能获取时间的api： time()函数 time_t结构体clock()函数 clock_t结构体gettimeofday()函数 timeval结构 timezone结构clock_gettime()函数 timespec结构getrusage()函数 rusage结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;sys&#x2F;time.h&gt; #include &lt;sys&#x2F;types.h&gt; #include &lt;sys&#x2F;resource.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; static int _getrusage(); &#x2F;&#x2F;Invalid static int _clock(); &#x2F;&#x2F;Invalid static int _time(); static int _gettimeofday(); static int _clock_gettime(); int main () &#123; _getrusage(); _clock(); _time(); _gettimeofday(); _clock_gettime(); return 0; &#125; int _getrusage() &#123; struct rusage t1; &#x2F;* breakpoint *&#x2F; getrusage (RUSAGE_SELF, &amp;t1); long used &#x3D; t1.ru_utime.tv_sec + t1.ru_stime.tv_sec; if (used &gt; 2) &#123; puts(&quot;debugged&quot;); &#125; return 0; &#125; int _clock()&#123; clock_t t1, t2; t1 &#x3D; clock (); &#x2F;* breakpoint *&#x2F; t2 &#x3D; clock (); double used &#x3D; (double)(t2 - t1) &#x2F; CLOCKS_PER_SEC; if (used &gt; 2) &#123; puts(&quot;debugged&quot;); &#125; return 0; &#125; int _time() &#123; time_t t1, t2; time (&amp;t1); &#x2F;* breakpoint *&#x2F; time (&amp;t2); if (t2 - t1 &gt; 2) &#123; puts(&quot;debugged&quot;); &#125; return 0; &#125; int _gettimeofday() &#123; struct timeval t1, t2; struct timezone t; gettimeofday (&amp;t1, &amp;t); &#x2F;* breakpoint *&#x2F; gettimeofday (&amp;t2, &amp;t); if (t2.tv_sec - t1.tv_sec &gt;2 )&#123; puts(&quot;debugged&quot;); &#125; return 0; &#125;int _clock_gettime()&#123; struct timespec t1, t2; clock_gettime (CLOCK_REALTIME, &amp;t1); &#x2F;* breakpoint *&#x2F; clock_gettime (CLOCK_REALTIME, &amp;t2); if (t2.tv_sec - t1.tv_sec &gt; 2) &#123; puts(&quot;debugged&quot;); &#125; return 0; &#125; 16 三种进程信息结构检测原理： 一些进程文件中存储了进程信息，可以读取这些信息得知是否为调试状态。 做法： 第一种：/proc/pid/status /proc/pid/task/pid/status TracerPid非0 statue字段中写入t（tracing stop） 第二种：/proc/pid/stat /proc/pid/task/pid/stat 第二个字段是t（T） 第三种：/proc/pid/wchan /proc/pid/task/pid/wchan ptrace_stop 代码： 略。 17 Inotify事件监控dump原理： 通常壳会在程序运行前完成对text的解密，所以脱壳可以通过dd与gdb_gcore来dump /proc/pid/mem或/proc/pid/pagemap，获取到解密后的代码内容。 可以通过Inotify系列api来监控mem或pagemap的打开或访问事件， 一旦发生时间就结束进程来阻止dump。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void thread_watchDumpPagemap() &#123; LOGA(&quot;-------------------watchDump:Pagemap------------------ - \\n&quot;); char dirName[NAME_MAX]&#x3D;&#123;0&#125;; snprintf(dirName,NAME_MAX,&quot;&#x2F;proc&#x2F;%d&#x2F;pagemap&quot;,getpid()); int fd &#x3D; inotify_init(); if (fd &lt; 0) &#123; LOGA(&quot;inotify_init err.\\n&quot;); return; &#125; int wd &#x3D; inotify_add_watch(fd,dirName,IN_ALL_EVENTS); if (wd &lt; 0) &#123; LOGA(&quot;inotify_add_watch err.\\n&quot;); close(fd); return; &#125; const int buflen&#x3D;sizeof(struct inotify_event) * 0x100; char buf[buflen]&#x3D;&#123;0&#125;; fd_set readfds; while(1) &#123; FD_ZERO(&amp;readfds); FD_SET(fd, &amp;readfds); int iRet &#x3D; select(fd+1,&amp;readfds,0,0,0); &#x2F;&#x2F; 此处阻塞 LOGB(&quot;iRet的返回值:%d\\n&quot;,iRet); if(-1&#x3D;&#x3D;iRet) break; if (iRet) &#123; memset(buf,0,buflen); int len &#x3D; read(fd,buf,buflen); int i&#x3D;0; while(i &lt; len) &#123; struct inotify_event *event &#x3D; (struct inotify_even t*)&amp;buf[i]; LOGB(&quot;1 event mask的数值为:%d\\n&quot;,event-&gt;mask); if( (event-&gt;mask&#x3D;&#x3D;IN_OPEN) ) &#123; &#x2F;&#x2F; 此处判定为有true,执行崩溃. LOGB(&quot;2 有人打开pagemap,第%d次.\\n\\n&quot;,i); &#x2F;&#x2F;__asm __volatile(&quot;.int 0x8c89fa98&quot;); &#125; i +&#x3D; sizeof (struct inotify_event) + event-&gt;len; &#125; LOGA(&quot;-----3 退出小循环-----\\n&quot;); &#125; &#125; inotify_rm_watch(fd,wd); close(fd); LOGA(&quot;-----4 退出大循环,关闭监视-----\\n&quot;); return; &#125; void smain() &#123; &#x2F;&#x2F; 监控&#x2F;proc&#x2F;pid&#x2F;mem pthread_t ptMem,t,ptPageMap; int iRet&#x3D;0; &#x2F;&#x2F; 监控&#x2F;proc&#x2F;pid&#x2F;pagemap iRet&#x3D;pthread_create(&amp;ptPageMap,NULL,(PPP)thread_watchDumpPagema p,NULL); if (0!&#x3D;iRet) &#123; LOGA(&quot;Create,thread_watchDumpPagemap,error!\\n&quot;); return; &#125; iRet&#x3D;pthread_detach(ptPageMap); if (0!&#x3D;iRet) &#123; LOGA(&quot;pthread_detach,thread_watchDumpPagemap,error!\\n&quot;); return; &#125; LOGA(&quot;-------------------smain-------------------\\n&quot;); LOGB(&quot;pid:%d\\n&quot;,getpid()); return; &#125; Frida反反调试应用崩溃退出1234567891011121314151617181920212223242526272829303132333435function show_native_stacks(flag)&#123; console.log(&#96;$&#123;flag&#125; \\tBacktrace:\\n\\t&#96; + Thread.backtrace(this.context,Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&#39;\\n\\t&#39;));&#125;function anti_exit() &#123; const exit_ptr &#x3D; Module.findExportByName(null, &#39;exit&#39;); console.log(&#39;anti_exit: &#39;, exit_ptr); if (null &#x3D;&#x3D; exit_ptr) &#123; return; &#125; Interceptor.replace(exit_ptr, new NativeCallback(function (flag) &#123; if (null &#x3D;&#x3D; this) &#123; return 0; &#125; console.log(&#39;anti_exit lr: &#39;,this.context.lr); show_native_stacks(&#39;anti_exit&#39;); return 0; &#125;, &#39;int&#39;, [&#39;int&#39;, &#39;int&#39;]));&#125;function anti_kill() &#123; const kill_ptr &#x3D; Module.findExportByName(null, &#39;kill&#39;); console.log(&#39;anti_kill: &#39;, kill_ptr); if (null &#x3D;&#x3D; kill_ptr) &#123; return; &#125; Interceptor.replace(kill_ptr, new NativeCallback(function (pid, flag) &#123; if (null &#x3D;&#x3D; this) &#123; return 0; &#125; console.log(&#96;anti_kill: lr&#x3D;$&#123;this.context.lr&#125; pid&#x3D;$&#123;pid&#125; flag&#x3D;$&#123;flag&#125;&#96;); show_native_stacks(&#39;anti_kill&#39;); return 0; &#125;, &#39;int&#39;, [&#39;int&#39;, &#39;int&#39;]));&#125; 检测是否被调试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115function anti_isDebuggerConnected()&#123; Java.perform(function() &#123; var Debug &#x3D; Java.use(&#39;android.os.Debug&#39;); Debug.isDebuggerConnected.implementation &#x3D; function() &#123; console.log(&#39;isDebuggerConnected Bypassed !&#39;); return false; &#125; &#125;);&#125;&#x2F;&#x2F;开发者模式function anti_developer_mod()&#123; Java.perform(function () &#123; var SSecure &#x3D; Java.use(&quot;android.provider.Settings$Secure&quot;); SSecure.getStringForUser.overload(&#39;android.content.ContentResolver&#39;, &#39;java.lang.String&#39;, &#39;int&#39;).implementation &#x3D; function (contentResolver, name, flag) &#123; if (name.indexOf(&quot;development_settings_enabled&quot;) &gt;&#x3D; 0) &#123; console.log(name); return this.getStringForUser.call(this, contentResolver, &#39;fuckyou&#39;, flag); &#125; return this.getStringForUser(contentResolver, name, flag); &#125; &#125;)&#125;&#x2F;&#x2F;long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);function anti_ptrace() &#123; var ptrace_ptr &#x3D; Module.findExportByName(null, &quot;ptrace&quot;); console.log(&#39;ptrace_ptr: &#39;, ptrace_ptr); if (null !&#x3D; ptrace_ptr) &#123; Interceptor.replace(ptrace_ptr.or(1), new NativeCallback(function (request, pid, addr, data) &#123; console.log(&#39;anti_ptrace entry&#39;); return 1; &#125;, &#39;long&#39;, [&#39;int&#39;, &quot;int&quot;, &#39;pointer&#39;, &#39;pointer&#39;])); &#125;&#125;&#x2F;&#x2F;每日优鲜function anti_fork() &#123; var fork_ptr &#x3D; Module.findExportByName(null, &quot;fork&quot;); console.log(&#39;fork_ptr: &#39;, fork_ptr); if (null !&#x3D; fork_ptr) &#123; Interceptor.replace(fork_ptr, new NativeCallback(function () &#123; console.log(&#39;fork_ptr&#39;, &#39;entry&#39;); return -1; &#125;, &#39;int&#39;, [])); &#125;&#125;function getModuleByAddr(addr) &#123; var result &#x3D; null; Process.enumerateModules().forEach(function (module) &#123; if (module.base &lt;&#x3D; addr &amp;&amp; addr &lt;&#x3D; (module.base.add(module.size))) &#123; result &#x3D; JSON.stringify(module); return false; &#x2F;&#x2F; 跳出循环 &#125; &#125;); return result;&#125;&#x2F;&#x2F;char *fgets(char *str, int n, FILE *stream)function anti_fgets() &#123; const tag &#x3D; &#39;anti_fgets&#39;; const fgets_ptr &#x3D; Module.findExportByName(null, &#39;fgets&#39;); console.log(&#39;fgets_ptr: &#39;, fgets_ptr); if (!fgets_ptr) &#123; return; &#125; var fgets &#x3D; new NativeFunction(fgets_ptr, &#39;pointer&#39;, [&#39;pointer&#39;, &#39;int&#39;, &#39;pointer&#39;]); Interceptor.replace(fgets_ptr, new NativeCallback(function (buffer, size, fp) &#123; if (null &#x3D;&#x3D; this) &#123; return 0; &#125; var logTag &#x3D; null; &#x2F;&#x2F; 进入时先记录现场 const lr &#x3D; this.context.lr &#x2F;&#x2F; 读取原 buffer var retval &#x3D; fgets(buffer, size, fp); var bufstr &#x3D; Memory.readUtf8String(buffer); if (null !&#x3D; bufstr) &#123; if (bufstr.indexOf(&quot;TracerPid:&quot;) &gt; -1) &#123; buffer.writeUtf8String(&quot;TracerPid:\\t0&quot;); logTag &#x3D; &#39;TracerPid&#39;; &#125; &#x2F;&#x2F;State: S (sleeping) else if (bufstr.indexOf(&quot;State:\\tt (tracing stop)&quot;) &gt; -1) &#123; buffer.writeUtf8String(&quot;State:\\tS (sleeping)&quot;); logTag &#x3D; &#39;State&#39;; &#125; &#x2F;&#x2F; ptrace_stop else if (bufstr.indexOf(&quot;ptrace_stop&quot;) &gt; -1) &#123; buffer.writeUtf8String(&quot;sys_epoll_wait&quot;); logTag &#x3D; &#39;ptrace_stop&#39;; &#125; &#x2F;&#x2F;(sankuai.meituan) t else if (bufstr.indexOf(&quot;) t&quot;) &gt; -1) &#123; buffer.writeUtf8String(bufstr.replace(&quot;) t&quot;, &quot;) S&quot;)); logTag &#x3D; &#39;stat_t&#39;; &#125; &#x2F;&#x2F; SigBlk else if (bufstr.indexOf(&#39;SigBlk:&#39;) &gt; -1) &#123; buffer.writeUtf8String(&#39;SigBlk:\\t0000000000001204&#39;); logTag &#x3D; &#39;SigBlk&#39;; &#125; if (logTag) &#123; console.log(tag + &quot; &quot; + logTag, bufstr + &quot; -&gt; &quot; + buffer.readCString() + &#39; lr: &#39; + lr + &quot;(&quot; + getModuleByAddr(lr) + &quot;)&quot;); show_native_stacks(tag) &#125; &#125; return retval; &#125;, &#39;pointer&#39;, [&#39;pointer&#39;, &#39;int&#39;, &#39;pointer&#39;]));&#125; frida检测12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&#x2F;&#x2F;梆梆检测点&#x2F;&#x2F;int readlink(const char *path, char *buf, size_t bufsiz);function anti_readlink()&#123; const readlink_ptr &#x3D; Module.findExportByName(null, &quot;readlink&quot;); console.log(&#39;readlink_ptr: &#39;, readlink_ptr); if(!readlink_ptr)&#123; return &#125; const readlink &#x3D; new NativeFunction(readlink_ptr, &#39;int&#39;, [&#39;pointer&#39;, &#39;pointer&#39;, &#39;pointer&#39;]) Interceptor.replace(readlink_ptr, new NativeCallback(function(path, buf, size)&#123; var retval &#x3D; readlink(path, buf, size); var bufstr &#x3D; buf.readCString(); if (bufstr.indexOf(&#39;frida&#39;)!&#x3D;&#x3D;-1 || bufstr.indexOf(&#39;gum-js-loop&#39;)!&#x3D;&#x3D;-1 || bufstr.indexOf(&#39;gmain&#39;)!&#x3D;&#x3D;-1 || bufstr.indexOf(&#39;linjector&#39;)!&#x3D;&#x3D;-1)&#123; console.log(&#96;\\nreadlink(path&#x3D;$&#123;path.readCstring()&#125;, buf&#x3D;$&#123;bufstr&#125;, size&#x3D;$&#123;size&#125;&#96;); this.buf.writeUtf8String(&quot;&#x2F;system&#x2F;framework&#x2F;boot.art&quot;) console.log(&quot;replce with: &quot;+ this.buf.readCString()) return 0x1A; &#125; return retval; &#125;, &#39;int&#39;, [&#39;pointer&#39;, &#39;pointer&#39;, &#39;pointer&#39;]))&#125;&#x2F;&#x2F;char *strstr(const char *haystack, const char *needle)function anti_strstr()&#123; const strstr_ptr &#x3D; Module.findExportByName(null, &quot;strstr&quot;); console.log(&#39;strstr_ptr: &#39;, strstr_ptr); if(!strstr_ptr)&#123; return &#125; const strstr &#x3D; new NativeFunction(strstr_ptr, &#39;pointer&#39;, [&#39;pointer&#39;, &#39;pointer&#39;]) Interceptor.replace(strstr_ptr, new NativeCallback(function(haystack, needle)&#123; var retval &#x3D; strstr(haystack, needle); var haystackstr &#x3D; haystack.readCString(); var needle_content &#x3D; haystack.readCString(); if (haystackstr.indexOf(&#39;frida&#39;)!&#x3D;&#x3D;-1 || needle_content.indexOf(&#39;frida&#39;)!&#x3D;&#x3D;-1 || haystackstr.indexOf(&#39;gum-js-loop&#39;)!&#x3D;&#x3D;-1 || needle_content.indexOf(&#39;gum-js-loop&#39;)!&#x3D;&#x3D;-1 || haystackstr.indexOf(&#39;gmain&#39;)!&#x3D;&#x3D;-1 || needle_content.indexOf(&#39;gmain&#39;)!&#x3D;&#x3D;-1 || haystackstr.indexOf(&#39;linjector&#39;)!&#x3D;&#x3D;-1 || needle_content.indexOf(&#39;linjector&#39;)!&#x3D;&#x3D;-1)&#123; console.log(&#96;\\nstrstr(haystack&#x3D;$&#123;haystackstr&#125;, needle&#x3D;$&#123;needle_content&#125;&#96;); this.buf.writeUtf8String(&quot;&#x2F;system&#x2F;framework&#x2F;boot.art&quot;) console.log(&quot;replce with: &quot;+ this.buf.readCString()) return 0; &#125; return retval; &#125;, &#39;pointer&#39;, [&#39;pointer&#39;, &#39;pointer&#39;]))&#125;&#x2F;&#x2F;线程检测&#x2F;&#x2F;int pthread_create(pthread_t* thread_out, pthread_attr_t const* attr, &#x2F;&#x2F;void* (*start_routine)(void*), void* arg)function anti_pthread_create_detect_frida_loop()&#123; const pthread_create_ptr &#x3D; Module.findExportByName(null, &quot;pthread_create&quot;); console.log(&#39;pthread_create_ptr: &#39;, pthread_create_ptr); if(!strstr_ptr)&#123; return &#125; const pthread_create &#x3D; new NativeFunction(pthread_create_ptr, &#39;int&#39;, [&#39;pointer&#39;, &#39;pointer&#39;,&#39;pointer&#39;,&#39;pointer&#39;]); Interceptor.replace(pthread_create_ptr, new NativeCallback(function (thread_out, attr, start_routine, arg) &#123; var retval; var detect_frida_loop &#x3D; Module.findExportByName(null, &quot;_Z17detect_frida_loopPv&quot;); if (String(detect_frida_loop) &#x3D;&#x3D;&#x3D; String(start_routine))&#123; retval &#x3D; 0; console.log(&#39;Prevent detect_frida_loop Thread start&#39;) &#125; else&#123; retval &#x3D; pthread_create(thread_out, attr, start_routine, arg); &#125; return retval &#125;,&#39;int&#39;, [&#39;pointer&#39;, &#39;pointer&#39;,&#39;pointer&#39;,&#39;pointer&#39;]))&#125; 环境检测123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121const openPtr &#x3D; Module.getExportByName(&#39;libc.so&#39;, &#39;open&#39;);const open &#x3D; new NativeFunction(openPtr, &#39;int&#39;, [&#39;pointer&#39;, &#39;int&#39;]);var readPtr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;read&quot;);var read &#x3D; new NativeFunction(readPtr, &#39;int&#39;, [&#39;int&#39;, &#39;pointer&#39;, &quot;int&quot;]);var fakePath &#x3D; &quot;&#x2F;data&#x2F;data&#x2F;com.xingin.xhs&#x2F;maps&quot;;&#x2F;&#x2F;这里要改包名var file &#x3D; new File(fakePath, &quot;w&quot;);var buffer &#x3D; Memory.alloc(512);var fakePath2 &#x3D; &quot;&#x2F;data&#x2F;data&#x2F;com.xingin.xhs&#x2F;task&quot;;var file2 &#x3D; new File(fakePath2, &quot;w&quot;);var buffer2 &#x3D; Memory.alloc(512);Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123; var pathname &#x3D; Memory.readUtf8String(pathnameptr); var realFd &#x3D; open(pathnameptr, flag); console.log(&quot;open:&quot;, pathname) &#x2F;&#x2F;路径是否包含maps 和task if (pathname.indexOf(&quot;maps&quot;) &gt;&#x3D; 0 || pathname.indexOf(&quot;status&quot;) &gt;&#x3D; 0 || pathname.indexOf(&quot;cmdline&quot;) &gt;&#x3D; 0) &#123; var temp &#x3D; pathname.indexOf(&quot;maps&quot;) &gt;&#x3D; 0 ? 1:2; &#x2F;&#x2F;包含maps则map为1 task为2 switch (temp) &#123; case 1:&#x2F;&#x2F;maps &#123; &#x2F;&#x2F; console.log(&quot;open maps:&quot;, pathname); while (parseInt(read(realFd, buffer, 512)) !&#x3D;&#x3D; 0) &#123; var oneLine &#x3D; Memory.readCString(buffer); &#x2F;&#x2F; if(pathname&#x3D;&#x3D;&quot;&#x2F;proc&#x2F;self&#x2F;maps&quot;)&#123; &#x2F;&#x2F; console.log(&quot;maps 打印 oneLine: &quot;,oneLine); &#x2F;&#x2F; &#125; if (oneLine.indexOf(&quot;tmp&quot;) &#x3D;&#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; &#x3D;&#x3D;&#x3D; 比&#x3D;&#x3D; 更加严格 &#x3D;&#x3D;类型不匹配再转化匹配值 &#x3D;&#x3D;&#x3D;类型不匹配就是false &#x2F;&#x2F; 就是online 不包含tmp 则写入&#x2F;data&#x2F;data&#x2F;com.wujie.chengxin&#x2F;maps中 &#x2F;&#x2F; 因为Frida在运行时会先确定&#x2F;data&#x2F;local&#x2F;tmp路径下是否有re.frida.server文件夹， &#x2F;&#x2F; 若没有则创建该文件夹并存放frida\u0002agent.so等文件 &#x2F;&#x2F; console.log(&quot;write :&quot;,oneLine); file.write(oneLine); &#125; else &#123; &#125; &#125; console.log(&quot;外打印 maps oneLine: &quot;,oneLine) var filename &#x3D; Memory.allocUtf8String(fakePath); return open(filename, flag); break; &#125; case 2:&#x2F;&#x2F;task &#123; console.log(&quot;open task:&quot;, pathname); while(parseInt(read(realFd, buffer2, 512)) !&#x3D;&#x3D; 0)&#123; var oneLine &#x3D; Memory.readCString(buffer2); console.log(&quot;打印 oneLine: &quot;,oneLine) if(oneLine.indexOf(&quot;gum-js-loop&quot;)!&#x3D;-1)&#123; var replaceStr &#x3D; &quot;AAAAAAAAAA&quot; oneLine &#x3D; oneLine.replace(&quot;gum-js-loop&quot;, replaceStr) &#x2F;&#x2F;console.log(oneLine) &#125; if(oneLine.indexOf(&quot;pool-frida&quot;)!&#x3D;-1)&#123; var replaceStr &#x3D; &quot;BBBBBBB&quot; oneLine &#x3D; oneLine.replace(&quot;pool-frida&quot;, replaceStr) &#x2F;&#x2F;console.log(oneLine) &#125; if(oneLine.indexOf(&quot;gmain&quot;)!&#x3D;-1)&#123; var replaceStr &#x3D; &quot;CCCCCCC&quot; &#x2F;&#x2F;最终只有这里匹配上了 oneLine &#x3D; oneLine.replace(&quot;gmain&quot;, replaceStr) &#x2F;&#x2F;console.log(oneLine) &#125; file2.write(oneLine); &#125; console.log(&quot;外打印 oneLine: &quot;,oneLine) var filename &#x3D; Memory.allocUtf8String(fakePath2); return open(filename, flag);&#x2F;&#x2F;把伪造的路径打开返回 break; &#125; &#125; &#125; var fd &#x3D; open(pathnameptr, flag); &#x2F;&#x2F; Thread.sleep(1) return fd; &#125;, &#39;int&#39;, [&#39;pointer&#39;, &#39;int&#39;]));function get_self_process_name() &#123; var openPtr &#x3D; Module.getExportByName(&#39;libc.so&#39;, &#39;open&#39;); var open &#x3D; new NativeFunction(openPtr, &#39;int&#39;, [&#39;pointer&#39;, &#39;int&#39;]); var readPtr &#x3D; Module.getExportByName(&quot;libc.so&quot;, &quot;read&quot;); var read &#x3D; new NativeFunction(readPtr, &quot;int&quot;, [&quot;int&quot;, &quot;pointer&quot;, &quot;int&quot;]); var closePtr &#x3D; Module.getExportByName(&#39;libc.so&#39;, &#39;close&#39;); var close &#x3D; new NativeFunction(closePtr, &#39;int&#39;, [&#39;int&#39;]); var path &#x3D; Memory.allocUtf8String(&quot;&#x2F;proc&#x2F;self&#x2F;cmdline&quot;); var fd &#x3D; open(path, 0); if (fd !&#x3D; -1) &#123; var buffer &#x3D; Memory.alloc(0x1000); var result &#x3D; read(fd, buffer, 0x1000); close(fd); result &#x3D; ptr(buffer).readCString(); console.log(&quot;进程的名字是:&quot;+result); return result; &#125; return &quot;-1&quot;;&#125;&#x2F;&#x2F;int __system_property_get(const char *name, char *value);function anti_system_property_get()&#123; const system_property_get_ptr &#x3D; Module.getExportByName(&#39;libc.so&#39;, &#39;__system_property_get&#39;); if (!system_property_get_ptr)&#123; return &#125; var system_property_get &#x3D; new NativeFunction(system_property_get_ptr, &#39;int&#39;, [&#39;pointer&#39;, &#39;pointer&#39;]) Interceptor.replace(system_property_get, new NativeCallback(function (name, value) &#123; console.log(&#96;\\n__system_property_get(name&#x3D;$&#123;name.readCString()&#125;, value&#x3D;$&#123;value.readCString()&#125;&#96;); var retval &#x3D; system_property_get(name, value); return retval; &#125;, &#39;int&#39;, [&#39;pointer&#39;, &#39;pointer&#39;]))&#125; 案例查看加载所有的module 12345678910function fridaProcess() &#123; Java.perform(function () &#123; var enumMoudle &#x3D; Process.enumerateModules(); for (var i &#x3D; 0; i &lt; enumMoudle.length; i++) &#123; console.log(&quot;&quot;, enumMoudle[i].name) &#125; &#125;);&#125;setImmediate(fridaProcess, 0) 查看底层打开的所有文件 123456789101112var pth &#x3D; Module.findExportByName(null, &quot;open&quot;);Interceptor.attach(ptr(pth), &#123; onEnter: function (args) &#123; this.filename &#x3D; args[0]; console.log(&quot;&quot;, this.filename.readCString()) if (this.filename.readCString().indexOf(&quot;.so&quot;) !&#x3D; -1) &#123; &#125; &#125;, onLeave: function (retval) &#123; return retval; &#125;&#125;) 最终闪退时打开的文件maps，备份一个正常maps文件用来替换 1234567891011121314151617181920212223242526function main() &#123; const openPtr &#x3D; Module.getExportByName(&#39;libc.so&#39;, &#39;open&#39;); const open &#x3D; new NativeFunction(openPtr, &#39;int&#39;, [&#39;pointer&#39;, &#39;int&#39;]); var readPtr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;read&quot;); var read &#x3D; new NativeFunction(readPtr, &#39;int&#39;, [&#39;int&#39;, &#39;pointer&#39;, &quot;int&quot;]); var fakePath &#x3D; &quot;&#x2F;data&#x2F;data&#x2F;com.app&#x2F;maps&quot;; var file &#x3D; new File(fakePath, &quot;w&quot;); var buffer &#x3D; Memory.alloc(512); Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123; var pathname &#x3D; Memory.readUtf8String(pathnameptr); var realFd &#x3D; open(pathnameptr, flag); if (pathname.indexOf(&quot;maps&quot;) &gt;&#x3D; 0) &#123; while (parseInt(read(realFd, buffer, 512)) !&#x3D;&#x3D; 0) &#123; var oneLine &#x3D; Memory.readCString(buffer); if (oneLine.indexOf(&quot;tmp&quot;) &#x3D;&#x3D;&#x3D; -1) &#123; file.write(oneLine); &#125; &#125; var filename &#x3D; Memory.allocUtf8String(fakePath); return open(filename, flag); &#125; var fd &#x3D; open(pathnameptr, flag); return fd; &#125;, &#39;int&#39;, [&#39;pointer&#39;, &#39;int&#39;]));&#125;setImmediate(main) 端口检测123456789101112131415161718192021222324252627282930Interceptor.attach(Module.findExportByName(&quot;libc.so&quot;, &quot;connect&quot;), &#123; onEnter: function (args) &#123; var memory &#x3D; Memory.readByteArray(args[1], 64); var b &#x3D; new Uint8Array(memory); if (b[2] &#x3D;&#x3D; 0x69 &amp;&amp; b[3] &#x3D;&#x3D; 0xa2 &amp;&amp; b[4] &#x3D;&#x3D; 0x7f &amp;&amp; b[5] &#x3D;&#x3D; 0x00 &amp;&amp; b[6] &#x3D;&#x3D; 0x00 &amp;&amp; b[7] &#x3D;&#x3D; 0x01) &#123; this.frida_detection &#x3D; true; &#125; &#125;, onLeave: function (retval) &#123; if (this.frida_detection) &#123; console.log(&quot;Frida Bypassed&quot;); retval.replace(-1); &#125; &#125;&#125;);Interceptor.attach(Module.findExportByName(null, &quot;connect&quot;), &#123; onEnter: function (args) &#123; var family &#x3D; Memory.readU16(args[1]); if (family !&#x3D;&#x3D; 2) &#123; return &#125; var port &#x3D; Memory.readU16(args[1].add(2)); port &#x3D; ((port &amp; 0xff) &lt;&lt; 8) | (port &gt;&gt; 8); if (port &#x3D;&#x3D;&#x3D; 27042) &#123; console.log(&#39;Frida port check&#39;); Memory.writeU16(args[1].add(2), 0x0101); &#125; &#125;&#125;); var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"SO逆向之爱库存sig","slug":"SO逆向之爱库存sig","date":"2022-10-15T14:12:04.000Z","updated":"2022-10-28T14:27:11.427Z","comments":true,"path":"2022/10/15/SO逆向之爱库存sig/","link":"","permalink":"http://onejane.github.io/2022/10/15/SO%E9%80%86%E5%90%91%E4%B9%8B%E7%88%B1%E5%BA%93%E5%AD%98sig/","excerpt":"","text":"绕过更新老版本5.7.8 1234frida-ps -Ua 查看包名com.aikucun.akappobjection -g com.aikucun.akapp explore -P ~&#x2F;.objection&#x2F;pluginsandroid hooking list activities 查看所有Activityandroid intent launch_activity com.aikucun.akapp.activity.LoginActivity 跳到登录Activity不过被更新弹窗盖住 jadx反编译搜索&quot;立即更新&quot;,直接hook掉show方法 12345678910function hook_sig()&#123; Java.perform(function()&#123; console.log(&quot;Entering hook&quot;) &#x2F;&#x2F; 干掉弹窗 Java.use(&quot;com.aikucun.akapp.widget.dialog.ConfirmDialog&quot;).show.implementation &#x3D; function()&#123; console.log(&quot;hook show &quot;) &#125; &#125;)&#125;setImmediate(hook_sig) frida -U -f com.aikucun.akapp -l hook_sig.js –no-pause signV1抓包https://zuul.aikucun.com/aggregation-center-facade/api/app/search/product/image/switch appid 38741001 did 24c29bc14b5e3ddec1bf571c844a7e78 noncestr ae5a5c timestamp 1665846444 zuul 1 sig c5a0da1284344f608043722f45c85dfd934c0ce7 反编译搜索”sig” 上frida打印参数和返回值 123456789101112var MXSecurity &#x3D; Java.use(&#39;com.mengxiang.arch.security.MXSecurity&#39;)MXSecurity.signV1.implementation &#x3D; function (a, b, c) &#123; console.log(&#39;a: &#39;, a); &#x2F;&#x2F; url console.log(&#39;b: &#39;, b); &#x2F;&#x2F; noncestr console.log(&#39;c: &#39;, c); &#x2F;&#x2F; timestamp var res &#x3D; this.signV1(a, b, c); &#x2F;&#x2F; 加密返回 console.log(&#39;res: &#39;, res); return res&#125; IDA打开libmx.so，搜索java发现signV1是静态注册函数 拼接了appid，noncestr，timestamp，secret，url等参数后调用digest函数进行加密，参数分别是JNIEnv，SHA1加密函数，加密内容的bytearray 如果需要还原算法，那么前提得拿到secret盐，可以通过jnitrace或者frida hook native都可以，或者直接使用unidbg黑盒调用。 Jnitrace12pip install jnitrace&#x3D;&#x3D;3.0.8jnitrace -l libmx.so -m spawn com.aikucun.akapp --ignore-vm &gt; akc.log Unidbg黑盒调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class AkuMx1 extends AbstractJni &#123; &#x2F;&#x2F; 初始化一些 apk 常量 private final AndroidEmulator emulator; private final VM vm; private final Module module; private final DvmClass mxSecurity; &#x2F;&#x2F; APK 路径 public String apkPath &#x3D; &quot;C:\\\\Users\\\\Administrator\\\\Downloads\\\\爱库存5.7.8.apk&quot;; &#x2F;&#x2F; so 文件路径 public String soPath &#x3D; &quot;unidbg-android&#x2F;src&#x2F;test&#x2F;resources&#x2F;demo&#x2F;akc&#x2F;libmx.so&quot;; &#x2F;&#x2F; 加载指定版本的系统库 private static LibraryResolver createLibraryResolver() &#123; return new AndroidResolver(23); &#125; &#x2F;&#x2F; 创建 android 模拟器，这里是 32 位的 private static AndroidEmulator createARMEmulator() &#123; return AndroidEmulatorBuilder.for32Bit().build(); &#125; AkuMx1() &#123; emulator &#x3D; createARMEmulator(); final Memory memory &#x3D; emulator.getMemory(); &#x2F;&#x2F; 设置 sdk版本 23 memory.setLibraryResolver(createLibraryResolver()); &#x2F;&#x2F;创建DalvikVM，可以载入apk，也可以为null vm &#x3D; emulator.createDalvikVM(new File(apkPath)); &#x2F;&#x2F; 设置可以调用 jni 函数 vm.setJni(this); &#x2F;&#x2F; 打印 jni 函数调用具体的 log vm.setVerbose(true); &#x2F;&#x2F; 加载 so 文件 DalvikModule dm &#x3D; vm.loadLibrary(new File(soPath), true); module &#x3D; dm.getModule(); &#x2F;&#x2F; 加载 java 加密函数所在 类 mxSecurity &#x3D; vm.resolveClass(&quot;com&#x2F;mengxiang&#x2F;arch&#x2F;security&#x2F;MXSecurity&quot;); &#125; &#x2F;&#x2F; 关闭模拟器 private void destroy() throws IOException &#123; emulator.close(); System.out.println(&quot;destroy&quot;); &#125; public static void main(String[] args) throws IOException &#123; AkuMx1 aku &#x3D; new AkuMx1(); aku.run(); aku.destroy(); &#125; public void run() &#123; String a &#x3D; &quot;https:&#x2F;&#x2F;zuul.aikucun.com&#x2F;aggregation-center-facade&#x2F;api&#x2F;app&#x2F;search&#x2F;product&#x2F;image&#x2F;switch?appid&#x3D;38741001&amp;did&#x3D;24c29bc14b5e3ddec1bf571c844a7e78&amp;noncestr&#x3D;af7aff&amp;timestamp&#x3D;1665849838&amp;zuul&#x3D;1&quot;; String b &#x3D; &quot;af7aff&quot;; String c &#x3D; &quot;1665849838&quot;; DvmObject&lt;?&gt; strRc &#x3D; mxSecurity.callStaticJniMethodObject( emulator, &quot;signV1(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;, vm.addLocalObject(new StringObject(vm, a)), vm.addLocalObject(new StringObject(vm, b)), vm.addLocalObject(new StringObject(vm, c)) ); System.out.println(&quot;strRc: &quot; + strRc.getValue()); &#125;&#125; 返回值确实空的，使用frida主动调用正常返回 123456789function invoke_sig() &#123; Java.perform(function () &#123; var MXSecurity &#x3D; Java.use(&#39;com.mengxiang.arch.security.MXSecurity&#39;); var a &#x3D; &quot;https:&#x2F;&#x2F;zuul.aikucun.com&#x2F;aggregation-center-facade&#x2F;api&#x2F;app&#x2F;search&#x2F;product&#x2F;image&#x2F;switch?appid&#x3D;38741001&amp;did&#x3D;24c29bc14b5e3ddec1bf571c844a7e78&amp;noncestr&#x3D;af7aff&amp;timestamp&#x3D;1665849838&amp;zuul&#x3D;1&quot;; var b &#x3D; &quot;af7aff&quot;; var c &#x3D; &quot;1665849838&quot;; console.log(MXSecurity.signV1(a, b, c)); &#125;)&#125; 通过jnitrace查看libmx.so的执行流可知需要先执行Java_com_mengxiang_arch_security_MXSecurity_init，即public static final native int init(Context context, boolean z); 12345678910111213141516171819202122232425public void run() &#123; &#x2F;&#x2F; 加载 context 上下文对象 DvmClass Context &#x3D; vm.resolveClass(&quot;android&#x2F;content&#x2F;Context&quot;); DvmObject&lt;?&gt; strRc1 &#x3D; mxSecurity.callStaticJniMethodObject( emulator, &quot;init(Landroid&#x2F;content&#x2F;Context;Z;)I;&quot;, &#x2F;&#x2F; Context.newObject(null) 初始化对象，参数直接 null vm.addLocalObject(Context.newObject(null)), &#x2F;&#x2F; frida hook打印入参为 false vm.addLocalObject(DvmBoolean.valueOf(vm,false)) ); System.out.println(&quot;strRc1: &quot; + strRc1); String a &#x3D; &quot;https:&#x2F;&#x2F;zuul.aikucun.com&#x2F;aggregation-center-facade&#x2F;api&#x2F;app&#x2F;search&#x2F;product&#x2F;image&#x2F;switch?appid&#x3D;38741001&amp;did&#x3D;24c29bc14b5e3ddec1bf571c844a7e78&amp;noncestr&#x3D;af7aff&amp;timestamp&#x3D;1665849838&amp;zuul&#x3D;1&quot;; String b &#x3D; &quot;af7aff&quot;; String c &#x3D; &quot;1665849838&quot;; DvmObject&lt;?&gt; strRc2 &#x3D; mxSecurity.callStaticJniMethodObject( emulator, &quot;signV1(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;, vm.addLocalObject(new StringObject(vm, a)), vm.addLocalObject(new StringObject(vm, b)), vm.addLocalObject(new StringObject(vm, c)) ); System.out.println(&quot;strRc2: &quot; + strRc2.getValue());&#125; SHA256 是 android里的，java 里是 SHA-256，我们需要重写该函数 1234567891011121314151617181920212223@Overridepublic DvmObject&lt;?&gt; callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;java&#x2F;security&#x2F;MessageDigest-&gt;getInstance(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;security&#x2F;MessageDigest;&quot;: StringObject type &#x3D; vaList.getObjectArg(0); String name &#x3D; &quot;&quot;; if (&quot;\\&quot;SHA256\\&quot;&quot;.equals(type.toString())) &#123; name &#x3D; &quot;SHA-256&quot;; &#125; else &#123; name &#x3D; type.toString(); System.out.println(&quot;else name: &quot; + name); &#125; try &#123; return vm.resolveClass(&quot;java&#x2F;security&#x2F;MessageDigest&quot;).newObject(MessageDigest.getInstance(name)); &#125; catch (NoSuchAlgorithmException e) &#123; throw new IllegalStateException(e); &#125; &#125; return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList);&#125; 12345678if (&quot;\\&quot;SHA256\\&quot;&quot;.equals(type.toString())) &#123; name &#x3D; &quot;SHA-256&quot;;&#125; else if (&quot;\\&quot;SHA1\\&quot;&quot;.equals(type.toString())) &#123; name &#x3D; &quot;SHA-1&quot;;&#125; else &#123; name &#x3D; type.toString(); System.out.println(&quot;else name: &quot; + name);&#125; signV3分析使用最新版本6.2.3，搜索&quot;sign&quot;或者sign= https://zuul.aikucun.com/api/gquery 查看业绩中心的数据 appid 38741001 did 0347d498ac2a5433d090a52dfe9315d1 noncestr 6ed25f subuserid 2aeb8f7cd6cb2aa69479c30366baf8f6 svs v3 timestamp 1666495412 token 831156285ba5413ba43ed83bfbdb38d0 userId 2aeb8f7cd6cb2aa69479c30366baf8f6 userid 2aeb8f7cd6cb2aa69479c30366baf8f6 sign e1c350a82dd7d8a22d21452ce4e47ab2201493eec0bc3ff3cb7174a4ef8727b1 尝试用objection hook一下MXSecurity的方法public static final native String signV3(@NotNull String str, @NotNull String str2, @NotNull String str3, @NotNull String str4); 123456com.aikucun.akapp on (Android: 10) [usb] # (agent) [374201] Called com.mengxiang.arch.utils.MD5Utils.b(java.lang.String)(agent) [374201] Arguments com.mengxiang.arch.utils.MD5Utils.b(&#123;&quot;variables&quot;:&#123;&#125;,&quot;query&quot;:&quot; query achieveCenterSalesBoard&#123;\\n saleBoardData:achieveCenterSalesBoard &#123;\\n orderCountShop\\n saleShop\\n averageTransactionValue\\n customerCount\\n &#125;\\n &#125;\\n &quot;,&quot;operationName&quot;:&quot;achieveCenterSalesBoard&quot;&#125;)(agent) [374201] Return Value: 1d1233cbfb6d5227fce0a483fd186ba6(agent) [302898] Called com.mengxiang.arch.security.MXSecurity.signV3(java.lang.String, java.lang.String, java.lang.String, java.lang.String)(agent) [302898] Arguments com.mengxiang.arch.security.MXSecurity.signV3(https:&#x2F;&#x2F;zuul.aikucun.com&#x2F;api&#x2F;gquery?appid&#x3D;38741001&amp;did&#x3D;0347d498ac2a5433d090a52dfe9315d1&amp;noncestr&#x3D;6ed25f&amp;subuserid&#x3D;2aeb8f7cd6cb2aa69479c30366baf8f6&amp;svs&#x3D;v3&amp;timestamp&#x3D;1666495412&amp;token&#x3D;831156285ba5413ba43ed83bfbdb38d0&amp;userId&#x3D;2aeb8f7cd6cb2aa69479c30366baf8f6&amp;userid&#x3D;2aeb8f7cd6cb2aa69479c30366baf8f6, 6ed25f, 1666495412, 1d1233cbfb6d5227fce0a483fd186ba6) (agent) [302898] Return Value: e1c350a82dd7d8a22d21452ce4e47ab2201493eec0bc3ff3cb7174a4ef8727b1 str1是url，str2是noncestr，str3是timestamp，至于str4，可以看到有时候是null，有时候是32位字符串，通过两个请求的对比，发现GET请求时，str4为null，POST请求时，str4为32位字符串，Z1由Z1生成 String Z1 = Z1(request); String sb2 = sb.toString(); Intrinsics.f(sb2, &quot;builder.toString()&quot;); String signV3 = MXSecurity.signV3(sb2, substring, valueOf, Z1); 即body的md5就是str4的值，body中的参数md5 IDA打开MXSecurity中引入的libmx.so找到Java_com_mengxiang_arch_security_MXSecurity_signV3，最终返回的v35大概率由SHA256生成，传入digest函数的args[2]v34的类型是jByteArray digest上frida hook digest方法，MikManager中设置com.aikucun.akapp的启动方式是listen_wait，打开app，frida -U 爱库存 -l signv3.js 12345678910111213141516171819202122232425262728function dump(name, addr, legnth) &#123; console.log(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot; + name + &quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); console.log(hexdump(addr, &#123; length: legnth || 32 &#125;));&#125;function hook_signV3() &#123; &#x2F;&#x2F; var bptr &#x3D; Module.findBaseAddress(&quot;libmx.so&quot;); var bptr &#x3D; Module.findExportByName(&quot;libmx.so&quot;,&quot;_Z6digestP7_JNIEnvPKcP11_jbyteArray&quot;) console.log(&quot;&#x3D;&#x3D;&#x3D;&quot;+bptr) Interceptor.attach(bptr, &#123; onEnter: function (args) &#123; console.log(&quot;arg1:&quot;, args[1].readCString()); var sptr &#x3D; Java.vm.tryGetEnv().getByteArrayElements(args[2]); console.log(&quot;arg2:&quot;, sptr.readCString()); &#125;, onLeave: function (retval) &#123; dump(&quot;sign&quot;, retval, 64); &#125; &#125;)&#125;function main() &#123; hook_signV3();&#125;setImmediate(main) SHA256的输入，它是由appid，svs，noncestr，timestamp，secret(04fdc5e4d9c7420e896ee92b17c68e9f)，url构成，如果是POST请求，还会用&quot;&amp;&quot;与body的MD5拼接。 Python还原1234567891011121314151617181920212223242526import hashlibimport jsonfrom urllib.parse import urlencodedef calc_signv3(url, params, body&#x3D;None): data &#x3D; [ (&#39;appid&#39;, params[&#39;appid&#39;]), (&#39;svs&#39;, params[&#39;svs&#39;]), (&#39;noncestr&#39;, params[&#39;noncestr&#39;]), (&#39;timestamp&#39;, params[&#39;timestamp&#39;]), (&#39;secret&#39;, &#39;04fdc5e4d9c7420e896ee92b17c68e9f&#39;), (&#39;url&#39;, url + &#39;?&#39; + urlencode(sorted(params.items()))), ] data &#x3D; &#39;&amp;&#39;.join(f&#39;&#123;k&#125;&#x3D;&#123;v&#125;&#39; for k, v in data) if body: if isinstance(body, (dict, list)): body &#x3D; json.dumps(body, separators&#x3D;(&#39;,&#39;, &#39;:&#39;)) if isinstance(body, str): body &#x3D; body.encode() s1 &#x3D; hashlib.md5(body).hexdigest() data +&#x3D; &#39;&amp;&#39; + s1 sign &#x3D; hashlib.sha256(data.encode()).hexdigest() return sign Unidbg黑盒调用 12345678910111213public void runSignV3() &#123; List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;(10); list.add(vm.getJNIEnv()); list.add(0); list.add(vm.addLocalObject(new StringObject(vm,&quot;https:&#x2F;&#x2F;zuul.aikucun.com&#x2F;akucun-member-aggregation&#x2F;api&#x2F;v2.0&#x2F;user.do?action&#x3D;phonelogin&amp;appid&#x3D;38741001&amp;did&#x3D;a93e299cbe12251f10f0356d06e6db1b&amp;noncestr&#x3D;e91f4f&amp;svs&#x3D;v3&amp;timestamp&#x3D;1638341417&quot;))); list.add(vm.addLocalObject(new StringObject(vm, &quot;e91f4f&quot;))); list.add(vm.addLocalObject(new StringObject(vm, &quot;1638341417&quot;))); list.add(vm.addLocalObject(new StringObject(vm, &quot;5119e6c79149b40ea578fdab80489fbd&quot;))); Number number &#x3D; module.callFunction(emulator, 0x8254 + 1, list.toArray())[0]; String result &#x3D; vm.getObject(number.intValue()).getValue().toString(); System.out.println(&quot;runSignV3：&quot;+result);&#125; 返回JNIEnv-&gt;NewStringUTF(&quot;&quot;) was called from unidbg@0xffff0000，发现在MXSecurity 类中调用了init函数，可能用来配置一些变量 导出函数的地址是00007F14 1234567891011public void call_init() &#123; List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;(10); list.add(vm.getJNIEnv()); list.add(0); DvmObject&lt;?&gt; context &#x3D; vm.resolveClass(&quot;android&#x2F;content&#x2F;Context&quot;).newObject(null); list.add(vm.addLocalObject(context)); list.add(0); module.callFunction(emulator, 0x7F14 + 1, list.toArray());&#125;aku.call_init();aku.runSignV3(); 123456789101112131415161718192021222324252627@Overridepublic DvmObject&lt;?&gt; callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;java&#x2F;security&#x2F;MessageDigest-&gt;getInstance(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;security&#x2F;MessageDigest;&quot;: StringObject type &#x3D; vaList.getObjectArg(0); String name &#x3D; &quot;&quot;; if (&quot;\\&quot;MD5\\&quot;&quot;.equals(type.toString())) &#123; name &#x3D; &quot;MD5&quot;; &#125; else if (&quot;\\&quot;SHA256\\&quot;&quot;.equals(type.toString())) &#123; name &#x3D; &quot;SHA-256&quot;; &#125; else if (&quot;\\&quot;SHA1\\&quot;&quot;.equals(type.toString())) &#123; name &#x3D; &quot;SHA-1&quot;; &#125; else &#123; name &#x3D; type.toString(); System.out.println(&quot;else name: &quot; + name); &#125; try &#123; return vm.resolveClass(&quot;java&#x2F;security&#x2F;MessageDigest&quot;).newObject(MessageDigest.getInstance(name)); &#125; catch (NoSuchAlgorithmException e) &#123; throw new IllegalStateException(e); &#125; &#125; return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList);&#125; 接下来通过console debugger来分析输入，在类的构造函数中加入emulator.attach().addBreakPoint(module.base + 0x83FC);，将v21处设置断点 重新运行代码 输入mr5打印寄存器数据 没有完整输出，看到r6的值为0x24b，它应该是数组的长度，输入mr5 0x24b完整打印 c-跳过断点，n-下一步，d - Varibles 窗口，m - watch(mr0-mr7, mfp, mip, msp [size],m(address) [size]) var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"ida","slug":"ida","permalink":"http://onejane.github.io/tags/ida/"}]},{"title":"FridaHook大全","slug":"FridaHook大全","date":"2022-06-05T10:14:59.000Z","updated":"2022-10-22T07:11:22.858Z","comments":true,"path":"2022/06/05/FridaHook大全/","link":"","permalink":"http://onejane.github.io/2022/06/05/FridaHook%E5%A4%A7%E5%85%A8/","excerpt":"","text":"Mobile-Security-Framework-MobSF 记一次frida实战——对某视频APP的脱壳、hook破解、模拟抓包、协议分析一条龙服务 安卓 App 逆向课程之三 frida 注入 Okhttp 抓包上篇 安卓 App 逆向课程之四 frida 注入 Okhttp 抓包中篇 安卓 App 逆向课程之五 frida 注入 Okhttp 抓包下篇 XPOSED魔改一：获取特征 【SO壳】17种安卓native反调试收集 遍历连接手机所有端口发送D-bus消息，如果返回”REJECT”这个特征则认为存在frida-server 直接调用openat的syscall的检测在text节表中搜索frida-gadget*.so / frida-agent*.so字符串，避免了hook libc来anti-anti的方法。**frida-detection** 内存中存在frida rpc字符串，认为有frida-server，**AntiFrida** 来自高纬的对抗①：定制ART解释器脱所有一二代壳 （附件） 来自高纬的对抗②：魔改XPOSED过框架检测(上) 来自高纬的对抗③：魔改XPOSED过框架检测(下)（附件1、附件2） 来自高纬的对抗④：定制安卓内核过反调试(附件:链接：https://pan.baidu.com/s/1zAYliYbkagdUUsykww_L4g 提取码：vv5u]) 来自高纬的对抗⑤：替换安卓内核并解封Linux命令和环境（附件） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114function hook_java()&#123; Java.perform(function()&#123; &#x2F;&#x2F; 静态函数的hook和主动调用 Java.use(&quot;com.example.demoso1.MainActivity&quot;).stringFromJNI.implementation &#x3D; function ()&#123; var result &#x3D; this.stringFromJNI(); console.log(&quot;result is &#x3D;&gt; &quot;,result); return result; &#125; &#x2F;&#x2F;console.log(&quot;invoke stringFromJNI : &#x3D;&gt; &quot;+Java.use(&quot;com.example.demoso1.MainActivity&quot;).stringFromJNI() ); &#x2F;&#x2F; 动态注册的函数 Java.use(&quot;com.example.demoso1.MainActivity&quot;).stringFromJNI2.implementation &#x3D; function ()&#123; var result &#x3D; this.stringFromJNI2(); console.log(&quot;result is &#x3D;&gt; &quot;,result); return result; &#125; &#x2F;&#x2F;console.log(&quot;invoke stringFromJNI2 : &#x3D;&gt; &quot;+Java.use(&quot;com.example.demoso1.MainActivity&quot;).stringFromJNI2() ); Java.use(&quot;com.example.demoso1.MainActivity&quot;).myfirstjniJNI(&quot;JSstring&quot;) &#x2F;&#x2F; 动态函数的hook Java.use(&quot;com.example.demoso1.MainActivity&quot;).init.implementation &#x3D; function()&#123; console.log(&quot;hook init successfully!&quot;) return this.init(); &#125; &#x2F;* &#x2F;&#x2F; 动态函数的主动调用 Java.choose(&quot;com.example.demoso1.MainActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;Found instance!&quot;); instance.init(); &#125;,onComplete:function()&#123;console.log(&quot;Search complete!&quot;)&#125; &#125;) *&#x2F; &#125;)&#125;&#x2F;&#x2F; memory list modules&#x2F;&#x2F; memory list exports libnaive-lib.so function hook_nativelib()&#123; var native_lib_addr &#x3D; Module.findBaseAddress(&quot;libnative-lib.so&quot;); console.log(&quot;native_lib_addr &#x3D;&gt; &quot;,native_lib_addr); var myfirstjniJNI &#x3D; Module.findExportByName(&quot;libnative-lib.so&quot;, &quot;Java_com_example_demoso1_MainActivity_myfirstjniJNI&quot;); console.log(&quot;myfirstjniJNI addr &#x3D;&gt; &quot;,myfirstjniJNI); var myfirstjniJNI_invoke &#x3D; new NativeFunction(myfirstjniJNI,&quot;pointer&quot;,[&quot;pointer&quot;,&quot;pointer&quot;,&quot;pointer&quot;]) Interceptor.attach(myfirstjniJNI,&#123; onEnter:function(args)&#123; console.log(&quot;Interceptor.attach myfirstjniJNI args:&quot;,args[0],args[1],args[2]); console.log(&quot;args2 jstring is &quot;,Java.vm.getEnv().getStringUtfChars( args[2],null).readCString()) console.log(&quot;myfirstjniJNI_invoke result &#x3D;&gt; &quot;,myfirstjniJNI_invoke(args[0],args[1],args[2])) var newArgs2 &#x3D; Java.vm.getEnv().newStringUtf(&quot;new args2 from frida&quot;); args[2] &#x3D; newArgs2; &#125;,onLeave:function(retval)&#123; console.log(&quot;Interceptor.attach myfirstjniJNI retval &#x3D;&gt; &quot;,retval) console.log(&quot;retval jstring is &quot;,Java.vm.getEnv().getStringUtfChars( retval,null).readCString()) var newRetval &#x3D; Java.vm.getEnv().newStringUtf(&quot;new Retval from frida&quot;); &#x2F;&#x2F; jstring retval.replace(newRetval); &#125; &#125;)&#125;&#x2F;&#x2F; hook和主动调用native函数function hookandinvoke_add()&#123; var native_lib_addr &#x3D; Module.findBaseAddress(&quot;libnative-lib.so&quot;); console.log(&quot;native_lib_addr &#x3D;&gt; &quot;,native_lib_addr); var r0add_addr &#x3D; Module.findExportByName(&quot;libnative-lib.so&quot;, &quot;_Z5r0addii&quot;); console.log(&quot;r0add addr &#x3D;&gt; &quot;,r0add_addr); &#x2F;&#x2F; 附加 Interceptor.attach(r0add_addr,&#123; onEnter:function(args)&#123; console.log(&quot;x&#x3D;&gt;&quot;,args[0],&quot; y&#x3D;&gt;&quot;,args[1]); &#x2F;&#x2F; 打印调用栈 console.log(&#39;CCCryptorCreate called from:\\n&#39; + Thread.backtrace(this.context, Backtracer.FUZZY) .map(DebugSymbol.fromAddress).join(&#39;\\n&#39;) + &#39;\\n&#39;); &#125;,onLeave:function(retval)&#123; console.log(&quot;retval is &#x3D;&gt; &quot;,retval); &#125; &#125;) var r0add &#x3D; new NativeFunction(r0add_addr,&quot;int&quot;,[&quot;int&quot;,&quot;int&quot;]); var r0add_result &#x3D; r0add(50,1); console.log(&quot;invoke result is &#x3D;&gt; &quot;,r0add_result);&#125;function hook_replace()&#123; var native_lib_addr &#x3D; Module.findBaseAddress(&quot;libnative-lib.so&quot;); console.log(&quot;native_lib_addr &#x3D;&gt; &quot;,native_lib_addr); var myfirstjniJNI &#x3D; Module.findExportByName(&quot;libnative-lib.so&quot;, &quot;Java_com_example_demoso1_MainActivity_myfirstjniJNI&quot;); console.log(&quot;myfirstjniJNI addr &#x3D;&gt; &quot;,myfirstjniJNI); var myfirstjniJNI_invoke &#x3D; new NativeFunction(myfirstjniJNI,&quot;pointer&quot;,[&quot;pointer&quot;,&quot;pointer&quot;,&quot;pointer&quot;]) &#x2F;&#x2F; 替换 Interceptor.replace(myfirstjniJNI,new NativeCallback(function(args0,args1,args2)&#123; console.log(&quot;Interceptor.replace myfirstjniJNI args:&quot;,args0,args1,args2); &#x2F;&#x2F;var result &#x3D; myfirstjniJNI_invoke(args0,args1,args2) return Java.vm.getEnv().newStringUtf(&quot;new Retval from frida&quot;);; &#125;,&quot;pointer&quot;,[&quot;pointer&quot;,&quot;pointer&quot;,&quot;pointer&quot;]))&#125;&#x2F;&#x2F; 枚举所有符号function EnumerateAllExports()&#123; var modules &#x3D; Process.enumerateModules(); &#x2F;&#x2F;console.log(&quot;Process.enumerateModules &#x3D;&gt; &quot;,JSON.stringify(modules)) for(var i&#x3D;0;i&lt;modules.length;i++)&#123; var module &#x3D; modules[i]; var module_name &#x3D; modules[i].name; var exports &#x3D; module.enumerateExports(); console.log(&quot;module_name&#x3D;&gt;&quot;,module_name,&quot; module.enumerateExports &#x3D; &gt; &quot;,JSON.stringify(exports)) &#125;&#125; Process，Module，Memory，Thread 123456789function MODULE()&#123; var native_lib_addr &#x3D; Process.findModuleByAddress(Module.findBaseAddress(&quot;linker64&quot;)); console.log(&quot;native_lib_addr &#x3D;&gt; &quot;,JSON.stringify(native_lib_addr)); console.log(&quot;enumerateImports&#x3D;&gt;&quot;,JSON.stringify(native_lib_addr.enumerateSymbols())) console.log(&quot;enumerateImports&#x3D;&gt;&quot;,JSON.stringify(native_lib_addr.enumerateExports())) console.log(&quot;enumerateImports&#x3D;&gt;&quot;,JSON.stringify(native_lib_addr.enumerateImports()))&#125;setImmediate(MODULE) jni hook123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112function EnumerateAllExports()&#123; var modules &#x3D; Process.enumerateModules(); &#x2F;&#x2F;console.log(&quot;Process.enumerateModules &#x3D;&gt; &quot;,JSON.stringify(modules)) for(var i&#x3D;0;i&lt;modules.length;i++)&#123; var module &#x3D; modules[i]; var module_name &#x3D; modules[i].name; var exports &#x3D; module.enumerateExports(); console.log(&quot;module_name&#x3D;&gt;&quot;,module_name,&quot; module.enumerateExports &#x3D; &gt; &quot;,JSON.stringify(exports)) &#125;&#125;&#x2F;&#x2F; memory list exports libart.so http:&#x2F;&#x2F;demangler.com&#x2F; 获取符号对应的函数function hook_JNI()&#123; var GetStringUTFChars_addr &#x3D; null; var symbols &#x3D; Process.findModuleByName(&quot;libart.so&quot;).enumerateSymbols() &#x2F;&#x2F;console.log(JSON.stringify(symbols)) for(var i &#x3D; 0;i&lt;symbols.length;i++)&#123; var symbol &#x3D; symbols[i].name; if((symbol.indexOf(&quot;CheckJNI&quot;)&#x3D;&#x3D;-1)&amp;&amp;(symbol.indexOf(&quot;JNI&quot;)&gt;&#x3D;0))&#123; if(symbol.indexOf(&quot;GetStringUTFChars&quot;)&gt;&#x3D;0)&#123; console.log(&quot;finally found GetStringUTFChars name :&quot;,symbol); GetStringUTFChars_addr &#x3D;symbols[i].address ; console.log(&quot;finally found GetStringUTFChars address :&quot;,GetStringUTFChars_addr); &#125; &#125; &#125; Interceptor.attach(GetStringUTFChars_addr,&#123; onEnter:function(args)&#123; console.log(&quot;art::JNI::GetStringUTFChars(_JNIEnv*, _jstring*, unsigned char*)&#x3D;&gt;&quot;,args[0],Java.vm.getEnv().getStringUtfChars( args[1],null).readCString(),args[2]); &#x2F;&#x2F; console.log(&#39;CCCryptorCreate called from:\\n&#39; + &#x2F;&#x2F; Thread.backtrace(this.context, Backtracer.ACCURATE) &#x2F;&#x2F;Backtracer.FUZZY &#x2F;&#x2F; .map(DebugSymbol.fromAddress).join(&#39;\\n&#39;) + &#39;\\n&#39;); &#125;,onLeave:function(retval)&#123; console.log(&quot;retval is &#x3D;&gt; &quot;,retval.readCString()); &#125; &#125;)&#125;function replace_JNI()&#123; var NewStringUTF_addr &#x3D; null; var symbols &#x3D; Process.findModuleByName(&quot;libart.so&quot;).enumerateSymbols() &#x2F;&#x2F;console.log(JSON.stringify(symbols)) for(var i &#x3D; 0;i&lt;symbols.length;i++)&#123; var symbol &#x3D; symbols[i].name; if((symbol.indexOf(&quot;CheckJNI&quot;)&#x3D;&#x3D;-1)&amp;&amp;(symbol.indexOf(&quot;JNI&quot;)&gt;&#x3D;0))&#123; if(symbol.indexOf(&quot;NewStringUTF&quot;)&gt;&#x3D;0)&#123; console.log(&quot;finally found NewStringUTF_name :&quot;,symbol); &#x2F;&#x2F; 函数名 NewStringUTF_addr &#x3D;symbols[i].address ; console.log(&quot;finally found NewStringUTF_addr :&quot;,NewStringUTF_addr); &#x2F;&#x2F; 函数地址 &#125; &#125; &#125; var NewStringUTF &#x3D; new NativeFunction(NewStringUTF_addr,&quot;pointer&quot;,[&quot;pointer&quot;,&quot;pointer&quot;]) Interceptor.replace(NewStringUTF_addr, new NativeCallback(function(parg1,parg2)&#123; console.log(&quot;parg1,parg2&#x3D;&gt;&quot;,parg1,parg2.readCString()); &#x2F;&#x2F; console.log(&#39;CCCryptorCreate called from:\\n&#39; + &#x2F;&#x2F; Thread.backtrace(this.context, Backtracer.ACCURATE) &#x2F;&#x2F; .map(DebugSymbol.fromAddress).join(&#39;\\n&#39;) + &#39;\\n&#39;); var newPARG2 &#x3D; Memory.allocUtf8String(&quot;newPARG2&quot;) var result &#x3D; NewStringUTF(parg1,newPARG2); return result; &#125;,&quot;pointer&quot;, [&quot;pointer&quot;,&quot;pointer&quot;]))&#125;function hook_RegisterNatives()&#123; var RegisterNatives_addr &#x3D; null; var symbols &#x3D; Process.findModuleByName(&quot;libart.so&quot;).enumerateSymbols() &#x2F;&#x2F;console.log(JSON.stringify(symbols)) for(var i &#x3D; 0;i&lt;symbols.length;i++)&#123; var symbol &#x3D; symbols[i].name; if((symbol.indexOf(&quot;CheckJNI&quot;)&#x3D;&#x3D;-1)&amp;&amp;(symbol.indexOf(&quot;JNI&quot;)&gt;&#x3D;0))&#123; if(symbol.indexOf(&quot;RegisterNatives&quot;)&gt;&#x3D;0)&#123; console.log(&quot;finally found RegisterNatives_name :&quot;,symbol); RegisterNatives_addr &#x3D;symbols[i].address ; console.log(&quot;finally found RegisterNatives_addr :&quot;,RegisterNatives_addr); &#125; &#125; &#125; if(RegisterNatives_addr!&#x3D;null)&#123; Interceptor.attach(RegisterNatives_addr,&#123; onEnter:function(args)&#123; console.log(&quot;[RegisterNatives]method counts :&quot;,args[3]); var env &#x3D; args[0]; var jclass &#x3D; args[1]; var class_name &#x3D; Java.vm.tryGetEnv().getClassName(jclass); var methods_ptr &#x3D; ptr(args[2]); var method_count &#x3D; parseInt(args[3]); for (var i &#x3D; 0; i &lt; method_count; i++) &#123; var name_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3)); var sig_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize)); var fnPtr_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2)); var name &#x3D; Memory.readCString(name_ptr); var sig &#x3D; Memory.readCString(sig_ptr); var find_module &#x3D; Process.findModuleByAddress(fnPtr_ptr); console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr, &quot;module_name:&quot;, find_module.name, &quot;module_base:&quot;, find_module.base, &quot;offset:&quot;, ptr(fnPtr_ptr).sub(find_module.base)); &#125; &#125;,onLeave:function(retval)&#123; &#125; &#125;) &#125;else&#123; console.log(&quot;didn&#96;t found RegisterNatives address&quot;) &#125;&#125;setImmediate(hook_RegisterNatives); libc hook123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112function beginAnti()&#123; Java.perform(function()&#123; Java.choose(&quot;com.example.demoso1.MainActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;Found instance!&quot;); instance.init(); &#x2F;&#x2F; 触发反调试 &#125;,onComplete:function()&#123;console.log(&quot;Search complete!&quot;)&#125; &#125;)&#125;) &#125;function hook_pthread()&#123; var pthread_create_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;); &#x2F;&#x2F; var symbols &#x3D; Process.findModuleByName(&quot;libc.so&quot;).enumerateSymbols() var time_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;time&quot;); &#x2F;&#x2F; 随意指定一个函数 console.log(&quot;pthread_create_addr&#x3D;&gt;&quot;,pthread_create_addr) Interceptor.attach(pthread_create_addr,&#123; onEnter:function(args)&#123; console.log(&quot;args&#x3D;&gt;&quot;,args[0],args[1],args[2],args[4]) var libnativebaseaddress &#x3D; Module.findBaseAddress(&quot;libnative-lib.so&quot;) if(libnativebaseaddress!&#x3D;null)&#123; console.log(&quot;libnativebaseaddress&#x3D;&gt;&quot;,libnativebaseaddress); &#x2F;&#x2F;var detect_frida_loop_addr &#x3D; args[2]-libnativebaseaddress; &#x2F;&#x2F;console.log(&quot;detect_frida_loop offset is &#x3D;&gt;&quot;,detect_frida_loop_addr) 偏移64900 if(args[2]-libnativebaseaddress &#x3D;&#x3D; 64900)&#123; console.log(&quot;found anti frida loop!,excute time_addr&#x3D;&gt;&quot;,time_addr); args[2]&#x3D;time_addr; &#125; &#125; &#125;,onLeave:function(retval)&#123; console.log(&quot;retval is &#x3D;&gt;&quot;,retval) &#125; &#125;)&#125;function replace_pthread()&#123; var pthread_create_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;); console.log(&quot;pthread_create_addr&#x3D;&gt;&quot;,pthread_create_addr) var pthread_create &#x3D; new NativeFunction(pthread_create_addr,&quot;int&quot;,[&quot;pointer&quot;,&quot;pointer&quot;,&quot;pointer&quot;,&quot;pointer&quot;]) Interceptor.replace(pthread_create_addr, new NativeCallback(function(parg1,parg2,parg3,parg4)&#123; console.log(parg1,parg2,parg3,parg4) var libnativebaseaddress &#x3D; Module.findBaseAddress(&quot;libnative-lib.so&quot;) if(libnativebaseaddress!&#x3D;null)&#123; console.log(&quot;libnativebaseaddress&#x3D;&gt;&quot;,libnativebaseaddress); if(parg3-libnativebaseaddress &#x3D;&#x3D; 64900)&#123; return null; &#125; &#125; return pthread_create(parg1,parg2,parg3,parg4) &#125;,&quot;int&quot;,[&quot;pointer&quot;,&quot;pointer&quot;,&quot;pointer&quot;,&quot;pointer&quot;]))&#125;function writeSomething(path,contents)&#123; var fopen_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fopen&quot;); var fputs_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fputs&quot;); var fclose_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fclose&quot;); &#x2F;&#x2F;console.log(&quot;fopen&#x3D;&gt;&quot;,fopen_addr,&quot; fputs&#x3D;&gt;&quot;,fputs_addr,&quot; fclose&#x3D;&gt;&quot;,fclose_addr); var fopen &#x3D; new NativeFunction(fopen_addr,&quot;pointer&quot;,[&quot;pointer&quot;,&quot;pointer&quot;]) var fputs &#x3D; new NativeFunction(fputs_addr,&quot;int&quot;,[&quot;pointer&quot;,&quot;pointer&quot;]) var fclose &#x3D; new NativeFunction(fclose_addr,&quot;int&quot;,[&quot;pointer&quot;]) console.log(path,contents) var fileName &#x3D; Memory.allocUtf8String(path); var mode &#x3D; Memory.allocUtf8String(&quot;a+&quot;); var fp &#x3D; fopen(fileName,mode); var contentHello &#x3D; Memory.allocUtf8String(contents); var ret &#x3D; fputs(contentHello,fp) fclose(fp);&#125;function EnumerateAllExports()&#123; &#x2F;* var packageName &#x3D; null Java.perform(function()&#123; packageName &#x3D; Java.use(&#39;android.app.ActivityThread&#39;).currentApplication().getApplicationContext().getPackageName(); console.log(&quot;package name is :&quot;,packageName) &#125;) if(!packageName)&#123; console.log(&quot;can&#96;t get package name ,quitting .&quot;) return null; &#125; *&#x2F; var modules &#x3D; Process.enumerateModules(); &#x2F;&#x2F;console.log(&quot;Process.enumerateModules &#x3D;&gt; &quot;,JSON.stringify(modules)) for(var i&#x3D;0;i&lt;modules.length;i++)&#123; var module &#x3D; modules[i]; var module_name &#x3D; modules[i].name; &#x2F;&#x2F;var exports &#x3D; module.enumerateExports(); var exports &#x3D; module.enumerateSymbols(); console.log(&quot;module_name&#x3D;&gt;&quot;,module_name,&quot; module.enumerateExports &#x3D; &gt; &quot;,JSON.stringify(exports)) for(var m &#x3D;0; m&lt;exports.length;m++)&#123; console.log(&quot;m&#x3D;&gt;&quot;,m) &#x2F;&#x2F;writeSomething(&quot;&#x2F;sdcard&#x2F;&quot;+packageName+&quot;&#x2F;&quot;+module_name+&quot;.txt&quot;, &quot;type:&quot;+exports[m].type+ &quot; name:&quot;+ exports[m].name+&quot; address:&quot;+exports[m].address+&quot;\\n&quot;) writeSomething(&quot;&#x2F;sdcard&#x2F;settings&#x2F;&quot;+module_name+&quot;.txt&quot;, &quot;type:&quot;+exports[m].type+ &quot; name:&quot;+ exports[m].name+&quot; address:&quot;+exports[m].address+&quot;\\n&quot;) &#125; &#125;&#125;setImmediate(EnumerateAllExports) linker hook在Android so文件的.init、.init_array上和JNI_OnLoad处下断点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&#x2F;&#x2F;应用以32位在64位终端环境下运行&#x2F;&#x2F;adb install --abi armeabi-v7a &lt;path to apk&gt;function hook_pthread() &#123; var pthread_create_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;); var time_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;time&quot;); console.log(&quot;pthread_create_addr&#x3D;&gt;&quot;, pthread_create_addr) Interceptor.attach(pthread_create_addr, &#123; onEnter: function (args) &#123; console.log(&quot;args&#x3D;&gt;&quot;, args[0], args[1], args[2], args[4]) var libnativebaseaddress &#x3D; Module.findBaseAddress(&quot;libnative-lib.so&quot;) if (libnativebaseaddress !&#x3D; null) &#123; console.log(&quot;libnativebaseaddress&#x3D;&gt;&quot;, libnativebaseaddress); &#x2F;&#x2F;var detect_frida_loop_addr &#x3D; args[2]-libnativebaseaddress; &#x2F;&#x2F;console.log(&quot;detect_frida_loop offset is &#x3D;&gt;&quot;,detect_frida_loop_addr) if (args[2] - libnativebaseaddress &#x3D;&#x3D; 0x95c9) &#123; console.log(&quot;found anti frida loop!,excute time_addr&#x3D;&gt;&quot;, time_addr); args[2] &#x3D; time_addr; &#125; &#125; &#125;, onLeave: function (retval) &#123; console.log(&quot;retval is &#x3D;&gt;&quot;, retval) &#125; &#125;)&#125;function EnumerateAllExports() &#123; var linker &#x3D; Process.getModuleByName(&quot;linker&quot;) &#x2F;&#x2F;console.log(&quot;exports&#x3D;&gt;&quot;,JSON.stringify(linker.enumerateSymbols())) var call_function_addr &#x3D; null; var exports &#x3D; linker.enumerateSymbols(); &#x2F;&#x2F;console.log(&quot;module_name&#x3D;&gt;&quot;,module_name,&quot; module.enumerateExports &#x3D; &gt; &quot;,JSON.stringify(exports)) for (var m &#x3D; 0; m &lt; exports.length; m++) &#123; &#x2F;&#x2F;console.log(&quot;m&#x3D;&gt;&quot;,m) &#x2F;&#x2F;writeSomething(&quot;&#x2F;sdcard&#x2F;&quot;+packageName+&quot;&#x2F;&quot;+module_name+&quot;.txt&quot;, &quot;type:&quot;+exports[m].type+ &quot; name:&quot;+ exports[m].name+&quot; address:&quot;+exports[m].address+&quot;\\n&quot;) &#x2F;&#x2F;writeSomething(&quot;&#x2F;sdcard&#x2F;settings&#x2F;&quot;+module_name+&quot;.txt&quot;, &quot;type:&quot;+exports[m].type+ &quot; name:&quot;+ exports[m].name+&quot; address:&quot;+exports[m].address+&quot;\\n&quot;) if (exports[m].name &#x3D;&#x3D; &quot;__dl__ZL13call_functionPKcPFviPPcS2_ES0_&quot;) &#123; &#x2F;&#x2F; 用demangler查看函数 call_function_addr &#x3D; exports[m].address; console.log(&quot;found call_function_addr &#x3D;&gt; &quot;, call_function_addr) hook_call_function(call_function_addr) &#125; &#125; &#x2F;* __dl__ZL13call_functionPKcPFvvES0_ __dl_call_function(char const*, void (*)(), char const*) __dl__ZL13call_functionPKcPFviPPcS2_ES0_ __dl_call_function(char const*, void (*)(int, char**, char**), char const*) *&#x2F;&#125;function hook_call_function(_call_function_addr)&#123; console.log(&quot;hook call function begin!hooking address :&#x3D;&gt;&quot;,_call_function_addr) Interceptor.attach(_call_function_addr,&#123; onEnter:function(args)&#123; if(args[2].readCString().indexOf(&quot;base.odex&quot;)&lt;0)&#123; &#x2F;&#x2F; 过滤 console.log(&quot;function_name : agrs[0]&#x3D;&gt;&quot;,args[0].readCString()) console.log(&quot;so path : agrs[2]&#x3D;&gt;&quot;,args[2].readCString()) console.log(&quot;function offset : args[1]&#x3D;&gt;&quot;,&quot;0x&quot;+(args[1]-Module.findBaseAddress(&quot;libnative-lib.so&quot;)).toString(16)) &#125; &#125;,onLeave:function(retval)&#123; &#125; &#125;)&#125;setImmediate(EnumerateAllExports) boringssl证书方案1： frida替换校验证书时回调函数的返回值，修改为枚举变量ssl_verify_ok的值0 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#x2F;&#x2F; so加载之后立马hookfunction todoOndlopen(libraryName, fn) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; var exportName &#x3D; Java.androidVersion &gt;&#x3D; 8.1 ? &#39;android_dlopen_ext&#39; : &#39;dlopen&#39;; var dlopen_ptr &#x3D; Module.findExportByName(null, exportName); if (dlopen_ptr) &#123; Interceptor.attach(dlopen_ptr, &#123; onEnter: function (args) &#123; var libPath &#x3D; args[0].readCString(); if (libPath.indexOf(libraryName) !&#x3D; -1) &#123; console.log(&#96;libraryPath: $&#123;libPath&#125;&#96;); this.hook &#x3D; true &#125; &#125;, onLeave: function (retVal) &#123; if (this.hook) &#123; console.log(&#39;hooking&#39;) resolve(fn()); &#125; &#125; &#125;) &#125; else &#123; reject(exportName + &#39; not found&#39;) &#125; &#125;)&#125;&#x2F;&#x2F; enum ssl_verify_result_t BORINGSSL_ENUM_INT &#123;&#x2F;&#x2F; ssl_verify_ok, 0&#x2F;&#x2F; ssl_verify_invalid, 1&#x2F;&#x2F; ssl_verify_retry, 2&#x2F;&#x2F; &#125;;&#x2F;&#x2F; 修改为枚举变量ssl_verify_ok的值0function replaceCallback(pcustom_verify_callback)&#123; Interceptor.attach(pcustom_verify_callback, &#123; onLeave(retval)&#123; if (retval !&#x3D; 0)&#123; console.log(&quot;custom_verify_callback retval: &quot;, retval) console.log(&#39;custom_verify_callback retval replace with 0x0&#39;); retval.replace(ptr(&#39;0x0&#39;)) &#125; &#125; &#125;)&#125;&#x2F;&#x2F;void SSL_CTX_set_custom_verify(&#x2F;&#x2F; SSL_CTX *ctx, int mode,&#x2F;&#x2F; enum ssl_verify_result_t (*callback)(SSL *ssl, uint8_t *out_alert)) &#123;&#x2F;&#x2F; ctx-&gt;verify_mode &#x3D; mode;&#x2F;&#x2F; ctx-&gt;custom_verify_callback &#x3D; callback;&#x2F;&#x2F; &#125;&#x2F;&#x2F; 替换校验证书时回调函数的返回值function anti_ssl_verify()&#123; const libraryName &#x3D; &#39;libsscronet.so&#39;; return todoOndlopen(libraryName, ()&#x3D;&gt;&#123; const pSSL_CTX_set_custom_verify &#x3D; Module.findExportByName(&#39;libttboringssl.so&#39;, &#39;SSL_CTX_set_custom_verify&#39;); var SSL_CTX_set_custom_verify &#x3D; new NativeFunction(pSSL_CTX_set_custom_verify, &#39;pointer&#39;, [&#39;pointer&#39;, &#39;int&#39;, &#39;pointer&#39;]); Interceptor.replace(pSSL_CTX_set_custom_verify, new NativeCallback((ctx, verify_mode, pcustom_verify_callback)&#x3D;&gt;&#123; console.log(&#96;SSL_CTX_set_custom_verify be called, ctx: $&#123;ctx&#125;, verify_mode: $&#123;verify_mode&#125;, pcustom_verify_callback&#x3D;$&#123;pcustom_verify_callback&#125;&#96;); replaceCallback(pcustom_verify_callback) return SSL_CTX_set_custom_verify(ctx, verify_mode, pcustom_verify_callback); &#125;, &#39;pointer&#39;,[&#39;pointer&#39;, &#39;int&#39;, &#39;pointer&#39;])) &#125;)&#125;function main()&#123; anti_ssl_verify();&#125;setImmediate(main) 方案2：记录所有回调函数的地址，获取函数所在模块和偏移，然后在ida中patch返回值，然后推送到存放app动态库的目录下面 12345678910function getModuleByAddr(addr) &#123; var result &#x3D; null; Process.enumerateModules().forEach(function (module) &#123; if (module.base &lt;&#x3D; addr &amp;&amp; addr &lt;&#x3D; (module.base.add(module.size))) &#123; result &#x3D; JSON.stringify(module); return false; &#x2F;&#x2F; 跳出循环 &#125; &#125;); return result;&#125; IDA打开libsscronet.so(抖音) N修改sub_1CCB20为VerifyCallback，在VerifyCallBack函数中最终return sub_1CCD58(v3)就是函数返回的位置。 找到j_ret的引用处，设置Options-General的opcode字节长度为4，ARM to HEX将opcode的MOVS R0, #0转成16进制0020 打开Hex View-1,F2修改01 20为00 20，F2应用。 同理，进入sub_1CCD58中所有return 1;和return 2;的地方的opcode都修改为0020,Edit-Patch Program-apply patches to input file保存好后放到/data/app/com.ss.android.ugc.aweme-mjb-5ipSrniOlGTyMxBrQg==/lib/arm 123chgrp system libsscronet.sochown system libsscronet.sochmod 777 libsscronet.so ollvmhellojni_2.0.0.apk 函数sign1函数，打开libhello-jni.so的导出函数没有搜到，但是出现了多个.datadiv_decode函数，这就是ollvm默认字符串混淆前缀。 以上byte开头编译过程是把字符串加密的逻辑，双击进入byte_37118，在010Editor中新建十六进制文件 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"Xposed二进制补丁插件开发","slug":"Xposed二进制补丁插件开发","date":"2022-05-04T03:45:59.000Z","updated":"2022-06-05T10:14:11.711Z","comments":true,"path":"2022/05/04/Xposed二进制补丁插件开发/","link":"","permalink":"http://onejane.github.io/2022/05/04/Xposed%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E4%B8%81%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/","excerpt":"","text":"介绍Xposed是一款可以在不修改APK的情况下影响程序运行(修改系统)的框架，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。在这个框架下，我们可以编写并加载自己编写的插件APP，实现对目标apk的注入拦截等。 原理就是控制zygote进程，通过替换/system/bin/app_process程序控制zygote进程，使得它在系统启动过程中会加载Xposed framework的一个jar文件即XposedBridge.jar，从而完成对zygote进程及其创建的Dalvik/ART虚拟机的劫持，并且能够运行开发者独立的替代任何class，例如framework本身，系统UI又或者随意的一个app。 4.4以下Android版本安装较为简单，将root后的手机安装xposedInstaller，不过官网不再维护，导致无法直接通过xposedInstaller下载补丁包。 5.0开始，谷歌使用ART替换Dalvik，xposed分为两个部分，xposed*.zip和XposedInstaller.apk，zip文件是框架主体，需要进入Recovery后刷入，apk文件是xposed模块管理应用，主要用于下载，激活，是否启用模块等管理功能。首先完成对手机root，并刷入recove(如twrp)，下载对应zip补丁包，进入recovery刷入，重启手机安装xposedinstaller并收入root权限。 Nexus6前arm32,后arm64 安卓8以上安装Edxposed，对于Xposed官方不支持的较新的Android版本可以先安装magisk，接着安装riru模块，最后再进行Edxposed的安装。 Android Red Velvet Cake (11, sdk30) Android Queen Cake (10, sdk29) Android Pie (9, sdk28) Android Oreo (8.1, sdk27) Android Oreo (8.0, sdk26) Magisk-v24.3.apk 实现root 12345EdXposed-SandHook-v0.4.6.2.4529.-release.zipEdXposed-YAHFA-v0.4.6.2.4529.-release.zipEdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apkmagisk-riru-v21.1.zipMagisk-v20.4.zip Hook 拷贝XposedBridgeApi.jar到新建工程的libs目录 修改app目录下的build.gradle文件，在AndroidManifest.xml中增加Xposed相关内容 新建hook类，编写hook代码 新建assets文件夹，然后在assets目录下新建xposed_init，在里面写hook类的完整路径 app/libs放入XposedBridgeApi-54.jar app/build.gradle 12345678dependencies &#123; compileOnly fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) implementation &#39;androidx.appcompat:appcompat:1.1.0&#39; implementation &#39;androidx.constraintlayout:constraintlayout:1.1.3&#39; testImplementation &#39;junit:junit:4.12&#39; androidTestImplementation &#39;androidx.test.ext:junit:1.1.1&#39; androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.2.0&#39;&#125; AndroidManifest.xml 123456789101112131415161718192021222324&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; package&#x3D;&quot;com.kanxue.xposed01&quot;&gt; &lt;application android:allowBackup&#x3D;&quot;true&quot; android:icon&#x3D;&quot;@mipmap&#x2F;ic_launcher&quot; android:label&#x3D;&quot;@string&#x2F;app_name&quot; android:roundIcon&#x3D;&quot;@mipmap&#x2F;ic_launcher_round&quot; android:supportsRtl&#x3D;&quot;true&quot; android:theme&#x3D;&quot;@style&#x2F;AppTheme&quot;&gt; &lt;meta-data android:name&#x3D;&quot;xposedmodule&quot; android:value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;meta-data android:name&#x3D;&quot;xposeddescription&quot; android:value&#x3D;&quot;第一个Xposed插件&quot;&#x2F;&gt; &lt;meta-data android:name&#x3D;&quot;xposedminversion&quot; android:value&#x3D;&quot;54&quot; &#x2F;&gt; &lt;activity android:name&#x3D;&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name&#x3D;&quot;android.intent.action.MAIN&quot; &#x2F;&gt; &lt;category android:name&#x3D;&quot;android.intent.category.LAUNCHER&quot; &#x2F;&gt; &lt;&#x2F;intent-filter&gt; &lt;&#x2F;activity&gt; &lt;&#x2F;application&gt;&lt;&#x2F;manifest&gt; Xposed01.java 123456789101112131415161718192021222324252627282930313233343536import android.content.pm.ApplicationInfo;import android.telephony.TelephonyManager;import android.util.Log;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XC_MethodReplacement;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.XposedHelpers;import de.robv.android.xposed.callbacks.XC_LoadPackage;public class Xposed01 implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; Log.i(&quot;Xposed01&quot;, loadPackageParam.packageName); XposedBridge.log(&quot;Xposed01-&gt;app packagename&quot; + loadPackageParam.packageName); if (loadPackageParam.packageName.equals(&quot;com.example.test&quot;)) &#123; XposedBridge.log(&quot;kanxue &quot; + loadPackageParam.packageName); XposedHelpers.findAndHookMethod(TelephonyManager.class, &quot;getDeviceId&quot;, new XC_MethodReplacement() &#123; @Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable &#123; return XposedBridge.invokeOriginalMethod(param.method,param.thisObject,param.args); &#x2F;&#x2F;return &quot;this is imei&quot;; &#125; &#125;); XposedHelpers.findAndHookMethod(TelephonyManager.class, &quot;getSubscriberId&quot;, new XC_MethodReplacement() &#123; @Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable &#123; return &quot;this is imsi&quot;; &#125; &#125;); &#125; ; &#125;&#125; app/src/main/assets/xposed_init 12com.kanxue.xposed01.Xposed01com.kanxue.xposed01.HookConstructors 构造函数java反射或xposed的api属性修改 HookConstructors.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public class HookConstructors implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; Log.i(&quot;Xposed01&quot;, loadPackageParam.packageName); XposedBridge.log(&quot;Xposed01-&gt;app packagename&quot; + loadPackageParam.packageName); if (loadPackageParam.packageName.equals(&quot;com.kanxue.xposedhook01&quot;)) &#123; &#x2F;&#x2F;XposedBridge.log(&quot;kanxue &quot; + loadPackageParam.packageName); &#x2F;&#x2F; 无参构造函数 ClassLoader classLoader &#x3D; loadPackageParam.classLoader; Class StudentClass &#x3D; classLoader.loadClass(&quot;com.kanxue.xposedhook01.Student&quot;); XposedHelpers.findAndHookConstructor(StudentClass, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); XposedBridge.log(&quot;com.kanxue.xposedhook01.Student() is called!!beforeHookedMethod&quot;); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;com.kanxue.xposedhook01.Student() is called!!afterHookedMethod&quot;); &#125; &#125;); &#x2F;&#x2F; public Student(String name2) &#123; &#x2F;&#x2F; this.name &#x3D; name2; &#x2F;&#x2F; this.id &#x3D; &quot;default&quot;; &#x2F;&#x2F; &#125; &#x2F;&#x2F; public java.lang.Object thisObject; &#x2F;&#x2F; public java.lang.Object[] args; &#x2F;&#x2F; private java.lang.Object result; &#x2F;&#x2F; 一个参数的构造函数 XposedHelpers.findAndHookConstructor(StudentClass, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); java.lang.Object[] argsobjarray &#x3D; param.args; String name &#x3D; (String) argsobjarray[0]; XposedBridge.log(&quot;com.kanxue.xposedhook01.Student(String) is called!!beforeHookedMethod--&quot; + name); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;com.kanxue.xposedhook01.Student(String) is called!!afterHookedMethod&quot;); &#125; &#125;); &#x2F;&#x2F; public Student(String name2, String id2) &#123; &#x2F;&#x2F; this.name &#x3D; name2; &#x2F;&#x2F; this.id &#x3D; id2; &#x2F;&#x2F; &#125; &#x2F;&#x2F; 两个参数的构造函数 XposedHelpers.findAndHookConstructor(&quot;com.kanxue.xposedhook01.Student&quot;, loadPackageParam.classLoader, String.class, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); java.lang.Object[] argsobjarray &#x3D; param.args; String name &#x3D; (String) argsobjarray[0]; String id &#x3D; (String) argsobjarray[1]; XposedBridge.log(&quot;com.kanxue.xposedhook01.Student(String,String) is called!!beforeHookedMethod--&quot; + name + &quot;---&quot; + id); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;com.kanxue.xposedhook01.Student(String,String) is called!!afterHookedMethod&quot;); &#125; &#125;); &#x2F;&#x2F; 获取属性 ClassLoader pathClassLoader&#x3D; loadPackageParam.classLoader; final Class stuClass&#x3D;pathClassLoader.loadClass(&quot;com.kanxue.xposedhook01.Student&quot;); XposedBridge.log(&quot;StudentClass-&gt;&quot;+stuClass); &#x2F;&#x2F; 使用java反射修改属性&#x2F;* Field teacherField&#x3D;stuClass.getDeclaredField(&quot;teacher&quot;); teacherField.setAccessible(true); teacherField.set(null,&quot;teacher666&quot;); String teachername1&#x3D; (String) teacherField.get(null); XposedBridge.log(&quot;teacherField-&gt;&quot;+teachername1);*&#x2F; &#x2F;&#x2F; 使用Xposed的api修改属性 &#x2F;&#x2F;(java.lang.Class&lt;?&gt; clazz, java.lang.String fieldName, java.lang.Object value) XposedHelpers.setStaticObjectField(stuClass,&quot;teacher&quot;,&quot;teacher888&quot;); String teachername2&#x3D; (String) XposedHelpers.getStaticObjectField(stuClass,&quot;teacher&quot;); XposedBridge.log(&quot;XposedHelpers.getStaticObjectField-&gt;&quot;+teachername2); &#x2F;&#x2F;public Student(String name, String id, int age, String teachername, String nickname) &#x2F;&#x2F; 5个参数的构造函数 XposedHelpers.findAndHookConstructor(StudentClass, String.class, String.class, int.class,String.class,String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); java.lang.Object[] argsobjarray &#x3D; param.args; String name &#x3D; (String) argsobjarray[0]; String id &#x3D; (String) argsobjarray[1]; int age &#x3D; (int) (argsobjarray[2]); argsobjarray[1] &#x3D; &quot;2050&quot;; &#x2F;&#x2F; 修改值 argsobjarray[2] &#x3D; 100; String teacher&#x3D; (String) argsobjarray[3]; String nickname&#x3D; (String) argsobjarray[4]; XposedBridge.log(&quot;com.kanxue.xposedhook01.Student(String,String) is called!!beforeHookedMethod--&quot; + name + &quot;---&quot; + id + &quot;--&quot; + age+&quot;---&quot;+teacher+&quot;---&quot;+nickname); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); Object thisobj &#x3D; param.thisObject; &#x2F;* Field nicknameField&#x3D;stuClass.getDeclaredField(&quot;nickname&quot;); XposedBridge.log(stuClass+&quot;--nicknameField-&gt;&quot;+nicknameField); nicknameField.setAccessible(true); nicknameField.set(thisobj,&quot;bear&quot;);*&#x2F; XposedHelpers.setObjectField(thisobj,&quot;nickname&quot;,&quot;chick&quot;); Object returnobj &#x3D; param.getResult(); XposedBridge.log(thisobj + &quot;---&quot; + returnobj); XposedBridge.log(&quot;com.kanxue.xposedhook01.Student(String,String,int) is called!!afterHookedMethod&quot;); &#125; &#125;); &#125; &#125;&#125; 动静属性1234567891011121314151617181920212223242526272829303132public class HookFlag implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; Log.i(&quot;HookFlag&quot;, loadPackageParam.packageName); XposedBridge.log(&quot;HookFlag-&gt;app packagename&quot; + loadPackageParam.packageName); if (loadPackageParam.packageName.equals(&quot;com.kanxue.xposedflag&quot;)) &#123; XposedBridge.log(&quot;HookFlag &quot; + loadPackageParam.packageName); &#x2F;&#x2F; 修改静态属性 ClassLoader classLoader&#x3D;loadPackageParam.classLoader; Class Flag1Class&#x3D;classLoader.loadClass(&quot;com.kanxue.xposedflag.Flag1&quot;); XposedHelpers.setStaticIntField(Flag1Class,&quot;length&quot;,8); &#x2F;&#x2F; 修改Flag2的flag动态属性为123456 XposedHelpers.findAndHookConstructor(&quot;com.kanxue.xposedflag.Flag2&quot;, classLoader, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); XposedBridge.log(&quot;go into com.kanxue.xposedflag.Flag2()-&gt;beforeHookedMethod&quot;); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;leave com.kanxue.xposedflag.Flag2()-&gt;afterHookedMethod&quot;); Object Flag2obj&#x3D;param.thisObject; XposedHelpers.setObjectField(Flag2obj,&quot;flag&quot;,&quot;12345678&quot;); &#125; &#125;); &#125; &#125;&#125; DexClassLoaderXposed不止可以实现对app自己试下拿到类构造函数hook，对于系统框架层的java函数可以进行hook，Hook所有classLoader包括加载dex中的，并打印这些classLoader中的类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HookDexClassLoader implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; Log.i(&quot;HookDexClassLoader&quot;, loadPackageParam.packageName); XposedBridge.log(&quot;HookDexClassLoader-&gt;app packagename&quot; + loadPackageParam.packageName); if (loadPackageParam.packageName.equals(&quot;com.kanxue.loaddex&quot;)) &#123; &#x2F;&#x2F;public DexClassLoader(String dexPath, String optimizedDirectory, &#x2F;&#x2F; String librarySearchPath, ClassLoader parent) &#123; &#x2F;&#x2F; super(dexPath, null, librarySearchPath, parent); &#x2F;&#x2F; &#125; XposedHelpers.findAndHookConstructor(DexClassLoader.class, String.class, String.class, String.class, ClassLoader.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Object array[]&#x3D;param.args; String dexpath&#x3D; (String) array[0]; String optimizedDirectory&#x3D; (String) array[1]; String librarySearchPath&#x3D; (String) array[2]; XposedBridge.log(&quot;DexClassLoader beforeHookedMethod:&quot;+dexpath+&quot;---&quot;+optimizedDirectory+&quot;---&quot;+librarySearchPath); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); DexClassLoader dexClassLoader&#x3D; (DexClassLoader) param.thisObject; XposedBridge.log(&quot;DexClassLoader afterHookedMethod:&quot;+dexClassLoader); GetClassLoaderClasslist(dexClassLoader); &#x2F;&#x2F; 指定classLoader XposedHelpers.findAndHookMethod(&quot;com.kanxue.test02.TestClass&quot;, dexClassLoader, &quot;testcontent&quot;, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Object[] objectarray &#x3D; param.args; String arg0 &#x3D; (String) objectarray[0]; XposedBridge.log(&quot;beforeHookedMethod11 privatefunc-&gt;arg0:&quot; + arg0); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); &#x2F;&#x2F; String result &#x3D; (String) param.getResult(); &#x2F;&#x2F; XposedBridge.log(&quot;afterHookedMethod11 privatefunc-&gt;result:&quot; + result); param.setResult(true); &#125; &#125;); &#125; &#125;); &#125; &#125;&#125; 一般函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class HookJavaFunction implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; Log.i(&quot;Xposed01&quot;, loadPackageParam.packageName); XposedBridge.log(&quot;HookJava-&gt;app packagename&quot; + loadPackageParam.packageName); if (loadPackageParam.packageName.equals(&quot;com.kanxue.xposedhook01&quot;)) &#123; XposedBridge.log(&quot;kanxue &quot; + loadPackageParam.packageName); ClassLoader classLoader &#x3D; loadPackageParam.classLoader; XposedBridge.log(&quot;loadPackageParam.classLoader-&gt;&quot; + classLoader); Class StuClass &#x3D; classLoader.loadClass(&quot;com.kanxue.xposedhook01.Student&quot;); &#x2F;&#x2F; public static String publicstaticfunc(String arg1, int arg2) &#123;&#x2F;&#x2F; String result &#x3D; privatestaticfunc(&quot;privatestaticfunc&quot;, 200);&#x2F;&#x2F; return arg1 + &quot;---&quot; + arg2 + &quot;---&quot; + result;&#x2F;&#x2F; &#125;&#x2F;&#x2F; 公有函数的hook与修改 XposedHelpers.findAndHookMethod(StuClass, &quot;publicstaticfunc&quot;, String.class, int.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Object[] objectarray&#x3D;param.args; String arg0&#x3D; (String) objectarray[0]; int arg1&#x3D; (int) objectarray[1]; objectarray[0]&#x3D;&quot;changedbyxposedjava&quot;; objectarray[1]&#x3D;888; XposedBridge.log(&quot;beforeHookedMethod publicstaticfunc-&gt;arg0:&quot;+arg0+&quot;---arg1:&quot;+arg1); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); String result&#x3D; (String) param.getResult(); param.setResult(&quot;changedbyxposed-&gt;afterHookedMethod&quot;); XposedBridge.log(&quot;afterHookedMethod publicstaticfunc-&gt;result:&quot;+result); &#125; &#125;);&#x2F;&#x2F; 私有函数的hook与修改 XposedHelpers.findAndHookMethod(StuClass, &quot;privatestaticfunc&quot;, String.class, int.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Object[] objectarray &#x3D; param.args; String arg0 &#x3D; (String) objectarray[0]; int arg1 &#x3D; (int) objectarray[1]; objectarray[0] &#x3D; &quot;changedbyxposedjava&quot;; objectarray[1] &#x3D; 888; XposedBridge.log(&quot;beforeHookedMethod privatestaticfunc-&gt;arg0:&quot; + arg0 + &quot;---arg1:&quot; + arg1); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); String result &#x3D; (String) param.getResult(); param.setResult(&quot;changedbyxposed-&gt;afterHookedMethod&quot;); XposedBridge.log(&quot;afterHookedMethod privatestaticfunc-&gt;result:&quot; + result); &#125; &#125;);&#x2F;&#x2F; private static String privatestaticfunc(String arg1, int arg2) &#123;&#x2F;&#x2F; return arg1 + &quot;---&quot; + arg2;&#x2F;&#x2F; &#125; XposedHelpers.findAndHookMethod(StuClass, &quot;publicfunc&quot;, String.class, int.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Object[] objectarray &#x3D; param.args; String arg0 &#x3D; (String) objectarray[0]; int arg1 &#x3D; (int) objectarray[1]; objectarray[0] &#x3D; &quot;changedbyxposedjava&quot;; objectarray[1] &#x3D; 888; XposedBridge.log(&quot;beforeHookedMethod publicfunc-&gt;arg0:&quot; + arg0 + &quot;---arg1:&quot; + arg1); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); String result &#x3D; (String) param.getResult(); param.setResult(&quot;changedbyxposed-&gt;afterHookedMethod&quot;); XposedBridge.log(&quot;afterHookedMethod publicfunc-&gt;result:&quot; + result); &#125; &#125;);&#x2F;&#x2F; private String privatefunc(String arg1, int arg2) &#123;&#x2F;&#x2F; return arg1 + &quot;---&quot; + arg2;&#x2F;&#x2F; &#125; &#x2F;&#x2F; 指定classLoader XposedHelpers.findAndHookMethod(&quot;com.kanxue.xposedhook01.Student&quot;, loadPackageParam.classLoader, &quot;privatefunc&quot;, String.class, int.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Object[] objectarray &#x3D; param.args; String arg0 &#x3D; (String) objectarray[0]; int arg1 &#x3D; (int) objectarray[1]; XposedBridge.log(&quot;beforeHookedMethod11 privatefunc-&gt;arg0:&quot; + arg0 + &quot;---arg1:&quot; + arg1); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); String result &#x3D; (String) param.getResult(); XposedBridge.log(&quot;afterHookedMethod11 privatefunc-&gt;result:&quot; + result); &#125; &#125;);&#x2F;&#x2F; 内部类，匿名内部类$1,$2... Class personClass &#x3D; XposedHelpers.findClass(&quot;com.kanxue.xposedhook01.Student$person&quot;, loadPackageParam.classLoader); XposedHelpers.findAndHookMethod(personClass, &quot;getpersonname&quot;, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); XposedBridge.log(&quot;beforeHookedMethod getpersonname-&gt;&quot; + param.args[0]); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;afterHookedMethod getpersonname-&gt;&quot; + param.getResult()); &#125; &#125;); &#x2F;&#x2F; public static java.lang.Class&lt;?&gt; findClass(java.lang.String className, java.lang.ClassLoader classLoader) &#x2F;&#x2F;Class StuClassByXposed&#x3D;XposedHelpers.findClass(&quot;com.kanxue.xposedhook01.Student&quot;,classLoader); &#125; &#125;&#125; JNI函数123456789101112131415161718192021222324252627282930313233343536public class HookJni implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; Log.i(&quot;Xposed01&quot;, loadPackageParam.packageName); XposedBridge.log(&quot;HookJava-&gt;app packagename&quot; + loadPackageParam.packageName); if (loadPackageParam.packageName.equals(&quot;com.kanxue.loaddex&quot;)) &#123; Class MainActivityClass&#x3D;XposedHelpers.findClass(&quot;com.kanxue.loaddex.MainActivity&quot;,loadPackageParam.classLoader); XposedHelpers.findAndHookMethod(MainActivityClass, &quot;onCreate&quot;, Bundle.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); XposedBridge.log(&quot;beforeHookedMethod onCreate-&gt;&quot;+param.args[0]); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;afterHookedMethod onCreate-&gt;&quot;+param.thisObject); &#125; &#125;); XposedHelpers.findAndHookMethod(MainActivityClass, &quot;replaceClassloader&quot;, ClassLoader.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); XposedBridge.log(&quot;beforeHookedMethod replaceClassloader-&gt;Classloader:&quot;+param.args[0]); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;afterHookedMethod replaceClassloader-&gt;&quot;+param.thisObject); &#125; &#125;); &#125; &#125;&#125; 主动调用对于类中的静态函数，直接调用即可。对于非静态函数，需要先得到类的实例，才能完成调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class HookActiveInvoke implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; Log.i(&quot;XposedActiveInvoke&quot;, loadPackageParam.packageName); XposedBridge.log(&quot;XposedActiveInvoke-&gt;app packagename&quot; + loadPackageParam.packageName); if (loadPackageParam.packageName.equals(&quot;com.kanxue.xposedhook01&quot;)) &#123; XposedBridge.log(&quot;kanxue &quot; + loadPackageParam.packageName); &#x2F;&#x2F; 主动调用&#x2F;&#x2F; public static String publicstaticfunc(String arg1, int arg2) &#123;&#x2F;&#x2F; String result &#x3D; privatestaticfunc(&quot;privatestaticfunc&quot;, 200);&#x2F;&#x2F; Log.i(&quot;Xposed&quot;,&quot;publicstaticfunc is called!&quot;);&#x2F;&#x2F; return arg1 + &quot;---&quot; + arg2 + &quot;---&quot; + result;&#x2F;&#x2F; &#125; &#x2F;&#x2F; 反射调用 ClassLoader classLoader &#x3D; loadPackageParam.classLoader; Class StuClass &#x3D; classLoader.loadClass(&quot;com.kanxue.xposedhook01.Student&quot;); Method publicstaticfunc_method &#x3D; StuClass.getDeclaredMethod(&quot;publicstaticfunc&quot;, String.class, int.class); publicstaticfunc_method.invoke(null, &quot;InvokedByXposed&quot;, 100); &#x2F;&#x2F; api调用静态函数 java.lang.Class&lt;?&gt;[] parameterTypes &#x3D; &#123;String.class, int.class&#125;; XposedHelpers.callStaticMethod(StuClass, &quot;publicstaticfunc&quot;, parameterTypes, &quot;publicstaticfunc is called by XposedHelpers.callStaticMethod11&quot;, 100); XposedHelpers.callStaticMethod(StuClass, &quot;publicstaticfunc&quot;, &quot;publicstaticfunc is called by XposedHelpers.callStaticMethod22&quot;, 200); XposedHelpers.callStaticMethod(StuClass, &quot;privatestaticfunc&quot;, parameterTypes, &quot;privatestaticfunc is called by XposedHelpers.callStaticMethod11&quot;, 400); XposedHelpers.callStaticMethod(StuClass, &quot;privatestaticfunc&quot;, &quot;privatestaticfunc is called by XposedHelpers.callStaticMethod22&quot;, 300); &#x2F;&#x2F; 反射调用静态函数 Method privatestaticfunc_method &#x3D; StuClass.getDeclaredMethod(&quot;privatestaticfunc&quot;, String.class, int.class); privatestaticfunc_method.setAccessible(true); String result &#x3D; (String) privatestaticfunc_method.invoke(null, &quot;privatestaticfuncIsInvokedByXposed&quot;, 200); XposedBridge.log(&quot;privatestaticfuncIsInvokedByXposed-&gt;result:&quot; + result);&#x2F;&#x2F; private static String privatestaticfunc(String arg1, int arg2) &#123;&#x2F;&#x2F; Log.i(&quot;Xposed&quot;,&quot;privatestaticfunc is called!&quot;);&#x2F;&#x2F; return arg1 + &quot;---&quot; + arg2;&#x2F;&#x2F; &#125; &#x2F;&#x2F; api调用动态函数 Object StuObjByXposed &#x3D; XposedHelpers.newInstance(StuClass, &quot;StuObjByXposed.newInstance&quot;, &quot;500&quot;); String result1 &#x3D; (String) XposedHelpers.callMethod(StuObjByXposed, &quot;publicfunc&quot;, &quot;publicfunc is called by XposedHelpers.callMethod&quot;, 125); XposedBridge.log(&quot;publicfunc XposedHelpers.callMethod result-&gt;&quot; + result1); XposedHelpers.callMethod(StuObjByXposed, &quot;privatefunc&quot;, &quot;privatefunc is called by XposedHelpers.callMethod&quot;, 130); &#x2F;&#x2F; 反射调用动态函数 Method publicfunc_method &#x3D; StuClass.getDeclaredMethod(&quot;publicfunc&quot;, String.class, int.class); &#x2F;&#x2F; public Student(String name, String id) &#123;&#x2F;&#x2F; this.name &#x3D; name;&#x2F;&#x2F; this.id &#x3D; id;&#x2F;&#x2F; &#125; &#x2F;&#x2F; public Student(String name, String id) 调用构造函数获得对象 反射主动调用 Constructor StuCon &#x3D; StuClass.getDeclaredConstructor(String.class, String.class); Object StuObj &#x3D; StuCon.newInstance(&quot;InstanceByXposed&quot;, &quot;300&quot;); publicfunc_method.invoke(StuObj, &quot;publicfuncInvokedByXposed&quot;, 100);&#x2F;&#x2F; public String publicfunc(String arg1, int arg2) &#123;&#x2F;&#x2F; String result &#x3D; privatefunc(&quot;privatefunc&quot;, 300);&#x2F;&#x2F; Log.i(&quot;Xposed&quot;,&quot;publicfunc is called!&quot;+&quot;---&quot;+arg1+&quot;---&quot;+arg2);&#x2F;&#x2F; person tmp&#x3D;new person();&#x2F;&#x2F; String tmpresult&#x3D;tmp.getpersonname(&quot;person&quot;);&#x2F;&#x2F; return arg1 + &quot;---&quot; + arg2 + &quot;---&quot; + result+&quot;---&quot;+tmpresult;&#x2F;&#x2F; &#125;&#x2F;&#x2F; Method privatefunc_method &#x3D; StuClass.getDeclaredMethod(&quot;privatefunc&quot;, String.class, int.class); privatefunc_method.setAccessible(true); String privatefunc_result &#x3D; (String) privatefunc_method.invoke(StuObj, &quot;privatefuncInvokedByXposed&quot;, 200); XposedBridge.log(&quot;privatefunc activeInvokeByXposed--&gt;&quot; + privatefunc_result);&#x2F;&#x2F; private String privatefunc(String arg1, int arg2) &#123;&#x2F;&#x2F; Log.i(&quot;Xposed&quot;,&quot;privatefunc is called!&quot;+&quot;---&quot;+arg1+&quot;---&quot;+arg2);&#x2F;&#x2F; return arg1 + &quot;---&quot; + arg2;&#x2F;&#x2F; &#125; &#x2F;&#x2F;Student cstudent &#x3D; new Student(&quot;xiaohua&quot;, &quot;2020&quot;); &#x2F;&#x2F; hook 构造函数 XposedHelpers.findAndHookConstructor(StuClass, String.class, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); XposedBridge.log(&quot;Student(String,String) is called beforeHookedMethod&quot;); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;Student(String,String) is called afterHookedMethod&quot;); Object cstudent&#x3D;param.thisObject; XposedHelpers.callMethod(cstudent,&quot;publicfunc&quot;,&quot;publicfunc is called XposedHelpers.findAndHookConstructor&quot;,666); XposedHelpers.callMethod(cstudent,&quot;privatefunc&quot;,&quot;privatefunc is called XposedHelpers.findAndHookConstructor&quot;,888); &#125; &#125;);&#x2F;&#x2F; public String getNickname() &#123;&#x2F;&#x2F; return nickname;&#x2F;&#x2F; &#125; &#x2F;&#x2F; hook 普通函数 XposedHelpers.findAndHookMethod(StuClass, &quot;getNickname&quot;, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Object obj&#x3D;param.thisObject; XposedHelpers.callMethod(obj,&quot;publicfunc&quot;,&quot;beforeHookedMethod publicfunc is called XposedHelpers.callMethod&quot;,444); XposedHelpers.callMethod(obj,&quot;privatefunc&quot;,&quot;beforeHookedMethod privatefunc is called XposedHelpers.callMethod&quot;,333); XposedBridge.log(&quot;getNickname is called beforeHookedMethod-&gt;&quot;+obj); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); Object obj&#x3D;param.thisObject; XposedHelpers.callMethod(obj,&quot;publicfunc&quot;,&quot;afterHookedMethod publicfunc is called XposedHelpers.callMethod&quot;,222); XposedHelpers.callMethod(obj,&quot;privatefunc&quot;,&quot;afterHookedMethod privatefunc is called XposedHelpers.callMethod&quot;,111); XposedBridge.log(&quot;getNickname is called afterHookedMethod-&gt;&quot;+param.thisObject); &#125; &#125;); &#125; &#125;&#125; 加壳app处理类不在classLoader中，在自定义的Application中的attachBaseContext和onCreate中完成dex的解密和classLoader修正。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227public class HookJava implements IXposedHookLoadPackage &#123; public static Field getClassField(ClassLoader classloader, String class_name, String filedName) &#123; try &#123; Class obj_class &#x3D; classloader.loadClass(class_name);&#x2F;&#x2F;Class.forName(class_name); Field field &#x3D; obj_class.getDeclaredField(filedName); field.setAccessible(true); return field; &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static Object getClassFieldObject(ClassLoader classloader, String class_name, Object obj, String filedName) &#123; try &#123; Class obj_class &#x3D; classloader.loadClass(class_name);&#x2F;&#x2F;Class.forName(class_name); Field field &#x3D; obj_class.getDeclaredField(filedName); field.setAccessible(true); Object result &#x3D; null; result &#x3D; field.get(obj); return result; &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static Object invokeStaticMethod(String class_name, String method_name, Class[] pareTyple, Object[] pareVaules) &#123; try &#123; Class obj_class &#x3D; Class.forName(class_name); Method method &#x3D; obj_class.getMethod(method_name, pareTyple); return method.invoke(null, pareVaules); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static Object getFieldOjbect(String class_name, Object obj, String filedName) &#123; try &#123; Class obj_class &#x3D; Class.forName(class_name); Field field &#x3D; obj_class.getDeclaredField(filedName); field.setAccessible(true); return field.get(obj); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NullPointerException e) &#123; e.printStackTrace(); &#125; return null; &#125; &#x2F;&#x2F; 获取当前classLoader public static ClassLoader getClassloader() &#123; ClassLoader resultClassloader &#x3D; null; Object currentActivityThread &#x3D; invokeStaticMethod( &quot;android.app.ActivityThread&quot;, &quot;currentActivityThread&quot;, new Class[]&#123;&#125;, new Object[]&#123;&#125;); Object mBoundApplication &#x3D; getFieldOjbect( &quot;android.app.ActivityThread&quot;, currentActivityThread, &quot;mBoundApplication&quot;); Application mInitialApplication &#x3D; (Application) getFieldOjbect(&quot;android.app.ActivityThread&quot;, currentActivityThread, &quot;mInitialApplication&quot;); Object loadedApkInfo &#x3D; getFieldOjbect( &quot;android.app.ActivityThread$AppBindData&quot;, mBoundApplication, &quot;info&quot;); Application mApplication &#x3D; (Application) getFieldOjbect(&quot;android.app.LoadedApk&quot;, loadedApkInfo, &quot;mApplication&quot;); resultClassloader &#x3D; mApplication.getClassLoader(); return resultClassloader; &#125; &#x2F;&#x2F; 打印classLoader中所有的类 public void GetClassLoaderClasslist(ClassLoader classLoader) &#123; &#x2F;&#x2F;private final DexPathList pathList; XposedBridge.log(&quot;start dealwith classloader:&quot; + classLoader); Object pathListObj &#x3D; XposedHelpers.getObjectField(classLoader, &quot;pathList&quot;); &#x2F;&#x2F;private final Element[] dexElements; Object[] dexElementsObj &#x3D; (Object[]) XposedHelpers.getObjectField(pathListObj, &quot;dexElements&quot;); for (Object i : dexElementsObj) &#123; &#x2F;&#x2F;private final DexFile dexFile; Object dexFileObj &#x3D; XposedHelpers.getObjectField(i, &quot;dexFile&quot;); &#x2F;&#x2F;private Object mCookie; Object mCookieObj &#x3D; XposedHelpers.getObjectField(dexFileObj, &quot;mCookie&quot;); &#x2F;&#x2F;private static native String[] getClassNameList(Object cookie); &#x2F;&#x2F; public static java.lang.Object callStaticMethod(java.lang.Class&lt;?&gt; clazz, java.lang.String methodName, java.lang.Object... args) &#123; &#x2F;* compiled code *&#x2F; &#125; Class DexFileClass &#x3D; XposedHelpers.findClass(&quot;dalvik.system.DexFile&quot;, classLoader); String[] classlist &#x3D; (String[]) XposedHelpers.callStaticMethod(DexFileClass, &quot;getClassNameList&quot;, mCookieObj); for (String classname : classlist) &#123; XposedBridge.log(dexFileObj + &quot;---&quot; + classname); &#125; &#125; XposedBridge.log(&quot;end dealwith classloader:&quot; + classLoader); &#125; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; Log.i(&quot;Xposed01&quot;, loadPackageParam.packageName); XposedBridge.log(&quot;HookJava-&gt;app packagename&quot; + loadPackageParam.packageName); if (loadPackageParam.packageName.equals(&quot;com.kanxue.xposedhook01&quot;)) &#123; XposedBridge.log(&quot;kanxue &quot; + loadPackageParam.packageName); ClassLoader classLoader &#x3D; loadPackageParam.classLoader; XposedBridge.log(&quot;loadPackageParam.classLoader-&gt;&quot; + classLoader);&#x2F;* 01-09 05:26:25.678 29011-29011&#x2F;? I&#x2F;Xposed: loadPackageParam.classLoader-&gt;dalvik.system.PathClassLoader[DexPathList[[zip file &quot;&#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;base.apk&quot;],nativeLibraryDirectories&#x3D;[&#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;lib&#x2F;arm, &#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib]]] 01-09 05:26:25.679 29011-29011&#x2F;? I&#x2F;Xposed: start dealwith classloader:dalvik.system.PathClassLoader[DexPathList[[zip file &quot;&#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;base.apk&quot;],nativeLibraryDirectories&#x3D;[&#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;lib&#x2F;arm, &#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib]]] 01-09 05:26:25.681 29011-29011&#x2F;? I&#x2F;Xposed: &#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;base.apk---com.qihoo.util.Configuration 01-09 05:26:25.681 29011-29011&#x2F;? I&#x2F;Xposed: &#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;base.apk---com.qihoo.util.DtcLoader 01-09 05:26:25.681 29011-29011&#x2F;? I&#x2F;Xposed: &#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;base.apk---com.qihoo.util.QHDialog 01-09 05:26:25.681 29011-29011&#x2F;? I&#x2F;Xposed: &#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;base.apk---com.qihoo.util.ᵢˋ 01-09 05:26:25.681 29011-29011&#x2F;? I&#x2F;Xposed: &#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;base.apk---com.qihoo.util.ᵢˎ 01-09 05:26:25.681 29011-29011&#x2F;? I&#x2F;Xposed: &#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;base.apk---com.qihoo.util.ᵢˏ 01-09 05:26:25.681 29011-29011&#x2F;? I&#x2F;Xposed: &#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;base.apk---com.stub.StubApp 01-09 05:26:25.681 29011-29011&#x2F;? I&#x2F;Xposed: end dealwith classloader:dalvik.system.PathClassLoader[DexPathList[[zip file &quot;&#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;base.apk&quot;],nativeLibraryDirectories&#x3D;[&#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;lib&#x2F;arm, &#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib]]]*&#x2F; GetClassLoaderClasslist(classLoader); ClassLoader parent &#x3D; classLoader.getParent(); &#x2F;&#x2F; 将当前classLoader双亲委派模型打印 while (parent !&#x3D; null) &#123; XposedBridge.log(&quot;parent-&gt;&quot; + parent); if (parent.toString().contains(&quot;BootClassLoader&quot;)) &#123; &#125; else &#123; GetClassLoaderClasslist(parent); &#125; parent &#x3D; parent.getParent(); &#125;&#x2F;** 01-09 05:05:34.284 24462-24462&#x2F;? I&#x2F;Xposed: loadPackageParam.classLoader-&gt;dalvik.system.PathClassLoader[DexPathList[[zip file &quot;&#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;base.apk&quot;],nativeLibraryDirectories&#x3D;[&#x2F;data&#x2F;app&#x2F;com.kanxue.xposedhook01-1&#x2F;lib&#x2F;arm, &#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib]]]01-09 05:05:34.284 24462-24462&#x2F;? I&#x2F;Xposed: parent-&gt;dalvik.system.PathClassLoader[DexPathList[[dex file &quot;&#x2F;data&#x2F;dalvik-cache&#x2F;xposed_XResourcesSuperClass.dex&quot;, dex file &quot;&#x2F;data&#x2F;dalvik-cache&#x2F;xposed_XTypedArraySuperClass.dex&quot;],nativeLibraryDirectories&#x3D;[&#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib]]]01-09 05:05:34.284 24462-24462&#x2F;? I&#x2F;Xposed: parent-&gt;java.lang.BootClassLoader@6c4cdad* *&#x2F; &#x2F;&#x2F; hook壳的onCreate Class StubAppClass&#x3D;XposedHelpers.findClass(&quot;com.stub.StubApp&quot;,loadPackageParam.classLoader); &#x2F;&#x2F; 获取该类所有函数 Method[] methods&#x3D;StubAppClass.getDeclaredMethods(); for(Method i:methods)&#123; XposedBridge.log(&quot;com.stub.StubApp-&gt;&quot;+i); &#125; XposedHelpers.findAndHookMethod(&quot;com.stub.StubApp&quot;, loadPackageParam.classLoader, &quot;onCreate&quot;, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); XposedBridge.log(&quot;com.stub.StubApp-&gt;onCreate beforeHookedMethod&quot;); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;com.stub.StubApp-&gt;onCreate afterHookedMethod&quot;); ClassLoader finalClassLoader&#x3D;getClassloader(); XposedBridge.log(&quot;finalClassLoader-&gt;&quot; + finalClassLoader); GetClassLoaderClasslist(finalClassLoader); XposedHelpers.findAndHookMethod(&quot;com.kanxue.xposedhook01.Student&quot;, finalClassLoader, &quot;privatefunc&quot;, String.class, int.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Object[] objectarray &#x3D; param.args; String arg0 &#x3D; (String) objectarray[0]; int arg1 &#x3D; (int) objectarray[1]; XposedBridge.log(&quot;beforeHookedMethod11 privatefunc-&gt;arg0:&quot; + arg0 + &quot;---arg1:&quot; + arg1); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); String result &#x3D; (String) param.getResult(); XposedBridge.log(&quot;afterHookedMethod11 privatefunc-&gt;result:&quot; + result); &#125; &#125;); Class personClass &#x3D; XposedHelpers.findClass(&quot;com.kanxue.xposedhook01.Student$person&quot;, finalClassLoader); XposedHelpers.findAndHookMethod(personClass, &quot;getpersonname&quot;, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); XposedBridge.log(&quot;beforeHookedMethod getpersonname-&gt;&quot; + param.args[0]); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;afterHookedMethod getpersonname-&gt;&quot; + param.getResult()); &#125; &#125;); &#125; &#125;); &#125; &#125;&#125; Lebo 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Overridepublic void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; Log.i(&quot;Xposed01&quot;, loadPackageParam.packageName); XposedBridge.log(&quot;HookLebo-&gt;app packagename&quot; + loadPackageParam.packageName); if (loadPackageParam.packageName.equals(&quot;com.f0208.lebo&quot;)) &#123; XposedBridge.log(&quot;kanxue &quot; + loadPackageParam.packageName); Class StubAppClass&#x3D;XposedHelpers.findClass(&quot;com.f0208.lebo.MyWrapperProxyApplication&quot;,loadPackageParam.classLoader); Method[] methods&#x3D;StubAppClass.getDeclaredMethods(); for(Method i:methods)&#123; XposedBridge.log(&quot;com.f0208.lebo.MyWrapperProxyApplication-&gt;&quot;+i); &#125; XposedHelpers.findAndHookMethod(&quot;com.f0208.lebo.MyWrapperProxyApplication&quot;, loadPackageParam.classLoader, &quot;onCreate&quot;, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); XposedBridge.log(&quot;com.f0208.lebo.MyWrapperProxyApplication-&gt;onCreate beforeHookedMethod&quot;); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;com.f0208.lebo.MyWrapperProxyApplication-&gt;onCreate afterHookedMethod&quot;); ClassLoader finalClassLoader&#x3D;getClassloader(); XposedBridge.log(&quot;finalClassLoader-&gt;&quot; + finalClassLoader); XposedHelpers.findAndHookMethod(&quot;com.zw.lebo.MainActivity&quot;, finalClassLoader, &quot;onCreate&quot;, Bundle.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); XposedBridge.log(&quot;beforeHookedMethod com.zw.lebo.MainActivity.onCreate&quot;); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;afterHookedMethod com.zw.lebo.MainActivity.onCreate&quot;); &#125; &#125;); &#125; &#125;); &#125;&#125; SO函数处理32位hookXposed01动态加载dex 1234567891011121314151617181920212223242526272829 @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; Log.i(&quot;XposedHookSo&quot;, loadPackageParam.packageName); XposedBridge.log(&quot;XposedHookSo-&gt;app packagename&quot; + loadPackageParam.packageName); if (loadPackageParam.packageName.equals(&quot;com.kanxue.xposedhookso&quot;)) &#123; XposedBridge.log(&quot;XposedHookSo &quot; + loadPackageParam.packageName);&#x2F;&#x2F; 6.0 XposedHelpers.findAndHookMethod(&quot;java.lang.Runtime&quot;, loadPackageParam.classLoader, &quot;loadLibrary&quot;, String.class,ClassLoader.class, new XC_MethodHook() &#123;&#x2F;&#x2F; 7.0 XposedHelpers.findAndHookMethod(&quot;java.lang.Runtime&quot;, loadPackageParam.classLoader, &quot;loadLibrary&quot;, ClassLoader.class, String.class, new XC_MethodHook() &#123; XposedHelpers.findAndHookMethod(&quot;java.lang.Runtime&quot;, loadPackageParam.classLoader, &quot;loadLibrary0&quot;, String.class,ClassLoader.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); &#x2F;&#x2F; 7.0 String soname&#x3D; (String) param.args[1]; String soname&#x3D; (String) param.args[0]; &#x2F;&#x2F; 6.0 XposedBridge.log(&quot;beforeHookedMethod Runtime.load(&quot;+soname+&quot;,&quot;+param.args[1]+&quot;)&quot;); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); &#x2F;&#x2F; 7.0 String soname&#x3D; (String) param.args[0]; String soname&#x3D; (String) param.args[0]; &#x2F;&#x2F; 6.0 XposedBridge.log(&quot;afterHookedMethod Runtime.load(&quot;+soname+&quot;)&quot;); if(soname.contains(&quot;native-lib&quot;))&#123; System.load(&quot;&#x2F;data&#x2F;data&#x2F;com.kanxue.xposedhookso&#x2F;files&#x2F;hookso.so&quot;); &#125; &#125; &#125;); &#125; &#125; git clone https://github.com/ele7enxxh/Android-Inline-Hook.git inline的hook库面向32位，复制include，inlineHook.c，relocate.c，relocate.h到cpp下，并在CMakeLists.txt中引入 1234567891011add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). inlineHook.c relocate.c native-lib.cpp) native-lib.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android&#x2F;log.h&gt;#include &lt;dlfcn.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;extern &quot;C&quot; &#123;#include &quot;include&#x2F;inlineHook.h&quot;&#125;void *(*old_strstr)(char *, char *) &#x3D; nullptr;void *new_strstr(char *arg0, char *arg1) &#123; __android_log_print(4, &quot;hookso&quot;, &quot;strstr is called,arg1:%s,arg2:%s&quot;, arg0, arg1); if (strcmp(arg1, &quot;hookso&quot;) &#x3D;&#x3D; 0) &#123; int a &#x3D; 1; return &amp;a; &#125; else &#123; void *result &#x3D; old_strstr(arg0, arg1); return result; &#125;;&#125;void starthooklibc() &#123; void *libchandle &#x3D; dlopen(&quot;libc.so&quot;, RTLD_NOW); void *strstr_addr &#x3D; dlsym(libchandle, &quot;strstr&quot;); if (registerInlineHook((uint32_t) strstr_addr, (uint32_t) new_strstr, (uint32_t **) &amp;old_strstr) !&#x3D; ELE7EN_OK) &#123; return; &#125; if (inlineHook((uint32_t) strstr_addr) &#x3D;&#x3D; ELE7EN_OK) &#123; __android_log_print(4, &quot;hookso&quot;, &quot;hook libc.so-&gt;strstr success!&quot;); &#x2F;&#x2F;return -1; &#125;&#125;extern &quot;C&quot; void _init(void) &#123; __android_log_print(4,&quot;kanxuetest&quot;,&quot;go into _init&quot;); starthooklibc();&#125;__attribute__ ((constructor(10), visibility (&quot;hidden&quot;))) void initarray_4(void) &#123; __android_log_print(4,&quot;kanxuetest&quot;,&quot;go into initarray_4&quot;);&#125;JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) &#123; JNIEnv *env &#x3D; nullptr; jint result &#x3D; -1; __android_log_print(4,&quot;kanxuetest&quot;,&quot;go into JNI_OnLoad&quot;); &#x2F;&#x2F;starthooklibc(); if ((vm)-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) !&#x3D; JNI_OK) &#123; printf(&quot;err!!&quot;); return JNI_ERR; &#125; return JNI_VERSION_1_6;&#125;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_kanxue_hookso_MainActivity_stringFromJNI( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; __android_log_print(4,&quot;kanxuetest&quot;,&quot;go into Java_com_kanxue_hookso_MainActivity_stringFromJNI&quot;); std::string hello &#x3D; &quot;Hello from C++&quot;; if(strstr(&quot;aaaaabbbbb&quot;,&quot;hookso&quot;)!&#x3D; nullptr)&#123; __android_log_print(4,&quot;kanxuetest&quot;,&quot;find hookso&quot;); &#125;else&#123; __android_log_print(4,&quot;kanxuetest&quot;,&quot;not find hookso&quot;); &#125; return env-&gt;NewStringUTF(hello.c_str());&#125; 编译生成的libnative-lib.so重命名为hookso.so放到手机/data/data/com.kanxue.xposedhookso/files下，给予权限，重新启动，打开Xposed01 app，完成调用libc的strstr函数的hook。 64位hookgit clone https://github.com/asLody/SandHook.git 将cpp中代码拷贝到XposeeHookSoBySandHook项目的cpp中 build.gradle 1234567externalNativeBuild &#123; cmake &#123; arguments &#39;-DBUILD_TESTING&#x3D;OFF&#39; cppFlags &quot;-frtti -fexceptions -Wpointer-arith&quot; abiFilters &#39;armeabi-v7a&#39;, &#39;arm64-v8a&#39; &#125;&#125; native-lib.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;jni.h&gt;#include &lt;string&gt;#include &quot;sandhook_native.h&quot;#include &quot;utils&#x2F;log.h&quot;#include &lt;android&#x2F;log.h&gt;#include &lt;unistd.h&gt;#include &lt;cassert&gt;#include &lt;cstdlib&gt;#include &quot;includes&#x2F;elf.h&quot;class instance;void *(*old_strstr)(char *, char *) &#x3D; nullptr;void *new_strstr(char *arg0, char *arg1) &#123; __android_log_print(4, &quot;hooksoarm64&quot;, &quot;strstr is called,arg1:%s,arg2:%s&quot;, arg0, arg1); if (strcmp(arg1, &quot;hookso&quot;) &#x3D;&#x3D; 0) &#123; int a &#x3D; 1; return &amp;a; &#125; else &#123; void *result &#x3D; old_strstr(arg0, arg1); return result; &#125;;&#125;void starthooklibc() &#123; if (sizeof(void *) &#x3D;&#x3D; 8) &#123; const char *libcpath &#x3D; &quot;&#x2F;system&#x2F;lib64&#x2F;libc.so&quot;; old_strstr &#x3D; reinterpret_cast&lt;void *(*)(char *, char *)&gt;(SandInlineHookSym(libcpath, &quot;strstr&quot;, reinterpret_cast&lt;void *&gt;(new_strstr))); &#125; else &#123; const char *libcpath &#x3D; &quot;&#x2F;system&#x2F;lib&#x2F;libc.so&quot;; old_strstr &#x3D; reinterpret_cast&lt;void *(*)(char *, char *)&gt;(SandInlineHookSym(libcpath, &quot;strstr&quot;, reinterpret_cast&lt;void *&gt;(new_strstr))); &#125;&#125;bool testhook(const char *content) &#123; if (strstr(content, &quot;hookso&quot;) !&#x3D; nullptr) &#123; __android_log_print(4, &quot;xposedhookso&quot;, &quot;find hookso&quot;); return true; &#125; else &#123; __android_log_print(4, &quot;xposedhookso&quot;, &quot;not find hookso&quot;); &#125; return false;&#125;int (*testhookfunctin)(const char *) &#x3D; nullptr;extern &quot;C&quot; void _init(void) &#123; LOGD(&quot;go into _init&quot;); &#x2F;&#x2F;starthooklibc();&#125;&#x2F;&#x2F; 比initarray中的方法早extern &quot;C&quot; jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) &#123; LOGD(&quot;go into JNI_OnLoad&quot;); starthooklibc(); return JNI_VERSION_1_6;&#125;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_kanxue_xposeehooksobysandhook_MainActivity_stringFromJNI( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; std::string hello &#x3D; &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str());&#125; 编译生成so拷贝到/data/data/com.kanxue.xposedhookso/files/hookso.so下并配置权限 主动调用XposeeHookSoBySandHook 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849bool testhook(const char *content) &#123; if (strstr(content, &quot;hookso&quot;) !&#x3D; nullptr) &#123; __android_log_print(4, &quot;xposedhookso&quot;, &quot;find hookso&quot;); return true; &#125; else &#123; __android_log_print(4, &quot;xposedhookso&quot;, &quot;not find hookso&quot;); &#125; return false;&#125;extern &quot;C&quot; jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) &#123; LOGD(&quot;go into JNI_OnLoad&quot;); &#x2F;&#x2F;starthooklibc(); activecalltesthook(); return JNI_VERSION_1_6;&#125;void activecalltesthook() &#123; typedef int (*testhook)(const char *a1); testhook testhookfunction &#x3D; nullptr; &#x2F;&#x2F;得到函数地址&#x2F;* extern &quot;C&quot; EXPORT void* SandGetModuleBase(const char* so);*&#x2F; void *libnativebase &#x3D; SandGetModuleBase(&quot;libnative-lib.so&quot;); &#x2F;&#x2F;thumb 0x8B4C是testhook的基地址偏移 if(sizeof(void*)&#x3D;&#x3D;4)&#123; &#x2F;&#x2F; 指针不能直接参与运算 32位 unsigned long tmpaddr &#x3D; (unsigned long) libnativebase + 0x8B4C + 1; void *testhookaddr &#x3D; reinterpret_cast&lt;void *&gt;(tmpaddr); testhookfunction &#x3D; reinterpret_cast&lt;testhook&gt;(testhookaddr); &#125;else&#123; &#x2F;&#x2F; 64位 unsigned long tmpaddr &#x3D; (unsigned long) libnativebase + 0xf67c; void *testhookaddr &#x3D; reinterpret_cast&lt;void *&gt;(tmpaddr); testhookfunction &#x3D; reinterpret_cast&lt;testhook&gt;(testhookaddr); LOGD(&quot;libnative-lib.so base:%p,testfuncaddr:%p&quot;,libnativebase,(void*)tmpaddr); &#125; int result1 &#x3D; testhookfunction(&quot;aaaaahookso&quot;); LOGD(&quot;testhookfunction(\\&quot;aaaaahookso\\&quot;); return:%d&quot;, result1); int result2 &#x3D; testhookfunction(&quot;aaaabbbbb&quot;); LOGD(&quot;testhookfunction(\\&quot;aaaabbbbb\\&quot;); return:%d&quot;, result2);&#125; 编译生成的libsandhook-native.so推送到/sdcard/32.so，重命名为hookso.so复制到/data/data/com.kabxue.xposedhookso/files下 进入xposed01项目中，定义XposedActiveCallSoFunction类 1234567891011121314151617181920212223242526272829 @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; Log.i(&quot;XposedHookSo&quot;, loadPackageParam.packageName); XposedBridge.log(&quot;XposedHookSo-&gt;app packagename&quot; + loadPackageParam.packageName); if (loadPackageParam.packageName.equals(&quot;com.kanxue.xposedhookso&quot;)) &#123; XposedBridge.log(&quot;XposedHookSo &quot; + loadPackageParam.packageName);&#x2F;&#x2F; 6.0 XposedHelpers.findAndHookMethod(&quot;java.lang.Runtime&quot;, loadPackageParam.classLoader, &quot;loadLibrary&quot;, String.class,ClassLoader.class, new XC_MethodHook() &#123;&#x2F;&#x2F; 7.0 XposedHelpers.findAndHookMethod(&quot;java.lang.Runtime&quot;, loadPackageParam.classLoader, &quot;loadLibrary&quot;, ClassLoader.class, String.class, new XC_MethodHook() &#123; XposedHelpers.findAndHookMethod(&quot;java.lang.Runtime&quot;, loadPackageParam.classLoader, &quot;loadLibrary0&quot;, String.class,ClassLoader.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); &#x2F;&#x2F; 7.0 String soname&#x3D; (String) param.args[1]; String soname&#x3D; (String) param.args[0]; &#x2F;&#x2F; 6.0 XposedBridge.log(&quot;beforeHookedMethod Runtime.load(&quot;+soname+&quot;,&quot;+param.args[1]+&quot;)&quot;); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); &#x2F;&#x2F; 7.0 String soname&#x3D; (String) param.args[0]; String soname&#x3D; (String) param.args[0]; &#x2F;&#x2F; 6.0 XposedBridge.log(&quot;afterHookedMethod Runtime.load(&quot;+soname+&quot;)&quot;); if(soname.contains(&quot;native-lib&quot;))&#123; System.load(&quot;&#x2F;data&#x2F;data&#x2F;com.kanxue.xposedhookso&#x2F;files&#x2F;hookso.so&quot;); &#125; &#125; &#125;); &#125; &#125; 指纹检测与定制反检测 Xposed插件管理-XposedInstaller Xposed对函数hook根本原理-java函数变native函数 Xposed大量api Xposed框架特定文件等 XposedChecker Xposed框架组成 XposedInstaller 完整的Android工程，编译生成apk，用于管理Xposed框架的插件 Xposed 对Zygote进程定制，能够实现对接下来任何一个app进程的hook android_art 用于支持对Java类函数hook而对ART源码进程的一系列定制 XposedBridge Xposed的java部分，可单独作为Android工程进行编译 XposedTools 用于编译和打包Xposed框架 简单定制 修改Xposed框架中所有关于Xposed相关的类，函数等指纹信息(比如关键字Xposed)，便可以绕过大多数Xposed框架指纹检测技术，其他的根据Xposed对Java函数hook的根本原理进行检测(如判断函数属性是否变为native),也可以在编写对应插件进行绕过。 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"xposed","slug":"xposed","permalink":"http://onejane.github.io/tags/xposed/"}]},{"title":"Frida逆向与利用自动化","slug":"Frida逆向与利用自动化","date":"2022-05-01T13:22:20.000Z","updated":"2022-10-12T15:51:19.629Z","comments":true,"path":"2022/05/01/Frida逆向与利用自动化/","link":"","permalink":"http://onejane.github.io/2022/05/01/Frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/","excerpt":"","text":"Kalikali里面时间老是不对，其实只是时区不对而已，一个命令就搞定： dpkg-reconfigure tzdata 然后选择Asia→Shanghai，然后重启即可。 KaliLinux默认不带中文 apt install xfonts-intl-chinese apt install ttf-wqy-microhei kali装中文输入法，参考https://blog.csdn.net/qq_42333641/article/details/89325576 apt install htop 动态查看当前活跃占用高的进程。 apt install jnettop 流量查看工具。 wifiadb qtscrcpy wifi群控 安装pyenv https://github.com/pyenv/pyenv-installer 12345678910111213141516171819202122sudo apt-get update; sudo apt-get install make build-essential libssl-dev zlib1g-dev \\libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \\libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-devcurl https:&#x2F;&#x2F;pyenv.run | bashproxychains curl -L https:&#x2F;&#x2F;github.com&#x2F;pyenv&#x2F;pyenv-installer&#x2F;raw&#x2F;master&#x2F;bin&#x2F;pyenv-installer | bash mkdir ~&#x2F;.pyenvproxychains git clone https:&#x2F;&#x2F;github.com&#x2F;pyenv&#x2F;pyenv.git ~&#x2F;.pyenvls .pyenv&#x2F;echo $HOMEecho &#39;export PYENV_ROOT&#x3D;&quot;$HOME&#x2F;.pyenv&quot;&#39; &gt;&gt; ~&#x2F;.bash_profileecho &#39;export PATH&#x3D;&quot;$PYENV_ROOT&#x2F;bin:$PATH&quot;&#39; &gt;&gt; ~&#x2F;.bash_profilels .pyenv&#x2F;bin&#x2F;source .bash_profilepyenvpyenv --version # 获取pyenv版本号echo -e &#39;if command -v pyenv 1&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1; then\\n eval &quot;$(pyenv init -)&quot;\\n fi&#39; &gt;&gt; ~&#x2F;.bashrc 添加&quot;pyenv init -&quot;到shellexec &quot;$SHELL&quot;pyenv install 3.8.0 安装vscode dpkg -i code_1.45.1-1589445602_amd64.deb 安装node 12apt updateapt install -y nodejs 刷机 1234567891011wget https:&#x2F;&#x2F;dl.google.com&#x2F;dl&#x2F;android&#x2F;aosp&#x2F;sailfish-opm1.171019.011-factory-56d15350.zip下载https:&#x2F;&#x2F;developer.android.com&#x2F;studio&#x2F;releases&#x2F;platform-toolsunzip platform-tools_r33.0.1-linux.zipcd platform-tools &amp;&amp; vim ~&#x2F;.bashrcexport PATH&#x3D;&quot;&#x2F;root&#x2F;platform-tools:$PATH&quot; 有了fastbootunzip sailfish-opm1.171019.011-factory-56d15350.zip关机键+音量减 启动到bootloader.&#x2F;flash-all.sh重启进入BootLoaderfastboot boot twrp-3.3.1-0-sailfish.img安装 magisk frida 1234567891011121314151617181920211. git clone https:&#x2F;&#x2F;github.com&#x2F;oleavr&#x2F;frida-agent-example.git2. cd frida-agent-example&#x2F;3. npm install4. 使用VSCode等IDE打开此工程，在agent下编写typescript，会有智能提示。5. npm run watch会监控代码修改自动编译生成js文件6. frida -U -f com.example.android --no-pause -l _agent.js想要使用基于特定frida版本的objection，只需先安装好特定版本的frida和frida-tools（星球里搜“特定版本”有对应关系），再去objection的release里找那个日期之后一点点的版本。比如以frida 12.8.0版本举例：pip install frida&#x3D;&#x3D;12.8.0pip install frida-tools&#x3D;&#x3D;5.3.0pip install objection&#x3D;&#x3D;1.8.4按照这个顺序，在装objection的时候，就会直接Requirement already satisfied，不会再去下载新的frida来安装了。function main()&#123; Java.perform(function()&#123; console.log(&quot;Inside Frida Java Perform !&quot;) &#125;)&#125;setImmediate(main)模拟器frida-server012.9.4-android-x86.xz 1234567891011121314151617181920212223242526272829303132333435android hooking list activitiesandroid intent launch_activity com.android.settings.DisplaySettings 启动activityandroid hooking list servicesmemory list modules 进程中加载的somemory list exports libssl.so 查看导出函数地址android heap search instances com.android.setting.DisplaySettings --fresh 查看类是否被实例化android heap execute 0x2286 getPreferenceScreenResId 主动调用 # android heap evaluate 0x2526 也可以在找到的实例上直接编写js脚本 (The handle at &#96;0x2526&#96; will be available as the &#96;clazz&#96; variable.)console.log(&quot;evaluate result:&quot;+clazz.getPreferenceScreenResId()) JavaScript capture complete. Evaluating...Handle 0x2526 is to class com.android.settings.DisplaySettingsevaluate result:2132082764android hooking search classes display 搜索相关类android hooking search methods display 搜索相关方法 android hooking list class_methods sum.util.locale.LocaleUtils 查看类所有方法android hooking watch class_method android.bluetooth.BluetoothDevice.equals --dump-args --dump-backtrace --dump-return android hooking watch class java.io.File.$init proxychains git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;Wallbreaker.gitplugin load &#x2F;root&#x2F;Wallbreakerplugin wallbreaker classdump --fullname android.bluetooth.BluetoothDeviceplugin wallbreaker objectdump --fullname 0x12aqplugin wallbreaker objectsearch android.view.View$ListenerInfo 搜索实例proxychains git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;FRIDA-DEXDump.gitplugin load &#x2F;root&#x2F;FRIDA-Dexdumpplugin dexdump dump 脱壳objection无法hook nativeobjection -g packageName explore --startup-command &#39;android hooking watch xxx&#39; 如果找不到进程就去spawn启动，看来是自带spawn 实用FRIDA进阶：内存漫游、hook anywhere、抓包 jadx-gui-1.3.5-no-jre-win.exe 反编译软件 java -jar abe-all.jar unpack 1.ab 1.tar 其中abe.jar 安卓备份文件 12wget https:&#x2F;&#x2F;redirector.gvt1.com&#x2F;edgedl&#x2F;android&#x2F;studio&#x2F;ide-zips&#x2F;2021.1.1.23&#x2F;android-studio-2021.1.1.23-linux.tar.gz.&#x2F;bin&#x2F;studio.sh frida -U com.example.lesson -l lesson.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function main()&#123; Java.perform(function()&#123; &#x2F;* &#x2F;&#x2F; 重载 Java.use(&quot;com.example.lesson4one.MainActivity&quot;).fun.overload(&#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(arg1,arg2)&#123; var result &#x3D; this.fun(arg1,arg2); &#x2F;&#x2F; 打印调用栈 console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(&quot;arg1,arg2,result&quot;,arg1,arg2,result) return 800; &#125; Java.use(&quot;com.example.lesson4one.MainActivity&quot;).fun.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (arg1 )&#123; var result &#x3D; this.fun(Java.use(&#39;java.lang.String&#39;).$new(&quot;NIHAOJAVA&quot;)); console.log(&quot;arg1,result&quot;,arg1,result) return Java.use(&#39;java.lang.String&#39;).$new(&quot;NIHAOJS&quot;); &#125; &#x2F;&#x2F; 主动调用动态函数 Java.choose(&quot;com.example.lesson4one.MainActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance :&quot;,instance) console.log(&quot;found instance :&quot;,instance.secret()) &#125;,onComplete:function()&#123;&#125; &#125;) &#x2F;&#x2F; 主动调用静态函数 var result &#x3D; Java.use(&quot;com.example.lesson4one.MainActivity&quot;).secret2(); console.log(result); *&#x2F; Java.use(&quot;net.sqlcipher.database.SQLiteOpenHelper&quot;).getWritableDatabase.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (x)&#123; var result &#x3D; this.getWritableDatabase(x); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(&quot;xString,result&quot;,x,result); return result; &#125; Java.use(&quot;net.sqlcipher.database.SQLiteOpenHelper&quot;).getWritableDatabase.overload(&#39;[C&#39;).implementation &#x3D; function (x)&#123; var result &#x3D; this.getWritableDatabase(x); console.log(&quot;xCharSe,result&quot;,x,result); return result; &#125; &#125;)&#125;setImmediate(main)function ()&#123; Java.perform(function()&#123; Java.choose(&quot;com.example.yaphetshan.tencentwelcome.MainActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found insttance &quot;,instance); console.log(&quot;invoke instance.a &quot;,instance.a()); &#125;,onComplete:function()&#123;console.log(&quot;search completed !&quot;)&#125; &#125;) &#125;)&#125;setTimeout(invoke,2000) Fridanpm i -g @types/frida-gum 安装vs的frida自动提示 frida_example_1.0frida -U -f com.frida.example -l hook.js –no-pause 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109function main() &#123; Java.perform(function () &#123; Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;r0gson.dex&quot;).load(); const gson &#x3D; Java.use(&#39;com.r0ysue.gson.Gson&#39;); &#x2F;&#x2F;console.log(gson.$new().toJson(xxx)); &#x2F;* &#x2F;&#x2F; 字符串 Java.use(&quot;java.lang.Character&quot;).toString.overload(&#39;char&#39;).implementation &#x3D; function(x)&#123; var result &#x3D; this.toString(x); console.log(&quot;x,result&quot;,x,result); return &quot;对象数组&quot;; &#125; &#x2F;&#x2F; 字符数组 Java.use(&quot;java.util.Arrays&quot;).toString.overload(&#39;[C&#39;).implementation &#x3D; function (x)&#123; var charArray &#x3D; Java.array(&#39;char&#39;, [ &#39;一&#39;,&#39;去&#39;,&#39;二&#39;,&#39;三&#39;,&#39;里&#39; ]); var result &#x3D; this.toString(charArray); &#x2F;&#x2F; console.log(&quot;x,result&quot;,JSON.stringify(x),result); console.log(&quot;x,result&quot;,gson.$new().toJson(charArray),result); return Java.use(&#39;java.lang.String&#39;).$new(Java.array(&#39;char&#39;,[&#39;烟&#39;,&#39;村&#39;,&#39;四&#39;,&#39;五&#39;,&#39;家&#39;])); &#125; &#x2F;&#x2F; 字节数组 Java.use(&quot;java.util.Arrays&quot;).toString.overload(&#39;[B&#39;).implementation &#x3D; function (x)&#123; var result &#x3D; this.toString(x); &#x2F;&#x2F;console.log(&quot;x,result&quot;,gson.$new().toJson(x),result); console.log(&quot;x,result&quot;,x,result); return result; &#125; &#x2F;&#x2F; 类型转换 父-&gt;子 var Waterhandle &#x3D; null; Java.choose(&quot;com.r0ysue.a0526printout.Water&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance:&quot;,instance); console.log(&quot;water instance call still:&quot;,instance.still(instance)); Waterhandle &#x3D; instance; &#125;,onComplete:function()&#123;console.log(&quot;search completed!&quot;)&#125; &#125;) var JuiceHandle &#x3D; Java.cast(Waterhandle,Java.use(&quot;com.r0ysue.a0526printout.Juice&quot;)); console.log(&quot;Juice fillEnergy method :&quot;,JuiceHandle.fillEnergy()); &#x2F;&#x2F; 类型转换 子-&gt;父 var JuiceHandle &#x3D; null ; Java.choose(&quot;com.r0ysue.a0526printout.Juice&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance :&quot;,instance); console.log(&quot;filling energy,&quot;,instance.fillEnergy()); JuiceHandle&#x3D; instance; &#125;,onComplete:function()&#123;&quot;Search Completed!&quot;&#125; &#125;) var WaterHandle &#x3D; Java.cast(JuiceHandle ,Java.use(&quot;com.r0ysue.a0526printout.Water&quot;)); console.log(&quot;Water invoke still &quot;, WaterHandle.still(WaterHandle)); &#x2F;&#x2F; 注册一个接口类 var beer &#x3D; Java.registerClass(&#123; name: &#39;com.r0ysue.a0526printout.beer&#39;, implements: [Java.use(&#39;com.r0ysue.a0526printout.liquid&#39;)], methods: &#123; flow: function () &#123; console.log(&quot;look I&#96;m beer!&quot;); return &quot;taste good!&quot;; &#125; &#125; &#125;); console.log(&quot;beer.flow:&quot;,beer.$new().flow()); *&#x2F; &#x2F;&#x2F; 主动调用枚举实例方法 Java.choose(&quot;com.r0ysue.a0526printout.Signal&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance:&quot;,instance) console.log(&quot;invoke getDeclaringClass&quot;,instance.getDeclaringClass()) &#125;,onComplete:function()&#123;console.log(&quot;Search Completed!&quot;)&#125; &#125;) &#125;)&#125;&#x2F;&#x2F;setImmediate(main,2000)function hashmap888()&#123; Java.perform(function()&#123; &#x2F;* &#x2F;&#x2F; 主动调用打印map Java.choose(&quot;java.util.HashMap&quot;,&#123; onMatch:function(instance)&#123; if(instance.toString().indexOf(&quot;ISBN&quot;)!&#x3D;-1)&#123; console.log(&quot;found HashMap&quot;,instance); console.log(&quot;HashMap toString:&quot;,instance.toString()); &#125; &#125;,onComplete:function()&#123;console.log(&quot;Search Completed!&quot;)&#125; &#125;) *&#x2F; &#x2F;&#x2F; hook map方法 Java.use(&quot;java.util.HashMap&quot;).put.implementation &#x3D; function(x,y)&#123; var result &#x3D; this.put(x,y); console.log(&quot;x,y,result&quot;,x,y,result) return result; &#125; &#125;)&#125;setImmediate(hashmap888); Non-ASCII有一些不可视, 所以可以先编码打印出来, 再用编码后的字符串去 hook. 123456789101112131415161718192021int ֏(int x) &#123; return x + 100;&#125;Java.perform( function x() &#123; var targetClass &#x3D; &quot;com.example.hooktest.MainActivity&quot;; var hookCls &#x3D; Java.use(targetClass); var methods &#x3D; hookCls.class.getDeclaredMethods(); for (var i in methods) &#123; console.log(methods[i].toString()); console.log(encodeURIComponent(methods[i].toString().replace(&#x2F;^.*?\\.([^\\s\\.\\(\\)]+)\\(.*?$&#x2F;, &quot;$1&quot;))); &#125; hookCls[decodeURIComponent(&quot;%D6%8F&quot;)] .implementation &#x3D; function (x) &#123; console.log(&quot;original call: fun(&quot; + x + &quot;)&quot;); var result &#x3D; this[decodeURIComponent(&quot;%D6%8F&quot;)](900); return result; &#125; &#125;) 六层锁机案例 objection -g com.example.androiddemo explore 1234567891011121314151617function main()&#123; Java.perform(function()&#123; &#x2F;&#x2F; 拿到result放入密码框即可 hook LoginActivity.a &#x2F;&#x2F; hook函数 打印入参及调用原返回值 &#x2F;&#x2F; input text &quot;R4jSLLLLLLLLLLOrLE7&#x2F;5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL&#x3D;&quot; 自动输入文本 Java.use(&quot;com.example.androiddemo.Activity.LoginActivity&quot;).a.overload(&#39;java.lang.String&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function(x,y)&#123; var result &#x3D; this.a(x,y); console.log(&quot;x,y,result&quot;,x,y,result); return result; &#125; &#x2F;&#x2F; hook 修改返回值,没有调用原来的函数，直接返回值 Java.use(&quot;com.example.androiddemo.Activity.FridaActivity1&quot;).a.implementation &#x3D; function (x)&#123; console.log(&quot;first challenge 1&quot;) return &quot;R4jSLLLLLLLLLLOrLE7&#x2F;5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL&#x3D;&quot; ; &#125; &#125;)&#125; 12345678910111213function second()&#123; Java.perform(function()&#123; &#x2F;&#x2F; 静态主动调用 Java.use(&quot;com.example.androiddemo.Activity.FridaActivity2&quot;).setStatic_bool_var(); &#x2F;&#x2F; 非静态主动调用 Java.choose(&quot;com.example.androiddemo.Activity.FridaActivity2&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance :&quot;,instance); instance.setBool_var() &#125;,onComplete:function()&#123;&#125; &#125;) &#125;)&#125; 123456789101112131415function third()&#123; Java.perform(function()&#123; &#x2F;&#x2F; hook设置成员变量的值 Java.use(&quot;com.example.androiddemo.Activity.FridaActivity3&quot;).static_bool_var.value &#x3D; true ; Java.choose(&quot;com.example.androiddemo.Activity.FridaActivity3&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance :&quot;,instance); &#x2F;&#x2F;设置非静态成员变量的值 instance.bool_var.value &#x3D; true ; &#x2F;&#x2F;设置有相同函数名的成员变量的值 same_name_bool_var instance._same_name_bool_var.value &#x3D; true ; &#125;,onComplete:function()&#123;&#125; &#125;) &#125;)&#125; 12345678910111213141516171819202122232425262728function forth()&#123; &#x2F;&#x2F;hook内部类 private static class InnerClasses Java.perform(function()&#123; Java.use(&quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot;).check1.implementation &#x3D; function()&#123;return true&#125;; Java.use(&quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot;).check2.implementation &#x3D; function()&#123;return true&#125;; Java.use(&quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot;).check3.implementation &#x3D; function()&#123;return true&#125;; Java.use(&quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot;).check4.implementation &#x3D; function()&#123;return true&#125;; Java.use(&quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot;).check5.implementation &#x3D; function()&#123;return true&#125;; Java.use(&quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot;).check6.implementation &#x3D; function()&#123;return true&#125;; &#125;)&#125;function forth2()&#123; &#x2F;&#x2F; 反射获取所有内部类的方法hook设置返回值 hook 类的多个函数 Java.perform(function()&#123; var class_name &#x3D; &quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot; ; var InnerClass &#x3D; Java.use(class_name); var all_methods &#x3D; InnerClass.class.getDeclaredMethods(); &#x2F;&#x2F;console.log(all_methods); for(var i &#x3D; 0;i&lt;all_methods.length;i++)&#123; var method &#x3D; all_methods[i]; &#x2F;&#x2F;console.log(method.toString()); var substring &#x3D; method.toString().substr(method.toString().indexOf(class_name)+class_name.length+1); var finalMethodString &#x3D; substring.substr(0,substring.indexOf(&quot;(&quot;)); console.log(finalMethodString); InnerClass[finalMethodString].implementation &#x3D; function()&#123;return true&#125;; &#125; &#125;)&#125; 123456789101112131415161718192021222324252627function fifth()&#123; &#x2F;&#x2F; hook 动态dex中的方法 Java.perform(function()&#123; Java.choose(&quot;com.example.androiddemo.Activity.FridaActivity5&quot;,&#123; onMatch:function(instance)&#123; &#x2F;&#x2F; 拿到getDynamicDexCheck返回的类的className是DynamicCheck console.log(&quot;found instance getDynamicDexCheck :&quot;,instance.getDynamicDexCheck().$className); &#125;,onComplete:function()&#123;console.log(&quot;search complete!&quot;)&#125; &#125;) &#x2F;&#x2F; 枚举所有classloader Java.enumerateClassLoaders(&#123; onMatch:function(loader)&#123; try &#123; &#x2F;&#x2F; 切换classloader if(loader.findClass(&quot;com.example.androiddemo.Dynamic.DynamicCheck&quot;))&#123; console.log(&quot;Succefully found loader!&quot;,loader); Java.classFactory.loader &#x3D; loader; &#125; &#125; catch (error) &#123; console.log(&quot;found error &quot;+error) &#125; &#125;,onComplete:function()&#123;&quot;enum completed!&quot;&#125; &#125;) Java.use(&quot;com.example.androiddemo.Dynamic.DynamicCheck&quot;).check.implementation &#x3D; function()&#123;return true&#125;; &#125;)&#125; 12345678910111213141516171819202122function sixth ()&#123; &#x2F;&#x2F; 主动调用静态方法 Java.perform(function()&#123; Java.use(&quot;com.example.androiddemo.Activity.Frida6.Frida6Class0&quot;).check.implementation &#x3D; function ()&#123;return true &#125;; Java.use(&quot;com.example.androiddemo.Activity.Frida6.Frida6Class1&quot;).check.implementation &#x3D; function ()&#123;return true &#125;; Java.use(&quot;com.example.androiddemo.Activity.Frida6.Frida6Class2&quot;).check.implementation &#x3D; function ()&#123;return true &#125;; &#125;) &#125;function sixth2()&#123; Java.perform(function()&#123; &#x2F;&#x2F; 枚举所有类 主动调用静态方法 Java.enumerateLoadedClasses(&#123; onMatch:function(name,handle)&#123; if(name.toString().indexOf(&quot;com.example.androiddemo.Activity.Frida6.Frida6&quot;)&gt;&#x3D;0)&#123; console.log(&quot;name&quot;,name) Java.use(name).check.implementation &#x3D; function()&#123;return true&#125; &#125; &#125;,onComplete()&#123;&#125; &#125;) &#125;) &#125; setImmediate(sixth2); 获取枚举所有实现类 123456789101112131415161718192021222324Java.perform(function()&#123; Java.enumerateLoadedClasses(&#123; &quot;onMatch&quot; : function(classname)&#123; if(classname.indexOf(&quot;com.csair.mbp&quot;) &lt; 0)&#123; return; &#125; &#x2F;&#x2F; 实现类 implements try&#123; var hookCls &#x3D; Java.use(classname) var interFaces &#x3D; hookCls.class.getInterfaces(); if (interFaces.length &gt; 0) &#123; console.log(classname) for (var i in interFaces) &#123; &#x2F;&#x2F; 接口类 interFaces console.log(&quot;\\t&quot;, interFaces[i].toString()) &#125; &#125; &#125;catch(e)&#123; console.log(e) &#125; &#125;, &quot;onComplete&quot; : function()&#123;&#125; &#125;) kgb-messenger R.string.User在资源文件的resources.arsc/res/valus/strings.xml 1234567891011121314151617181920212223function hook_java() &#123; Java.perform(function () &#123; var System &#x3D; Java.use(&quot;java.lang.System&quot;); console.log(System); &#x2F;&#x2F;frida -U --no-pause -f com.tlamb96.spetsnazmessenger -l hook.js &#x2F;&#x2F;hook System, System.getProperty.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (key) &#123; var result &#x3D; this.getProperty(key); result &#x3D; &quot;Russia&quot;; console.log(&quot;System.getProperty:&quot;, key, result); return result; &#125;; System.getenv.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (key) &#123; var result &#x3D; this.getProperty(key); result &#x3D; &quot;RkxBR3s1N0VSTDFOR180UkNIM1J9Cg&#x3D;&#x3D;&quot;; console.log(&quot;System.getenv:&quot;, key, result); return result; &#125;; &#125;);&#125; R.string.username在资源文件的resources.arsc/res/valus/strings.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344function hook_java() &#123; &#x2F;&#x2F;var ddex &#x3D; Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;ddex.dex&quot;); &#x2F;&#x2F;frida动态加载了dex &#x2F;* jar -cvf ddex.jar com&#x2F;example&#x2F;androiddemo&#x2F;DecodeUtils.class &#x2F;Users&#x2F;yang&#x2F;Library&#x2F;Android&#x2F;sdk&#x2F;build-tools&#x2F;28.0.3&#x2F;dx --dex --output&#x3D;ddex.dex ddex.jar 生成dex的类DecodeUtils用来实现a算法逆向 *&#x2F; var ddex2 &#x3D; Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;ddex2.dex&quot;); Java.perform(function () &#123; &#x2F;&#x2F;frida动态加载了dex ddex2.load(); var DecodeUtils &#x3D; Java.use(&quot;com.example.androiddemo.DecodeUtils&quot;); console.log(&quot;DecodeUtils.decode_p:&quot;, DecodeUtils.decode_p()); console.log(&quot;r to hex&quot;, DecodeUtils.r_to_hex()); var a &#x3D; Java.use(&quot;com.tlamb96.kgbmessenger.b.a&quot;); &#x2F;&#x2F;hook 构造函数 a.$init.implementation &#x3D; function (i, str, str2, z) &#123; this.$init(i, str, str2, z); console.log(&quot;a.$init:&quot;, i, str, str2, z); print_stack(); &#x2F;&#x2F;打印了调用栈找到com.tlamb96.kgbmessenger.MessengerActivity.a &#125;; var MessengerActivity &#x3D; Java.use(&quot;com.tlamb96.kgbmessenger.MessengerActivity&quot;); MessengerActivity.a.implementation &#x3D; function (str) &#123; console.log(&quot;MessengerActivity.a:&quot;, str); var result &#x3D; this.a(str); console.log(&quot;MessengerActivity.a:&quot;, str, result); return result; &#125;; &#125;);&#125;function print_stack() &#123; Java.perform(function () &#123; var Exception &#x3D; Java.use(&quot;java.lang.Exception&quot;); var instance &#x3D; Exception.$new(&quot;print_stack&quot;); var stack &#x3D; instance.getStackTrace(); console.log(stack); instance.$dispose(); &#125;);&#125; 先解密r为text字符串，需要用到z3的库 12jar -cvf ddex.jar com&#x2F;example&#x2F;androiddemo&#x2F;DecodeUtils.class&#x2F;Users&#x2F;yang&#x2F;Library&#x2F;Android&#x2F;sdk&#x2F;build-tools&#x2F;28.0.3&#x2F;dx --dex --output&#x3D;ddex.dex ddex.jar 生成dex的类DecodeUtils用来实现r的16进制字符串为0064736c707d6f510020646b73247c4d0068202b4159516700502a214d24675100 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from z3 import *&#x2F;&#x2F; pip install z3-solverfrom binascii import b2a_hex, a2b_hexdef main(): s &#x3D; Solver() r &#x3D; &quot;0064736c707d6f510020646b73247c4d0068202b4159516700502a214d24675100&quot; &#x2F;&#x2F; 转成byte数组 r_result &#x3D; bytearray(a2b_hex(r)) print(r_result) &#x2F;&#x2F; 字符串翻转 for i in range(int(len(r_result) &#x2F; 2)): c &#x3D; r_result[i] r_result[i] &#x3D; r_result[len(r_result) - i - 1] r_result[len(r_result) - i - 1] &#x3D; c print(b2a_hex(r_result)) &#x2F;&#x2F; 将反转字符串转成字节数组 x &#x3D; [BitVec(&quot;x%s&quot; % i, 32) for i in range(len(r_result))] for i in range(len(r_result)): c &#x3D; r_result[i] print(i, hex(c)) s.add(((x[i] &gt;&gt; (i % 8)) ^ x[i]) &#x3D;&#x3D; r_result[i]) #z3 &#x2F;&#x2F; Solver转为字符串 if (s.check() &#x3D;&#x3D; sat): model &#x3D; (s.model()) print(model) flag &#x3D; &quot;&quot; for i in range(len(r_result)): if (model[x[i]] !&#x3D; None): flag +&#x3D; chr(model[x[i]].as_long().real) else: flag +&#x3D; &quot; &quot; print(&#39;&quot;&#39; + flag + &#39;&quot;&#39;) print(len(flag), len(r_result))if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main()&#39;&#39;&#39; private String b(String str) &#123; char[] charArray &#x3D; str.toCharArray(); for (int i &#x3D; 0; i &lt; charArray.length; i++) &#123; charArray[i] &#x3D; (char) ((charArray[i] &gt;&gt; (i % 8)) ^ charArray[i]); &#125; &#x2F;&#x2F; 字符串翻转 for (int i2 &#x3D; 0; i2 &lt; charArray.length &#x2F; 2; i2++) &#123; char c &#x3D; charArray[i2]; charArray[i2] &#x3D; charArray[(charArray.length - i2) - 1]; charArray[(charArray.length - i2) - 1] &#x3D; c; &#125; return new String(charArray); &#125;&#39;&#39;&#39; xman 12345678910111213141516171819function hook_java() &#123; Java.perform(function () &#123; var MyApp &#x3D; Java.use(&quot;com.gdufs.xman.MyApp&quot;); &#x2F;&#x2F; hook java 层的jni函数 MyApp.saveSN.implementation &#x3D; function (str) &#123; console.log(&quot;MyApp.saveSN:&quot;, str); this.saveSN(str); &#125;; var Process &#x3D; Java.use(&quot;android.os.Process&quot;); &#x2F;&#x2F; 干掉killProcess Process.killProcess.implementation &#x3D; function (pid) &#123; &#x2F;&#x2F;this.killProcess(pid); console.log(&quot;Process.killProcess:&quot;, pid); &#125;; console.log(&quot;hook_java&quot;); &#125;);&#125; 由于搜索导出函数没有saveSN，查看JNI_OnLoad和.init_array（ctrl+s没有函数），当registerNative不好找时**frida_hook_libart** off_5004是函数数组，双击进入 saveSN在n2中，双击进入 进入text View模式，设置opcode字节为4，函数开头2字节，中间4字节，是thumb格式函数，基地址+1才能正确hook 123456789101112131415161718function hook_native() &#123; &#x2F;&#x2F;获取模块的基址 var base_myjni &#x3D; Module.findBaseAddress(&quot;libmyjni.so&quot;); if (base_myjni) &#123; &#x2F;&#x2F;获取模块的导出函数 var n2 &#x3D; Module.findExportByName(&quot;libmyjni.so&quot;, &quot;n2&quot;); &#x2F;&#x2F;thumb的函数，0x000011F8, 实际地址0xdba461f9 console.log(&quot;base_myjni:&quot;, base_myjni, &quot;n2:&quot;, n2); &#x2F;&#x2F;hook模块的导出函数 Interceptor.attach(n2, &#123; onEnter: function (args) &#123; console.log(&quot;n2 onEnter:&quot;, args[0], args[1], args[2]); &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125;&#125; MyApp中m=0，需要找到哪里对m设值，在initSN中n1函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function hook_libart() &#123; var module_libart &#x3D; Process.findModuleByName(&quot;libart.so&quot;); var symbols &#x3D; module_libart.enumerateSymbols(); &#x2F;&#x2F;枚举模块的符号 var addr_GetStringUTFChars &#x3D; null; var addr_FindClass &#x3D; null; var addr_GetStaticFieldID &#x3D; null; var addr_SetStaticIntField &#x3D; null; for (var i &#x3D; 0; i &lt; symbols.length; i++) &#123; var name &#x3D; symbols[i].name; if (name.indexOf(&quot;art&quot;) &gt;&#x3D; 0) &#123; if ((name.indexOf(&quot;CheckJNI&quot;) &#x3D;&#x3D; -1) &amp;&amp; (name.indexOf(&quot;JNI&quot;) &gt;&#x3D; 0)) &#123; if (name.indexOf(&quot;GetStringUTFChars&quot;) &gt;&#x3D; 0) &#123; console.log(name); addr_GetStringUTFChars &#x3D; symbols[i].address; &#125; else if (name.indexOf(&quot;FindClass&quot;) &gt;&#x3D; 0) &#123; console.log(name); addr_FindClass &#x3D; symbols[i].address; &#125; else if (name.indexOf(&quot;GetStaticFieldID&quot;) &gt;&#x3D; 0) &#123; console.log(name); addr_GetStaticFieldID &#x3D; symbols[i].address; &#125; else if (name.indexOf(&quot;SetStaticIntField&quot;) &gt;&#x3D; 0) &#123; console.log(name); addr_SetStaticIntField &#x3D; symbols[i].address; &#125; &#125; &#125; &#125; &#x2F;&#x2F;hook jni的一些函数 if (addr_GetStringUTFChars) &#123; Interceptor.attach(addr_GetStringUTFChars, &#123; onEnter: function (args) &#123; &#x2F;&#x2F;打印调用栈 &#x2F;&#x2F; console.log(&#39;addr_GetStringUTFChars onEnter called from:\\n&#39; + &#x2F;&#x2F; Thread.backtrace(this.context, Backtracer.FUZZY) &#x2F;&#x2F; .map(DebugSymbol.fromAddress).join(&#39;\\n&#39;) + &#39;\\n&#39;); &#125;, onLeave: function (retval) &#123; &#x2F;&#x2F; retval const char* 打印char* console.log(&quot;addr_GetStringUTFChars onLeave:&quot;, ptr(retval).readCString(), &quot;\\r\\n&quot;); &#125; &#125;); &#125; if (addr_FindClass) &#123; Interceptor.attach(addr_FindClass, &#123; onEnter: function (args) &#123; console.log(&quot;addr_FindClass:&quot;, ptr(args[1]).readCString()); &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125; if (addr_GetStaticFieldID) &#123; Interceptor.attach(addr_GetStaticFieldID, &#123; onEnter: function (args) &#123; console.log(&quot;addr_GetStaticFieldID:&quot;, ptr(args[2]).readCString(), ptr(args[3]).readCString()); &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125; if (addr_SetStaticIntField) &#123; Interceptor.attach(addr_SetStaticIntField, &#123; onEnter: function (args) &#123; console.log(&quot;addr_SetStaticIntField:&quot;, args[3]); &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125;&#125; 需要在n1函数中strcmp返回true时将v9设置为1 12345678910111213141516function hook_libc() &#123; &#x2F;&#x2F;hook libc的函数 var strcmp &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;); console.log(&quot;strcmp:&quot;, strcmp); Interceptor.attach(strcmp, &#123; onEnter: function (args) &#123; var str_2 &#x3D; ptr(args[1]).readCString(); if (str_2 &#x3D;&#x3D; &quot;EoPAoY62@ElRD&quot;) &#123; console.log(&quot;strcmp:&quot;, ptr(args[0]).readCString(), ptr(args[1]).readCString()); &#125; &#125;, onLeave: function (retval) &#123; &#125; &#125;);&#125; 将/sdcard/reg.dat中内容改为EoPAoY62@ElRD即可 12345678910111213141516171819202122232425262728293031function write_reg_dat() &#123; &#x2F;&#x2F;frida 的api来写文件 var file &#x3D; new File(&quot;&#x2F;sdcard&#x2F;reg.dat&quot;, &quot;w&quot;); file.write(&quot;EoPAoY62@ElRD&quot;); file.flush(); file.close();&#125;function write_reg_dat2() &#123; &#x2F;&#x2F;把C函数定义为NativeFunction来写文件 var addr_fopen &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fopen&quot;); var addr_fputs &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fputs&quot;); var addr_fclose &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fclose&quot;); console.log(&quot;addr_fopen:&quot;, addr_fopen, &quot;addr_fputs:&quot;, addr_fputs, &quot;addr_fclose:&quot;, addr_fclose); var fopen &#x3D; new NativeFunction(addr_fopen, &quot;poin ter&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]); var fputs &#x3D; new NativeFunction(addr_fputs, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]); var fclose &#x3D; new NativeFunction(addr_fclose, &quot;int&quot;, [&quot;pointer&quot;]); var filename &#x3D; Memory.allocUtf8String(&quot;&#x2F;sdcard&#x2F;reg.dat&quot;); var open_mode &#x3D; Memory.allocUtf8String(&quot;w+&quot;); var file &#x3D; fopen(filename, open_mode); console.log(&quot;fopen file:&quot;, file); var buffer &#x3D; Memory.allocUtf8String(&quot;EoPAoY62@ElRD&quot;); var ret &#x3D; fputs(buffer, file); console.log(&quot;fputs ret:&quot;, ret); fclose(file);&#125; RPC主动调用lesson7lesson4.js 1234567891011121314function invoke()&#123; Java.perform(function()&#123; Java.choose(&quot;com.example.lesson4one.MainActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance :&quot;,instance) console.log(&quot;found instance :&quot;,instance.secret()) &#125;,onComplete:function()&#123;&#125; &#125;) &#125;)&#125; &#x2F;&#x2F;setTimeout(invoke,2000) 主动调用 rpc.exports &#x3D; &#123; invokefunc:invoke&#125; lesson7loader.py 1234567891011121314151617181920212223242526272829303132import timeimport frida# frida默认27042 .&#x2F;fs1280arm4 -l 0.0.0.0:9999def my_message_handler(message,payload): print(message) print(payload)#device &#x3D; frida.get_usb_device() wifi连接可以实现多主机多手机多端口混连device &#x3D; frida.get_device_manager().add_remote_device(&quot;192.168.1.102:9999&quot;)#device &#x3D; frida.get_device_manager().add_remote_device(&quot;192.168.1.109:9999&quot;)# 枚举所有进程print(device.enumerate_processes())# spawn模式#pid &#x3D; device.spawn([&quot;com.example.lesson4one&quot;])#device.resume#time.sleep(1)#session &#x3D; device.attach(pid)# attach模式session &#x3D; device.attach(&quot;com.example.lesson4one&quot;)with open(&quot;lesson7lesson4.js&quot;) as f : script &#x3D; session.create_script(f.read())script.on(&quot;message&quot;,my_message_handler)script.load()command &#x3D; &quot;&quot;while True : command &#x3D; input(&quot;Enter Command:&quot;) if command &#x3D;&#x3D; &quot;1&quot;: break elif command &#x3D;&#x3D; &quot;2&quot;: script.exports.invokefunc() 接受回调 lesson7sec.js 123456789101112131415161718Java.perform(function()&#123; Java.use(&quot;android.widget.TextView&quot;).setText.overload(&#39;java.lang.CharSequence&#39;).implementation &#x3D; function(x)&#123; var string_to_send_x &#x3D; x.toString(); var string_to_recv; &#x2F;&#x2F; 发送 send(string_to_send_x); &#x2F;&#x2F; 回调 recv(function(received_json_objection)&#123; string_to_recv &#x3D; received_json_objection.my_data console.log(&quot;string_to_recv:&quot;+string_to_recv) &#125;).wait(); var javaStringToSend&#x3D;Java.use(&#39;java.lang.String&#39;).$new(string_to_recv); var result &#x3D; this.setText(javaStringToSend); &#x2F;&#x2F;console.log(&quot;x.toString(),result&quot;,x.toString(),result); return result; &#125;&#125;) lesson7secloader.py 123456789101112131415161718192021222324252627282930313233import timeimport fridaimport base64def my_message_handler(message,payload): print(message) print(payload) if message[&quot;type&quot;]&#x3D;&#x3D;&quot;send&quot;: print(message[&quot;payload&quot;]) data &#x3D; message[&quot;payload&quot;].split(&quot;:&quot;)[1].strip() print(&#39;message:&#39;,message) data &#x3D; str(base64.b64decode(data)) print(&#39;data:&#39;,data) usr,pw &#x3D; data.split(&quot;:&quot;) print(&#39;pw:&#39;,pw) &#x2F;&#x2F; 修改输入用户名改为admin data &#x3D; str(base64.b64encode((&quot;admin&quot;+&quot;:&quot;+pw).encode())) print(&quot;encode data:&quot;,data) script.post(&#123;&quot;my_data&quot;:data&#125;) print(&quot;Modified data sent !&quot;)device &#x3D; frida.get_usb_device()#pid &#x3D; device.spawn([&quot;com.example.lesson4one&quot;])#device.resume#time.sleep(1)#session &#x3D; device.attach(pid)session &#x3D; device.attach(&quot;com.example.lesson7sec&quot;)with open(&quot;lesson7sec.js&quot;) as f : script &#x3D; session.create_script(f.read())script.on(&quot;message&quot;,my_message_handler)script.load()input() NPS内网穿透代理，linux_amd64_server.tar.gz服务端，linux_amd64_client.tar.gz客户端， 12sudo .&#x2F;nps installsudo nps start 启动服务端 新增客户端，复制客户端命令在客户端运行即可 客户端启动frida ./fs1280arm64 -l 0.0.0.0:8888 ，新增TCP隧道，将内网端口8888映射到公网58888，其中的目标可以填入很多IP:端口进行映射 Zentrace批量hook 12345678# pyenv install 3.8.0# git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;ZenTracer# cd ZenTracer# pyenv local 3.8.0# python -m pip install --upgrade pip# pip install PyQt5# pip install frida-tools# python ZenTracer.py 点击打开“设置”应用； 选择Action→Match RegEx 输入E:java.io.File，点击add，然后关闭窗口 点击Action→Start 可以观察到java.io.File类的所有方法都被hook了，，并且像java.io.File.createTempFile方法的所有重载也被hook了 点击Action→Stop，再点击Action→Clean，本次观察结束。 也可以使用模糊匹配模式，比如输入M:java.io.File之后，会将诸如java.io.FileOutputStream类的诸多方法也都hook上，不过无法打印调用栈，无法hook构造函数，也就是$init。 案例过弹窗 12android hooking list activitiesandroid intent launch_activity com.tlamb96.spetsnazmessenger.LoginActivity 123456789101112131415function main()&#123; Java.perform(function()&#123; Java.use(&quot;java.lang.System&quot;).getProperty.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(x)&#123; var result &#x3D; this.getProperty(x); console.log(&quot;x,result:&quot;,x,result); return Java.use(&quot;java.lang.String&quot;).$new(&quot;Russia&quot;); &#125; Java.use(&quot;java.lang.System&quot;).getenv.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(x)&#123; var result &#x3D; this.getenv(x); console.log(&quot;x,result:&quot;,x,result); return Java.use(&quot;java.lang.String&quot;).$new(&quot;RkxBR3s1N0VSTDFOR180UkNIM1J9Cg&#x3D;&#x3D;&quot;); &#125; &#125;)&#125;setImmediate(main) 过登录 username:codenameduchess password:guest 123456789101112function main()&#123; Java.perform(function()&#123; &#x2F;&#x2F; 发消息 Java.use(&quot;com.tlamb96.kgbmessenger.b.a&quot;).$init.implementation &#x3D; function(str0,str1,str2,b)&#123; var result &#x3D; this.$init(str0,str1,str2,b); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(&quot;str0,str1,str2,b:&quot;,str0,str1,str2,b) return result; &#125; &#125;)&#125;setImmediate(main) 123456789101112131415161718192021function main()&#123; Java.perform(function()&#123; Java.use(&quot;com.tlamb96.kgbmessenger.MessengerActivity&quot;).a.implementation &#x3D; function(x)&#123; var result &#x3D; this.a(x); console.log(&quot;a:x,result:&quot;,x,result); if(x&#x3D;&#x3D;&quot;aaaa&quot;)&#123; result&#x3D; Java.use(&quot;java.lang.String&quot;).$new(&quot;V@]EAASB\\u0012WZF\\u0012e,a$7(&amp;am2(3.\\u0003&quot;); &#125; return result; &#125; Java.use(&quot;com.tlamb96.kgbmessenger.MessengerActivity&quot;).b.implementation &#x3D; function(x)&#123; var result &#x3D; this.b(x); console.log(&quot;b:x,result:&quot;,x,result); if(x&#x3D;&#x3D;&quot;bbbb&quot;)&#123; result&#x3D; Java.use(&quot;java.lang.String&quot;).$new(&quot;\\u0000dslp&#125;oQ\\u0000 dks$|M\\u0000h +AYQg\\u0000P*!M$gQ\\u0000&quot;); &#125; return result; &#125; &#125;)&#125;setImmediate(main) 逆向实现 1234567891011121314151617181920212223242526272829public class reverseA &#123; public static String decode_P()&#123; String p &#x3D; &quot;V@]EAASB\\u0012WZF\\u0012e,a$7(&amp;am2(3.\\u0003&quot;; String result &#x3D; a(p); return result; &#125; private static String a(String str) &#123; char[] charArray &#x3D; str.toCharArray(); for (int i &#x3D; 0; i &lt; charArray.length &#x2F; 2; i++) &#123; char c &#x3D; charArray[i]; charArray[i] &#x3D; (char) (charArray[(charArray.length - i) - 1] ^ &#39;A&#39;); charArray[(charArray.length - i) - 1] &#x3D; (char) (c ^ &#39;2&#39;); &#125; return new String(charArray); &#125; public static String r_to_hex()&#123; String r &#x3D; &quot;\\u0000dslp&#125;oQ\\u0000 dks$|M\\u0000h +AYQg\\u0000P*!M$gQ\\u0000&quot;; byte[] bytes &#x3D; r.getBytes(); String result &#x3D; &quot;&quot;; for(int i&#x3D;0;i&lt;bytes.length;i++)&#123; result +&#x3D; String.format(&quot;%02x&quot;,bytes[i]); &#125; return result; &#125;&#125; 将class文件打包成dex，d8 reverseA.class 12345678910function main()&#123; Java.perform(function()&#123; Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;classes.dex&quot;).load(); const reverseA &#x3D; Java.use(&#39;com.example.lesson9.reverseA&#39;); console.log(&quot;reverseA result:&quot;,reverseA.decode_P()); console.log(&quot;r_to_hex result:&quot;,reverseA.r_to_hex()); &#125;)&#125;setImmediate(main) pip install z3-solver 12345678910111213141516171819202122232425262728293031323334from z3 import *from binascii import b2a_hex,a2b_hexs &#x3D;Solver()r &#x3D; &quot;0064736c707d6f510020646b73247c4d0068202b4159516700502a214d24675100&quot;r_result &#x3D; bytearray(a2b_hex(r))print(r_result)for i in range(int(len(r_result)&#x2F;2)) : c &#x3D; r_result[i] r_result[i] &#x3D; r_result[len(r_result)-i-1] r_result[len(r_result)-i-1] &#x3D; cprint(b2a_hex(r_result))x &#x3D; [BitVec(&quot;x%s&quot; % i, 32) for i in range(len(r_result))]for i in range(len(r_result)): c &#x3D; r_result[i] print(i,hex(c)) s.add(((x[i] &gt;&gt; (i % 8)) ^ x[i] ) &#x3D;&#x3D; r_result[i])if (s.check() &#x3D;&#x3D; sat): model &#x3D; s.model() print(model) flag&#x3D;&quot;&quot; for i in range(len(r_result)): if (model[x[i]] !&#x3D; None): flag +&#x3D; chr(model[x[i]].as_long().real) else: flag +&#x3D; &quot; &quot; print(&#39;&quot;&#39; + flag + &#39;&quot;&#39;) print(len(flag), len(r_result)) adb shell input text “aaa” 输入adb var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"天猫抢茅台分析实现","slug":"天猫抢茅台分析实现","date":"2022-03-02T12:45:39.000Z","updated":"2022-03-05T13:50:52.485Z","comments":true,"path":"2022/03/02/天猫抢茅台分析实现/","link":"","permalink":"http://onejane.github.io/2022/03/02/%E5%A4%A9%E7%8C%AB%E6%8A%A2%E8%8C%85%E5%8F%B0%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"抓包部分接口基于spdy协议，利用frida直接跳过即可，抓包工具charles 123456789setImmediate(function () &#123; Java.perform(function () &#123; var SwitchConfig &#x3D; Java.use(&#39;mtopsdk.mtop.global.SwitchConfig&#39;); SwitchConfig.isGlobalSpdySwitchOpen.overload().implementation &#x3D; function () &#123; var ret &#x3D; this.isGlobalSpdySwitchOpen.apply(this, arguments); console.log(&quot;\\nisGlobalSpdySwitchOpenl &quot; + ret) &#125; &#125;);&#125;) 加入购物车 购买商品 分析加入购物车搜索”x-sign”大概定位到mtopsdk.framework.manager.impl.InnerFilterManagerImpl中new InnerNetworkConverter()用到了”x-sign” 123frida -UF -l tianmao.js 过掉spdy协议adb shell dumpsys window|grep mCurrentFocus 查看包名com.tmall.wirelessandroid hooking watch class_method mtopsdk.framework.manager.impl.InnerFilterManagerImpl --dump-args --dump-backtrace --dump-return 不过尝试内存漫游的时候报错，因为objection不带Java.classFactory，objection的android hooking search classes底层实现 Java.enumerateLoadedClassesSync()，这个API可以返回所有classloader里的类。但是有一些类你直接搜刮，因为objection不带Java.classFactory，无法hook动态加载的dex，所以无法切换classloader。 12hook(&quot;mtopsdk.framework.manager.impl&quot;,&quot; &quot;,&quot;mtopsdk.framework.manager.impl&quot;); frida -UF -l r0tracer.js -o tianmao.log 利用r0trace实现该类的追踪 不过一无所获，尝试so层的追踪 1frida -UF -l hook_art.js &gt; tianmao.log 出现在libsgmainso-6.4.156.so的0xb5561地址 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"SO逆向之唯品会api_sign","slug":"SO逆向之唯品会api-sign","date":"2022-02-28T12:34:07.000Z","updated":"2022-10-15T11:59:02.934Z","comments":true,"path":"2022/02/28/SO逆向之唯品会api-sign/","link":"","permalink":"http://onejane.github.io/2022/02/28/SO%E9%80%86%E5%90%91%E4%B9%8B%E5%94%AF%E5%93%81%E4%BC%9Aapi-sign/","excerpt":"","text":"抓包postern+chales https://mapi.appvipshop.com/vips-mobile/rest/shopping/product/module/list/v2 OAuth Authentication api_sign 851720db2410ed92d3628f1739c00e1374d26c02 分析jadx打开唯品会7.45.6.apk，搜索api_sign 进入apiSign 123456public static String apiSign(Context context, TreeMap&lt;String, String&gt; treeMap, String str) throws Exception &#123; if (context &#x3D;&#x3D; null) &#123; context &#x3D; VCSPCommonsConfig.getContext(); &#125; return VCSPSecurityConfig.getMapParamsSign(context, treeMap, str, false);&#125; 进入getMapParamsSign 12345678910111213141516171819202122232425262728public static String getMapParamsSign(Context context, TreeMap&lt;String, String&gt; treeMap, String str, boolean z) &#123; String str2 &#x3D; null; if (treeMap &#x3D;&#x3D; null) &#123; return null; &#125; boolean z2 &#x3D; false; Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet &#x3D; treeMap.entrySet(); if (entrySet !&#x3D; null) &#123; Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it &#x3D; entrySet.iterator(); while (true) &#123; if (it &#x3D;&#x3D; null || !it.hasNext()) &#123; break; &#125; Map.Entry&lt;String, String&gt; next &#x3D; it.next(); if (next !&#x3D; null &amp;&amp; next.getKey() !&#x3D; null &amp;&amp; ApiConfig.USER_TOKEN.equals(next.getKey()) &amp;&amp; !TextUtils.isEmpty(next.getValue())) &#123; z2 &#x3D; true; break; &#125; &#125; &#125; if (z2) &#123; if (TextUtils.isEmpty(str)) &#123; str &#x3D; VCSPCommonsConfig.getTokenSecret(); &#125; str2 &#x3D; str; &#125; return getSignHash(context, treeMap, str2, z);&#125; 一顿操作不过是为了生成str2作为参数传入getSignHash 12345678public static String getSignHash(Context context, Map&lt;String, String&gt; map, String str, boolean z) &#123; try &#123; return gs(context.getApplicationContext(), map, str, z); &#125; catch (Throwable th) &#123; VCSPMyLog.error(clazz, th); return &quot;error! params invalid&quot;; &#125;&#125; 调用了gs函数 123456789101112131415161718192021222324252627282930private static String gs(Context context, Map&lt;String, String&gt; map, String str, boolean z) &#123; try &#123; if (clazz &#x3D;&#x3D; null || object &#x3D;&#x3D; null) &#123; synchronized (lock) &#123; initInstance(); &#125; &#125; if (gsMethod &#x3D;&#x3D; null) &#123; gsMethod &#x3D; clazz.getMethod(&quot;gs&quot;, Context.class, Map.class, String.class, Boolean.TYPE); &#125; return (String) gsMethod.invoke(object, context, map, str, Boolean.valueOf(z)); &#125; catch (Exception e) &#123; e.printStackTrace(); return &quot;Exception gs: &quot; + e.getMessage(); &#125; catch (Throwable th) &#123; th.printStackTrace(); return &quot;Throwable gs: &quot; + th.getMessage(); &#125;&#125;private static void initInstance() &#123; if (clazz &#x3D;&#x3D; null || object &#x3D;&#x3D; null) &#123; try &#123; Class&lt;?&gt; cls &#x3D; Class.forName(&quot;com.vip.vcsp.KeyInfo&quot;); clazz &#x3D; cls; object &#x3D; cls.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; gs中通过反射获取KeyInfo类，并反射调用了该类的gs方法，进入KeyInfo类 123456789private static final String LibName &#x3D; &quot;keyinfo&quot;;public static String gs(Context context, Map&lt;String, String&gt; map, String str, boolean z) &#123; try &#123; return gsNav(context, map, str, z); &#125; catch (Throwable th) &#123; return &quot;KI gs: &quot; + th.getMessage(); &#125;&#125;private static native String gsNav(Context context, Map&lt;String, String&gt; map, String str, boolean z); gsNav位于libkeyinfo.so中，想必就是api_sign生成的位置，IDA打开libkeyinfo.so F5反汇编，想必主要加密逻辑在 j_Functions_gs 函数里 1234567891011int __fastcall Java_com_vip_vcsp_KeyInfo_gsNav(int a1, int a2, int a3, int a4, int a5, int a6)&#123; int v9; &#x2F;&#x2F; r5 if ( j_Utils_ima() ) v9 &#x3D; j_Functions_gs(a1, a2, a4, a5, a6); else v9 &#x3D; 0; j_Utils_checkJniException(a1); return v9;&#125; 进入j_Functions_gs后，上面对params的map做处理 可疑函数j_getByteHash，看这逻辑要么返回0，要么返回((int (__fastcall *)(JNIEnv *))(*a1)-&gt;NewStringUTF)(a1) 进入j_getByteHash，看着像是调用SHA1算法返回字符串，固定长度为160位的消息摘要，40个字符长度，和api_sign长度一致 1234567891011121314151617181920212223242526272829303132char *__fastcall getByteHash(int a1, int a2, int a3, int a4, char *a5)&#123; char *v7; &#x2F;&#x2F; r4 int i; &#x2F;&#x2F; r5 int v9; &#x2F;&#x2F; r2 _QWORD v11[8]; &#x2F;&#x2F; [sp+0h] [bp-D8h] BYREF _DWORD v12[26]; &#x2F;&#x2F; [sp+44h] [bp-94h] BYREF if ( !a3 ) return 0; v7 &#x3D; a5; j_SHA1Reset(v12); j_SHA1Input(v12, a3, a4); if ( j_SHA1Result(v12) ) &#123; for ( i &#x3D; 0; i !&#x3D; 5; ++i ) &#123; v9 &#x3D; v12[i]; v11[6] &#x3D; 0LL; v11[7] &#x3D; 0LL; v11[4] &#x3D; 0LL; v11[5] &#x3D; 0LL; v11[0] &#x3D; 0LL; v11[1] &#x3D; 0LL; v11[2] &#x3D; 0LL; v11[3] &#x3D; 0LL; sprintf((char *)v11, &quot;%08x&quot;, v9); strcat(a5, (const char *)v11); &#125; &#125; return v7;&#125; frida123456789101112131415161718192021function main() &#123; Java.perform(function () &#123; &#x2F;&#x2F; 导出jni函数 var native_func &#x3D; Module.findExportByName( &quot;libkeyinfo.so&quot;, &quot;getByteHash&quot; ); Interceptor.attach(native_func, &#123; onEnter: function (args) &#123; &#x2F;&#x2F; getByteHash(int a1, int a2, int a3, int a4, char *a5) &#x2F;&#x2F; getByteHash(JNIEnv *env, jobject a2, int a3, int a4, char *a5) console.log(&#39;args[2]: &#39;, Memory.readCString(args[2])); &#125;, onLeave: function (return_val) &#123; console.log(&#39;return_val: &#39;, Memory.readCString(return_val)); &#125; &#125;); &#125;);&#125;setImmediate(main) 一次api_sign的生成调用了两次非魔改后的sha1算法，两次前面都加了盐a84c5883206309ad076deea939e850dc&amp;8cf90dfd9a89070a9e8653d92f57349b 1234args[2]: a84c5883206309ad076deea939e850dc&amp;8cf90dfd9a89070a9e8653d92f57349bapi_key&#x3D;23e7f28019e8407b98b84cd05b5aef2c&amp;app_name&#x3D;shop_android&amp;app_version&#x3D;7.45.6&amp;channel_flag&#x3D;0_1&amp;client&#x3D;android&amp;client_type&#x3D;android&amp;context&#x3D;&#123;&quot;615&quot;:&quot;1&quot;,&quot;872&quot;:&quot;1&quot;&#125;&amp;darkmode&#x3D;0&amp;deeplink_cps&#x3D;&amp;extParams&#x3D;&#123;&quot;floatwin&quot;:&quot;1&quot;,&quot;preheatTipsVer&quot;:&quot;4&quot;,&quot;exclusivePrice&quot;:&quot;1&quot;,&quot;stdSizeVids&quot;:&quot;&quot;,&quot;showSellPoint&quot;:&quot;3&quot;,&quot;mclabel&quot;:&quot;1&quot;,&quot;cmpStyle&quot;:&quot;1&quot;,&quot;ic2label&quot;:&quot;1&quot;,&quot;reco&quot;:&quot;1&quot;,&quot;vreimg&quot;:&quot;1&quot;,&quot;couponVer&quot;:&quot;v2&quot;,&quot;live&quot;:&quot;1&quot;&#125;&amp;fdc_area_id&#x3D;103102105112&amp;mars_cid&#x3D;ace44cff-85cb-37d0-a38a-b7499fa3e70b&amp;mobile_channel&#x3D;kowd7uq2:::&amp;mobile_platform&#x3D;3&amp;other_cps&#x3D;&amp;page_id&#x3D;page_te_commodity_search_1646140605059&amp;phone_model&#x3D;Pixel XL&amp;productIds&#x3D;6919509726012421404,6919653222532612239,6919504313346508736,6919594284198742478,6919507303163532941,6919724272812959428,6919299612550957276,6919665164573995599,6919665282973824340,6919553310211147976&amp;province_id&#x3D;103102&amp;referer&#x3D;com.achievo.vipshop.search.activity.VerticalTabSearchProductListActivity&amp;rom&#x3D;Dalvik&#x2F;2.1.0 (Linux; U; Android 10; Pixel XL Build&#x2F;QP1A.191005.007.A3)&amp;scene&#x3D;search&amp;sd_tuijian&#x3D;0&amp;session_id&#x3D;ace44cff-85cb-37d0-a38a-b7499fa3e70b_shop_android_1646136043568&amp;skey&#x3D;2d30297ff20ec9b7442dc4f3c335abdc&amp;source_app&#x3D;android&amp;standby_id&#x3D;kowd7uq2:::&amp;sys_version&#x3D;29&amp;timestamp&#x3D;1646140654&amp;user_token&#x3D;F4B99E10F54F31E68D773637A4FC3D78E92EC915&amp;warehouse&#x3D;VIP_SHreturn_val: 924af08b6533322960ae5a597777084e226cbc7eargs[2]: a84c5883206309ad076deea939e850dc&amp;8cf90dfd9a89070a9e8653d92f57349b924af08b6533322960ae5a597777084e226cbc7ereturn_val: a9673ab3c2f64b755a639c9c9e641b2fc6f089ab var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"ida","slug":"ida","permalink":"http://onejane.github.io/tags/ida/"}]},{"title":"SO逆向之小红书shield","slug":"SO逆向之小红书shield","date":"2022-02-24T01:08:28.000Z","updated":"2022-10-16T02:58:26.297Z","comments":true,"path":"2022/02/24/SO逆向之小红书shield/","link":"","permalink":"http://onejane.github.io/2022/02/24/SO%E9%80%86%E5%90%91%E4%B9%8B%E5%B0%8F%E7%BA%A2%E4%B9%A6shield/","excerpt":"","text":"抓包安装charles证书 安卓8 1234567cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o remount,rw &#x2F;mount -o remount,rw &#x2F;systemchmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o remount,ro &#x2F;mount -o remount,ro &#x2F;system 避免SSL Pinning报错网络错误，也可以通过frida过掉SSLPinning 分析jadx搜索shield，没什么实际结果，大概率不在java层，frida_hook_libart对libart进行hook，其中hook_RegisterNatives.js动态注册jni函数，hook_art.js对常用Native方法hook 12345.&#x2F;fs14216arm64 pyenv local 3.8.2frida --version 14.2.16frida -UF -l hook_art.js -o xhs.log 由于在 NewStringUTF 函数中处理了这个shield签名，添加定位地址，修改hook_art.js 12345678910111213141516171819202122if (addrNewStringUTF !&#x3D; null) &#123; Interceptor.attach(addrNewStringUTF, &#123; onEnter: function (args) &#123; if (args[1] !&#x3D; null) &#123; var module &#x3D; Process.findModuleByAddress(this.returnAddress); if (module !&#x3D; null &amp;&amp; module.name.indexOf(so_name) &#x3D;&#x3D; 0) &#123; var string &#x3D; Memory.readCString(args[1]); &#x2F;&#x2F; console.log(&quot;[NewStringUTF] bytes:&quot; + string, DebugSymbol.fromAddress(this.returnAddress)); &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;xhs&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; if (string.length &gt; 50) &#123; console.log(&quot;[NewStringUTF] bytes:&quot; + string); console.log(&quot;xhs---------&quot;, Thread.backtrace(this.context, Backtracer.FUZZY) .map(DebugSymbol.fromAddress).join(&quot;\\n&quot;)) &#125; &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;xhs&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; &#125; &#125; &#125;, onLeave: function (retval) &#123; &#125; &#125;);&#125; IDA打开libshield.so,G跳转到0x93fa8地址，看到该位置处于函数sub_939D8 F5反汇编，X查看sub_939D8方法的调用处 可知在Java层的intercept方法，参数**(Lokhttp3/Interceptor”,0x24,”Chain;J)Lokhttp3/Response;** 搜索intercept( 开始hook 123456789101112131415161718192021222324252627&#x2F;&#x2F; 干掉 Android SSL Pinningvar array_list &#x3D; Java.use(&quot;java.util.ArrayList&quot;);var ApiClient &#x3D; Java.use(&#39;com.android.org.conscrypt.TrustManagerImpl&#39;);ApiClient.checkTrustedRecursive.implementation &#x3D; function(a1, a2, a3, a4, a5, a6) &#123; var k &#x3D; array_list.$new(); return k; &#125;&#x2F;&#x2F; shieldvar shieldCls &#x3D; Java.use(&quot;com.xingin.shield.http.XhsHttpInterceptor&quot;);shieldCls.intercept.overload(&#39;okhttp3.Interceptor$Chain&#39;, &#39;long&#39;).implementation &#x3D; function(chain,j)&#123; var result &#x3D; this.intercept(chain,j); var request &#x3D; chain.request(); console.log(request.toString()); console.log(result.toString()); return result;&#125;&#x2F;&#x2F; okhttpvar OkHttpClient &#x3D; Java.use(&quot;okhttp3.OkHttpClient&quot;);OkHttpClient.newCall.implementation &#x3D; function (request) &#123; var result &#x3D; this.newCall(request); console.log(request.toString()); var stack &#x3D; threadinstance.currentThread().getStackTrace(); console.log(&quot;http &gt;&gt;&gt; Full call stack:&quot; + Where(stack)); return result;&#125;; 这也就意味着http的请求和shield的生成都在so层完成。 Unidbg打开libshield.so，搜索java，没有函数说明都是动态注册进入JNI_OnLoad 1234jint JNI_OnLoad(JavaVM *vm, void *reserved)&#123; return sub_1027C(vm);&#125; 搭建框架调用callJNI_OnLoad 1234567891011121314151617181920212223242526public class XhsShield extends AbstractJni &#123; private final AndroidEmulator emulator; private final VM vm; private final Module module; private Headers headers; private Request request; public static String shield; private String commonParams; public XhsShield()&#123; emulator &#x3D; AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;com.xhs&quot;).build(); &#x2F;&#x2F; 创建模拟器实例，要模拟32位或者64位，在这里区分 final Memory memory &#x3D; emulator.getMemory(); &#x2F;&#x2F; 模拟器的内存操作接口 memory.setLibraryResolver(new AndroidResolver(23)); &#x2F;&#x2F; 设置系统类库解析 vm &#x3D; emulator.createDalvikVM(new File(&quot;小红书v6.73.0.apk&quot;)); vm.setVerbose(true); vm.setJni(this); DalvikModule dm &#x3D; vm.loadLibrary(new File(&quot;libshield.so&quot;), true); module &#x3D; dm.getModule(); System.out.println(&quot;call JNIOnLoad&quot;); dm.callJNI_OnLoad(emulator); &#125; public static void main(String[] args) &#123; XhsShield test &#x3D; new XhsShield(); &#125;&#125; initializeNative对jni调用java方法的一些类进行初始化操作 进入sub_1027C函数 发现函数有很多，在IDA View-A中alt+t搜索上文中的com.xingin.shield.http.XhsHttpInterceptor的initializeNative方法 .text 程序代码段内存区域.data 已初始化的全局数据、全局常量段内存区域.rodata 资源数据段，#define定义的常量.bss 程序中未初始化的全局变量的内存区域 直接看.data数据块中的汇编，initializeNative地址0x94288+1，intercept地址sub_939D8+1，initialize地址sub_937B0+1 g跳转到0x94288+1，查看initializeNative函数，n重命名 在XhsHttpInterceptor类中函数执行顺序，initializeNative&gt;initialize&gt;intercept 12345678910public void callinitializeNative()&#123; List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;(10); list.add(vm.getJNIEnv()); &#x2F;&#x2F; 第一个参数是env list.add(0); &#x2F;&#x2F; 第二个参数，实例方法是jobject，静态方法是jclazz，直接填0，一般用不到。 module.callFunction(emulator, 0x94288+1, list.toArray());&#125;public static void main(String[] args) &#123; XhsShield test &#x3D; new XhsShield(); test.callinitializeNative();&#125; 123456789@Overridepublic DvmObject&lt;?&gt; callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123; switch (signature)&#123; case &quot;java&#x2F;nio&#x2F;charset&#x2F;Charset-&gt;defaultCharset()Ljava&#x2F;nio&#x2F;charset&#x2F;Charset;&quot;:&#123; return vm.resolveClass(&quot;java&#x2F;nio&#x2F;charset&#x2F;Charset&quot;).newObject(Charset.defaultCharset()); &#125; &#125; return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList);&#125; 通过objection内存搜索，是PackageInfo的一个实例变量，该类获取AndroidManifest.xml文件的信息 123frida-ps -Uaobjection -g com.xingin.xhs explore -P ~&#x2F;.objection&#x2F;pluginsplugin wallbreaker classdump --fullname android.content.pm.PackageInfo 也可以通过jnitrace获取versionCode,jnitrace -l libshield.so -m spawn com.xingin.xhs --ignore-vm &gt; xhs.log jnitrace 出现app闪退或者黑屏解决方案 更新版本pip install jnitrace==v3.0.8 ，frida==12.8.0 修改jnitrace-engine 1234567891011121314Interceptor.attach(dlopenRef, &#123; onEnter:function(args)&#123; this.path &#x3D; args[0].readCString(); &#125;,onLeave:function(retval)&#123; if (this.path !&#x3D;&#x3D; null) &#123; if (checkLibrary(this.path)) &#123; trackedLibs.set(retval.toString(), true); &#125; else &#123; libBlacklist.set(retval.toString(), true); &#125; &#125; &#125;&#125;); python -m jnitrace.jnitrace -l libshield.so -b none com.xingin.xhs 123456789@Overridepublic int getIntField(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature) &#123; switch (signature)&#123; case &quot;android&#x2F;content&#x2F;pm&#x2F;PackageInfo-&gt;versionCode:I&quot;:&#123; return 6730157; &#125; &#125; return super.getIntField(vm, dvmObject, signature);&#125; 获取静态变量，frida一步到位，console.log(Java.use(&quot;com.xingin.shield.http.ContextHolder&quot;).sDeviceId.value) 123456789@Overridepublic DvmObject&lt;?&gt; getStaticObjectField(BaseVM vm, DvmClass dvmClass, String signature) &#123; switch (signature)&#123; case &quot;com&#x2F;xingin&#x2F;shield&#x2F;http&#x2F;ContextHolder-&gt;sDeviceId:Ljava&#x2F;lang&#x2F;String;&quot;:&#123; return new StringObject(vm, &quot;145b5374-b973-38d1-8299-eb98f9d950ce&quot;); &#125; &#125; return super.getStaticObjectField(vm, dvmClass, signature);&#125; 同理frida一步到位，console.log(Java.use(&quot;com.xingin.shield.http.ContextHolder&quot;).sAppId.value),或者jnitrace 123456789@Overridepublic int getStaticIntField(BaseVM vm, DvmClass dvmClass, String signature) &#123; switch (signature)&#123; case &quot;com&#x2F;xingin&#x2F;shield&#x2F;http&#x2F;ContextHolder-&gt;sAppId:I&quot;:&#123; return -319115519; &#125; &#125; return super.getStaticIntField(vm, dvmClass, signature);&#125; jnitrace或者frida一步到位 12345678@Overridepublic boolean getStaticBooleanField(BaseVM vm, DvmClass dvmClass, String signature) &#123; switch (signature) &#123; case &quot;com&#x2F;xingin&#x2F;shield&#x2F;http&#x2F;ContextHolder-&gt;sExperiment:Z&quot;: return true; &#125; return super.getStaticBooleanField(vm, dvmClass, signature);&#125; initialize1234567public XhsHttpInterceptor(String str, a&lt;Request&gt; aVar) &#123; this.cPtr &#x3D; initialize(str); this.predicate &#x3D; aVar;&#125;public static XhsHttpInterceptor newInstance(String str, a&lt;Request&gt; aVar) &#123; return new XhsHttpInterceptor(str, aVar);&#125; 在XhsHttpInterceptor的newInstance查找用例找到b函数，直接传入的字符串为”main” 1234567891011121314&#x2F;&#x2F; 第二个初始化函数 public native long initialize(String str);public long callinitialize()&#123; List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;(10); list.add(vm.getJNIEnv()); &#x2F;&#x2F; 第一个参数是env list.add(0); &#x2F;&#x2F; 第二个参数，实例方法是jobject，静态方法是jclazz，直接填0，一般用不到。 list.add(vm.addLocalObject(new StringObject(vm, &quot;main&quot;))); Number number &#x3D; module.callFunction(emulator, 0x937B0+1, list.toArray())[0]; return number.longValue();&#125;public static void main(String[] args) &#123; XhsShield test &#x3D; new XhsShield(); test.callinitializeNative(); long ptr &#x3D; test.callinitialize();&#125; 123456789@Overridepublic DvmObject&lt;?&gt; callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;java&#x2F;nio&#x2F;charset&#x2F;Charset-&gt;defaultCharset()Ljava&#x2F;nio&#x2F;charset&#x2F;Charset;&quot;: &#123; return vm.resolveClass(&quot;java&#x2F;nio&#x2F;charset&#x2F;Charset&quot;).newObject(Charset.defaultCharset()); &#125; &#125; return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList);&#125; Context.getSharedPreferences(String name,int mode)**获取一个SharedPreferences实例，name文件名称，不需要加后缀.xml，一般这个文件存储在/data/data//shared_prefs**下，mode指读写权限，从jnitrace中查看jstring为0x11，jint为0，断点调试jstring就是”s”，DvmObject对象是Unidbg抽象出来的一个JNI交互的对象，给他一个这样的对象都不会报错，这个值后面要用到所以不能newObject(null)。 123456789@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;android&#x2F;content&#x2F;Context-&gt;getSharedPreferences(Ljava&#x2F;lang&#x2F;String;I)Landroid&#x2F;content&#x2F;SharedPreferences;&quot;: return vm.resolveClass(&quot;android&#x2F;content&#x2F;SharedPreferences&quot;).newObject(vaList.getObjectArg(0)); &#125; return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125; 123456789101112131415161718192021&#x2F;&#x2F; ???为什么main返回空，main_hmac返回s.xml的内容@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123; switch (signature) &#123; &#x2F;&#x2F; android.content.SharedPreferences android.content.Context.getSharedPreferences(java.lang.String, int) case &quot;android&#x2F;content&#x2F;Context-&gt;getSharedPreferences(Ljava&#x2F;lang&#x2F;String;I)Landroid&#x2F;content&#x2F;SharedPreferences;&quot;: return vm.resolveClass(&quot;android&#x2F;content&#x2F;SharedPreferences&quot;).newObject(vaList.getObjectArg(0)); case &quot;android&#x2F;content&#x2F;SharedPreferences-&gt;getString(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;: &#123; if(((StringObject) dvmObject.getValue()).getValue().equals(&quot;s&quot;))&#123; System.out.println(&quot;getString :&quot;+vaList.getObjectArg(0).getValue()); if (vaList.getObjectArg(0).getValue().equals(&quot;main&quot;)) &#123; return new StringObject(vm, &quot;&quot;); &#125; if(vaList.getObjectArg(0).getValue().equals(&quot;main_hmac&quot;))&#123; return new StringObject(vm, &quot;hmLDH4NVbddu&#x2F;qNZWZj80kqBVKWrexc+1w3zCF0FCNQ03x3a9o9RsHcP2e1LwpK0gPbC4nHeU9dU2d0hyOhPElbIBZlNMjj9HRCCNMmb0uRWywu1tq3IvjogrlLosRl5&quot;); &#125; &#125; &#125; &#125; return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125; intercept该函数中完成了请求与响应，所以必然会出现shield的生成。 1234567891011121314151617&#x2F;&#x2F; 目标函数 public Response intercept(Interceptor.Chain chain)public void callintercept(long ptr)&#123; List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;(10); list.add(vm.getJNIEnv()); &#x2F;&#x2F; 第一个参数是env list.add(0); &#x2F;&#x2F; 第二个参数，实例方法是jobject，静态方法是jclazz，直接填0，一般用不到。 DvmObject&lt;?&gt; chain &#x3D; vm.resolveClass(&quot;okhttp3&#x2F;Interceptor$Chain&quot;).newObject(null); list.add(vm.addLocalObject(chain)); list.add(ptr); module.callFunction(emulator, 0x939D8 + 1, list.toArray());&#125;&#x2F;&#x2F; jadx中分析调用initialize得到的结果作为参数传入intercept函数中public static void main(String[] args) &#123; XhsShield test &#x3D; new XhsShield(); test.callinitializeNative(); long ptr &#x3D; test.callinitialize(); test.callintercept(ptr);&#125; 12345678&#x2F;&#x2F; ??? request哪里来request &#x3D; new Request.Builder() .url(&quot;https:&#x2F;&#x2F;edith.xiaohongshu.com&#x2F;api&#x2F;sns&#x2F;v6&#x2F;homefeed?oid&#x3D;homefeed_recommend&amp;cursor_score&#x3D;&amp;geo&#x3D;eyJsYXRpdHVkZSI6MC4wMDAwMDAsImxvbmdpdHVkZSI6MC4wMDAwMDB9%0A&amp;trace_id&#x3D;3eb910d5-a037-3076-92d3-739e2d02e3e0&amp;note_index&#x3D;0&amp;refresh_type&#x3D;1&amp;client_volume&#x3D;0.00&amp;preview_ad&#x3D;&amp;loaded_ad&#x3D;%7B%22ads_id_list%22%3A%5B%5D%7D&amp;personalization&#x3D;1&amp;pin_note_id&#x3D;&amp;pin_note_source&#x3D;&amp;unread_begin_note_id&#x3D;620cc5700000000021036137&amp;unread_end_note_id&#x3D;6203bff30000000021039a28&amp;unread_note_count&#x3D;6&quot;) .addHeader(&quot;xy-common-params&quot;, &quot;fid&#x3D;164554128510caadf802049b8d38a1ca58cbf294b8d2&amp;device_fingerprint&#x3D;20220222224814dd7db8705f0befea0b24b13732c811a70164bde096a4c7f6&amp;device_fingerprint1&#x3D;20220222224814dd7db8705f0befea0b24b13732c811a70164bde096a4c7f6&amp;launch_id&#x3D;1645664833&amp;tz&#x3D;Asia%2FShanghai&amp;channel&#x3D;YingYongBao&amp;versionName&#x3D;6.73.0&amp;deviceId&#x3D;145b5374-b973-38d1-8299-eb98f9d950ce&amp;platform&#x3D;android&amp;sid&#x3D;session.1645766627567507884448&amp;identifier_flag&#x3D;0&amp;t&#x3D;1645784087&amp;project_id&#x3D;ECFAAF&amp;build&#x3D;6730157&amp;x_trace_page_current&#x3D;explore_feed&amp;lang&#x3D;zh-Hans&amp;app_id&#x3D;ECFAAF01&amp;uis&#x3D;light&quot;) .build();case &quot;okhttp3&#x2F;Interceptor$Chain-&gt;request()Lokhttp3&#x2F;Request;&quot;: &#123; return vm.resolveClass(&quot;okhttp3&#x2F;Request&quot;).newObject(request);&#125; 12345&#x2F;&#x2F; ??? 为什么url为request的urlcase &quot;okhttp3&#x2F;Request-&gt;url()Lokhttp3&#x2F;HttpUrl;&quot;: &#123; Request request &#x3D; (Request) dvmObject.getValue(); return vm.resolveClass(&quot;okhttp3&#x2F;HttpUrl&quot;).newObject(request.url());&#125; 12345case &quot;com&#x2F;xingin&#x2F;shield&#x2F;http&#x2F;Base64Helper-&gt;decode(Ljava&#x2F;lang&#x2F;String;)[B&quot;:&#123; String input &#x3D; (String) vaList.getObjectArg(0).getValue(); byte[] result &#x3D; Base64.decodeBase64(input); return new ByteArray(vm, result);&#125; 1234case &quot;okhttp3&#x2F;HttpUrl-&gt;encodedPath()Ljava&#x2F;lang&#x2F;String;&quot;: &#123; HttpUrl httpUrl &#x3D; (HttpUrl) dvmObject.getValue(); return new StringObject(vm, httpUrl.encodedPath());&#125; 1234case &quot;okhttp3&#x2F;HttpUrl-&gt;encodedQuery()Ljava&#x2F;lang&#x2F;String;&quot;: &#123; HttpUrl httpUrl &#x3D; (HttpUrl) dvmObject.getValue(); return new StringObject(vm, httpUrl.encodedQuery());&#125; 1234case &quot;okhttp3&#x2F;Request-&gt;body()Lokhttp3&#x2F;RequestBody;&quot;: &#123; Request request &#x3D; (Request) dvmObject.getValue(); return vm.resolveClass(&quot;okhttp3&#x2F;RequestBody&quot;).newObject(request.body());&#125; 1234case &quot;okhttp3&#x2F;Request-&gt;headers()Lokhttp3&#x2F;Headers;&quot;: &#123; Request request &#x3D; (Request) dvmObject.getValue(); return vm.resolveClass(&quot;okhttp3&#x2F;Headers&quot;).newObject(request.headers());&#125; 12345678@Overridepublic DvmObject&lt;?&gt; newObjectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123; switch (signature)&#123; case &quot;okio&#x2F;Buffer-&gt;&lt;init&gt;()V&quot;: return dvmClass.newObject(new Buffer()); &#125; return super.newObjectV(vm, dvmClass, signature, vaList);&#125; 123456case &quot;okio&#x2F;Buffer-&gt;writeString(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;nio&#x2F;charset&#x2F;Charset;)Lokio&#x2F;Buffer;&quot;: &#123; System.out.println(&quot;write to my buffer:&quot;+vaList.getObjectArg(0).getValue()); Buffer buffer &#x3D; (Buffer) dvmObject.getValue(); buffer.writeString(vaList.getObjectArg(0).getValue().toString(), (Charset) vaList.getObjectArg(1).getValue()); return dvmObject;&#125; 123case &quot;okhttp3&#x2F;Headers-&gt;size()I&quot;: Headers headers &#x3D; (Headers) dvmObject.getValue(); return headers.size(); 1234case &quot;okhttp3&#x2F;Headers-&gt;name(I)Ljava&#x2F;lang&#x2F;String;&quot;: &#123; Headers headers &#x3D; (Headers) dvmObject.getValue(); return new StringObject(vm, headers.name(vaList.getIntArg(0)));&#125; 1234case &quot;okhttp3&#x2F;Headers-&gt;value(I)Ljava&#x2F;lang&#x2F;String;&quot;: &#123; Headers headers &#x3D; (Headers) dvmObject.getValue(); return new StringObject(vm, headers.value(vaList.getIntArg(0)));&#125; 123456789101112case &quot;okhttp3&#x2F;RequestBody-&gt;writeTo(Lokio&#x2F;BufferedSink;)V&quot;: &#123; BufferedSink bufferedSink &#x3D; (BufferedSink) vaList.getObjectArg(0).getValue(); RequestBody requestBody &#x3D; (RequestBody) dvmObject.getValue(); if(requestBody !&#x3D; null)&#123; try &#123; requestBody.writeTo(bufferedSink); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return;&#125; 1234case &quot;okio&#x2F;Buffer-&gt;clone()Lokio&#x2F;Buffer;&quot;: &#123; Buffer buffer &#x3D; (Buffer) dvmObject.getValue(); return vm.resolveClass(&quot;okio&#x2F;Buffer&quot;).newObject(buffer.clone());&#125; 123case &quot;okio&#x2F;Buffer-&gt;read([B)I&quot;: Buffer buffer &#x3D; (Buffer) dvmObject.getValue(); return buffer.read((byte[]) vaList.getObjectArg(0).getValue()); 1234case &quot;okhttp3&#x2F;Request-&gt;newBuilder()Lokhttp3&#x2F;Request$Builder;&quot;: &#123; Request request &#x3D; (Request) dvmObject.getValue(); return vm.resolveClass(&quot;okhttp3&#x2F;Request$Builder&quot;).newObject(request.newBuilder());&#125; 12345678case &quot;okhttp3&#x2F;Request$Builder-&gt;header(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)Lokhttp3&#x2F;Request$Builder;&quot;: &#123; Request.Builder builder &#x3D; (Request.Builder) dvmObject.getValue(); builder.header(vaList.getObjectArg(0).getValue().toString(), vaList.getObjectArg(1).getValue().toString()); if(&quot;shield&quot;.equals(vaList.getObjectArg(0).getValue().toString()))&#123; shield &#x3D; vaList.getObjectArg(1).getValue().toString(); &#125; return dvmObject;&#125; 1234case &quot;okhttp3&#x2F;Request$Builder-&gt;build()Lokhttp3&#x2F;Request;&quot;: &#123; Request.Builder builder &#x3D; (Request.Builder) dvmObject.getValue(); return vm.resolveClass(&quot;okhttp3&#x2F;Request&quot;).newObject(builder.build());&#125; 123case &quot;okhttp3&#x2F;Interceptor$Chain-&gt;proceed(Lokhttp3&#x2F;Request;)Lokhttp3&#x2F;Response;&quot;: &#123; return vm.resolveClass(&quot;okhttp3&#x2F;Response&quot;).newObject(null);&#125; 12case &quot;okhttp3&#x2F;Response-&gt;code()I&quot;: return 200; Unidbg-server经过一番getStaticObjectField补环境，终于拿到了shield，保存在静态变量中，引入unidbg-server 12345678910111213@RequestMapping(value &#x3D; &quot;xhs&quot;, method &#x3D; &#123;RequestMethod.GET, RequestMethod.POST&#125;)public String xhsShield() &#123; String url &#x3D; &quot;https:&#x2F;&#x2F;edith.xiaohongshu.com&#x2F;api&#x2F;sns&#x2F;v6&#x2F;homefeed?oid&#x3D;homefeed_recommend&amp;cursor_score&#x3D;&amp;geo&#x3D;eyJsYXRpdHVkZSI6MC4wMDAwMDAsImxvbmdpdHVkZSI6MC4wMDAwMDB9%0A&amp;trace_id&#x3D;3eb910d5-a037-3076-92d3-739e2d02e3e0&amp;note_index&#x3D;0&amp;refresh_type&#x3D;1&amp;client_volume&#x3D;0.00&amp;preview_ad&#x3D;&amp;loaded_ad&#x3D;%7B%22ads_id_list%22%3A%5B%5D%7D&amp;personalization&#x3D;1&amp;pin_note_id&#x3D;&amp;pin_note_source&#x3D;&amp;unread_begin_note_id&#x3D;620cc5700000000021036137&amp;unread_end_note_id&#x3D;6203bff30000000021039a28&amp;unread_note_count&#x3D;6&quot;; String commonParams &#x3D; &quot;fid&#x3D;164554128510caadf802049b8d38a1ca58cbf294b8d2&amp;device_fingerprint&#x3D;20220222224814dd7db8705f0befea0b24b13732c811a70164bde096a4c7f6&amp;device_fingerprint1&#x3D;20220222224814dd7db8705f0befea0b24b13732c811a70164bde096a4c7f6&amp;launch_id&#x3D;1645664833&amp;tz&#x3D;Asia%2FShanghai&amp;channel&#x3D;YingYongBao&amp;versionName&#x3D;6.73.0&amp;deviceId&#x3D;145b5374-b973-38d1-8299-eb98f9d950ce&amp;platform&#x3D;android&amp;sid&#x3D;session.1645766627567507884448&amp;identifier_flag&#x3D;0&amp;t&#x3D;1645784087&amp;project_id&#x3D;ECFAAF&amp;build&#x3D;6730157&amp;x_trace_page_current&#x3D;explore_feed&amp;lang&#x3D;zh-Hans&amp;app_id&#x3D;ECFAAF01&amp;uis&#x3D;light&quot;; String platformInfo &#x3D; &quot;platform&#x3D;android&amp;build&#x3D;6730157&amp;deviceId&#x3D;145b5374-b973-38d1-8299-eb98f9d950ce&quot;; XhsShield xhs &#x3D; new XhsShield(); String shield &#x3D; xhs.getShield(); Map&lt;String, String&gt; headMap &#x3D; new HashMap&lt;&gt;(); headMap.put(&quot;xy-common-params&quot;,commonParams); headMap.put(&quot;shield&quot;,shield); headMap.put(&quot;xy-platform-info&quot;,platformInfo); return httpGet(url,null, headMap);&#125; objection hook构造函数的方法 1.9.6版本以前/root/.pyenv/versions/3.8.0/lib/python3.8/site-packages/objection/agent.js的9211行 1.9.6版本以后/root/.pyenv/versions/3.8.0/lib/python3.8/site-packages/objection/agent.js的20238行 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"unidbg","slug":"unidbg","permalink":"http://onejane.github.io/tags/unidbg/"},{"name":"ida","slug":"ida","permalink":"http://onejane.github.io/tags/ida/"},{"name":"frida_hook_libart","slug":"frida-hook-libart","permalink":"http://onejane.github.io/tags/frida-hook-libart/"},{"name":"unidbg-server","slug":"unidbg-server","permalink":"http://onejane.github.io/tags/unidbg-server/"}]},{"title":"SO逆向之大众点评cx","slug":"SO逆向之大众点评cx","date":"2022-02-07T11:27:28.000Z","updated":"2022-02-21T17:57:39.189Z","comments":true,"path":"2022/02/07/SO逆向之大众点评cx/","link":"","permalink":"http://onejane.github.io/2022/02/07/SO%E9%80%86%E5%90%91%E4%B9%8B%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84cx/","excerpt":"","text":"抓包10.37.13打开首页一篇文章，APP默认TCP连接，通过降级采用HTTP连接 jadx反编译代码中 1234567891011121314151617public int g() &#123; Object[] objArr &#x3D; new Object[0]; ChangeQuickRedirect changeQuickRedirect &#x3D; a; if (PatchProxy.isSupport(objArr, this, changeQuickRedirect, false, &quot;18c862d70fb657f32643dbd9124704f9&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123; return ((Integer) PatchProxy.accessDispatch(objArr, this, changeQuickRedirect, false, &quot;18c862d70fb657f32643dbd9124704f9&quot;)).intValue(); &#125; if (&quot;cip&quot;.equals(this.d)) &#123; return 2; &#125; if (&quot;http&quot;.equals(this.d)) &#123; return 3; &#125; if (&quot;wns&quot;.equals(this.d)) &#123; return 4; &#125; return 2;&#125; 绕过CIP和WNS代理，直接走HTTP通道 123456789101112131415var nvnetwork_g &#x3D; Java.use(&quot;com.dianping.nvnetwork.g&quot;);nvnetwork_g.g.overload().implementation &#x3D; function()&#123; console.log(&quot;----------------------------- Hook g()---------------------------&quot;); return 3;&#125;var URL &#x3D; Java.use(&#39;java.net.URL&#39;);URL.openConnection.overload().implementation &#x3D; function () &#123; var retval &#x3D; this.openConnection(); if (retval.toString().indexOf(&quot;getfeedcontent.bin&quot;) &gt;&#x3D; 0) &#123; console.log(&#39;URL openConnection&#39; + retval); var stack &#x3D; threadinstance.currentThread().getStackTrace(); console.log(&quot;&gt;&gt;&gt; openConnection Full call stack:&quot; + Where(stack)); &#125; return retval;&#125;; https://mapi.dianping.com/mapi/note/getfeedcontent.bin mainid 1022239297 feedtype 1 lng 120.657842 lat 31.247756 displaypattern 1 firstimagekey 354e9fb1c37f37e0545c4920b2836838 bubblepagetype null cx d41bgtHhx7iFJPuvzpwy8iFLnCFMXM6fS2yctn2WPbzFlem8iZNRzE8dwDdAJBizjPObdAdd9l4E /WPkVpzZ98H4AxJuoHD/jua2n0MFnYR2gOrNM9S2f+4YYbH/AXnoFwkOouAyK0cp1tLnIBLtRSj7 Z8CMpInn86vqR4RAen4TJgnPLuExYMlrkn4rsakNnoNIVJY5w9SOTupr++Rejmp962pdQG233hW9 mLkZGe68MNPRZ8pVKVz5320QB6Z6E/2K8aqtWUKaERSx+Dxte4Nfkg74pxM41CG+Airu4b5qB9hx VWKFIS+t9UzxCH0/z2MNFKaNB1fcWX0SBTaa6TfYZ5F6K1eOmtzUlhTKNHYZJCa3fvpaxdNEqI1I 7olz8l1n3qJBlRxJgBMFKQ/EFgFyebeQd3LqD5jovyEJxbq9kDGdL8Y3M4hHXFlsVRVnWBFN43SC cAqjycYOeMWmLOuJm2Foy8L8VdNuWxDDmnAb++cNSPW7voFgKJuBLKQcCKxtStDUTnqlLpNzKCw0 iyQe3vC0+OcKDK+pdedg0PEAciOMwTOPF+dNtOoXzzY2dQgSCplchcoiOX2f7pRpwxfL6KjcAEnE Xv0YFXusECmFTnEGiLJGs5JouMKUY80CIrBQ+5VlS3rbmCPbcZm8eC9cqEDPqhBcsKvgeEkvvwO6 129IdRjDRPCFpJvh6TZPCsZRTFIU56qoFVI/KNzNoPwZZEjWi0k7XjDmKMEjTc2d2Ut/aC/AclQn /26saBqm7Xt7aI7xPieS59EsU14ZRmhlf4dHq4xm/NmihVazMnkM0p60PRoOvC39KIi8WOvAJxYG xByMV3bGgY71PXSijjUhrXZA8KSaJiaLiCNvyoOJ6kdQwjCCgz2KPMEQwIVjkMTNzJh6rCFG1E2N PRl2TwyZHxWrGJVRMD807JK4CCcqkyDqrML//n0NoSC+UTxiTmtFrmvkT90rhOJJkggvfGWrbyiV x/BXn9AMjslSvYyzmgyNqLJZHaou8ajJ6ZCX19v+DuDQReYnnO4MlZ8rgSS7dvffh3VsJy8lR3Ts ii6S2VnKby0g6orLOYpUlq2tu7nIGoKzyNgZ27sBpB/FDT9k5gNVqXg2cDw2l7Ycgv29iPq+Dl6j TS+8ULvdfUUHqKVeRUeRrU9bxE3EUVoJkhQ/LL238Zs7nvYgG+vNaaasgCij6knihj/8tZ8vsZoN CJFbY0Zu0gLxu6ZFWYqpji6/ojhQj8T+dMEGGrqa29LJUEQo7GCrPX8jRZSPeF/d1aFekuI2QIbg IkhMe+9d32653h5FTuw78ix93ZYLM7TkDeBtHnUM0hV2/J1PYKjfebOoAQ9ATh+Ac98cFI7aL9fo 8GfuOWq1PwjI3hPl1euO09Gv1jHX7nbWTbAIfnjTD1m87IgB0j2A4jTp2ZofpGdwYdOd34Y021cj tr2A+cAC2Mk06CGcJB2NWxOzgxHJTc9ikjsP14qGbcZwLFf8KHRtAS2Lkt3hg2P1Go6Kv7GNcTup 3spjhYRPnXqFQYGpSqGhAzZogs2xI/yRDT7KPN7N/XEuLm4wM9HLUX2/3YU4ZoF8FpphZulI7PhE vZJyGtcXd01XdgMe8P1RDKWez2ce7FTGJ234HDStT9TKkJIQxcgmLx/UDRrDoahf9tJCE9atGnTm fX3m1SAX6GoFCzY3IbnjxNyVHGvKgAq/ZtzupezB33437yeQ8RzNnj2/mKB8uXQpLORzI1Wez4b9 DypcRF0F5dwwfCZdQqEwhkh3CBa8dHSbnAokTGqltcb2/s6NAVzCYp2CJeO5y0Z7gIxhWLtDYBvg duTy7LbacIWgrGzkCMYfY3RibFackLnWb3GJDlYXz1Ei2FxjOrVc+iiDj2wdoYYL85qi/alERJ8y k21JbuD3+DBcROi3BNnJm3zQ39/mOjDIAR+TWMSG7TeC8S4lVntgFD7VdnqKcPNyTUYxfH7fzxKK VyiUxxRl7/VOgiuLA0TWooPiMfV9OUq9gIdiP5J5z74cS24z5UWEakAuO5YVRhz193NeoAX3Lf1F Bym252MFE2xWBILikJ8eZBL8Apua8NgV27T+sPDnTKwSOuKfNmYaqimbJ1JHtbLCfEGkF6zAh7Ny WwyTLoyrjwudQ1QpXgIOwO1g46YR1RAuhVKXcbLLeBadrOH6LshMrPcoh7fmIQVZ2qne/Xtn7j0f 69mB9Lh0iGxI23sCJAZw9eXILtkhib2JDMXL7k0kbX9D14CJkWq7fPvu6NgufRJ9ZhQIF9vQwNmh YX9AOOOlnr80k06rtPTiSeO9vneMjRm0E+n4GlCIRAeoGO+7Ss6cBR2J2JaPDd+Mt/43wEMLr5dJ BJawsofyPMSsO7iPsfpm4okZfK0ZU9/RQRM2OiR/svZRblavlTcngzeDTJw3zh3TNtoWdRhUZDlX +hrLtyRx6vneN7k5CQAN0IUDhq1+H2xM0WSet11J11arnrSNk/z6hl0YfXNmYeMV4+QLOrfDkdY= pagecityid 6 optimus_partner 76 optimus_risk_level 71 optimus_code 10 picsize {“single”:{“width”:900,”height”:900},”many”:{“width”:500,”height”:500},”glance”:{“width”:1440,”minHeight”:810,”maxHeight”:1920}} pagesource 1 picscale 0.749651385199241 返回数据加密，但是展示时正常文字展示，说明数据在客户端被解密，monitor.bat 录制轨迹 12345678var MapiModuleCls &#x3D; Java.use(&#39;com.dianping.picasso.commonbridge.MapiModule&#39;);MapiModuleCls.resolveData.overload(&#39;com.dianping.archive.DPObject&#39;, &#39;boolean&#39;, &#39;int&#39;).implementation &#x3D; function (a, b, c) &#123; var result &#x3D; this.resolveData(a, b, c); console.log(&quot;resolveData rc&#x3D;&quot; + result+ &quot;&#x3D;&#x3D;&#x3D;boolean&#x3D;&#x3D;&#x3D;&quot; +b+&quot;&#x3D;&#x3D;&#x3D;int&#x3D;&#x3D;&#x3D;&quot; +c); var stack &#x3D; threadinstance.currentThread().getStackTrace(); console.log(&quot;&gt;&gt;&gt; resolveData Full call stack:&quot; + Where(stack)); return result;&#125; 上图类MapiModule中的fetch和fetchV2方法中的innerFetch方法中exec(this.host.getContext().getApplicationContext(), bVar2, bVar, z, hashMap, optInt2);的exec方法中调用了 MapiModule.this.resolveData((DPObject) gVar.b(), z, i) cx字段里面有两个比较明显的特征，大量含有 + / 这两个字符串，末尾是 ==，断定，这个cx字段是Base64字串。 123456789101112131415161718var Base64Class &#x3D; Java.use(&quot;android.util.Base64&quot;);Base64Class.encodeToString.overload(&#39;[B&#39;, &#39;int&#39;).implementation &#x3D; function (a, b) &#123; var result &#x3D; this.encodeToString(a, b); if (result.indexOf(&quot;d41bgtH&quot;) &gt;&#x3D; 0) &#123; console.log(&quot;Base64 1 rc&#x3D;&quot; + result); var stack &#x3D; threadinstance.currentThread().getStackTrace(); console.log(&quot;&gt;&gt;&gt; Base64 Full call stack:&quot; + Where(stack)); &#125; return result;&#125;Base64Class.encodeToString.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (a, b, c, d) &#123; var result &#x3D; this.encodeToString(a, b, c, d); console.log(&quot;Base64 2 rc&#x3D;&quot; + result); return result;&#125; jadx直接查看com.meituan.android.common.fingerprint.encrypt.DESHelper.encryptByPublic 123456var fingerprintCls &#x3D; Java.use(&#39;com.meituan.android.common.fingerprint.encrypt.DESHelper&#39;);fingerprintCls.encryptByPublic.implementation &#x3D; function(a,b)&#123; var result &#x3D; this.encryptByPublic(a,b); console.log(&#39;encryptByPublic inbuf&#x3D; &#39;+ a +&#39;,key&#x3D;&#39;+b +&#39;,outBuf&#x3D;&#39; + result); return result;&#125; 拿到key和strInBuf，即dESKeySpec和secretKey 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.security.Key;import java.util.Base64;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;import javax.crypto.spec.IvParameterSpec;public class Main &#123; public static void main(String[] args) &#123; String strInBuf &#x3D; &quot;d41bgtHhx7iFJPuvzpwy...9jFK8DgJ63ysfpx6KvdxodXzD7cg+sAikWZ1&#x2F;iX1I0P&#x2F;XNuAAj0&#x2F;QApN25mtLQ&#x3D;&#x3D;&quot;; String key &#x3D; &quot;kwBq8snI&quot;; String strOut &#x3D; &quot;&quot;; try &#123; byte[] base64decodedBytes &#x3D; Base64.getDecoder().decode(strInBuf); DESKeySpec dESKeySpec; SecretKey secretKey &#x3D; null; dESKeySpec &#x3D; new DESKeySpec(key.getBytes()); secretKey &#x3D; SecretKeyFactory.getInstance(&quot;DES&quot;).generateSecret(dESKeySpec); Cipher instance &#x3D; Cipher.getInstance(&quot;DES&#x2F;CBC&#x2F;PKCS5Padding&quot;); instance.init(2, secretKey, new IvParameterSpec(dESKeySpec.getKey())); strOut &#x3D; new String(instance.doFinal(base64decodedBytes)); &#x2F;* com.dianping.nvnetwork.tunnel.tool.c 的加密数据 解密 strInBuf &#x3D; &quot;EcFKDV1V&#x2F;3X2+rkklRGVjOnl9sRyHe3e+4OFRvluXA+R+1lns804Ew1STfKND1mPA7mQa8cOm0sn3zHuA6Kp58lSRmaeHlH4mlpg3YzWyPDtfOChpOwC4RjRKXargIjpCDnol++yP92Y2L8fCRDL9LtX5KJQDiQa&quot;; key &#x3D;&quot;&quot;1nzbcvFS1LCtoNHr&quot;; Key a &#x3D; SecretKeyFactory.getInstance(&quot;DES&quot;).generateSecret(new DESKeySpec(key.getBytes())); Cipher instance &#x3D; Cipher.getInstance(&quot;DES&quot;); &#x2F;&#x2F; Cipher.ENCRYPT_MODE 1 加密 &#x2F;&#x2F; Cipher.DECRYPT_MODE 2 解密 instance.init(2, a); strOut &#x3D; new String(instance.doFinal(base64decodedBytes)); *&#x2F; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(strOut); &#125;&#125; var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"SO","slug":"SO","permalink":"http://onejane.github.io/tags/SO/"}]},{"title":"SO逆向之某bili的sign分析","slug":"SO逆向之某bili的sign分析","date":"2022-01-10T04:43:37.000Z","updated":"2022-03-05T13:50:52.482Z","comments":true,"path":"2022/01/10/SO逆向之某bili的sign分析/","link":"","permalink":"http://onejane.github.io/2022/01/10/SO%E9%80%86%E5%90%91%E4%B9%8B%E6%9F%90bili%E7%9A%84sign%E5%88%86%E6%9E%90/","excerpt":"","text":"主页抓包版本6.18.0 Charles本地证书 系统证书目录：/system/etc/security/cacerts/ 其中的每个证书的命名规则如下： . 文件名是一个Hash值，而后缀是一个数字。 文件名可以用下面的命令计算出来： openssl x509 -subject_hash_old -in 后缀名的数字是为了防止文件名冲突的，比如如果两个证书算出的Hash值是一样的话，那么一个证书的后缀名数字可以设置成0，而另一个证书的后缀名数字可以设置成1 安卓8 1234567cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o remount,rw &#x2F;mount -o remount,rw &#x2F;systemchmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o remount,ro &#x2F;mount -o remount,ro &#x2F;system 安卓7 1234567cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o rw,remount &#x2F;systemmount -o rw,remount &#x2F;chmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o ro,remount &#x2F;systemmount -o ro,remount &#x2F; 安卓10 Move_Certificates-v1.9 直接面具插件安排，重启即可 重启 appkey 1d8b6e7d45233436 build 6180500 c_locale zh-Hans_CN channel shenma069 duration 0 fnval 400 fnver 0 force_host 0 fourk 1 from_source app_search highlight 1 is_org_query 0 keyword 666 local_time 8 mobi_app android platform android player_net 1 pn 1 ps 20 qn 32 recommend 1 s_locale zh-Hans_CN statistics {“appId”:1,”platform”:3,”version”:”6.18.0”,”abtest”:””} ts 1641789657 sign 057565a1251d32fec516abcf65b75123 分析定位1frida -UF -l okhttp_poker.js 抓包 本app被混淆，尝试trace选中的类 1frida -UF -l r0tracer.js -o bilibili.txt 查看方法 com.bilibili.okretro.f.a.a 查看 d(a0Var.k(), h); 查看 b(hashMap); ， 该方法中只是把部分参数放到map里，不包括sign 查看 SignedQuery h = h(hashMap); 看着像是生成sign的地方 123public SignedQuery h(Map&lt;String, String&gt; map) &#123; return LibBili.g(map);&#125; 查看com.bilibili.nativelibrary.LibBili，目测在libbili.so中 123456789public static final String G &#x3D; &quot;bili&quot;;static &#123; c.c(PlayIndex.G);&#125;public static SignedQuery g(Map&lt;String, String&gt; map) &#123; return s(map &#x3D;&#x3D; null ? new TreeMap() : new TreeMap(map));&#125;static native SignedQuery s(SortedMap&lt;String, String&gt; sortedMap); 定位com.bilibili.nativelibrary.LibBili.s，直接hook之 1234567891011121314151617biliNative.s.implementation &#x3D; function (map) &#123; var result &#x3D; this.s(map); var keyStr &#x3D; &quot;&quot; var keys &#x3D; map.keySet(); var key_set &#x3D; keys.iterator(); while (key_set.hasNext()) &#123; var key &#x3D; key_set.next().toString(); keyStr +&#x3D; &quot;,&quot; + key &#125; console.log(&quot;keyStr&#x3D;&#x3D;&#x3D;&quot;+keyStr) console.log(map.values().toArray()); console.log(&quot;biliNative s(&quot; + map + &quot;) &#x3D; &quot; + result); return result;&#125; frida-trace -UF -i “Java_com*” 判断是静态注册 frida -U -f tv.danmaku.bili -l hook_RegisterNatives.js –no-pause -o bilibili.txt 判断动态注册，搜索com.bilibili.nativelibrary.LibBili 如果太多可以尝试修改hook_RegisterNatives.js Frida1234567891011121314var threadef &#x3D; Java.use(&#39;java.lang.Thread&#39;);var threadinstance &#x3D; threadef.$new();Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;r0gson.dex&quot;).load();var Gson &#x3D; Java.use(&#39;com.r0ysue.gson.Gson&#39;);var LibBili &#x3D; Java.use(&#39;com.bilibili.nativelibrary.LibBili&#39;);LibBili.g.implementation &#x3D; function (a) &#123; console.log(&quot;SignedQuery param:&quot; + Gson.$new().toJson(a)); var stack &#x3D; threadinstance.currentThread().getStackTrace(); console.log(&quot;Full call stack:&quot; + Where(stack)); var result &#x3D; this.g(a); console.log(&quot;SignedQuery result:&quot; + Gson.$new().toJson(a)); return result;&#125; 参数： 12345678910111213141516171819202122232425&#123; &quot;appkey&quot;: &quot;1d8b6e7d45233436&quot;, &quot;build&quot;: &quot;6180500&quot;, &quot;c_locale&quot;: &quot;zh-Hans_CN&quot;, &quot;channel&quot;: &quot;shenma069&quot;, &quot;duration&quot;: &quot;0&quot;, &quot;fnval&quot;: &quot;400&quot;, &quot;fnver&quot;: &quot;0&quot;, &quot;force_host&quot;: &quot;0&quot;, &quot;fourk&quot;: &quot;1&quot;, &quot;from_source&quot;: &quot;app_search&quot;, &quot;highlight&quot;: &quot;1&quot;, &quot;is_org_query&quot;: &quot;0&quot;, &quot;keyword&quot;: &quot;666&quot;, &quot;local_time&quot;: &quot;8&quot;, &quot;mobi_app&quot;: &quot;android&quot;, &quot;platform&quot;: &quot;android&quot;, &quot;player_net&quot;: &quot;1&quot;, &quot;pn&quot;: &quot;1&quot;, &quot;ps&quot;: &quot;20&quot;, &quot;qn&quot;: &quot;32&quot;, &quot;recommend&quot;: &quot;1&quot;, &quot;s_locale&quot;: &quot;zh-Hans_CN&quot;, &quot;statistics&quot;: &quot;&#123;\\&quot;appId\\&quot;:1,\\&quot;platform\\&quot;:3,\\&quot;version\\&quot;:\\&quot;6.18.0\\&quot;,\\&quot;abtest\\&quot;:\\&quot;\\&quot;&#125;&quot;&#125; 返回结果： 1234&#123; &quot;a&quot;: &quot;appkey&#x3D;1d8b6e7d45233436&amp;build&#x3D;6180500&amp;c_locale&#x3D;zh-Hans_CN&amp;channel&#x3D;shenma069&amp;duration&#x3D;0&amp;fnval&#x3D;400&amp;fnver&#x3D;0&amp;force_host&#x3D;0&amp;fourk&#x3D;1&amp;from_source&#x3D;app_search&amp;highlight&#x3D;1&amp;is_org_query&#x3D;0&amp;keyword&#x3D;666&amp;local_time&#x3D;8&amp;mobi_app&#x3D;android&amp;platform&#x3D;android&amp;player_net&#x3D;1&amp;pn&#x3D;1&amp;ps&#x3D;20&amp;qn&#x3D;32&amp;recommend&#x3D;1&amp;s_locale&#x3D;zh-Hans_CN&amp;statistics&#x3D;%7B%22appId%22%3A1%2C%22platform%22%3A3%2C%22version%22%3A%226.18.0%22%2C%22abtest%22%3A%22%22%7D&amp;ts&#x3D;1641817162&quot;, &quot;b&quot;: &quot;2fafacb931ae2fa3c68818646bc41c47&quot;&#125; 在 SignedQuery h = h(hashMap);之后，q.h(h.toString()); sign就是返回结果中的b值 unidbg主动调用s 1234567891011121314151617181920public void s()&#123; List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;(10); list.add(vm.getJNIEnv()); &#x2F;&#x2F; 第一个参数是env list.add(0); &#x2F;&#x2F; 第二个参数，实例方法是jobject，静态方法是jclazz，直接填0，一般用不到 TreeMap&lt;String, String&gt; keymap &#x3D; new TreeMap&lt;String, String&gt;(); keymap.put(&quot;appkey&quot;, &quot;1d8b6e7d45233436&quot;); ... &#x2F;&#x2F; 封装字节数组 &#x2F;&#x2F; byte[] inputByte &#x3D; &quot;666&quot;.getBytes(StandardCharsets.UTF_8); &#x2F;&#x2F; ByteArray inputByteArray &#x3D; new ByteArray(vm,inputByte); &#x2F;&#x2F; 封装map→AbstractMap→TreeMap DvmClass Map &#x3D; vm.resolveClass(&quot;java&#x2F;util&#x2F;Map&quot;); DvmClass AbstractMap &#x3D; vm.resolveClass(&quot;java&#x2F;util&#x2F;AbstractMap&quot;,Map); DvmObject&lt;?&gt; input_map &#x3D; vm.resolveClass(&quot;java&#x2F;util&#x2F;TreeMap&quot;, AbstractMap).newObject(keymap); list.add(vm.addLocalObject(input_map)); &#x2F;&#x2F; RegisterNative(com&#x2F;bilibili&#x2F;nativelibrary&#x2F;LibBili, s(Ljava&#x2F;util&#x2F;SortedMap;)Lcom&#x2F;bilibili&#x2F;nativelibrary&#x2F;SignedQuery;, RX@0x40001c97[libbili.so]0x1c97) Number number &#x3D; module.callFunction(emulator, 0x1c97, list.toArray())[0]; DvmObject result &#x3D; vm.getObject(number.intValue());&#125; 报错：java/util/Map-&gt;isEmpty()Z 12345678@Overridepublic boolean callBooleanMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) &#123; if (&quot;java&#x2F;util&#x2F;Map-&gt;isEmpty()Z&quot;.equals(signature)) &#123; TreeMap&lt;String, String&gt; treeMap &#x3D; (TreeMap&lt;String, String&gt;)dvmObject.getValue(); return treeMap.isEmpty(); &#125; return super.callBooleanMethod(vm, dvmObject, signature, varArg);&#125; 报错：java/util/Map-&gt;get(Ljava/lang/Object;)Ljava/lang/Object; 123456789101112@Overridepublic DvmObject&lt;?&gt; callObjectMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) &#123; switch (signature) &#123; case &quot;java&#x2F;util&#x2F;Map-&gt;get(Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;lang&#x2F;Object;&quot;: StringObject keyobject &#x3D; varArg.getObjectArg(0); String key &#x3D; keyobject.getValue(); TreeMap&lt;String, String&gt; treeMap &#x3D; (TreeMap&lt;String, String&gt;) dvmObject.getValue(); String value &#x3D; treeMap.get(key); return new StringObject(vm, value); &#125; return super.callObjectMethod(vm, dvmObject, signature, varArg);&#125; 报错：com/bilibili/nativelibrary/SignedQuery-&gt;r(Ljava/util/Map;)Ljava/lang/String; 查看SignedQuery的r方法 还原如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class utils &#123; private static final char[] f14934c &#x3D; &quot;0123456789ABCDEF&quot;.toCharArray(); public static final String KEY_VALUE_DELIMITER &#x3D; &quot;&#x3D;&quot;; public static final String FIELD_DELIMITER &#x3D; &quot;&amp;&quot;; private static boolean a(char c2, String str) &#123; return (c2 &gt;&#x3D; &#39;A&#39; &amp;&amp; c2 &lt;&#x3D; &#39;Z&#39;) || (c2 &gt;&#x3D; &#39;a&#39; &amp;&amp; c2 &lt;&#x3D; &#39;z&#39;) || !((c2 &lt; &#39;0&#39; || c2 &gt; &#39;9&#39;) &amp;&amp; &quot;-_.~&quot;.indexOf(c2) &#x3D;&#x3D; -1 &amp;&amp; (str &#x3D;&#x3D; null || str.indexOf(c2) &#x3D;&#x3D; -1)); &#125; static String r(Map&lt;String, String&gt; map) &#123; String str; if (!(map instanceof SortedMap)) &#123; map &#x3D; new TreeMap(map); &#125; StringBuilder sb &#x3D; new StringBuilder(256); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; String key &#x3D; entry.getKey(); if (!key.isEmpty()) &#123; sb.append(b(key)); sb.append(KEY_VALUE_DELIMITER); String value &#x3D; entry.getValue(); if (value &#x3D;&#x3D; null) &#123; str &#x3D; &quot;&quot;; &#125; else &#123; str &#x3D; b(value); &#125; sb.append(str); sb.append(FIELD_DELIMITER); &#125; &#125; int length &#x3D; sb.length(); if (length &gt; 0) &#123; sb.deleteCharAt(length - 1); &#125; if (length &#x3D;&#x3D; 0) &#123; return null; &#125; return sb.toString(); &#125; static String b(String str) &#123; return c(str, null); &#125; static String c(String str, String str2) &#123; StringBuilder sb &#x3D; null; if (str &#x3D;&#x3D; null) &#123; return null; &#125; int length &#x3D; str.length(); int i2 &#x3D; 0; while (i2 &lt; length) &#123; int i3 &#x3D; i2; while (i3 &lt; length &amp;&amp; a(str.charAt(i3), str2)) &#123; i3++; &#125; if (i3 !&#x3D; length) &#123; if (sb &#x3D;&#x3D; null) &#123; sb &#x3D; new StringBuilder(); &#125; if (i3 &gt; i2) &#123; sb.append((CharSequence) str, i2, i3); &#125; i2 &#x3D; i3 + 1; while (i2 &lt; length &amp;&amp; !a(str.charAt(i2), str2)) &#123; i2++; &#125; byte[] bytes &#x3D; str.substring(i3, i2).getBytes(StandardCharsets.UTF_8); int length2 &#x3D; bytes.length; for (int i4 &#x3D; 0; i4 &lt; length2; i4++) &#123; sb.append(&#39;%&#39;); sb.append(f14934c[(bytes[i4] &amp; 240) &gt;&gt; 4]); sb.append(f14934c[bytes[i4] &amp; 15]); &#125; &#125; else if (i2 &#x3D;&#x3D; 0) &#123; return str; &#125; else &#123; sb.append((CharSequence) str, i2, length); return sb.toString(); &#125; &#125; return sb &#x3D;&#x3D; null ? str : sb.toString(); &#125;&#125; 补环境 123456789101112@Overridepublic DvmObject&lt;?&gt; callStaticObjectMethod(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) &#123; switch (signature)&#123; case &quot;com&#x2F;bilibili&#x2F;nativelibrary&#x2F;SignedQuery-&gt;r(Ljava&#x2F;util&#x2F;Map;)Ljava&#x2F;lang&#x2F;String;&quot;:&#123; DvmObject&lt;?&gt; mapObject &#x3D; varArg.getObjectArg(0); TreeMap&lt;String, String&gt; mymap &#x3D; (TreeMap&lt;String, String&gt;) mapObject.getValue(); String result &#x3D; utils.r(mymap); return new StringObject(vm, result); &#125; &#125; return super.callStaticObjectMethod(vm, dvmClass, signature, varArg);&#125; 报错：com/bilibili/nativelibrary/SignedQuery-&gt;&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;)V需要手动构建SignedQuery该方法 12345678910111213141516171819202122@Overridepublic DvmObject&lt;?&gt; newObject(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) &#123; switch (signature) &#123; case &quot;com&#x2F;bilibili&#x2F;nativelibrary&#x2F;SignedQuery-&gt;&lt;init&gt;(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)V&quot;: StringObject stringObject1 &#x3D; varArg.getObjectArg(0); StringObject stringObject2 &#x3D; varArg.getObjectArg(1); String str1 &#x3D; stringObject1.getValue(); String str2 &#x3D; stringObject2.getValue(); return vm.resolveClass(&quot;com&#x2F;bilibili&#x2F;nativelibrary&#x2F;SignedQuery&quot;).newObject(new SignedQuery(str1, str2)); &#125; return super.newObject(vm, dvmClass, signature, varArg);&#125;public class SignedQuery &#123; public final String a; public final String b; public SignedQuery(String str, String str2) &#123; this.a &#x3D; str; this.b &#x3D; str2; &#125;&#125; init中有两个参数，参数2就是sign。 Unidbg提供了另外一种模拟Native调用JAVA的方式——缺啥补啥，其原理是JAVA的反射 LibBili不继承自AbstractJni vm.setJni(this);改成vm.setDvmClassFactory(new ProxyClassFactory()); 报错：com.bilibili.nativelibrary.SignedQuery 从jadx中将类拷贝出来，补充环境SignedQuery.java 算法还原JNITrace**static native SignedQuery s(SortedMap&lt;String, String&gt; sortedMap);**，入参是map，返回是SignedQuery对象 根据上文动态注册的函数地址com.bilibili.nativelibrary.LibBili.s的偏移量为0x1c97,IDA打开G跳转到该方法 双击进入sub_2F88 修改sub_2F88函数，int __fastcall sub_2F88(JNIEnv *env, int *map, int a3, int a4) 12pip install jnitrace jnitrace -l libbili.so tv.danmaku.bili --ignore-vm Get开头的JNI方法用于从Java的类型中取数据，GetStringUTFChars取出Java字符串中内容，jstring指针转化成一个UTF-8格式的C字符串，返回native中的字符串，用完后还必须要调用对应的ReleaseStringUTFChars释放资源，否则会导致JVM内存泄露。 1const jchar * GetStringChars(JNIEnv *env, jstring str, jboolean *isCopy); libbili.so!0x309b 表示位于什么模块!偏移地址多少 12345678function call_LibBili_s() &#123; var keymap &#x3D; Java.use(&quot;java.util.TreeMap&quot;).$new(); ... var result &#x3D; Java.use(&quot;com.bilibili.nativelibrary.LibBili&quot;).s(keymap); &#x2F;&#x2F; 打印结果，不需要做什么额外处理，这儿会隐式调用toString。 console.log(&quot;\\n返回结果：&quot;, result); return result;&#125; 启动jnitrace后，frida -UF tv.danmaku.bili -l bilibili.js 主动调用call_LibBili_s,查看jnitrace的log，可以根据左侧的时间判断执行的顺序。 123456789 &#x2F;* TID 12745 *&#x2F;116155 ms [+] JNIEnv-&gt;CallBooleanMethod116155 ms |- JNIEnv* : 0xeb8c1c40116155 ms |- jobject : 0xc9120210116155 ms |- jmethodID : 0x6f69db60 &#123; isEmpty()Z &#125;116155 ms |&#x3D; jboolean : 0 &#123; false &#125;116155 ms ------------------------Backtrace------------------------116155 ms |-&gt; 0xbf86d697: libbili.so!0x6697 (libbili.so:0xbf867000) 第一个JNI调用是CallBooleanMethod，调用java中的方法返回布尔型在native中转换为jboolean，如上图显示为false。IDA G跳转到0x6697，F5进入伪代码，Y修改类型为JNIEnv* X查看sub_6680交叉的引用 一共有两处，其中有一处就是上文中的sub_2F88函数，由于jnitrace时返回false，直接走下面框选的逻辑代码。 继续跟进jnitrace，ExceptionCheck异常处理和检查，NewStringUTF获取到appkey变量名 1234567891011121314151617 &#x2F;* TID 12745 *&#x2F;116167 ms [+] JNIEnv-&gt;ExceptionCheck116167 ms |- JNIEnv* : 0xeb8c1c40116167 ms |&#x3D; jboolean : 0 &#123; false &#125;116167 ms ------------------------Backtrace------------------------116167 ms |-&gt; 0xbf86b39b: libbili.so!0x439b (libbili.so:0xbf867000) &#x2F;* TID 12745 *&#x2F;116179 ms [+] JNIEnv-&gt;NewStringUTF116179 ms |- JNIEnv* : 0xeb8c1c40116179 ms |- char* : 0xbf86a1e4116179 ms |: appkey116179 ms |&#x3D; jstring : 0x9 &#123; appkey &#125;116179 ms ------------------------Backtrace------------------------116179 ms |-&gt; 0xbf86a019: libbili.so!0x3019 (libbili.so:0xbf867000) jobject的地址0xc9120210，即上文中的map参数，第四个参数0x9就是上文中的appkey，翻译一下就是map.get(“appkey”) 12345678910 &#x2F;* TID 12745 *&#x2F;116191 ms [+] JNIEnv-&gt;CallObjectMethod116191 ms |- JNIEnv* : 0xeb8c1c40116191 ms |- jobject : 0xc9120210116191 ms |- jmethodID : 0x6f69db0c &#123; get(Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;lang&#x2F;Object; &#125;116191 ms |: jobject : 0x9116191 ms |&#x3D; jobject : 0x11 &#123; java&#x2F;lang&#x2F;Object &#125;116191 ms ------------------------Backtrace------------------------116191 ms |-&gt; 0xbf86d4dd: libbili.so!0x64dd (libbili.so:0xbf867000) 继续分析jnitrace，0x11就是上文中appkey对应的值，就是if(v13), 而0x29就是”ts”字符串，图中的框选就是map.get(&quot;ts&quot;)，并返回0x35，即ts的值 12345678910111213141516171819202122232425262728293031 &#x2F;* TID 12745 *&#x2F;116215 ms [+] JNIEnv-&gt;GetStringUTFChars116215 ms |- JNIEnv* : 0xeb8c1c40116215 ms |- jstring : 0x11 &#123; 1d8b6e7d45233436 &#125;116215 ms |- jboolean* : 0x0116215 ms |&#x3D; char* : 0xdc9954a0116215 ms ------------------------Backtrace------------------------116215 ms |-&gt; 0xbf86a03d: libbili.so!0x303d (libbili.so:0xbf867000) &#x2F;* TID 12745 *&#x2F;116226 ms [+] JNIEnv-&gt;NewStringUTF116226 ms |- JNIEnv* : 0xeb8c1c40116226 ms |- char* : 0xbf86a4ac116226 ms |: ts116226 ms |&#x3D; jstring : 0x29 &#123; ts &#125;116226 ms ------------------------Backtrace------------------------116226 ms |-&gt; 0xbf86a439: libbili.so!0x3439 (libbili.so:0xbf867000) &#x2F;* TID 12745 *&#x2F;116240 ms [+] JNIEnv-&gt;CallObjectMethod116240 ms |- JNIEnv* : 0xeb8c1c40116240 ms |- jobject : 0xc9120210116240 ms |- jmethodID : 0x6f69db0c &#123; get(Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;lang&#x2F;Object; &#125;116240 ms |: jobject : 0x29 &#123; java&#x2F;lang&#x2F;Object &#125;116240 ms |&#x3D; jobject : 0x35 &#123; java&#x2F;lang&#x2F;Object &#125;116240 ms ------------------------Backtrace------------------------116240 ms |-&gt; 0xbf86d4dd: libbili.so!0x64dd (libbili.so:0xbf867000) 进入sub_3414操作完后通过DeleteLocalRef释放ts和ts的值 123456789101112131415 &#x2F;* TID 12745 *&#x2F;116264 ms [+] JNIEnv-&gt;DeleteLocalRef116264 ms |- JNIEnv* : 0xeb8c1c40116264 ms |- jobject : 0x29116264 ms ------------------------Backtrace------------------------116264 ms |-&gt; 0xbf86a485: libbili.so!0x3485 (libbili.so:0xbf867000) &#x2F;* TID 12745 *&#x2F;116276 ms [+] JNIEnv-&gt;DeleteLocalRef116276 ms |- JNIEnv* : 0xeb8c1c40116276 ms |- jobject : 0x35116276 ms ------------------------Backtrace------------------------116276 ms |-&gt; 0xbf86a48d: libbili.so!0x348d (libbili.so:0xbf867000) 跟进jnitrace，调用java函数中的SignedQuery的r方法，主要作用将map转为&amp;连接的string 12345678910 &#x2F;* TID 12745 *&#x2F;116298 ms [+] JNIEnv-&gt;CallStaticObjectMethod116298 ms |- JNIEnv* : 0xeb8c1c40116298 ms |- jclass : 0x2ac6 &#123; com&#x2F;bilibili&#x2F;nativelibrary&#x2F;SignedQuery &#125;116298 ms |- jmethodID : 0xc1509ce4 &#123; r(Ljava&#x2F;util&#x2F;Map;)Ljava&#x2F;lang&#x2F;String; &#125;116298 ms |: jobject : 0xc9120210116298 ms |&#x3D; jobject : 0x25 &#123; java&#x2F;lang&#x2F;Object &#125;116298 ms ------------------------Backtrace------------------------116298 ms |-&gt; 0xbf86a077: libbili.so!0x3077 (libbili.so:0xbf867000) 将java中的返回jstring转为native中的c字符串 123456789 &#x2F;* TID 12745 *&#x2F;116324 ms [+] JNIEnv-&gt;GetStringUTFChars116324 ms |- JNIEnv* : 0xeb8c1c40116324 ms |- jstring : 0x25116324 ms |- jboolean* : 0x0116324 ms |&#x3D; char* : 0xbf010240116324 ms ------------------------Backtrace------------------------116324 ms |-&gt; 0xbf86a09b: libbili.so!0x309b (libbili.so:0xbf867000) 搜索jnitrace返回的log中0xdc9954a0是appkey的value，现在释放内存 123456789 &#x2F;* TID 12745 *&#x2F;116337 ms [+] JNIEnv-&gt;ReleaseStringUTFChars116337 ms |- JNIEnv* : 0xeb8c1c40116337 ms |- jstring : 0xdc9954a0 &#123; 1d8b6e7d45233436 &#125;116337 ms |- char* : 0xdc9954a0116337 ms |: 1d8b6e7d45233436116337 ms ------------------------Backtrace------------------------116337 ms |-&gt; 0xbf86a0b7: libbili.so!0x30b7 (libbili.so:0xbf867000) 继续跟进jnitrace返回的595697e093d51d09be188caa5e393015就是主动调用时返回的sign 123456789 &#x2F;* TID 12745 *&#x2F;116351 ms [+] JNIEnv-&gt;NewStringUTF116351 ms |- JNIEnv* : 0xeb8c1c40116351 ms |- char* : 0xc9120140116351 ms |: 595697e093d51d09be188caa5e393015116351 ms |&#x3D; jstring : 0x39 &#123; 595697e093d51d09be188caa5e393015 &#125;116351 ms ------------------------Backtrace------------------------116351 ms |-&gt; 0xbf86a1a5: libbili.so!0x31a5 (libbili.so:0xbf867000) IDA跳转到0x31a5,进入伪代码 后续只要调用创建SignedQuery，在init的时候的0x39返回sign，而0x25就是上面map拼接返回的字符串 1234567891011 &#x2F;* TID 12745 *&#x2F;116376 ms [+] JNIEnv-&gt;NewObject116376 ms |- JNIEnv* : 0xeb8c1c40116376 ms |- jclass : 0x2ac6 &#123; com&#x2F;bilibili&#x2F;nativelibrary&#x2F;SignedQuery &#125;116376 ms |- jmethodID : 0xc1509c74 &#123; &lt;init&gt;(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)V &#125;116376 ms |: jstring : 0x25116376 ms |: jstring : 0x39 &#123; 595697e093d51d09be188caa5e393015 &#125;116376 ms |&#x3D; jobject : 0x1116376 ms ------------------------Backtrace------------------------116376 ms |-&gt; 0xbf86a1cb: libbili.so!0x31cb (libbili.so:0xbf867000) 函数分析sub_34B8sub_34B8函数的参数就是传入的appkey的值和IDA中定义的appkey的值对比 1v15 &#x3D; sub_34B8(v33); sub_3414sub_3414是操作ts的值并释放ts 1sub_3414(env, map); sub_227C1sub_227C(v36); 通过h转为十六进制数，这四个是MD5状态变量，该方法就是MD5Init，初始化核心变量，装入标准的幻数。 常见的md5的c算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void MD5Init (MD5Context *context) &#123; context-&gt;count[0] &#x3D; context-&gt;count[1] &#x3D; 0; context-&gt;state[0] &#x3D; 0x67452301; context-&gt;state[1] &#x3D; 0xefcdab89; context-&gt;state[2] &#x3D; 0x98badcfe; context-&gt;state[3] &#x3D; 0x10325476;&#125;void MD5Update (MD5Context *context, unsigned char *input, unsigned int inputLen)&#123; unsigned int i, index, partLen; &#x2F;&#x2F; Compute number of bytes mod 64 index &#x3D; (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F); &#x2F;&#x2F; Update number of bits if ((context-&gt;count[0] +&#x3D; ((u32)inputLen &lt;&lt; 3)) &lt; ((u32)inputLen &lt;&lt; 3)) context-&gt;count[1]++; context-&gt;count[1] +&#x3D; ((u32)inputLen &gt;&gt; 29); partLen &#x3D; 64 - index; &#x2F;&#x2F;Transform as many times as possible. if (inputLen &gt;&#x3D; partLen) &#123; memcpy((unsigned char *)&amp;context-&gt;buffer[index], (unsigned char *)input, partLen); MD5Transform (context-&gt;state, context-&gt;buffer); for (i &#x3D; partLen; i + 63 &lt; inputLen; i +&#x3D; 64) &#123; MD5Transform (context-&gt;state, &amp;input[i]); &#125; index &#x3D; 0; &#125; else i &#x3D; 0; &#x2F;&#x2F; Buffer remaining input memcpy((u8 *)&amp;context-&gt;buffer[index], (u8 *)&amp;input[i], inputLen-i);&#125;void MD5Final (u8 digest[16], MD5Context *context)&#123; unsigned char bits[8]; unsigned int index, padLen; &#x2F;&#x2F; Save number of bits memcpy(bits, context-&gt;count, 8); &#x2F;&#x2F; Pad out to 56 mod 64. index &#x3D; (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3f); padLen &#x3D; (index &lt; 56) ? (56 - index) : (120 - index); MD5Update (context, PADDING, padLen); &#x2F;&#x2F; Append length (before padding MD5Update (context, bits, 8); &#x2F;&#x2F;Store state in digest memcpy(digest, context-&gt;state, 16);&#125;int MD5MessageDigest(u8 *digest, u8 *buf, int len)&#123; MD5Context context; MD5Init (&amp;context); MD5Update (&amp;context, buf, len); MD5Final (digest, &amp;context); return 0;&#125; sub_22B0sub_22B0方法就是MD5Update，是MD5主计算过程，v36是context指针，v32是要变换的字节串，v27是长度。 1sub_22B0(v36, v32, v27); sub_2AE0sub_2AE0就是MD5Final，是整理和填写输出结果，v36是context指针，v37就是加密后的字符串 1sub_2AE0(v37, v36); 尝试hook MD5Update 1234567891011121314151617function hook_22B0() &#123; var libbili &#x3D; Module.findBaseAddress(&quot;libbili.so&quot;); if(libbili)&#123; &#x2F;&#x2F; 0x22b0 是 MD5Update 函数的地址，+1是因为指令是thumb模式 var md5_update &#x3D; libbili.add(0x22b0 + 1); Interceptor.attach(md5_update,&#123; onEnter:function (args) &#123; console.log(&quot;\\ncontents:&quot;); &#x2F;&#x2F; 这儿必须指定hexdump的length，hexdump默认长度256不足以显示全部内容 console.log(hexdump(args[1], &#123;length: args[2].toInt32()&#125;)); console.log(&quot;\\nLength:&quot;+args[2]); &#125;, onLeave:function (args) &#123; &#125; &#125;) &#125;&#125; 打印结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137contents: 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEFbd419000 61 64 5f 65 78 74 72 61 3d 33 36 38 31 45 38 43 ad_extra&#x3D;3681E8Cbd419010 33 41 43 35 33 37 45 42 30 39 33 39 46 34 35 31 3AC537EB0939F451bd419020 30 37 38 37 37 43 36 33 44 35 31 45 37 38 45 36 07877C63D51E78E6bd419030 43 39 39 34 41 39 35 30 45 31 34 41 44 43 41 39 C994A950E14ADCA9bd419040 41 39 46 43 30 35 33 36 43 33 38 44 31 36 38 35 A9FC0536C38D1685bd419050 31 43 31 35 31 33 31 32 37 44 30 38 43 30 37 34 1C1513127D08C074bd419060 44 41 43 35 31 31 33 42 36 31 31 39 39 39 31 42 DAC5113B6119991Bbd419070 42 33 38 45 34 37 36 37 44 44 32 44 30 32 37 43 B38E4767DD2D027Cbd419080 42 41 44 33 30 36 35 43 46 41 35 42 38 42 36 45 BAD3065CFA5B8B6Ebd419090 31 37 31 36 41 30 34 32 37 38 34 38 34 32 34 31 1716A04278484241bd4190a0 46 43 43 45 42 43 31 44 31 30 36 37 38 34 33 31 FCCEBC1D10678431bd4190b0 44 37 33 41 43 44 35 30 37 42 44 45 39 45 35 37 D73ACD507BDE9E57bd4190c0 36 34 33 42 33 42 32 34 36 46 46 46 42 45 42 35 643B3B246FFFBEB5bd4190d0 46 41 31 31 42 42 31 36 44 32 41 45 30 34 45 35 FA11BB16D2AE04E5bd4190e0 38 42 43 45 41 41 38 42 34 37 46 41 42 35 34 33 8BCEAA8B47FAB543bd4190f0 30 35 38 44 45 46 35 36 42 45 41 31 41 31 35 35 058DEF56BEA1A155bd419100 39 32 41 34 44 43 45 44 35 37 37 36 44 45 39 45 92A4DCED5776DE9Ebd419110 44 33 36 33 43 34 35 38 44 36 33 41 32 31 37 34 D363C458D63A2174bd419120 33 36 33 30 46 46 37 38 32 33 42 30 34 31 45 37 3630FF7823B041E7bd419130 41 31 42 35 33 39 33 38 35 42 41 42 43 41 43 44 A1B539385BABCACDbd419140 33 45 46 38 41 34 34 32 46 44 34 30 36 46 45 36 3EF8A442FD406FE6bd419150 33 41 39 44 39 43 36 38 37 36 35 30 35 45 46 42 3A9D9C6876505EFBbd419160 44 32 43 34 44 32 31 38 46 34 43 33 36 39 33 41 D2C4D218F4C3693Abd419170 38 38 32 36 37 36 41 32 41 38 35 34 36 37 37 33 882676A2A8546773bd419180 32 35 38 42 34 46 43 44 38 30 44 31 35 31 45 31 258B4FCD80D151E1bd419190 43 35 31 30 35 44 34 31 37 43 33 41 46 45 35 43 C5105D417C3AFE5Cbd4191a0 32 30 38 45 35 44 34 43 36 42 45 46 30 43 37 31 208E5D4C6BEF0C71bd4191b0 44 44 31 36 32 39 31 38 38 38 39 41 30 45 31 39 DD162918889A0E19bd4191c0 44 41 30 45 38 44 34 38 44 46 33 38 31 37 46 31 DA0E8D48DF3817F1bd4191d0 30 41 30 43 30 41 30 44 33 45 38 43 32 38 45 35 0A0C0A0D3E8C28E5bd4191e0 42 38 37 43 30 39 36 41 39 33 35 37 31 43 36 31 B87C096A93571C61bd4191f0 32 33 42 30 35 34 41 45 39 41 34 34 39 33 46 31 23B054AE9A4493F1bd419200 43 33 31 46 37 43 34 43 32 39 31 45 38 37 37 46 C31F7C4C291E877Fbd419210 35 32 44 33 46 41 41 32 34 35 35 36 36 42 37 41 52D3FAA245566B7Abd419220 38 32 39 38 35 34 39 39 31 37 37 31 42 33 41 31 829854991771B3A1bd419230 39 31 31 41 44 45 39 46 44 30 34 30 45 41 46 46 911ADE9FD040EAFFbd419240 41 31 33 44 34 33 35 39 43 37 46 43 45 46 32 30 A13D4359C7FCEF20bd419250 39 45 32 42 30 43 45 39 31 35 32 34 31 31 46 46 9E2B0CE9152411FFbd419260 31 32 43 46 42 35 30 42 33 37 33 45 44 38 39 46 12CFB50B373ED89Fbd419270 33 46 46 37 35 33 30 43 38 39 43 35 42 32 42 35 3FF7530C89C5B2B5bd419280 41 44 42 36 34 33 32 36 43 44 43 45 42 46 34 36 ADB64326CDCEBF46bd419290 32 31 32 32 42 42 34 45 44 36 37 41 31 39 32 30 2122BB4ED67A1920bd4192a0 33 37 37 30 34 33 37 35 36 30 45 41 36 46 42 33 3770437560EA6FB3bd4192b0 41 33 31 45 39 33 32 45 35 35 46 42 37 31 30 38 A31E932E55FB7108bd4192c0 41 41 42 36 35 38 33 38 36 35 37 45 43 36 43 45 AAB65838657EC6CEbd4192d0 34 41 31 42 45 32 43 42 35 38 45 32 33 38 32 37 4A1BE2CB58E23827bd4192e0 34 38 45 35 45 34 43 36 38 44 36 33 35 33 30 34 48E5E4C68D635304bd4192f0 36 37 44 31 32 32 43 35 44 31 46 38 31 42 46 35 67D122C5D1F81BF5bd419300 35 46 35 35 46 35 34 33 31 43 32 30 33 34 30 34 5F55F5431C203404bd419310 39 33 43 30 37 39 43 44 41 46 41 46 38 46 31 33 93C079CDAFAF8F13bd419320 41 42 37 46 31 45 43 42 39 37 43 34 33 42 39 42 AB7F1ECB97C43B9Bbd419330 33 30 43 30 42 43 30 44 43 34 31 35 43 36 46 39 30C0BC0DC415C6F9bd419340 37 36 46 42 31 36 41 33 38 39 43 37 34 30 41 46 76FB16A389C740AFbd419350 44 34 32 44 35 46 33 43 44 34 39 46 38 46 33 44 D42D5F3CD49F8F3Dbd419360 37 35 45 42 34 34 46 45 45 38 31 34 30 38 41 32 75EB44FEE81408A2bd419370 33 36 42 46 37 43 36 32 45 36 44 33 36 33 39 31 36BF7C62E6D36391bd419380 35 31 30 45 43 38 34 36 38 31 41 43 45 30 30 38 510EC84681ACE008bd419390 39 34 42 32 37 46 33 44 32 32 42 35 44 44 31 45 94B27F3D22B5DD1Ebd4193a0 36 30 32 33 31 39 39 42 43 38 38 44 37 37 35 33 6023199BC88D7753bd4193b0 46 32 37 38 43 37 34 43 44 30 34 35 42 39 34 31 F278C74CD045B941bd4193c0 38 43 41 43 44 46 30 36 32 26 61 70 70 6b 65 79 8CACDF062&amp;appkeybd4193d0 3d 31 64 38 62 36 65 37 64 34 35 32 33 33 34 33 &#x3D;1d8b6e7d4523343bd4193e0 36 26 61 75 74 6f 70 6c 61 79 5f 63 61 72 64 3d 6&amp;autoplay_card&#x3D;bd4193f0 31 31 26 62 61 6e 6e 65 72 5f 68 61 73 68 3d 36 11&amp;banner_hash&#x3D;6bd419400 33 32 36 36 30 30 30 38 30 34 37 31 37 31 33 32 3266000804717132bd419410 33 30 26 62 75 69 6c 64 3d 36 31 38 30 35 30 30 30&amp;build&#x3D;6180500bd419420 26 63 5f 6c 6f 63 61 6c 65 3d 7a 68 2d 48 61 6e &amp;c_locale&#x3D;zh-Hanbd419430 73 5f 43 4e 26 63 68 61 6e 6e 65 6c 3d 73 68 65 s_CN&amp;channel&#x3D;shebd419440 6e 6d 61 30 36 39 26 63 6f 6c 75 6d 6e 3d 32 26 nma069&amp;column&#x3D;2&amp;bd419450 64 65 76 69 63 65 5f 6e 61 6d 65 3d 50 69 78 65 device_name&#x3D;Pixebd419460 6c 25 32 30 58 4c 26 64 65 76 69 63 65 5f 74 79 l%20XL&amp;device_tybd419470 70 65 3d 30 26 66 6c 75 73 68 3d 36 26 66 6e 76 pe&#x3D;0&amp;flush&#x3D;6&amp;fnvbd419480 61 6c 3d 34 30 30 26 66 6e 76 65 72 3d 30 26 66 al&#x3D;400&amp;fnver&#x3D;0&amp;fbd419490 6f 72 63 65 5f 68 6f 73 74 3d 30 26 66 6f 75 72 orce_host&#x3D;0&amp;fourbd4194a0 6b 3d 31 26 67 75 69 64 61 6e 63 65 3d 30 26 68 k&#x3D;1&amp;guidance&#x3D;0&amp;hbd4194b0 74 74 70 73 5f 75 72 6c 5f 72 65 71 3d 30 26 69 ttps_url_req&#x3D;0&amp;ibd4194c0 64 78 3d 31 36 34 31 39 36 36 34 36 38 26 69 6e dx&#x3D;1641966468&amp;inbd4194d0 6c 69 6e 65 5f 64 61 6e 6d 75 3d 32 26 69 6e 6c line_danmu&#x3D;2&amp;inlbd4194e0 69 6e 65 5f 73 6f 75 6e 64 3d 31 26 6c 6f 67 69 ine_sound&#x3D;1&amp;logibd4194f0 6e 5f 65 76 65 6e 74 3d 30 26 6d 6f 62 69 5f 61 n_event&#x3D;0&amp;mobi_abd419500 70 70 3d 61 6e 64 72 6f 69 64 26 6e 65 74 77 6f pp&#x3D;android&amp;netwobd419510 72 6b 3d 77 69 66 69 26 6f 70 65 6e 5f 65 76 65 rk&#x3D;wifi&amp;open_evebd419520 6e 74 3d 26 70 6c 61 74 66 6f 72 6d 3d 61 6e 64 nt&#x3D;&amp;platform&#x3D;andbd419530 72 6f 69 64 26 70 6c 61 79 65 72 5f 6e 65 74 3d roid&amp;player_net&#x3D;bd419540 31 26 70 75 6c 6c 3d 74 72 75 65 26 71 6e 3d 33 1&amp;pull&#x3D;true&amp;qn&#x3D;3bd419550 32 26 72 65 63 73 79 73 5f 6d 6f 64 65 3d 30 26 2&amp;recsys_mode&#x3D;0&amp;bd419560 73 5f 6c 6f 63 61 6c 65 3d 7a 68 2d 48 61 6e 73 s_locale&#x3D;zh-Hansbd419570 5f 43 4e 26 73 70 6c 61 73 68 5f 69 64 3d 26 73 _CN&amp;splash_id&#x3D;&amp;sbd419580 74 61 74 69 73 74 69 63 73 3d 25 37 42 25 32 32 tatistics&#x3D;%7B%22bd419590 61 70 70 49 64 25 32 32 25 33 41 31 25 32 43 25 appId%22%3A1%2C%bd4195a0 32 32 70 6c 61 74 66 6f 72 6d 25 32 32 25 33 41 22platform%22%3Abd4195b0 33 25 32 43 25 32 32 76 65 72 73 69 6f 6e 25 32 3%2C%22version%2bd4195c0 32 25 33 41 25 32 32 36 2e 31 38 2e 30 25 32 32 2%3A%226.18.0%22bd4195d0 25 32 43 25 32 32 61 62 74 65 73 74 25 32 32 25 %2C%22abtest%22%bd4195e0 33 41 25 32 32 25 32 32 25 37 44 26 74 73 3d 31 3A%22%22%7D&amp;ts&#x3D;1bd4195f0 36 34 31 39 36 36 37 33 34 641966734Length:0x5f9contents: 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEFb9d11f70 35 36 30 63 35 32 63 63 560c52ccLength:0x8contents: 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEFb9d11f70 64 32 38 38 66 65 64 30 d288fed0Length:0x8contents: 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEFb9d11f70 34 35 38 35 39 65 64 31 45859ed1Length:0x8contents: 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEFb9d11f70 38 62 66 66 64 39 37 33 8bffd973Length:0x8contents: 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEFc92b8064 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................c92b8074 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ...............Length:0x1fcontents: 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEFb9d11eb4 c8 30 00 00 00 00 00 00 .0......Length:0x8 两次同时起两个终端hook，启用hook_22B0和hook_LibBili_s，用来对比生成的sign。总共调用了7次hook_22B0，即MD5Update，代码中总共调用了2+3=5次，以下通过N重命名函数 MD5Final中会调用两次 将MD5Update得到的5次的字符串拼接起来 1ad_extra&#x3D;3681E8C3AC537EB0939F45107877C63D51E78E6C994A950E14ADCA9A9FC0536C38D16851C1513127D08C074DAC5113B6119991BB38E4767DD2D027CBAD3065CFA5B8B6E1716A04278484241FCCEBC1D10678431D73ACD507BDE9E57643B3B246FFFBEB5FA11BB16D2AE04E58BCEAA8B47FAB543058DEF56BEA1A15592A4DCED5776DE9ED363C458D63A21743630FF7823B041E7A1B539385BABCACD3EF8A442FD406FE63A9D9C6876505EFBD2C4D218F4C3693A882676A2A8546773258B4FCD80D151E1C5105D417C3AFE5C208E5D4C6BEF0C71DD162918889A0E19DA0E8D48DF3817F10A0C0A0D3E8C28E5B87C096A93571C6123B054AE9A4493F1C31F7C4C291E877F52D3FAA245566B7A829854991771B3A1911ADE9FD040EAFFA13D4359C7FCEF209E2B0CE9152411FF12CFB50B373ED89F3FF7530C89C5B2B5ADB64326CDCEBF462122BB4ED67A19203770437560EA6FB3A31E932E55FB7108AAB65838657EC6CE4A1BE2CB58E2382748E5E4C68D63530467D122C5D1F81BF55F55F5431C20340493C079CDAFAF8F13AB7F1ECB97C43B9B30C0BC0DC415C6F976FB16A389C740AFD42D5F3CD49F8F3D75EB44FEE81408A236BF7C62E6D36391510EC84681ACE00894B27F3D22B5DD1E6023199BC88D7753F278C74CD045B9418CACDF062&amp;appkey&#x3D;1d8b6e7d45233436&amp;autoplay_card&#x3D;11&amp;banner_hash&#x3D;6326600080471713230&amp;build&#x3D;6180500&amp;c_locale&#x3D;zh-Hans_CN&amp;channel&#x3D;shenma069&amp;column&#x3D;2&amp;device_name&#x3D;Pixel%20XL&amp;device_type&#x3D;0&amp;flush&#x3D;6&amp;fnval&#x3D;400&amp;fnver&#x3D;0&amp;force_host&#x3D;0&amp;fourk&#x3D;1&amp;guidance&#x3D;0&amp;https_url_req&#x3D;0&amp;idx&#x3D;1641966468&amp;inline_danmu&#x3D;2&amp;inline_sound&#x3D;1&amp;login_event&#x3D;0&amp;mobi_app&#x3D;android&amp;network&#x3D;wifi&amp;open_event&#x3D;&amp;platform&#x3D;android&amp;player_net&#x3D;1&amp;pull&#x3D;true&amp;qn&#x3D;32&amp;recsys_mode&#x3D;0&amp;s_locale&#x3D;zh-Hans_CN&amp;splash_id&#x3D;&amp;statistics&#x3D;%7B%22appId%22%3A1%2C%22platform%22%3A3%2C%22version%22%3A%226.18.0%22%2C%22abtest%22%3A%22%22%7D&amp;ts&#x3D;1641966734560c52ccd288fed045859ed18bffd973 md5结果如下，正是d45938b080b6e74c5a8f9e66719998ab Python实现以个人空间为例，如果请求中没有sign将报错API校验密匙错误,针对入参中变量就是ts,vmid,sign进行拼接即可。 12345678import hashlibimport timeimport requeststs &#x3D; str(int(time.time()))origin_txt &#x3D; &#39;access_key&#x3D;***&amp;ad_extra&#x3D;3681E8C3AC537EB0939F45107877C63D51E78E6C994A950E14ADCA9A9FC0536C38D16851C1513127D08C074DAC5113B6119991BB38E4767DD2D027CBAD3065CFA5B8B6E1716A04278484241FCCEBC1D10678431D73ACD507BDE9E57643B3B246FFFBEB5FA11BB16D2AE04E58BCEAA8B47FAB543058DEF56BEA1A15592A4DCED5776DE9ED363C458D63A21743630FF7823B041E7A1B539385BABCACD3EF8A442FD406FE63A9D9C6876505EFBD2C4D218F4C3693A882676A2A8546773258B4FCD80D151E1C5105D417C3AFE5C208E5D4C6BEF0C71DD162918889A0E19DA0E8D48DF3817F10A0C0A0D3E8C28E5B87C096A93571C6123B054AE9A4493F1C31F7C4C291E877F52D3FAA245566B7A829854991771B3A1911ADE9FD040EAFFA13D4359C7FCEF209E2B0CE9152411FF12CFB50B373ED89F3FF7530C89C5B2B5ADB64326CDCEBF462122BB4ED67A19203770437560EA6FB3A31E932E55FB7108AAB65838657EC6CE4A1BE2CB58E2382748E5E4C68D63530467D122C5D1F81BF55F55F5431C20340493C079CDAFAF8F13AB7F1ECB97C43B9B30C0BC0DC415C6F976FB16A389C740AFD42D5F3CD49F8F3D75EB44FEE81408A236BF7C62E6D36391510EC84681ACE00894B27F3D22B5DD1E6023199BC88D7753F278C74CD045B9418CACDF062&amp;appkey&#x3D;1d8b6e7d45233436&amp;build&#x3D;6180500&amp;c_locale&#x3D;zh-Hans_CN&amp;channel&#x3D;shenma069&amp;fnval&#x3D;400&amp;fnver&#x3D;0&amp;force_host&#x3D;0&amp;fourk&#x3D;1&amp;from&#x3D;0&amp;mobi_app&#x3D;android&amp;platform&#x3D;android&amp;player_net&#x3D;1&amp;ps&#x3D;10&amp;qn&#x3D;32&amp;s_locale&#x3D;zh-Hans_CN&amp;statistics&#x3D;%7B%22appId%22%3A1%2C%22platform%22%3A3%2C%22version%22%3A%226.18.0%22%2C%22abtest%22%3A%22%22%7D&amp;ts&#x3D;&#123;&#125;&amp;vmid&#x3D;&#123;&#125;&#39;sign &#x3D; hashlib.md5(origin_txt.format(ts,&#39;1493964352&#39;+&#39;560c52ccd288fed045859ed18bffd973&#39;).encode(&#39;utf-8&#39;)).hexdigest()print(requests.get(&#39;https:&#x2F;&#x2F;app.bilibili.com&#x2F;x&#x2F;v2&#x2F;space?&#39;+origin_txt.format(ts,&#39;1493964352&#39;)+&#39;&amp;sign&#x3D;&#39;+sign).json()) 视频 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"unidbg","slug":"unidbg","permalink":"http://onejane.github.io/tags/unidbg/"},{"name":"ida","slug":"ida","permalink":"http://onejane.github.io/tags/ida/"}]},{"title":"SO逆向之轻小说sfsecurity分析","slug":"SO逆向之轻小说sfsecurity分析","date":"2021-12-16T02:13:01.000Z","updated":"2022-01-09T02:08:00.915Z","comments":true,"path":"2021/12/16/SO逆向之轻小说sfsecurity分析/","link":"","permalink":"http://onejane.github.io/2021/12/16/SO%E9%80%86%E5%90%91%E4%B9%8B%E8%BD%BB%E5%B0%8F%E8%AF%B4sfsecurity%E5%88%86%E6%9E%90/","excerpt":"","text":"抓包 postman发起请求 脱壳 123proxychains git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;FRIDA-DEXDump.git 移到~&#x2F;.objection&#x2F;plugins重命名为dexdumpobjection -g com.sfacg explore -P ~&#x2F;.objection&#x2F;plugins plugin dexdump dump 上图可见，脱壳效果并不好。不过不影响，搜索sfsecurity 12plugin wallbreaker objectsearch com.sf.security.AuthConfigplugin wallbreaker objectdump --fullname 0x36d6 1android hooking watch class_method com.sf.security.AuthConfig.getSFSecurity --dump-args --dump-backtrace --dump-return 入参为context和token，根据输出的结果，包含了nonce和sign两个加密键值对，timestamp时间戳，devicetoken是第二个参数。 Unidbg通过IDA的导出函数找到getSFSecurity的起始地址，尝试主动调用 12345678910111213141516171819202122232425262728293031323334353637383940public class qxs extends AbstractJni&#123; private final AndroidEmulator emulator; private final VM vm; private final Module module; qxs() &#123; emulator &#x3D; AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;com.sfacg&quot;).build(); &#x2F;&#x2F; 创建模拟器实例，要模拟32位或者64位，在这里区分 final Memory memory &#x3D; emulator.getMemory(); &#x2F;&#x2F; 模拟器的内存操作接口 memory.setLibraryResolver(new AndroidResolver(23)); &#x2F;&#x2F; 设置系统类库解析 vm &#x3D; emulator.createDalvikVM(new File(&quot;轻小说4.7.24.apk&quot;)); &#x2F;&#x2F; 创建Android虚拟机 DalvikModule dm &#x3D; vm.loadLibrary(new File(&quot;libsfdata.so&quot;), false); &#x2F;&#x2F; 加载libttEncrypt.so到unicorn虚拟内存，加载成功以后会默认调用init_array等函数 module &#x3D; dm.getModule(); &#x2F;&#x2F; &#x2F;&#x2F; 先把JNI Onload跑起来，里面做了大量的初始化工作 vm.setJni(this); vm.setVerbose(true); dm.callJNI_OnLoad(emulator); &#125; public static void main(String[] args) throws Exception &#123; qxs test &#x3D; new qxs(); System.out.println(test.getSFsecurity()); &#125; public String getSFsecurity()&#123; List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;(10); list.add(vm.getJNIEnv()); &#x2F;&#x2F; 第一个参数是env list.add(0); &#x2F;&#x2F; 第二个参数，实例方法是jobject，静态方法是jclazz，直接填0，一般用不到 Object custom &#x3D; null; DvmObject&lt;?&gt; context &#x3D; vm.resolveClass(&quot;android&#x2F;content&#x2F;Context&quot;).newObject(custom);&#x2F;&#x2F; context list.add(vm.addLocalObject(context)); list.add(vm.addLocalObject(new StringObject(vm, &quot;95048C92-C0A4-388E-923F-36861451DE6E&quot;))); Number number &#x3D; module.callFunction(emulator, 0xA944 + 1, list.toArray())[0]; String result &#x3D; vm.getObject(number.intValue()).getValue().toString(); return result; &#125;&#125; 运行在调用callStaticObjectMethodV时报错：java.lang.UnsupportedOperationException: java/util/UUID-&gt;randomUUID()Ljava/util/UUID;，补环境 123456789@Overridepublic DvmObject&lt;?&gt; callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;java&#x2F;util&#x2F;UUID-&gt;randomUUID()Ljava&#x2F;util&#x2F;UUID;&quot;:&#123; return dvmClass.newObject(UUID.randomUUID()); &#125; &#125; return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList);&#125; 运行在调用callObjectMethodV时报错：java.lang.UnsupportedOperationException: java/util/UUID-&gt;toString()Ljava/lang/String;，补环境 12345678910@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;java&#x2F;util&#x2F;UUID-&gt;toString()Ljava&#x2F;lang&#x2F;String;&quot;:&#123; String uuid &#x3D; dvmObject.getValue().toString(); return new StringObject(vm, uuid); &#125; &#125; return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125; 正常获取到结果，可以证明nonce就是通过uuid生成的随机数，timestamp就是当前时间戳，deviceToken就是传入的参数，sign就是生成的结果。 Sign本so进行了保护，无法反编译，findHash也没有结果，但是unidbg可以正常跑出加密后的sign，尝试使用traceCode追踪下汇编指令流。 默认的unidbg的trace是不保存寄存器值的信息的，修改ARM32下的AbstractARMEmulator.java 1234567891011121314151617181920private void printAssemble(PrintStream out, Capstone.CsInsn[] insns, long address, boolean thumb) &#123; StringBuilder sb &#x3D; new StringBuilder(); for (Capstone.CsInsn ins : insns) &#123; sb.append(&quot;### Trace Instruction &quot;); sb.append(ARM.assembleDetail(this, ins, address, thumb)); &#x2F;&#x2F; 打印每条汇编指令里参与运算的寄存器的值 Set&lt;Integer&gt; regset &#x3D; new HashSet&lt;Integer&gt;(); Arm.OpInfo opInfo &#x3D; (Arm.OpInfo) ins.operands; for(int i &#x3D; 0; i&lt;opInfo.op.length; i++)&#123; regset.add(opInfo.op[i].value.reg); &#125; String RegChange &#x3D; ARM.SaveRegs(this, regset); sb.append(RegChange); sb.append(&#39;\\n&#39;); address +&#x3D; ins.size; &#125; out.print(sb);&#125; 在ARM.java中新建SaveRegs方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public static String SaveRegs(Emulator&lt;?&gt; emulator, Set&lt;Integer&gt; regs) &#123; Backend backend &#x3D; emulator.getBackend(); StringBuilder builder &#x3D; new StringBuilder(); builder.append(&quot;&gt;&gt;&gt;&quot;); Iterator it &#x3D; regs.iterator(); while(it.hasNext()) &#123; int reg &#x3D; (int) it.next(); Number number; int value; switch (reg) &#123; case ArmConst.UC_ARM_REG_R0: number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; r0&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R1: number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; r1&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R2: number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; r2&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R3: number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; r3&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R4: number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; r4&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R5: number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; r5&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R6: number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; r6&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R7: number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; r7&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R8: number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; r8&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R9: &#x2F;&#x2F; UC_ARM_REG_SB number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; sb&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R10: &#x2F;&#x2F; UC_ARM_REG_SL number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; sl&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_FP: number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; fp&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_IP: number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; ip&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_SP: number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; SP&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_LR: number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; LR&#x3D;0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_PC: number &#x3D; backend.reg_read(reg); value &#x3D; number.intValue(); builder.append(String.format(Locale.US, &quot; PC&#x3D;0x%x&quot;, value)); break; &#125; &#125; return builder.toString();&#125; 开始跑traceCode并将结果保存在qxstrace.txt中，由于sign是32位的十六进制数，猜测是md5相关，关键特征有4个魔数和64个K。 12345678910111213141516171819202122# 魔数A &#x3D; 0x67452301B &#x3D; 0xefcdab89C &#x3D; 0x98badcfeD &#x3D; 0x10325476 # K表Ktable &#x3D; [ 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x2441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x4881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391] 通过检索这些关键特征，可以断定这是一个md5或者魔改后的md5 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"unidbg","slug":"unidbg","permalink":"http://onejane.github.io/tags/unidbg/"},{"name":"ida","slug":"ida","permalink":"http://onejane.github.io/tags/ida/"}]},{"title":"JS逆向之基础定位技巧","slug":"JS逆向之基础定位技巧","date":"2021-12-04T04:17:15.000Z","updated":"2021-12-26T05:53:15.007Z","comments":true,"path":"2021/12/04/JS逆向之基础定位技巧/","link":"","permalink":"http://onejane.github.io/2021/12/04/JS%E9%80%86%E5%90%91%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%BD%8D%E6%8A%80%E5%B7%A7/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 当我们拿到一个网站时，首先就是抓包定位加密参数的实现，本文将通过常用的定位方案结合实际案例完成对加密参数的分析。 搜索关键参数这是最常见也是最简单的定位方案，F12打开网站控制台后，Ctrl+Shift+F打开搜索面板，比如搜索password参数或者submit函数 1password:&#96;,&#96;password&#x3D;&#96;,&#96;password &#x3D;&#96;请求url，搜索方法&#96;var submit&#96;或者&#96;function submit&#96;或者&#96;submit: to8to 搜索password位置太多，由于抓包请求是new_login.php 在Element面板中搜索new_login.php，ctrl+shift+f 搜索loginCheck 该方法中jq(&#39;#rsa_userNum&#39;).val(rsaString(password));，调用rsaString方法加密password 123function rsaString(str) &#123; return encodeURIComponent(RSAUtilszb.encryptfun(str));&#125; 进入encryptfun定义的js中，rsa加密最少2000行，该方法不过163行，拷贝该js通过编程猫专用工具中的JS调试工具，加载代码，报错引用错误: window 未定义，添加var window = this;,报错引用错误: JSEncrypt 未定义,添加原js中var JSEncrypt = JSEncryptExports.JSEncrypt;，报错引用错误: JSEncryptExports 未定义,搜索var JSEncryptExports，将var JSEncryptExports = {};添加到JS调试工具，报错类型错误: JSEncrypt is not a constructor 尝试打上断点，但是每次都不能进入断点，说明肯定是动态加载的js，且每次刷新js后缀会有时间戳。勾选Disable cache,打开fiddler抓包，将js拷贝到本地实现http欺骗，选中该请求点击AutoResponder-Add Rule下拉选择Find a File,找到本地保存的js并开启规则 由于每次js请求地址不一样，使用正则匹配regex:https://static\\.to8to\\.com/gb_js/to8torsaszb\\.js\\?_=\\d+并保存规则重新发起请求https://static.to8to.com/gb_js/to8torsaszb.js?_=1628128571412，使用本地js欺骗网络请求js 将整个js格式化找到之前报错JSEncrypt is not a constructor是从上面的压缩的js中export出来的 将上面压缩的代码添加到编程猫的JS调试工具中加载代码，报错引用错误: navigator 未定义，添加var navigator = {}，报错引用错误: window 未定义，添加var window =this,因为如果用window ={}报错ASN1 未定义,而用this则可以拿到当前js中所有的变量函数。 dom元素事件监听通过控制台的Elements中的Event Listeners逐个排除按钮的Remove节点，直到最后一个Event Listeners使按钮无效，拿到该按钮真正生效的js位置。 中烟新商盟 以下通过dom元素事件监听实现对该j_mcmm加密参数逻辑定位分析。 以上通过尽可能多的地方打上断点，监听元素事件定位到jsmain-9826b285f8fad5a5.js，左下角格式化js后添加断点，在js页面ctrl查看所有变量值 鼠标悬停，或者控制台打印出来，点击进入方法声明时打上断点，为同一行中的函数打上断点，F8单步调试,完成加密参数的定位 xhr断点通过定位发包函数跟栈，复制网址请求路径到Sources下的XHR/fetch Breakpoints，支持正则。 七麦数据 通过关键加密参数analysis搜索无果，尝试在Sources中加入XHR断点，以请求路径作为断点内容 XHR断点后追溯调用栈，查看每个调用栈的出入参是否包含加密后的analysis,直到进入Promise异步l.request，单步调试到n.then(t.shift(), t.shift()),then作为Promise的异步函数，promise.then(onCompleted, onRejected);，而shift()通过逐条调用t中的方法，参数是上一个方法的返回值，同时删除该方法，相当于队列先进先出。控制台打印t，逐个方法进入打上断点 在l.prototype.request中暂时还没生成analysis加密参数，逐个进入t方法中 执行完r().interceptors.request.use该方法后生成的a就是analysis，观察该代码中的逻辑完成加密分析。a=(0,n.cv)((0,n.oZ)(r, l))作为逗号表达式，由上图分析n.cv和n.oZ是函数，r和l是变量，可以还原为n.cv(n.oz(r,l))。 通过控制台获取n中的函数 12345678910111213141516171819202122232425262728293031323334353637383940window &#x3D; global;window.document &#x3D; &#123; cookie: &#39;&#39; &#x2F;&#x2F; 这边带上自己的cookie&#125;function i(e) &#123; var t, a &#x3D; (t &#x3D; &quot;&quot;, [&quot;66&quot;, &quot;72&quot;, &quot;6f&quot;, &quot;6d&quot;, &quot;43&quot;, &quot;68&quot;, &quot;61&quot;, &quot;72&quot;, &quot;43&quot;, &quot;6f&quot;, &quot;64&quot;, &quot;65&quot;].forEach((function (e) &#123; t +&#x3D; unescape(&quot;%u00&quot; + e) &#125; )), t); return String[a](e)&#125;function s() &#123; return unescape(&quot;861831832863830866861836861862839831831839862863839830865834861863837837830830837839836861835833&quot;.replace(&#x2F;8&#x2F;g, &quot;%u00&quot;))&#125;var n &#x3D; &#123; oZ: function g(e, t) &#123; t || (t &#x3D; s()); for (var a &#x3D; (e &#x3D; e.split(&quot;&quot;)).length, n &#x3D; t.length, o &#x3D; &quot;charCodeAt&quot;, r &#x3D; 0; r &lt; a; r++) e[r] &#x3D; i(e[r][o](0) ^ t[(r + 10) % n][o](0)); return e.join(&quot;&quot;) &#125;, cv: function h(e) &#123; return function (e) &#123; try &#123; return btoa(e) &#125; catch (t) &#123; return Buffer.from(e).toString(&quot;base64&quot;) &#125; &#125;(encodeURIComponent(e).replace(&#x2F;%([0-9A-F]&#123;2&#125;)&#x2F;g, (function (e, t) &#123; return i(&quot;0x&quot; + t) &#125; ))) &#125;, ej: function u(e) &#123; var t, a &#x3D; new RegExp(&quot;(^| )&quot; + e + &quot;&#x3D;([^;]*)(;|$)&quot;); return (t &#x3D; document.cookie.match(a)) ? unescape(t[2]) : null &#125;&#125; 由于btoa本质就是base64加密，通过引入CryptoJS.pad.js后 1234567891011121314151617181920212223242526272829function base64(data) &#123; var wordArray &#x3D; CryptoJS.enc.Utf8.parse(data); var base64_data &#x3D; CryptoJS.enc.Base64.stringify(wordArray); return base64_data&#125;var n &#x3D; &#123; oZ: function g(e, t) &#123; t || (t &#x3D; s()); for (var a &#x3D; (e &#x3D; e.split(&quot;&quot;)).length, n &#x3D; t.length, o &#x3D; &quot;charCodeAt&quot;, r &#x3D; 0; r &lt; a; r++) e[r] &#x3D; i(e[r][o](0) ^ t[(r + 10) % n][o](0)); return e.join(&quot;&quot;) &#125;, cv: function h(e) &#123; return function (e) &#123; try &#123; return base64(e) &#125; catch (t) &#123; return Buffer.from(e).toString(&quot;base64&quot;) &#125; &#125;(encodeURIComponent(e).replace(&#x2F;%([0-9A-F]&#123;2&#125;)&#x2F;g, (function (e, t) &#123; return i(&quot;0x&quot; + t) &#125; ))) &#125;, ej: function u(e) &#123; var t, a &#x3D; new RegExp(&quot;(^| )&quot; + e + &quot;&#x3D;([^;]*)(;|$)&quot;); return (t &#x3D; document.cookie.match(a)) ? unescape(t[2]) : null &#125;&#125; 将try/catch中逻辑还原 123456789101112131415161718192021var l &#x3D; &quot;00000008d78d46a&quot;var d &#x3D; &quot;@#&quot;var e &#x3D; &#123; &#x2F;&#x2F; url: &quot;&#x2F;rank&#x2F;indexPlus&#x2F;brand_id&#x2F;1&quot;, url: &quot;&#x2F;rank&#x2F;indexPlus&#x2F;brand_id&#x2F;&quot; + pg, &#x2F;&#x2F; 1.免费榜 0.付费 2.畅销榜 baseURL: &quot;https:&#x2F;&#x2F;api.qimai.cn&quot;,&#125;var c &#x3D; &#123; default: function On(e) &#123; this._init(e) &#125;&#125;var u &#x3D; &quot;synct&quot;var t &#x3D; (0, n.ej)(u);var m &#x3D; &quot;syncd&quot;var f &#x3D; f &#x3D; c.default.prototype.difftime &#x3D; -(0, n.ej)(m) || +new Date - 1e3 * tvar o &#x3D; +new Date - (f || 0) - 1515125653845var r &#x3D; []r &#x3D; r.sort().join(&quot;&quot;), r &#x3D; (0, n.cv)(r), r +&#x3D; d + e.url.replace(e.baseURL, &quot;&quot;), r +&#x3D; d + o, r +&#x3D; d + 1,a_ &#x3D; (0, n.cv)((0, n.oZ)(r, l))return a_ Initiator栈追踪Network下的发包请求的Initiator，如jquery堆栈的顶层断点(可能会请求多次，找到发包请求时进入的断点)，重新请求找到堆栈中属于目标网站的js格式化断点。 升学e网通登录抓包，打开Initiator，进入堆栈顶层定位的代码行 打上断点，查看右侧调用栈，逐个方法往底层去调用，直到react库js找到了preLogin，找到出现password的位置，打上断点 再次登录时，进入断点，找到password 进入加密方法中，aes加密 打开WT-JS中的Crypto类复制key和iv，输出以HEX的十六进制格式，对比结果是标准的AES加密。 基于base64或十六进制的AES加解密实现见aes.js 长房集团 搜索j_password后打断点，重新登录 进入desEncrypt中，大致加密完成逻辑就在该函数中 加密逻辑中首先根据SECURITYKEY.get()获取到key，首先通过请求后端拿到str，判断加密类型是否为aes后截取字符串通过toHexString转成十六进制拿到key和iv和security 整理完逻辑扣出js报错CryptoJS is not defined,点击进入CryptoJS.AES.encrypt扣出来aes.js源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function toHexString(str) &#123; var temp &#x3D; &quot;&quot;; for (i &#x3D; 0; i &lt; str.length; i++) &#123; temp +&#x3D; str.charCodeAt(i).toString(16) &#125; return temp&#125;function getdes(encodeType) &#123; &#x2F;&#x2F; 请求&quot;&#x2F;resource&#x2F;js&#x2F;session.jsp?_&#x3D;1628210376229&quot;返回 var str &#x3D; &quot;E55A433905551AC39DB3165591D9CD74&quot;; if (encodeType &#x3D;&#x3D; null || encodeType &#x3D;&#x3D; &#39;aes&#39;) &#123; if (str.length &lt; 32) &#123; str +&#x3D; &quot;abcdefghijklmnopqrstuvwxyz1234567890&quot; &#125; str &#x3D; str.toUpperCase(); var key &#x3D; &#123;&#125;; key.key &#x3D; str.substring(0, 16); key.iv &#x3D; str.substring(16, 32); key.security &#x3D; &quot;\\u4435\\u5320\\u4d35&quot; &#125; else &#123; if (str.length &lt; 16) &#123; str +&#x3D; &quot;abcdefghijklmnopqrstuvwxyz&quot; &#125; str &#x3D; str.toUpperCase(); var key &#x3D; &#123;&#125;; key.key &#x3D; toHexString(str.substring(0, 8)); key.iv &#x3D; toHexString(str.substring(8, 16)); key.security &#x3D; &quot;\\u4445\\u5320\\u4d45&quot; &#125; return key&#125;function getPwd(value, type) &#123; var keyObj &#x3D; &#123;&#125;; if (type &#x3D;&#x3D; null || &quot;aes&quot; &#x3D;&#x3D; type.toLowerCase()) &#123; keyObj &#x3D; getdes() value &#x3D; CryptoJS.AES.encrypt(value, CryptoJS.enc.Utf8.parse(keyObj.key), &#123; iv: CryptoJS.enc.Utf8.parse(keyObj.iv) &#125;).toString() &#125; else &#123; keyObj &#x3D; getdes()(&#39;des&#39;); value &#x3D; CryptoJS.DES.encrypt(value, CryptoJS.enc.Hex.parse(keyObj.key), &#123; iv: CryptoJS.enc.Hex.parse(keyObj.iv) &#125;) &#125; return keyObj.security + value&#125; 安装编程猫插件 fiddler 版本必须 &gt;= v4.6.3，复制Fiddler 编程猫专用插件到fiddler程序目录下的Scripts目录中示例: C:\\Program Files (x86)\\Fiddler2\\Scripts 爱奇艺 覆盖原函数 12345678910function xxx()&#123; console.log(&quot;1111&quot;)&#125;var xxx_ &#x3D; xxx;xxx &#x3D; function()&#123; console.log(&quot;2222&quot;)&#125;window.alert &#x3D; function()&#123;console.log(&quot;?&quot;)&#125;console.clear &#x3D; function()&#123;console.log(&quot;?&quot;)&#125;setInterval &#x3D; function()&#123;&#125; Object.defineProperty替换对象属性(getter.setter) 123456789101112131415(function () &#123; var a &#x3D; &quot;&quot;; Object.defineProperty(document, &#39;cookie&#39;, &#123; set: function (val) &#123; console.log(&#39;Hook捕获到cookie设置-&gt;&#39;, val); a &#x3D; val; return val; &#125;, get: function()&#123; return a; &#125; &#125;);&#125;)();document.cookie &#x3D; &quot;1&quot; &#x2F;&#x2F; 设置document.cookie &#x2F;&#x2F; 获取 hook的时机在控制台注入的hook，刷新网页就失效了，过滤Network的js找到第一个加载的js，右键Open in Sources panel格式化，第一行断点，不过有些cookie可能异步可能在html中js生成，在控制台中注入以上hook，清除cookie，手动注入hook，控制台中找到VM虚拟机找到我们的hook的js打上断点，，每次hook都会经过set，右侧就可以查看调用栈，追溯cookie的来源与加密方式。(有可能注入hook的时机会晚于部分异步请求或者html中的js) 利用fiddler代理所有请求替换响应,编程猫专用工具注入hook 123456789101112(function () &#123; &#39;use strict&#39;; Object.defineProperty(document, &#39;cookie&#39;, &#123; set: function (val) &#123; if (val.indexOf(&quot;__dfp&quot;) !&#x3D; -1) &#123; debugger; &#125; console.log(&#39;Hook捕获到cookie设置-&gt;&#39;, val); return val; &#125; &#125;);&#125;)(); 接下来查看调用栈，最终保存到window.name中。 123456789101112131415(function () &#123; &#39;use strict&#39;; var a &#x3D; &quot;&quot;; Object.defineProperty(window, &#39;name&#39;, &#123; set: function (val) &#123; debugger; a &#x3D; val; console.log(&#39;Hook捕获到cookie设置-&gt;&#39;, val); return val; &#125;, get: function()&#123; return a; &#125; &#125;);&#125;)(); 重新进入iqiyi，断点完成hook定位从而可以根据调用栈分析cookie的生成逻辑。 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"SO逆向之蚂蜂窝zzzghostsigh","slug":"SO逆向之蚂蜂窝zzzghostsigh","date":"2021-11-25T06:40:57.000Z","updated":"2021-12-26T05:53:15.015Z","comments":true,"path":"2021/11/25/SO逆向之蚂蜂窝zzzghostsigh/","link":"","permalink":"http://onejane.github.io/2021/11/25/SO%E9%80%86%E5%90%91%E4%B9%8B%E8%9A%82%E8%9C%82%E7%AA%9Dzzzghostsigh/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 v9.3.7抓包postern+charles jadx反编译搜索zzzghostsigh找到params.put(LoginCommon.HTTP_BASE_PARAM_GHOSTSIGH, ghostSigh) 12345private static String appendGhostSighParams(Map&lt;String, String&gt; params, String encodeParams) &#123; String ghostSigh &#x3D; ghostSigh(encodeParams); params.put(LoginCommon.HTTP_BASE_PARAM_GHOSTSIGH, ghostSigh); return encodeParams + encodeUrl(&quot;&amp;&quot;) + encodeUrl(LoginCommon.HTTP_BASE_PARAM_GHOSTSIGH) + encodeUrl(&quot;&#x3D;&quot;) + encodeUrl(ghostSigh);&#125; 进入ghostSigh是Authorizer接口的一个方法 12adb shell dumpsys activity activities|more 拿到包名com.mfw.roadbookfrida -UF com.mfw.roadbook -l scripts.js 在searchInterface中使用接口名过滤name.indexOf(&quot;Authorizer&quot;) 利用frida找到该类的实现，ghostSigh的逻辑就是获取AuthorizeHelper实例house调用getSummary方法 12345public String ghostSigh(@Nullable Context context, @Nullable String params) &#123; String summary &#x3D; AuthorizeHelper.getInstance(LoginCommon.getAppPackageName()).getSummary(context, params); Intrinsics.checkExpressionValueIsNotNull(summary, &quot;AuthorizeHelper.getInsta…tSummary(context, params)&quot;); return summary;&#125; 跟进getSummary,其中调用了so层的xPreAuthencode方法 1234567private native String xPreAuthencode(Context context, String str, String str2);public String getSummary(Context context, String source) &#123; return xPreAuthencode(context, source, this.packageName);&#125;static &#123; System.loadLibrary(&quot;mfw&quot;);&#125; 使用objection内存漫游跟踪下xPreAuthencode 12objection -g com.mfw.roadbook explore -P ~&#x2F;.objection&#x2F;pluginsandroid hooking watch class_method com.mfw.tnative.AuthorizeHelper.xPreAuthencode --dump-args --dump-backtrace --dump-return 它接收三个参数，参数1是一个context，参数2是输入的明文，参数3是app的包名 主动调用frida构造context，主动调用动态普通函数xPreAuthencode返回b76da45d4855c8f405ec1352955fe58d3ef0adca 123456789101112131415function mfw()&#123; Java.perform(function()&#123; var currentApplication &#x3D; Java.use(&#39;android.app.ActivityThread&#39;).currentApplication(); var context &#x3D; currentApplication.getApplicationContext(); Java.choose(&quot;com.mfw.tnative.AuthorizeHelper&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance &#x3D;&gt;&quot;,instance); console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.xPreAuthencode(context,&quot;onejane&quot;,&quot;com.mfw.roadbook&quot;)) &#125;,onComplete:function()&#123; console.log(&#39;Search complete&#39;) &#125; &#125;) &#125;)&#125;setImmediate(mfw) unidbg搭建Unidbg框架 12345678910111213141516171819202122public class mfw extends AbstractJni&#123; private final AndroidEmulator emulator; private final VM vm; private final Module module; mfw() &#123; emulator &#x3D; AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;com.mfw.roadbook&quot;).build(); &#x2F;&#x2F; 创建模拟器实例 final Memory memory &#x3D; emulator.getMemory(); &#x2F;&#x2F; 模拟器的内存操作接口 memory.setLibraryResolver(new AndroidResolver(23)); &#x2F;&#x2F; 设置系统类库解析 vm &#x3D; emulator.createDalvikVM(new File(&quot;mafengwo_ziyouxing.apk&quot;)); &#x2F;&#x2F; 创建Android虚拟机 DalvikModule dm &#x3D; vm.loadLibrary(new File(&quot;libmfw.so&quot;), true); &#x2F;&#x2F; 加载so到虚拟内存 module &#x3D; dm.getModule(); &#x2F;&#x2F;获取本SO模块的句柄 vm.setJni(this); vm.setVerbose(true); dm.callJNI_OnLoad(emulator); &#125;; public static void main(String[] args) throws Exception &#123; mfw test &#x3D; new mfw(); &#125;&#125; JNI_OnLoad运行成功并打印出xPreAuthencode的地址为0x2e301 12345678910111213141516171819public String xPreAuthencode()&#123; List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;(10); list.add(vm.getJNIEnv()); &#x2F;&#x2F; 第一个参数是env list.add(0); &#x2F;&#x2F; 第二个参数，实例方法是jobject，静态方法是jclazz，直接填0，一般用不到。 Object custom &#x3D; null; DvmObject&lt;?&gt; context &#x3D; vm.resolveClass(&quot;android&#x2F;content&#x2F;Context&quot;).newObject(custom);&#x2F;&#x2F; context list.add(vm.addLocalObject(context)); list.add(vm.addLocalObject(new StringObject(vm, &quot;onejane&quot;))); list.add(vm.addLocalObject(new StringObject(vm, &quot;com.mfw.roadbook&quot;))); Number number &#x3D; module.callFunction(emulator, 0x2e301, list.toArray())[0]; String result &#x3D; vm.getObject(number.intValue()).getValue().toString(); return result;&#125;public static void main(String[] args) throws Exception &#123; mfw test &#x3D; new mfw(); System.out.println(test.xPreAuthencode());&#125; 算法还原由于明文不论多长输出固定为40位字符串，疑似哈希算法中的SHA1。使用IDA的FindHash跑完获取到自动生成的js 1frida -UF com.mfw.roadbook -l libmfw_findhash_1638601602.js g跳转到地址0x30548，x交叉引用，进入sub_2E300函数，正是xPreAuthencode函数的位置0x2e301 y设置变量a1类型为JNIEnv*,其中sub_30548一定是签名校验函数，如果失败返回Illegal signature，这个逻辑在Unidbg模拟执行时传入的apk替我们处理了签名校验。那么加密逻辑一定存在于sub_312E0或者sub_2E1F4中。 sub_312E0第一个参数v9是字符串，第二个参数v13是字符数组，第三个参数v10是字符串长度，使用HookZz尝试对sub_312E0hook并打印参数 12345678910111213141516171819202122232425262728293031public void hook_312E0()&#123; &#x2F;&#x2F; 获取HookZz对象 IHookZz hookZz &#x3D; HookZz.getInstance(emulator); &#x2F;&#x2F; 加载HookZz，支持inline hook，文档看https:&#x2F;&#x2F;github.com&#x2F;jmpews&#x2F;HookZz &#x2F;&#x2F; enable hook hookZz.enable_arm_arm64_b_branch(); &#x2F;&#x2F; 测试enable_arm_arm64_b_branch，可有可无 &#x2F;&#x2F; hook MDStringOld hookZz.wrap(module.base + 0x312E0 + 1, new WrapCallback&lt;HookZzArm32RegisterContext&gt;() &#123; &#x2F;&#x2F; inline wrap导出函数 @Override &#x2F;&#x2F; 方法执行前 public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) &#123; Pointer input &#x3D; ctx.getPointerArg(0); byte[] inputhex &#x3D; input.getByteArray(0, ctx.getR2Int()); &#x2F;&#x2F; 打印第一个参数v9 字符串 Inspector.inspect(inputhex, &quot;input&quot;); &#x2F;&#x2F; 将第二个参数v13放到context Pointer out &#x3D; ctx.getPointerArg(1); ctx.push(out); &#125;; @Override &#x2F;&#x2F; 方法执行后 public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) &#123; Pointer output &#x3D; ctx.pop(); &#x2F;&#x2F; 打印第二个参数v13[20] byte[] outputhex &#x3D; output.getByteArray(0, 20); Inspector.inspect(outputhex, &quot;output&quot;); &#125; &#125;); hookZz.disable_arm_arm64_b_branch();&#125; sub_312E0第一个参数v9正是我们输入的字符串onejane，第二个参数返回就是加密的最终结果。进入sub_312E0函数 h将数值转为十六进制 12345v30[1] &#x3D; 0xEFCDAB89;v30[0] &#x3D; 0x67452301;v30[2] &#x3D; 0x98BADCFE;v30[3] &#x3D; 0x5E4A1F7C;v30[4] &#x3D; 0x10325476; 查看androidxref的sha1.c源码，SHA1的魔数的第4个和第5个IV被改变了 我们尝试将sha1.py中的魔数成本例中的结果，很可惜结果并不是完全一致。 在函数sub_312E0中，n重命名入参，除了定义魔数之外，多处调用了sub_3151C函数，该函数591行，应该就是函数运算部分，加上sub_312E0共700多行，其中完成了对函数的魔改。 1234567891011121314151617181920212223242526272829303132int __fastcall sub_312E0(char *input, int output, int length)&#123; ... v30[1] &#x3D; 0xEFCDAB89; v30[0] &#x3D; 0x67452301; v30[2] &#x3D; 0x98BADCFE; v30[3] &#x3D; 0x5E4A1F7C; v30[4] &#x3D; 0x10325476; v4 &#x3D; 0; v32 &#x3D; 0; v31 &#x3D; 0; ... if ( (unsigned int)(v21 + 8) &lt; 0x40 ) &#123; v23 &#x3D; 0; &#125; else &#123; v27 &#x3D; 64 - v21; qmemcpy(&amp;v33[v21], v29, 64 - v21); sub_3151C(v30, v33); v23 &#x3D; v27; v21 &#x3D; 0; &#125; qmemcpy(&amp;v33[v21], &amp;v29[v23], 8 - v23); for ( k &#x3D; 0; k !&#x3D; 20; ++k ) &#123; *(_BYTE *)(output + k) &#x3D; *(unsigned int *)((char *)v30 + (k &amp; 0xFFFFFFFC)) &gt;&gt; (~(_BYTE)v22 &amp; 0x18); v22 +&#x3D; 8; &#125; return _stack_chk_guard - v35;&#125; 一个哈希算法主要流程有数据填充、添加长度、初始化变量、数据处理、输出，我们可以尝试通过hook加密函数，观察入参判断填充部分是否发生改变。 1234567891011121314151617181920212223242526272829303132333435363738public void hook_3151C()&#123; &#x2F;&#x2F; 获取HookZz对象 IHookZz hookZz &#x3D; HookZz.getInstance(emulator); &#x2F;&#x2F; 加载HookZz，支持inline hook，文档看https:&#x2F;&#x2F;github.com&#x2F;jmpews&#x2F;HookZz &#x2F;&#x2F; enable hook hookZz.enable_arm_arm64_b_branch(); &#x2F;&#x2F; 测试enable_arm_arm64_b_branch，可有可无 &#x2F;&#x2F; hook MDStringOld hookZz.wrap(module.base + 0x3151C + 1, new WrapCallback&lt;HookZzArm32RegisterContext&gt;() &#123; &#x2F;&#x2F; inline wrap导出函数 @Override &#x2F;&#x2F; 方法执行前 public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) &#123; &#x2F;&#x2F; 类似于Frida args[0] Pointer input &#x3D; ctx.getPointerArg(0); byte[] inputhex &#x3D; input.getByteArray(0, 20); Inspector.inspect(inputhex, &quot;IV&quot;); Pointer text &#x3D; ctx.getPointerArg(1); byte[] texthex &#x3D; text.getByteArray(0, 64); Inspector.inspect(texthex, &quot;block&quot;); ctx.push(input); ctx.push(text); &#125;; @Override &#x2F;&#x2F; 方法执行后 public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) &#123; Pointer text &#x3D; ctx.pop(); Pointer IV &#x3D; ctx.pop(); byte[] IVhex &#x3D; IV.getByteArray(0, 20); Inspector.inspect(IVhex, &quot;IV&quot;); byte[] outputhex &#x3D; text.getByteArray(0, 64); Inspector.inspect(outputhex, &quot;block out&quot;); &#125; &#125;); hookZz.disable_arm_arm64_b_branch();&#125; 运算函数入参正常，都是填充的明文，不存在自定义填充或者对明文变换的可能，而出参直接返回结果，所以算法不是在标准流程后魔改，而是修改了算法本身。 SHA1和MD5采用了相同的结构，每512比特分组需要一轮运算，我们的输入长度不超过一个分组的长度，所以只用考虑一轮运算。一轮运算是80步，每隔20步是一种模式。 HookZz实现Inline hook 1234567891011public void hook_315B0()&#123; IHookZz hookZz &#x3D; HookZz.getInstance(emulator); hookZz.enable_arm_arm64_b_branch(); hookZz.instrument(module.base + 0x315B0 + 1, new InstrumentCallback&lt;Arm32RegisterContext&gt;() &#123; @Override public void dbiCall(Emulator&lt;?&gt; emulator, Arm32RegisterContext ctx, HookEntryInfo info) &#123; &#x2F;&#x2F; 通过base+offset inline wrap内部函数，在IDA看到为sub_xxx那些 System.out.println(&quot;R2:&quot;+ctx.getR2Long()); &#125; &#125;);&#125; 但我们整体上需要进行十数次甚至数十次的inline hook，在这种情况下，用HookZz就略有些不方便，不妨试试Unidbg的console debugger。 样本中80步运算 12345678910111213141516for t in range(80): if t &lt;&#x3D; 15: K &#x3D; 0x5a827999 f &#x3D; (b &amp; c) ^ (~b &amp; d) elif t &lt;&#x3D; 19: K &#x3D; 0x6ed9eba1 f &#x3D; b ^ c ^ d elif t &lt;&#x3D; 39: K &#x3D; 0x8f1bbcdc f &#x3D; (b &amp; c) ^ (b &amp; d) ^ (c &amp; d) elif t &lt;&#x3D; 59: K &#x3D; 0x5a827999 f &#x3D; (b &amp; c) ^ (~b &amp; d) else: K &#x3D; 0xca62c1d6 f &#x3D; b ^ c ^ d 在标准流程中，20步切换一下K和非线性函数，一共4种模式，在样本中，每16步切换一下K和非线性函数，一种五种模式，但本质上依然是标准流程里的四个模式，因为一个模式用了两次。 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"unidbg","slug":"unidbg","permalink":"http://onejane.github.io/tags/unidbg/"},{"name":"ida","slug":"ida","permalink":"http://onejane.github.io/tags/ida/"}]},{"title":"SO逆向之京东sign分析","slug":"SO逆向之京东sign分析","date":"2021-11-21T05:54:20.000Z","updated":"2022-10-19T15:19:53.637Z","comments":true,"path":"2021/11/21/SO逆向之京东sign分析/","link":"","permalink":"http://onejane.github.io/2021/11/21/SO%E9%80%86%E5%90%91%E4%B9%8B%E4%BA%AC%E4%B8%9Csign%E5%88%86%E6%9E%90/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 抓包安装某东9.2.2，启动postern，开启socks抓包 分析jadx反编译搜索sign=或者getSign，出现地方太多随机挑一个 跟进HMACSHA256 1234567891011121314private static String HMACSHA256(byte[] bArr, byte[] bArr2) &#123; try &#123; SecretKeySpec secretKeySpec &#x3D; new SecretKeySpec(bArr2, &quot;HmacSHA256&quot;); Mac instance &#x3D; Mac.getInstance(&quot;HmacSHA256&quot;); instance.init(secretKeySpec); return byte2hex(instance.doFinal(bArr)); &#125; catch (NoSuchAlgorithmException e2) &#123; e2.printStackTrace(); return null; &#125; catch (InvalidKeyException e3) &#123; e3.printStackTrace(); return null; &#125;&#125; adb shell dumpsys activity activities|more 查看当前运行app的进程名为com.jingdong.app.mall，尝试使用frida对SecretKeySpec进行hook时SecretKeySpec报错secretKeySpec.$init.overload().implementation 启动了frida-server，app就进程卡死，被检测到了frida，具体方案查看多种特征检测 Frida 尝试修改frida名字为fs1280arm64,不以默认端口27047启动./fs1280arm64 -l 127.0.0.1:8080，转发端口到主机adb forward tcp:8080 tcp:8080 Fridafrida -H 127.0.0.1:8080 com.jingdong.app.mall -l jd.js 根据反编译源码Mac instance = Mac.getInstance(&quot;HmacSHA256&quot;);进行hook，结果并没有hook上，检测frida可以通过hluda反检测hluda-server-15.1.12-android-arm64.xz 123456789101112131415161718192021222324252627282930313233343536373839404142434445setImmediate(function()&#123; Java.perform(function () &#123; var secretKeySpec &#x3D; Java.use(&#39;javax.crypto.spec.SecretKeySpec&#39;); secretKeySpec.$init.overload(&#39;[B&#39;,&#39;java.lang.String&#39;).implementation &#x3D; function (a,b) &#123; var result &#x3D; this.$init(a, b); console.log(&quot;&gt;&gt;&gt; 算法名&quot; + b); return result; &#125; var mac &#x3D; Java.use(&#39;javax.crypto.Mac&#39;); mac.getInstance.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (a) &#123; &#x2F;&#x2F; showStacks(); var result &#x3D; this.getInstance(a); console.log(&quot;mac &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); console.log(&quot;算法名：&quot; + a); return result; &#125; mac.update.overload(&#39;[B&#39;).implementation &#x3D; function (a) &#123; this.update(a); console.log(&quot;mac &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); console.log(&quot;update:&quot; + bytesToString(a)) &#125; mac.update.overload(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;).implementation &#x3D; function (a,b,c) &#123; this.update(a,b,c) console.log(&quot;mac &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); console.log(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c); &#125; mac.doFinal.overload().implementation &#x3D; function () &#123; var result &#x3D; this.doFinal(); console.log(&quot;mac &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); console.log(&quot;doFinal结果(hex):&quot; + bytesToHex(result)); console.log(&quot;doFinal结果(base64):&quot; + bytesToBase64(result)); return result; &#125; mac.doFinal.overload(&#39;[B&#39;).implementation &#x3D; function (a) &#123; var result &#x3D; this.doFinal(a); console.log(&quot;mac &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); console.log(&quot;doFinal参数:&quot; + bytesToString(a)); console.log(&quot;doFinal结果(hex):&quot; + bytesToHex(result)); console.log(&quot;doFinal结果(base):&quot; + bytesToBase64(result)); return result; &#125; &#125;)&#125;) 我们尝试通过hook http，打印调用栈获取堆栈信息，或者hook系统时间函数（因为参数中拼装了st的时间戳），找到sign可能存在的位置 123456789101112131415161718192021222324252627function Where(stack)&#123; var at &#x3D; &quot;&quot; for(var i &#x3D; 0; i &lt; stack.length; ++i)&#123; at +&#x3D; stack[i].toString() + &quot;\\n&quot; &#125; return at&#125;var OkHttpClient &#x3D; Java.use(&quot;okhttp3.OkHttpClient&quot;);OkHttpClient.newCall.implementation &#x3D; function (request) &#123; var result &#x3D; this.newCall(request); console.log(request.toString()); var stack &#x3D; threadinstance.currentThread().getStackTrace(); console.log(&quot;http &gt;&gt;&gt; Full call stack:&quot; + Where(stack)); return result;&#125;;var SystemClass &#x3D; Java.use(&#39;java.lang.System&#39;);SystemClass.currentTimeMillis.implementation &#x3D; function()&#123; var result &#x3D; this.currentTimeMillis(); console.log(&quot;&#x3D;&#x3D;&#x3D;&#x3D; &quot; + result + &quot; &#x3D;&#x3D;&#x3D;&#x3D;&quot;); return result;&#125; 在jadx中搜索com.jingdong.sdk.jdupgrade.inner也一无所获，大概率在so里完成的加密。通过在so中搜索grep &quot;sign&quot; *.so或者strings -f *.so | grep &quot;Sign&quot;批量搜索so中的字符串 使用ida打开libjdbitmapkit.so，搜索sign静态绑定函数，尝试hook该方法com.jingdong.common.utils.BitmapkitUtils 12345678910var checkHookG &#x3D; Java.use(&#39;com.jingdong.common.utils.BitmapkitUtils&#39;);checkHookG.getSignFromJni.implementation &#x3D; function(a,b,c,d,e,f)&#123; var result &#x3D; this.getSignFromJni(a,b,c,d,e,f); console.log(&quot;&gt;&gt;&gt; checkHookG &#x3D; &quot; + b + &#39; &#x2F; &#39; + c + &#39; &#x2F; &#39; + d + &#39; &#x2F; &#39; + d + &#39; &#x2F; &#39; + f + &#39; \\n rc&#x3D; &#39; + result); &#x2F;&#x2F; var stack &#x3D; threadinstance.currentThread().getStackTrace(); &#x2F;&#x2F; console.log(&quot;Full call stack:&quot; + Where(stack)); return result;&#125; 查看BitmapkitUtils类，一共5个参数都是String 主动调用123456789101112131415161718192021function hookBitmapkitUtils() &#123; Java.perform(function () &#123; var currentApplication &#x3D; Java.use(&#39;android.app.ActivityThread&#39;).currentApplication(); var context &#x3D; currentApplication.getApplicationContext(); Java.choose(&quot;com.jingdong.common.utils.BitmapkitUtils&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance &#x3D;&gt;&quot;,instance); var a &#x3D; &quot;search&quot;; var b &#x3D; &#39;&#123;&quot;addrFilter&quot;:&quot;1&quot;,&quot;addressId&quot;:&quot;0&quot;,&quot;articleEssay&quot;:&quot;1&quot;,&quot;deviceidTail&quot;:&quot;35&quot;,&quot;exposedCount&quot;:&quot;0&quot;,&quot;gcLat&quot;:&quot;0.0&quot;,&quot;gcLng&quot;:&quot;0.0&quot;,&quot;imagesize&quot;:&#123;&quot;gridImg&quot;:&quot;709x709&quot;,&quot;listImg&quot;:&quot;455x455&quot;,&quot;longImg&quot;:&quot;709x908&quot;&#125;,&quot;insertArticle&quot;:&quot;1&quot;,&quot;insertScene&quot;:&quot;1&quot;,&quot;insertedCount&quot;:&quot;0&quot;,&quot;isCorrect&quot;:&quot;1&quot;,&quot;keyword&quot;:&quot;gg&quot;,&quot;locLat&quot;:&quot;&quot;,&quot;locLng&quot;:&quot;&quot;,&quot;newMiddleTag&quot;:&quot;1&quot;,&quot;newVersion&quot;:&quot;3&quot;,&quot;oneBoxMod&quot;:&quot;1&quot;,&quot;orignalSearch&quot;:&quot;1&quot;,&quot;orignalSelect&quot;:&quot;1&quot;,&quot;page&quot;:&quot;1&quot;,&quot;pageEntrance&quot;:&quot;1&quot;,&quot;pagesize&quot;:&quot;10&quot;,&quot;pvid&quot;:&quot;&quot;,&quot;searchVersionCode&quot;:&quot;9180&quot;,&quot;secondInsedCount&quot;:&quot;0&quot;,&quot;showShopTab&quot;:&quot;yes&quot;,&quot;showStoreTab&quot;:&quot;1&quot;,&quot;stock&quot;:&quot;1&quot;&#125;&#39; var c &#x3D; &#39;-accf8528c046&#39; var d &#x3D; &#39;-accf8528c046&#39; var e &#x3D; &#39;9.2.2&#39; var signature &#x3D; instance.getSignFromJni(context, a, b, c, d, e) console.log(signature) return signature &#125;,onComplete:function()&#123; console.log(&#39;Search complete&#39;) &#125; &#125;) &#125;)&#125; Xposed尝试主动调用com.jingdong.common.utils.BitmapkitUtils的getSignFromJni，传入通过frida hook得到的参数信息，暴露http请求 HookLoaderpublic static native String getSignFromJni(Context context, String str, String str2, String str3, String str4, String str5); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class HookLoader implements IXposedHookLoadPackage &#123; private final static String TAG &#x3D; &quot;onejane&quot;; public static void log(String s) &#123; Log.i(TAG, s); &#125; public static Context applicationContext; public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; if (loadPackageParam.packageName.equals(&quot;com.jingdong.app.mall&quot;)) &#123; log(&quot;Im comming jd 1&quot;); try &#123; Class&lt;?&gt; ContextClass &#x3D; XposedHelpers.findClass(&quot;android.content.ContextWrapper&quot;, loadPackageParam.classLoader); XposedHelpers.findAndHookMethod(ContextClass, &quot;getApplicationContext&quot;, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); if (applicationContext !&#x3D; null) return; applicationContext &#x3D; (Context) param.getResult(); log(&quot;--&gt;得到上下文&quot;); &#125; &#125;); &#125; catch (Throwable t) &#123; log(&quot;--&gt;获取上下文出错&quot;); &#x2F;&#x2F; XposedBridge.log(t); &#125; &#x2F;&#x2F; http server class myHttpServer extends NanoHTTPD &#123; private static final String REQUEST_ROOT &#x3D; &quot;&#x2F;&quot;; public myHttpServer() throws IOException &#123; &#x2F;&#x2F; 端口是8088，也就是说要通过http:&#x2F;&#x2F;127.0.0.1:8088来访当问 super(8888); start(NanoHTTPD.SOCKET_READ_TIMEOUT, true); log(&quot;---onejane Server---&quot;); &#125; @Override public Response serve(IHTTPSession session) &#123; &#x2F;&#x2F; log(&quot;serve&quot;); &#x2F;&#x2F;这个就是之前分析，重写父类的一个参数的方法， &#x2F;&#x2F;这里边已经把所有的解析操作已经在这里执行了 return super.serve(session); &#125; @Override public Response serve(String uri, Method method, Map&lt;String, String&gt; headers, Map&lt;String, String&gt; parms, Map&lt;String, String&gt; files) &#123; &#x2F;&#x2F; log(&quot;serve xxx&quot;); &#x2F;&#x2F;这就是上边的serve方法最后一行调用的那个过时的方法，这里简单的做个判断就好了 &#x2F;&#x2F; if (!method.equals(Method.POST)) &#123;&#x2F;&#x2F;判断请求方式是否争取 &#x2F;&#x2F; return newFixedLengthResponse(&quot;the request method is incoorect&quot;); &#x2F;&#x2F; &#125; log(uri); String strA &#x3D; &quot;&quot;; String strB &#x3D; &quot;&quot;; for (Map.Entry&lt;String, String&gt; entry : parms.entrySet()) &#123; strA +&#x3D; &quot; parms Key &#x3D; &quot; + entry.getKey() + &quot;, Value &#x3D; &quot; + entry.getValue(); log(&quot;parms Key &#x3D; &quot; + entry.getKey() + &quot;, Value &#x3D; &quot; + entry.getValue()); &#125; for (Map.Entry&lt;String, String&gt; entry : files.entrySet()) &#123; strB +&#x3D; &quot; files Key &#x3D; &quot; + entry.getKey() + &quot;, Value &#x3D; &quot; + entry.getValue(); log(&quot;files Key &#x3D; &quot; + entry.getKey() + &quot;, Value &#x3D; &quot; + entry.getValue()); &#125; Class&lt;?&gt; clazzJDUtils &#x3D; null; try &#123; clazzJDUtils &#x3D; loadPackageParam.classLoader.loadClass(&quot;com.jingdong.common.utils.BitmapkitUtils&quot;); log(&quot;load class:&quot; + clazzJDUtils); &#125; catch (Exception e) &#123; log(&quot;load class err:&quot; + Log.getStackTraceString(e)); return newFixedLengthResponse(&quot;BitmapkitUtils load class is null&quot;); &#125; if (StringUtils.containsIgnoreCase(uri, &quot;getSignFromJni&quot;)) &#123;&#x2F;&#x2F;判断uri是否正确 String str &#x3D; parms.get(&quot;str&quot;); String str2 &#x3D; parms.get(&quot;str2&quot;); String str3 &#x3D; parms.get(&quot;str3&quot;); String str4 &#x3D; parms.get(&quot;str4&quot;); String str5 &#x3D; parms.get(&quot;str5&quot;); log(&quot;getSignFromJni:&quot; + str + &quot; &#x2F; &quot; + str2 + &quot; &#x2F; &quot; + str3 + &quot; &#x2F; &quot; + str4 + &quot; &#x2F; &quot; + str5); if (!StringUtils.isEmpty(str)) &#123;&#x2F;&#x2F;判断post过来的数据是否正确 return getSignFromJni(clazzJDUtils, str, str2, str3, str4, str5); &#125; else &#123; return newFixedLengthResponse(&quot;getSignFromJni postData is null, &quot; + strA + strB); &#125; &#125; &#x2F;&#x2F;判断完了开始解析数据，如果是你想要的数据，那么你就给返回一个正确的格式就好了 &#x2F;&#x2F;举个栗子：return newFixedLengthResponse(&quot;&#123;\\&quot;result\\&quot;:0,\\&quot;success\\&quot;:true&#125;&quot;); return super.serve(uri, method, headers, parms, files); &#125; public Response getSignFromJni(Class&lt;?&gt; clazzUse, String str, String str2, String str3, String str4, String str5) &#123; if (applicationContext !&#x3D; null) &#123; String rc &#x3D; (String) XposedHelpers.callStaticMethod(clazzUse, &quot;getSignFromJni&quot;, applicationContext, str, str2, str3, str4, str5); log(&quot;getSignFromJni &#x3D; &quot; + rc); return newFixedLengthResponse(rc); &#125; return newFixedLengthResponse(&quot;getSignFromJni Context is null&quot;); &#125; &#125; new myHttpServer(); &#125; &#125;&#125; python调用1234567891011121314151617181920212223import requestsdef getKey(k1, k2, k3, k4, k5): data &#x3D; &#123; &quot;str&quot;: k1, &quot;str2&quot;: k2, &quot;str3&quot;: k3, &quot;str4&quot;: k4, &quot;str5&quot;: k5, &#125; sign &#x3D; requests.get(&quot;http:&#x2F;&#x2F;172.20.103.239:8888&#x2F;getSignFromJni&quot;, data).text return signif __name__ &#x3D;&#x3D; &#39;__main__&#39;: body &#x3D; &#39;&#123;&quot;addrFilter&quot;:&quot;1&quot;,&quot;addressId&quot;:&quot;0&quot;,&quot;articleEssay&quot;:&quot;1&quot;,&quot;deviceidTail&quot;:&quot;35&quot;,&quot;exposedCount&quot;:&quot;0&quot;,&quot;gcLat&quot;:&quot;0.0&quot;,&quot;gcLng&quot;:&quot;0.0&quot;,&quot;imagesize&quot;:&#123;&quot;gridImg&quot;:&quot;709x709&quot;,&quot;listImg&quot;:&quot;455x455&quot;,&quot;longImg&quot;:&quot;709x908&quot;&#125;,&quot;insertArticle&quot;:&quot;1&quot;,&quot;insertScene&quot;:&quot;1&quot;,&quot;insertedCount&quot;:&quot;0&quot;,&quot;isCorrect&quot;:&quot;1&quot;,&quot;keyword&quot;:&quot;冰箱&quot;,&quot;localNum&quot;:&quot;0&quot;,&quot;newMiddleTag&quot;:&quot;1&quot;,&quot;newVersion&quot;:&quot;3&quot;,&quot;oneBoxMod&quot;:&quot;1&quot;,&quot;orignalSearch&quot;:&quot;1&quot;,&quot;orignalSelect&quot;:&quot;1&quot;,&quot;page&quot;:&quot;1&quot;,&quot;pageEntrance&quot;:&quot;1&quot;,&quot;pagesize&quot;:&quot;10&quot;,&quot;pvid&quot;:&quot;&quot;,&quot;searchVersionCode&quot;:&quot;9180&quot;,&quot;secondInsedCount&quot;:&quot;0&quot;,&quot;showShopTab&quot;:&quot;yes&quot;,&quot;showStoreTab&quot;:&quot;1&quot;,&quot;stock&quot;:&quot;1&quot;&#125;&#39; sign &#x3D; getKey(&quot;search&quot;, body, &quot;-accf8528c046&quot;, &quot;-accf8528c046&quot;, &quot;9.2.2&quot;) print(sign) ExAndroidNativeEmuOnejaneNdkAndroid Studio新建C++项目，src/main/cpp/native-lib.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#x2F;&#x2F; ---- 静态注册 ----extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_onejanendk_MainActivity_stringFromJNI( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; std::string hello &#x3D; &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str());&#125;&#x2F;&#x2F; ---- 动态注册 ----&#x2F;&#x2F; 获取数组的大小# define NELEM(x) ((int) (sizeof(x) &#x2F; sizeof((x)[0])))&#x2F;&#x2F; 指定要注册的类，对应完整的java类名#define JNIREG_CLASS &quot;com&#x2F;example&#x2F;onejanendk&#x2F;MainActivity&quot;&#x2F;&#x2F; 返回字符串&quot;hello load jni&quot;JNIEXPORT jstring JNICALL native_hello(JNIEnv *env, jclass clazz) &#123; return env-&gt;NewStringUTF(&quot;onejane hello load jni.&quot;);&#125;&#x2F;&#x2F; Java和JNI函数的绑定表static JNINativeMethod method_table[] &#x3D; &#123; &#123;&quot;HelloLoad&quot;, &quot;()Ljava&#x2F;lang&#x2F;String;&quot;, (void *) native_hello&#125;,&#x2F;&#x2F;绑定&#125;;&#x2F;&#x2F; 注册native方法到java中static int registerNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *gMethods, int numMethods) &#123; jclass clazz; clazz &#x3D; env-&gt;FindClass(className); if (clazz &#x3D;&#x3D; NULL) &#123; return JNI_FALSE; &#125; if (env-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) &#123; return JNI_FALSE; &#125; return JNI_TRUE;&#125;int register_ndk_load(JNIEnv *env) &#123; &#x2F;&#x2F; 调用注册方法 return registerNativeMethods(env, JNIREG_CLASS, method_table, NELEM(method_table));&#125;JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) &#123; JNIEnv *env &#x3D; NULL; jint result &#x3D; -1; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_4) !&#x3D; JNI_OK) &#123; return result; &#125; register_ndk_load(env); &#x2F;&#x2F; 返回jni的版本 return JNI_VERSION_1_4;&#125; com/example/onejanendk/MainActivity.java 12345678910111213141516171819202122public class MainActivity extends AppCompatActivity &#123; &#x2F;&#x2F; Used to load the &#39;native-lib&#39; library on application startup. static &#123; System.loadLibrary(&quot;native-lib&quot;); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#x2F;&#x2F; Example of a call to a native method TextView tv &#x3D; findViewById(R.id.sample_text);&#x2F;&#x2F; tv.setText(stringFromJNI()); tv.setText(HelloLoad()); &#125; public native String stringFromJNI(); public native String HelloLoad();&#125; 生成的包中包括&#39;x86&#39;, &#39;armeabi-v7a&#39;, &#39;arm64-v8a&#39;, &#39;x86_64&#39;这些cpu平台的libnative-lib.so 1git clone https:&#x2F;&#x2F;github.com&#x2F;maiyao1988&#x2F;ExAndroidNativeEmu 新建runemu.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687def hook_code(mu, address, size, user_data): try: emu &#x3D; user_data if (not emu.memory.check_addr(address, UC_PROT_EXEC)): logger.error(&quot;addr 0x%08X out of range&quot;%(address,)) sys.exit(-1) # # androidemu.utils.debug_utils.dump_registers(mu, sys.stdout) # androidemu.utils.debug_utils.dump_code(emu, address, size, g_cfd) except Exception as e: logger.exception(&quot;exception in hook_code&quot;) sys.exit(-1) ##def hook_mem_read(uc, access, address, size, value, user_data): pc &#x3D; uc.reg_read(UC_ARM_REG_PC) passdef hook_mem_write(uc, access, address, size, value, user_data): pc &#x3D; uc.reg_read(UC_ARM_REG_PC) passclass MainActivity(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;com&#x2F;example&#x2F;onejanendk&#x2F;MainActivity&#39;): def __init__(self): pass @java_method_def(name&#x3D;&#39;HelloLoad&#39;, signature&#x3D;&#39;()Ljava&#x2F;lang&#x2F;String;&#39;, native&#x3D;True) def hello_load(self, mu): pass def main(): filename &#x3D; &quot;.&#x2F;libnative-lib.so&quot; # Initialize emulator emulator &#x3D; Emulator( vfp_inst_set &#x3D; True, vfs_root&#x3D;posixpath.join(posixpath.dirname(__file__), &quot;vfs&quot;) ) # Register Java class. emulator.java_classloader.add_class(MainActivity) emulator.mu.hook_add(UC_HOOK_CODE, hook_code, emulator) emulator.mu.hook_add(UC_HOOK_MEM_WRITE, hook_mem_write) emulator.mu.hook_add(UC_HOOK_MEM_READ, hook_mem_read) # Load all libraries. lib_module &#x3D; emulator.load_library(filename) # androidemu.utils.debug_utils.dump_symbols(emulator, sys.stdout) # Show loaded modules. logger.info(&quot;Loaded modules:&quot;) for module in emulator.modules: logger.info(&quot;&#x3D;&gt; 0x%08x - %s&quot; % (module.base, module.filename)) logger.info(&quot;&gt;&gt;&gt; libnative-lib.so load_base &#x3D; 0x%x&quot; % (lib_module.base) ) try: # Run JNI_OnLoad. # JNI_OnLoad will call &#39;RegisterNatives&#39;. emulator.call_symbol(lib_module, &#39;JNI_OnLoad&#39;, emulator.java_vm.address_ptr, 0x00) # 第一种方法，直接调用 strRc &#x3D; emulator.call_symbol(lib_module, &#39;Java_com_example_onejanendk_MainActivity_stringFromJNI&#39;,emulator.java_vm.jni_env.address_ptr,0x00) print(&quot;stringFromJNI result call: %s&quot; % strRc) # 第二种方法，通过类成员函数来调用 # Do native stuff. main_activity &#x3D; MainActivity() logger.info(&quot;Response from JNI call: %s&quot; % main_activity.hello_load(emulator)) # Dump natives found. logger.info(&quot;Exited EMU.&quot;) logger.info(&quot;Native methods registered to MainActivity:&quot;) for method in MainActivity.jvm_methods.values(): if method.native: logger.info(&quot;- [0x%08x] %s - %s&quot; % (method.native_addr, method.name, method.signature)) except UcError as e: print(&quot;Exit at 0x%x&quot; % emulator.mu.reg_read(UC_ARM_REG_PC)) raise python模拟123456789101112131415161718192021222324252627282930313233343536def main(): filename &#x3D; &quot;..&#x2F;jd&#x2F;libjdbitmapkit.so&quot; # Initialize emulator emulator &#x3D; Emulator( vfp_inst_set &#x3D; True, vfs_root&#x3D;posixpath.join(posixpath.dirname(__file__), &quot;vfs&quot;) ) # Register Java class. emulator.mu.hook_add(UC_HOOK_CODE, hook_code, emulator) emulator.mu.hook_add(UC_HOOK_MEM_WRITE, hook_mem_write) emulator.mu.hook_add(UC_HOOK_MEM_READ, hook_mem_read) # Load all libraries. lib_module &#x3D; emulator.load_library(filename) # androidemu.utils.debug_utils.dump_symbols(emulator, sys.stdout) # Show loaded modules. logger.info(&quot;Loaded modules:&quot;) for module in emulator.modules: logger.info(&quot;&#x3D;&gt; 0x%08x - %s&quot; % (module.base, module.filename)) logger.info(&quot;&gt;&gt;&gt; libnative-lib.so load_base &#x3D; 0x%x&quot; % (lib_module.base) ) try: # Run JNI_OnLoad. # JNI_OnLoad will call &#39;RegisterNatives&#39;. emulator.call_symbol(lib_module, &#39;JNI_OnLoad&#39;, emulator.java_vm.address_ptr, 0x00) except UcError as e: print(&quot;Exit at 0x%x&quot; % emulator.mu.reg_read(UC_ARM_REG_PC)) raise python runemu.py 报错如下：RuntimeError: Could not find class &#39;com/jingdong/common/utils/BitmapkitUtils&#39; for JNIEnv. 上文已经知道sign静态绑定函数是libjdbitmapkit.so的Java_com_jingdong_common_utils_BitmapkitUtils_getSignFromJni，在JNI中注册 BitmapkitUtils类，JavaClassDef指定类型 1234567from androidemu.java.java_field_def import JavaFieldDefclass BitmapkitUtils(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;com&#x2F;jingdong&#x2F;common&#x2F;utils&#x2F;BitmapkitUtils&#39;): def __init__(self): pass emulator.java_classloader.add_class(BitmapkitUtils) 报错如下：RuntimeError: Could not find static field (&#39;a&#39;, &#39;Landroid/app/Application;&#39;) in class com/jingdong/common/utils/BitmapkitUtils. 123456789class Application(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;android&#x2F;app&#x2F;Application&#39;): def __init__(self): passclass BitmapkitUtils(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;com&#x2F;jingdong&#x2F;common&#x2F;utils&#x2F;BitmapkitUtils&#39;,jvm_fields&#x3D;[JavaFieldDef(&quot;a&quot;, &quot;Landroid&#x2F;app&#x2F;Application;&quot;, True, Application())]): def __init__(self): passemulator.java_classloader.add_class(Application)emulator.java_classloader.add_class(BitmapkitUtils) 报错如下：RuntimeError: Could not find class &#39;android/app/Activity&#39; for JNIEnv. 1234class Activity(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;android&#x2F;app&#x2F;Activity&#39;): def __init__(self): passemulator.java_classloader.add_class(Activity) 报错如下：NameError: name &#39;Application&#39; is not defined 添加Application 1234class Application(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;android&#x2F;app&#x2F;Application&#39;): def __init__(self): passemulator.java_classloader.add_class(Application) 报错如下：RuntimeError: Could not find class &#39;android/content/pm/Signature&#39; for JNIEnv. 添加Signature 1234class Signature(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;android&#x2F;content&#x2F;pm&#x2F;Signature&#39;): def __init__(self): passemulator.java_classloader.add_class(Signature) 报错如下：RuntimeError: Could not find method (&#39;getPackageManager&#39;, &#39;()Landroid/content/pm/PackageManager;&#39;) in class android/app/Activity. 12345678class Activity(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;android&#x2F;app&#x2F;Activity&#39;): def __init__(self): pass @java_method_def(name&#x3D;&#39;getPackageManager&#39;, signature&#x3D;&#39;()Landroid&#x2F;content&#x2F;pm&#x2F;PackageManager;&#39; , native&#x3D;False) def getPackageManager(self, mu): logger.info(&quot;Im in Activity.getPackageManager&quot;) pass 报错如下：没有call_object_method的实现 getPackageManager方法大多在JNI_OnLoad中实现，IDA打开后进入check_status(v21)，CallObjectMethod方法有三个参数，a1是JNIEnv，dword_175DC是十六进制地址，v4是方法id call_object_method函数报错，从jni_env.py里面找到这个函数，发现没有实现这个函数，手动实现如下 1234@native_methoddef call_object_method(self, mu,env,obj_idx, method_id): logger.debug(&quot;JNIEnv-&gt;call_object_method(%d,%s) was called&quot; % (obj_idx,method_id) ) return self.__call_xxx_method(mu, env, obj_idx, method_id, None, 1) 继续运行runemu.py 报错如下，3523215368 方法调用失败 报错的obj_idx和method_id打印出来为JNIEnv-&gt;call_object_method(4096,3523215368) was called 在jni_env.py中的find_class添加log 123rc &#x3D; self.add_local_reference(jclass(clazz))logger.debug(&quot;JNIEnv-&gt;FindClass(%s) was called, rc &#x3D; %d&quot; % (name,rc))return rc 说明3523215368是android/app/Activity类的getPackageManager方法，该方法之前已经补过了，在__call_xxx_method中添加logger.debug(type(pyobj))，发现该对象是&lt;class &#39;__main__.Application&#39;&gt;，因为 Application 和 Activity 都是 ContextWrapper 的子类， getPackageManager 是 ContextWrapper 里的方法，获取的两个 jmethodid 自然是一样的。 我们在java_method_def.py中的方法java_method_def加一个参数jvm_id，并在初始化的时候做兼容 1234567def __init__(self, func_name, func, name, signature, native, args_list&#x3D;None, modifier&#x3D;None, ignore&#x3D;None,jvm_id &#x3D; None): if jvm_id &#x3D;&#x3D; None: self.jvm_id &#x3D; next_method_id() else: self.jvm_id &#x3D; jvm_id logger.debug(&quot;JavaMethodDef name &#x3D;%s,jvm_id &#x3D; %s&quot; % (name,self.jvm_id)) 在runemu.py中为Application和Activity都加上getPackageManager方法，设置jvm_id相同 1234567891011121314151617class Application(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;android&#x2F;app&#x2F;Application&#39;): def __init__(self): pass @java_method_def(name&#x3D;&#39;getPackageManager&#39;, signature&#x3D;&#39;()Landroid&#x2F;content&#x2F;pm&#x2F;PackageManager;&#39; , native&#x3D;False,jvm_id&#x3D;0xd2000000+0x1000) def getPackageManager(self, mu): logger.info(&quot;Im in Application.getPackageManager&quot;) passclass Activity(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;android&#x2F;app&#x2F;Activity&#39;): def __init__(self): pass @java_method_def(name&#x3D;&#39;getPackageManager&#39;, signature&#x3D;&#39;()Landroid&#x2F;content&#x2F;pm&#x2F;PackageManager;&#39; , native&#x3D;False,jvm_id&#x3D;0xd2000000+0x1000) def getPackageManager(self, mu): logger.info(&quot;Im in Activity.getPackageManager&quot;) pass 对抗AndroidNativeEmu思路，拿到Application的对象，然后也去调用Activity类的getPackageManager，跑到这个call_object_method，AndroidNativeEmu就会崩溃 12345678910111213141516171819202122232425262728293031Java_com_example_onejanendk_MainActivity_stringFromJNI( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; jclass AppClass &#x3D; env-&gt;FindClass(&quot;android&#x2F;app&#x2F;Application&quot;); jmethodID midA &#x3D; env-&gt;GetMethodID(AppClass, &quot;getPackageManager&quot;,&quot;()Landroid&#x2F;content&#x2F;pm&#x2F;PackageManager;&quot;); Method *pMid_a &#x3D; (Method *) midA; LOGD(&quot;midA &#x3D; 0x%08X&quot;, midA); LOGD(&quot;pMid_a &#x3D; 0x%08X&quot;, pMid_a-&gt;nativeFunc); jclass AppClassB &#x3D; env-&gt;FindClass(&quot;android&#x2F;app&#x2F;Activity&quot;); jmethodID midB &#x3D; env-&gt;GetMethodID(AppClassB, &quot;getPackageManager&quot;,&quot;()Landroid&#x2F;content&#x2F;pm&#x2F;PackageManager;&quot;); Method *pMid_b &#x3D; (Method *) midB; LOGD(&quot;midB &#x3D; 0x%08X&quot;, midB); LOGD(&quot;pMid_b &#x3D; 0x%08X&quot;, pMid_b-&gt;nativeFunc); &#x2F;&#x2F;获取Activity Thread的实例对象 jclass activityThread &#x3D; env-&gt;FindClass(&quot;android&#x2F;app&#x2F;ActivityThread&quot;); jmethodID currentActivityThread &#x3D; env-&gt;GetStaticMethodID(activityThread, &quot;currentActivityThread&quot;, &quot;()Landroid&#x2F;app&#x2F;ActivityThread;&quot;); jobject at &#x3D; env-&gt;CallStaticObjectMethod(activityThread, currentActivityThread); &#x2F;&#x2F;获取Application，也就是全局的Context jmethodID getApplication &#x3D; env-&gt;GetMethodID(activityThread, &quot;getApplication&quot;, &quot;()Landroid&#x2F;app&#x2F;Application;&quot;); jobject ApplicationObj &#x3D; env-&gt;CallObjectMethod(at, getApplication); jobject packageManager &#x3D; env-&gt;CallObjectMethod(ApplicationObj, midB); std::string hello &#x3D; &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str());&#125; Could not find method (&#39;getPackageName&#39;, &#39;()Ljava/lang/String;&#39;) in class android/app/Activity.回到上面的报错，添加getPackageName 123456789101112131415161718192021222324252627class Application(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;android&#x2F;app&#x2F;Application&#39;): def __init__(self): pass @java_method_def(name&#x3D;&#39;getPackageManager&#39;, signature&#x3D;&#39;()Landroid&#x2F;content&#x2F;pm&#x2F;PackageManager;&#39; , native&#x3D;False,jvm_id&#x3D;0xd2000000+0x1000) def getPackageManager(self, mu): logger.info(&quot;Im in Application.getPackageManager&quot;) pass @java_method_def(name&#x3D;&#39;getPackageName&#39;, signature&#x3D;&#39;()Ljava&#x2F;lang&#x2F;String;&#39; , native&#x3D;False,jvm_id&#x3D;0xd2000000+0x1004) def getPackageName(self, mu): logger.info(&quot;Im in Application.getPackageName&quot;) return &quot;com.jingdong.app.mall&quot;class Activity(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;android&#x2F;app&#x2F;Activity&#39;): def __init__(self): pass @java_method_def(name&#x3D;&#39;getPackageManager&#39;, signature&#x3D;&#39;()Landroid&#x2F;content&#x2F;pm&#x2F;PackageManager;&#39; , native&#x3D;False,jvm_id&#x3D;0xd2000000+0x1000) def getPackageManager(self, mu): logger.info(&quot;Im in Activity.getPackageManager&quot;) pass @java_method_def(name&#x3D;&#39;getPackageName&#39;, signature&#x3D;&#39;()Ljava&#x2F;lang&#x2F;String;&#39; , native&#x3D;False,jvm_id&#x3D;0xd2000000+0x1004) def getPackageName(self, mu): logger.info(&quot;Im in Application.getPackageName&quot;) return &quot;com.jingdong.app.mall&quot; 3523215368 从前面的日志能找到是getPackageInfo方法的jvm_id，打开androidemu.utils.debug_utils.dump_code(emu, address, size, g_cfd) 开关，会输出汇编代码，可以方便定位出错的代码位置。 IDA打开so，跳到0x00002BF4查看 之前调用 Application.getPackageManager() 来返回的PackageManager对象，在之前的代码里我们只打印了一下日志，并没有实现这个函数，引入原作者定义的PackageManager类 123456789101112131415161718192021222324252627282930from androidemu.java.classes.package_manager import *class Application(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;android&#x2F;app&#x2F;Application&#39;): def __init__(self): self.__pkg_Manager &#x3D; PackageManager() pass @java_method_def(name&#x3D;&#39;getPackageManager&#39;, signature&#x3D;&#39;()Landroid&#x2F;content&#x2F;pm&#x2F;PackageManager;&#39; , native&#x3D;False,jvm_id&#x3D;0xd2000000+0x1000) def getPackageManager(self, mu): logger.info(&quot;Im in Application.getPackageManager&quot;) return self.__pkg_Manager @java_method_def(name&#x3D;&#39;getPackageName&#39;, signature&#x3D;&#39;()Ljava&#x2F;lang&#x2F;String;&#39; , native&#x3D;False,jvm_id&#x3D;0xd2000000+0x1004) def getPackageName(self, mu): logger.info(&quot;Im in Application.getPackageName&quot;) return &quot;com.jingdong.app.mall&quot;class Activity(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;android&#x2F;app&#x2F;Activity&#39;): def __init__(self): self.__pkg_Manager &#x3D; PackageManager() pass @java_method_def(name&#x3D;&#39;getPackageManager&#39;, signature&#x3D;&#39;()Landroid&#x2F;content&#x2F;pm&#x2F;PackageManager;&#39; , native&#x3D;False,jvm_id&#x3D;0xd2000000+0x1000) def getPackageManager(self, mu): logger.info(&quot;Im in Activity.getPackageManager&quot;) return self.__pkg_Manager @java_method_def(name&#x3D;&#39;getPackageName&#39;, signature&#x3D;&#39;()Ljava&#x2F;lang&#x2F;String;&#39; , native&#x3D;False,jvm_id&#x3D;0xd2000000+0x1004) def getPackageName(self, mu): logger.info(&quot;Im in Application.getPackageName&quot;) return &quot;com.jingdong.app.mall&quot; 继续报错Could not find field (&#39;signatures&#39;, &#39;[Landroid/content/pm/Signature;&#39;) in class android/content/pm/PackageInfo.，于是我们将实现的Signature类挪到package_manager.py的PackageInfo中 123456789101112class Signature(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;android&#x2F;content&#x2F;pm&#x2F;Signature&#39;): def __init__(self): passclass PackageInfo(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;android&#x2F;content&#x2F;pm&#x2F;PackageInfo&#39;,jvm_fields&#x3D;[ JavaFieldDef(&#39;applicationInfo&#39;, &#39;Landroid&#x2F;content&#x2F;pm&#x2F;ApplicationInfo;&#39;, False), JavaFieldDef(&quot;signatures&quot;, &quot;[Landroid&#x2F;content&#x2F;pm&#x2F;Signature;&quot;, False), ]): def __init__(self): self.applicationInfo &#x3D; ApplicationInfo() self.signatures &#x3D; [Signature(),] 报错Could not find method (&#39;toByteArray&#39;, &#39;()[B&#39;) in class android/content/pm/Signature.，增加toByteArray, 它的返回值是个字节数组，暂时返回一个1234567890 12345678class Signature(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;android&#x2F;content&#x2F;pm&#x2F;Signature&#39;): def __init__(self): pass @java_method_def(name&#x3D;&#39;toByteArray&#39;, signature&#x3D;&#39;()[B&#39;) def toByteArray(self,mu): logger.info(&quot;Im in Signature.toByteArray 3082&quot;) return bytearray.fromhex(&#39;1234567890&#39;) 报错NotImplementedError get_byte_array_elements方法没有实现，将jbyteArray转成jbyte指针，参数有2个，jbyteArray对象和一个bool型的变量，GetByteArrayElements和ReleaseByteArrayElements是成对出现的，我们在jni_eny.py中添加函数 1234567891011121314@native_methoddef get_byte_array_elements(self, mu, env,array_idx,isCopy): logger.debug(&quot;JNIEnv-&gt;get_byte_array_elements (%d,%d) was called &quot;, array_idx,isCopy) obj &#x3D; self.get_local_reference(array_idx) if not isinstance(obj,jbyteArray): raise ValueError(&quot;Expected a jbyteArray&quot;) data_ptr &#x3D; self._emu.native_memory.allocate(len(obj.value)) mu.mem_write(data_ptr,bytes(obj.value)) return data_ptr@native_methoddef release_byte_array_elements(self, mu, env,jbArr,jb_ptr): logger.debug(&quot;JNIEnv-&gt;release_byte_array_elements was called&quot;) self._emu.native_memory.free(jb_ptr) # raise NotImplementedError() 在memory.py中添加free函数 12def free(self,data_ptr): return self._memory.unmap(data_ptr) 修改memory_map.py中的unmap函数 12345678910111213141516171819202122232425262728293031def unmap(self, addr, size &#x3D; None): if not self.__is_multiple(addr): raise RuntimeError(&#39;addr was not multiple of page size (%d, %d).&#39; % (addr, PAGE_SIZE)) if size &#x3D;&#x3D; None: size &#x3D; page_end(addr) - addr else: size &#x3D; page_end(addr+size) - addr try: print(&quot;unmap 0x%08X sz&#x3D;0x0x%08X end&#x3D;0x0x%08X&quot;%(addr,size, addr+size)) if (addr in self.__file_map_addr): file_map_attr &#x3D; self.__file_map_addr[addr] if (addr+size !&#x3D; file_map_attr[0]): raise RuntimeError(&quot;unmap error, range 0x%08X-0x%08X does not match file map range 0x%08X-0x%08X from file %s&quot; %(addr, addr+size, addr, file_map_attr[0])) # self.__file_map_addr.pop(addr) # self.__mu.mem_unmap(addr, size) # except unicorn.UcError as e: #TODO:just for debug for r in self.__mu.mem_regions(): print(&quot;region begin :0x%08X end:0x%08X, prot:%d&quot;%(r[0], r[1], r[2])) # raise return -1 # return 0 报错：Could not find class &#39;com/jingdong/jdsdk/widget/ToastUtils&#39; for JNIEnv. runemu.py添加类ToastUtils 12345678910class ToastUtils(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;com&#x2F;jingdong&#x2F;jdsdk&#x2F;widget&#x2F;ToastUtils&#39;): def __init__(self): pass @java_method_def(name&#x3D;&#39;longToast&#39;,args_list&#x3D;[&quot;jstring&quot;], signature&#x3D;&#39;(Ljava&#x2F;lang&#x2F;String;)V&#39;) def longToast(self, mu, *args, **kwargs): logger.info(&quot;longToast %r&quot; % args) passemulator.java_classloader.add_class(ToastUtils) 终于将JNI_OnLoad 跑通了 getSignFromJni函数我们之前分析过，它一共有6个参数，第一个参数是Context，后面5个都是String 12345from androidemu.java.classes.activity_thread import *activity_Th &#x3D; ActivityThread()result &#x3D; emulator.call_symbol(lib_module, &#39;Java_com_jingdong_common_utils_BitmapkitUtils_getSignFromJni&#39;,emulator.java_vm.jni_env.address_ptr,0x00, activity_Th.getSystemContext(emulator),&quot;asynInteface&quot;, &#39;&#123;&quot;intefaceType&quot;:&quot;asynIntefaceType&quot;,&quot;skuId&quot;:&quot;100008667315&quot;&#125;&#39;, &quot;99001184062989-f460e22c02fa&quot;, &quot;android&quot;, &quot;9.2.2&quot;)logger.info(&quot;Response from JNI call: %s&quot; % result.toString(emulator)) IDA反编译出的伪代码中比java多了两个参数，JNIEnv *env 和 jobject obj JNIEnv类型实际上代表了Java环境，通过这个JNIEnv* 指针，就可以对Java端的代码进行操作。例如，创建Java类中的对象，调用Java对象的方法，获取Java对象中的属性等等 jobject obj参数表示了 如果native方法不是static的话，这个obj就代表这个native方法的类实例，如果native方法是static的话，这个obj就代表这个native方法的类的class对象实例(static方法不需要类实例的，所以就代表这个类的class对象) 报错：RuntimeError: Could not find class &#39;java/lang/StringBuffer&#39; for JNIEnv. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from androidemu.java.jni_env import JNIEnvclass StringBuffer(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;java&#x2F;lang&#x2F;StringBuffer&#39;): def __init__(self): self._str &#x3D; &#39;&#39; pass @java_method_def(name&#x3D;&#39;&lt;init&gt;&#39;, signature&#x3D;&#39;()V&#39;, native&#x3D;False) def init(self, emu): pass @java_method_def(name&#x3D;&#39;append&#39;, args_list&#x3D;[&quot;jstring&quot;], signature&#x3D;&#39;(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuffer;&#39;, native&#x3D;False) def append(self, emu,*args, **kwargs): logger.info(&quot;append %r&quot; % args) pyobj &#x3D; JNIEnv.jobject_to_pyobject(args[0]) self._str +&#x3D; pyobj return self @java_method_def(name&#x3D;&#39;toString&#39;, signature&#x3D;&#39;()Ljava&#x2F;lang&#x2F;String;&#39;, native&#x3D;False) def toString(self, emu): logger.info(&quot;toString %r&quot; % self._str) return String(self._str)class Integer(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;java&#x2F;lang&#x2F;Integer&#39;): def __init__(self): self._int &#x3D; -1 pass @java_method_def(name&#x3D;&#39;&lt;init&gt;&#39;, args_list&#x3D;[&quot;jint&quot;], signature&#x3D;&#39;(I)V&#39;, native&#x3D;False) def init(self, emu,*args, **kwargs): # pyobj &#x3D; JNIEnv.jobject_to_pyobject(args[0]) logger.info(&quot;Integer init %d&quot; % args[0]) self._int &#x3D; args[0] pass @java_method_def(name&#x3D;&#39;toString&#39;, signature&#x3D;&#39;()Ljava&#x2F;lang&#x2F;String;&#39;, native&#x3D;False) def toString(self, emu): logger.info(&quot;Integer toString %d&quot; % self._int) return str(self._int) class String(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;java&#x2F;lang&#x2F;String&#39;): def __init__(self,inStr&#x3D;&#39;&#39;): self._str &#x3D; inStr pass @java_method_def(name&#x3D;&#39;getBytes&#39;, args_list&#x3D;[&quot;jstring&quot;], signature&#x3D;&#39;(Ljava&#x2F;lang&#x2F;String;)[B&#39;, native&#x3D;False) def getBytes(self, emu,*args, **kwargs): logger.info(&quot;%r String getBytes %r&quot; % (self._str, args) ) return bytearray(self._str.encode(&#39;utf8&#39;)) @java_method_def(name&#x3D;&#39;toString&#39;, signature&#x3D;&#39;()Ljava&#x2F;lang&#x2F;String;&#39;, native&#x3D;False) def toString(self, emu): return self._str emulator.java_classloader.add_class(StringBuffer)emulator.java_classloader.add_class(String)emulator.java_classloader.add_class(Integer) Unidbg12345678910111213141516171819202122232425262728293031323334353637383940414243public class JingDong extends AbstractJni &#123; private final AndroidEmulator emulator; private final VM vm; private Module module; private DvmClass bitMapKitUtils; &#x2F;&#x2F; jd apk 文件路径 public String apkPath &#x3D; &quot;&quot;; &#x2F;&#x2F; jd apk so 文件路径 public String soPath &#x3D; &quot;&quot;; private static LibraryResolver createLibraryResolver() &#123; return new AndroidResolver(23); &#125; private static AndroidEmulator createARMEmulator() &#123; return AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;&quot;).build(); &#125; public JingDong() &#123; emulator &#x3D; createARMEmulator(); final Memory memory &#x3D; emulator.getMemory(); memory.setLibraryResolver(createLibraryResolver()); vm &#x3D; emulator.createDalvikVM(new File(apkPath)); vm.setVerbose(true); DalvikModule dm &#x3D; vm.loadLibrary(new File(soPath), false); vm.setJni(this); dm.callJNI_OnLoad(emulator); module &#x3D; dm.getModule(); &#125; public static void main(String[] args) throws IOException &#123; JingDong jd &#x3D; new JingDong(); jd.destroy(); &#125; private void destroy() throws IOException &#123; emulator.close(); &#125;&#125; 12345678910@Overridepublic DvmObject&lt;?&gt; getStaticObjectField(BaseVM vm, DvmClass dvmClass, String signature) &#123; switch (signature) &#123; case &quot;com&#x2F;jingdong&#x2F;common&#x2F;utils&#x2F;BitmapkitUtils-&gt;a:Landroid&#x2F;app&#x2F;Application;&quot;: &#x2F;&#x2F; resolveClass 创建目标类，newObject创建实例 return vm.resolveClass(&quot;android&#x2F;content&#x2F;Application&quot;).newObject(null); &#125; return super.getStaticObjectField(vm, dvmClass, signature);&#125; 这里dvmMethod为空，打个log看看 1234567public static void main(String[] args) throws IOException &#123; Logger.getLogger(DalvikVM.class).setLevel(Level.DEBUG); Logger.getLogger(BaseVM.class).setLevel(Level.DEBUG); JingDong jd &#x3D; new JingDong(); jd.destroy();&#125; 从常规的jni开发来说，一般就是findClass，找到类对象，再通过类对象，找到方法的methodID，再通过callxxmethod来进行调用，第一个参数是jobject（打个比方，如果是static的话，就是jclass），第二个参数就是methodID,第三个参数就是输入参数，根据https://github.com/zhkl0228/unidbg/issues/315 MethodID不匹配，需要明确继承关系。so里面 Activity 类根本就没有实例化，可以在DalvikVM.java中加上硬编码转换或者把Application换成Activity也可以,毕竟Activity也是可以获取Application对象的 或者在getStaticObjectField中表明继承关系 unidbg中getMethodId方法中表明将每个类生成一个hashmap，以signature作为hashcode的key，类方法作为DvmMethod作为value，getMethod时先从hashmap中查找，找不到就从超类中查找，实现继承关关系就是为了DvmMethod的查找，如果application不继承自身hashmap没有，自然超类也没有。 1234567891011121314151617 @Override public DvmObject&lt;?&gt; getStaticObjectField(BaseVM vm, DvmClass dvmClass, String signature) &#123; switch (signature) &#123; case &quot;com&#x2F;jingdong&#x2F;common&#x2F;utils&#x2F;BitmapkitUtils-&gt;a:Landroid&#x2F;app&#x2F;Application;&quot;: &#x2F;&#x2F; resolveClass 创建目标类，newObject创建实例 &#x2F;** * DvmClass activity&#x3D;vm.resolveClass(&quot;android&#x2F;app&#x2F;Activity&quot;) * DvmClass application&#x3D;vm.resolveClass(&quot;android&#x2F;app&#x2F;Application&quot;,activity); * return application.newObject(signature); *&#x2F; return vm.resolveClass(&quot;android&#x2F;app&#x2F;Application&quot;,vm.resolveClass(&quot;android&#x2F;app&#x2F;Activity&quot;)).newObject(null); &#x2F;&#x2F; return vm.resolveClass(&quot;android&#x2F;app&#x2F;Activity&quot;, vm.resolveClass(&quot;android&#x2F;content&#x2F;ContextWrapper&quot;, vm.resolveClass(&quot;android&#x2F;content&#x2F;Context&quot;))).newObject(null);&#x2F;&#x2F; return vm.resolveClass(&quot;android&#x2F;app&#x2F;Application&quot;).newObject(null); &#125; return super.getStaticObjectField(vm, dvmClass, signature); &#125; 12345678@Overridepublic DvmObject&lt;?&gt; callObjectMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) &#123; switch (signature) &#123; case &quot;android&#x2F;app&#x2F;Application-&gt;getApplicationInfo()Landroid&#x2F;content&#x2F;pm&#x2F;ApplicationInfo;&quot;: return new ApplicationInfo(vm); &#125; return super.callObjectMethod(vm, dvmObject, signature, varArg);&#125; 1234567@Overridepublic DvmObject&lt;?&gt; getObjectField(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature) &#123; if (&quot;android&#x2F;content&#x2F;pm&#x2F;ApplicationInfo-&gt;sourceDir:Ljava&#x2F;lang&#x2F;String;&quot;.equals(signature)) &#123; return new StringObject(vm, apkPath); &#125; return super.getObjectField(vm, dvmObject, signature);&#125; objection -N -h 127.0.0.1 -p 8080 -g com.jingdong.app.mall explore -P ~/.objection/plugins –startup-command “android hooking watch class_method com.jingdong.common.utils.BitmapkitZip.unZip –dump-args –dump-return” 远程objection的spawn启动，查看入参并未检测到 frida -U -f com.jingdong.app.mall -l hook_RegisterNatives.js 修改针对性输出并没有想要的信息 IDA打开libjdbitmapkit.so，shift+F12搜索unZip F5拿到伪C代码 尝试hook so的导出函数和偏移地址，findBaseAddress并没有拿到地址，hook失败。 mikrom以listen_wait启动，frida -U 京东 -l hook_libart.js &gt; jd.log，unzip的三个参数分别是app安装目录 第二个参数为META-INF 目录 第三个是RSA，反编译后拿到META-INF下的JINGDONG.RSA 1234567891011121314151617@Overridepublic DvmObject&lt;?&gt; callStaticObjectMethod(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) &#123; switch (signature) &#123; case &quot;com&#x2F;jingdong&#x2F;common&#x2F;utils&#x2F;BitmapkitZip-&gt;unZip(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)[B&quot;: &#123; StringObject udApkPath &#x3D; varArg.getObjectArg(0); StringObject udDirectory &#x3D; varArg.getObjectArg(1); StringObject udFilename &#x3D; varArg.getObjectArg(2); if (apkPath.equals(udApkPath.getValue()) &amp;&amp; &quot;META-INF&#x2F;&quot;.equals(udDirectory.getValue()) &amp;&amp; &quot;.RSA&quot;.equals(udFilename.getValue())) &#123; byte[] data &#x3D; vm.unzip(&quot;META-INF&#x2F;JINGDONG.RSA&quot;); return new ByteArray(vm, data); &#125; &#125; &#125; return super.callStaticObjectMethod(vm ,dvmClass, signature, varArg);&#125; 1234567891011121314@Overridepublic DvmObject&lt;?&gt; newObject(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) &#123; switch (signature) &#123; case &quot;sun&#x2F;security&#x2F;pkcs&#x2F;PKCS7-&gt;&lt;init&gt;([B)V&quot;: &#123; ByteArray array &#x3D; varArg.getObjectArg(0); try &#123; return vm.resolveClass(&quot;sun&#x2F;security&#x2F;pkcs&#x2F;PKCS7&quot;).newObject(new PKCS7(array.getValue())); &#125; catch (ParsingException e) &#123; throw new IllegalStateException(e); &#125; &#125; &#125; return super.newObject(vm, dvmClass, signature, varArg);&#125; 1234567891011@Overridepublic DvmObject&lt;?&gt; callObjectMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) &#123; switch (signature) &#123; case &quot;sun&#x2F;security&#x2F;pkcs&#x2F;PKCS7-&gt;getCertificates()[Ljava&#x2F;security&#x2F;cert&#x2F;X509Certificate;&quot;: &#123; PKCS7 pkcs7 &#x3D; (PKCS7) dvmObject.getValue(); X509Certificate[] certificates &#x3D; pkcs7.getCertificates(); return ProxyDvmObject.createObject(vm, certificates); &#125; &#125; return super.callObjectMethod(vm, dvmObject, signature, varArg);&#125; 123456789101112131415161718192021222324@Overridepublic DvmObject&lt;?&gt; callStaticObjectMethod(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) &#123; switch (signature) &#123; case &quot;com&#x2F;jingdong&#x2F;common&#x2F;utils&#x2F;BitmapkitZip-&gt;objectToBytes(Ljava&#x2F;lang&#x2F;Object;)[B&quot;: &#123; DvmObject&lt;?&gt; obj &#x3D; varArg.getObjectArg(0); byte[] bytes &#x3D; objectToBytes(obj.getValue()); return new ByteArray(vm, bytes); &#125; &#125;&#125;private static byte[] objectToBytes(Object obj) &#123; try &#123; ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream(); ObjectOutputStream oos &#x3D; new ObjectOutputStream(baos); oos.writeObject(obj); oos.flush(); byte[] array &#x3D; baos.toByteArray(); oos.close(); baos.close(); return array; &#125; catch (IOException e) &#123; throw new IllegalStateException(e); &#125;&#125; 环境修补完成，开始调用函数 1234567891011public void callSign() &#123; DvmClass cBitmapkitUtils &#x3D; vm.resolveClass(&quot;com&#x2F;jingdong&#x2F;common&#x2F;utils&#x2F;BitmapkitUtils&quot;); StringObject ret &#x3D; cBitmapkitUtils.callStaticJniMethodObject(emulator, &quot;getSignFromJni()(Landroid&#x2F;content&#x2F;Context;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;, vm.resolveClass(&quot;android&#x2F;content&#x2F;Context&quot;).newObject(null), &quot;clientImage&quot;, &quot;&#123;\\&quot;moduleParams\\&quot;:&#123;\\&quot;18\\&quot;:\\&quot;1565611060638\\&quot;,\\&quot;19\\&quot;:\\&quot;1565229712150\\&quot;,\\&quot;25\\&quot;:\\&quot;1567478504636\\&quot;,\\&quot;27\\&quot;:\\&quot;1602488415048\\&quot;,\\&quot;28\\&quot;:\\&quot;1631069159956\\&quot;,\\&quot;30\\&quot;:\\&quot;1567404005627\\&quot;,\\&quot;32\\&quot;:\\&quot;1567997588476\\&quot;,\\&quot;34\\&quot;:\\&quot;1593508185597\\&quot;,\\&quot;35\\&quot;:\\&quot;1568708316462\\&quot;,\\&quot;37\\&quot;:\\&quot;1630293538664\\&quot;,\\&quot;42\\&quot;:\\&quot;1623741761542\\&quot;,\\&quot;44\\&quot;:\\&quot;1569247647090\\&quot;,\\&quot;46\\&quot;:\\&quot;1588839806224\\&quot;,\\&quot;47\\&quot;:\\&quot;1571295610042\\&quot;,\\&quot;61\\&quot;:\\&quot;1582091758495\\&quot;,\\&quot;70\\&quot;:\\&quot;1585279774645\\&quot;,\\&quot;74\\&quot;:\\&quot;1586781606615\\&quot;&#125;&#125;&quot;, &quot;d5a585639f505b18&quot;, &quot;android&quot;, &quot;10.2.0&quot;); System.out.println(ret.getValue());&#125; 123456789@Overridepublic DvmObject&lt;?&gt; newObjectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123; switch (signature) &#123; case \"java/lang/StringBuffer-&gt;&lt;init&gt;()V\": &#123; return vm.resolveClass(\"java/lang/StringBuffer\").newObject(new StringBuffer()); &#125; &#125; return super.newObjectV(vm, dvmClass, signature, vaList);&#125; 123456789101112@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123; switch (signature) &#123; case \"java/lang/StringBuffer-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuffer;\": &#123; StringBuffer buffer = (StringBuffer) dvmObject.getValue(); StringObject str = vaList.getObjectArg(0); buffer.append(str.getValue()); return dvmObject; &#125; &#125; return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125; 1234567891011@Overridepublic DvmObject&lt;?&gt; newObjectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;java&#x2F;lang&#x2F;Integer-&gt;&lt;init&gt;(I)V&quot;: &#123; int intArg &#x3D; vaList.getIntArg(0); Integer integer &#x3D; Integer.valueOf(intArg); return vm.resolveClass(&quot;java&#x2F;lang&#x2F;Integer&quot;).newObject(integer); &#125; &#125; return super.newObjectV(vm, dvmClass, signature, vaList);&#125; 12345678910@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;java&#x2F;lang&#x2F;Integer-&gt;toString()Ljava&#x2F;lang&#x2F;String；&quot;: &#123; Integer integer &#x3D; (Integer) dvmObject.getValue(); return new StringObject(vm, integer.toString()); &#125; &#125; return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125; 12345678910@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;java&#x2F;lang&#x2F;StringBuffer-&gt;toString()Ljava&#x2F;lang&#x2F;String;&quot;: &#123; StringBuffer stringBuffer &#x3D; (StringBuffer) dvmObject.getValue(); return new StringObject(vm, stringBuffer.toString()); &#125; &#125; return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125; var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"unidbg","slug":"unidbg","permalink":"http://onejane.github.io/tags/unidbg/"},{"name":"ida","slug":"ida","permalink":"http://onejane.github.io/tags/ida/"}]},{"title":"JS逆向之腾讯视频wasm的ckey分析","slug":"JS逆向之腾讯视频wasm的ckey分析","date":"2021-11-18T02:14:57.000Z","updated":"2021-12-12T03:09:39.273Z","comments":true,"path":"2021/11/18/JS逆向之腾讯视频wasm的ckey分析/","link":"","permalink":"http://onejane.github.io/2021/11/18/JS%E9%80%86%E5%90%91%E4%B9%8B%E8%85%BE%E8%AE%AF%E8%A7%86%E9%A2%91wasm%E7%9A%84ckey%E5%88%86%E6%9E%90/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 起因最近对腾讯视频下手了，因为公众号中的视频来源都是腾讯视频，也就是说通过2分钟阅读本文，腾讯视频下整站视频都可以下载下来，也是大多数在线解析vip等视频网站底层实现逻辑，接下来就是建站接广告接流量接法院传单。。。。 分析通过点击播放抓包发现不停的请求http://btrace.video.qq.com/kvcollect，点击发现没有发现，不过这些请求都是m3u8格式片段，我们大胆猜测这是m3u8，将视频切成无数ts小段，一段一段加载播放，可以根据网络状况自动切换视频清晰度，保障流畅播放。那么这种播放方式前端一定有请求索引文件保存ts文件，保存了网络url链接，这些链接顺序播放就完成了整个视频的播放。而我们数据抓取只需要关注这个文件，m3u8转为mp4格式，具体转换代码见https://github.com/OneJane/datautil 废话一堆，开始寻找m3u8请求，通过过滤筛选找到该请求后,http://58.216.106.14/omts.tc.qq.com/AjzDO1DrTOFhSuI4sQa-qkOmtUv8yq9UrejaLeSKpF2M/uwMROfz2r57BIaQXGdGnC2deOm7WRbkbfdWCxMUsemsF2Gfz/svp_50001/NO3RnkZVfa4hKoQCijd2VpXELo5sw-cgX_CMZmI7XeU8ZfKGTirnxL1xJGXvDq2mliBQiL2MqcB6egr3lk7nk3wyBP18yb1lGlcVFNCkQ82kNml8GgGg4BbokC6yjxDcIJIVugQ8OkIG6GOCUijW9a3QpotWcmbZTrCI5kfpcYxax9isGSZL7Q/szg_3772_50001_0bc3hqaciaaameaajrug6rqvcpgdeq6aajca.f304110.ts.m3u8?ver=4 这个请求除去域名外所有参数都加密了，随便找一段加密参数随便搜搜，找到了目标请求http://vd.l.qq.com/proxyhttp 通过json格式化vinfo参数可以判断url+pt即可拿到我们想要的m3u8文件 好戏开场了 参数做减法，去除adparam和vinfoparam中的logintoken和ehost，重点关注guid，flowid，cKey，tm就是时间戳，vid就是请求中的视频id 123456789101112131415161718192021222324252627282930spsrt&#x3D;1charge&#x3D;0defaultfmt&#x3D;autootype&#x3D;ojsonguid&#x3D;a66e56d20401a21c8a35e92ad94eebdeflowid&#x3D;82a7dcecd17cede6b9dc02a39571c4bc_70201platform&#x3D;70201sdtfrom&#x3D;v1104defnpayver&#x3D;0appVer&#x3D;3.4.40host&#x3D;v.qq.comrefer&#x3D;v.qq.comsphttps&#x3D;0tm&#x3D;1637204401spwm&#x3D;4vid&#x3D;s3306hychobdefn&#x3D;fhdswitch&#x3D;0show1080p&#x3D;0isHLS&#x3D;1dtype&#x3D;3sphls&#x3D;1spgzip&#x3D;dlver&#x3D;hdcp&#x3D;0spau&#x3D;1spaudio&#x3D;15defsrc&#x3D;1encryptVer&#x3D;9.1cKey&#x3D;doItDoTdYRR79ZEItZs_lpJX5WFNi2CdS8kE1h7qVaqtHEZQ1c_X6m2O8hQenWPBG5hnGM2UODs52vPBr7VR-rE3OCFTLlH3-xN1QMZmGWCleJdQ62v6N6dvhRBy86U5pyEtRx0KHILNluNDEH6IC8EOljLQ2VfW2sTdospNPlD9535CNT9iSo3cLRH93ogtX_OJeYNVWrDYS8btjkFpGl3F3IxmISJc_8dRIBruTik-e4rt0isxZAXexKqWDJGxu2qxHq-QxHER_ek2fB1T6ywJriVO0ksOGo7_XQLdE-FshP9ARvdxQlEJPKWtziEF2xwGBgYGBgY0KhFT 打上xhr断点vd.l.qq.com/proxyhttp，在调用栈中r.requestPostCgi中参数已经生成，继续向上追溯 追溯到requestNewGetinfoImpl，该方法中p.requestPostCgi发起请求参数已经封装完成，手动调用this.getInfoConfig(&quot;vinfoad&quot;, i)时cKey及guid，flowid都已经加密完成。 进入getInfoConfig 在如下这段代码中guid不存在时，guid: this.context.dataset.guid将通过l.getUserId(this.context.config) 12this.context.dataset.guid || (this.context.config.guid &#x3D; l.getUserId(this.context.config),this.context.dataset.guid &#x3D; this.context.config.guid); 由于l = o(436)，进入436: function(e, t, o)找到了getUserId，当从本地或者内存中取不到时调用d.createGUID()，也就是随机32位字符串。 1234567891011121314getUserId: function(e) &#123; var t &#x3D; e.guid || d.getData(i.localStorageKey.userId); return e.guid || !d.browser.pcqqlive &amp;&amp; !d.browser.macqqlive || (t &#x3D; (t &#x3D; d.getPcClientGuid()) || d.getData(i.localStorageKey.userId)), t || (t &#x3D; d.createGUID(), d.setData(i.localStorageKey.userId, t)), t&#125;,createGUID: function(e) &#123; e &#x3D; e || 32; for (var t &#x3D; &quot;&quot;, o &#x3D; 1; o &lt;&#x3D; e; o++) &#123; t +&#x3D; Math.floor(16 * Math.random()).toString(16) &#125; return t&#125;, 至于flowid跟踪代码得知是通过随机32位字符串_70201 1234updatePlayerId: function() &#123; this.context.dataset.playerId &#x3D; l.createGUID(), this.context.dataset.flowid &#x3D; this.context.dataset.playerId + &quot;_&quot; + this.context.dataset.platform&#125;, 在执行m(s)前s中没有cKey的值，执行后cKey生成 cKey逆向可以将整个js拷贝出来放到vs code中分析。 修改如下 123456789101112131415var createGUID &#x3D; function(e) &#123; e &#x3D; e || 32; for (var t &#x3D; &quot;&quot;, o &#x3D; 1; o &lt;&#x3D; e; o++) &#123; t +&#x3D; Math.floor(16 * Math.random()).toString(16) &#125; return t&#125;&#x2F;&#x2F; n函数存在走 (e.encryptVer &#x3D; &quot;9.1&quot;,n(e.platform, e.appVer, e.vids || e.vid, &quot;&quot;, e.guid, e.tm))function m(e) &#123; &#x2F;&#x2F; var t &#x3D; n ? (e.encryptVer &#x3D; &quot;9.1&quot;, &#x2F;&#x2F; n(e.platform, e.appVer, e.vids || e.vid, &quot;&quot;, e.guid, e.tm)) : (e.encryptVer &#x3D; &quot;8.1&quot;, &#x2F;&#x2F; a(e.vids || e.vid, e.tm, e.appVer, e.guid, e.platform)); var t &#x3D; n(&quot;70201&quot;, &quot;3.4.40&quot;, &quot;s3306hychob&quot;, &quot;&quot;, createGUID(), Date.parse(new Date()).toString().substr(0,10)) return t&#125; 进入n函数 123456n &#x3D; r.cwrap(&quot;getckey&quot;, &quot;string&quot;, [&quot;number&quot;, &quot;string&quot;, &quot;string&quot;, &quot;string&quot;, &quot;string&quot;, &quot;number&quot;]),h.cwrap &#x3D; function(e, t, o, i) &#123; return function() &#123; return u(e, t, o, arguments) &#125;&#125; 进入u函数，其中w函数就是判断存在否则异常报错，Ge根据值是否存在校验跑错，没有操作逻辑。 123456789101112131415161718192021222324252627282930313233343536&#x2F;&#x2F; function w(e, t) &#123;&#x2F;&#x2F; e || Ge(&quot;Assertion failed: &quot; + t)&#x2F;&#x2F; &#125;&#x2F;&#x2F; function Ge(t) &#123;&#x2F;&#x2F; h.onAbort &amp;&amp; h.onAbort(t),&#x2F;&#x2F; t &#x3D; void 0 !&#x3D;&#x3D; t ? (r(t),&#x2F;&#x2F; y(t),&#x2F;&#x2F; JSON.stringify(t)) : &quot;&quot;,&#x2F;&#x2F; v &#x3D; !0,&#x2F;&#x2F; 0;&#x2F;&#x2F; var o &#x3D; &quot;abort(&quot; + t + &quot;) at &quot; + P();&#x2F;&#x2F; throw $e &amp;&amp; $e.forEach(function(e) &#123;&#x2F;&#x2F; o &#x3D; e(o, t)&#x2F;&#x2F; &#125;),&#x2F;&#x2F; o&#x2F;&#x2F; return t&#x2F;&#x2F; &#125;function w(e, t) &#123; return e&#125;function u(e, t, o, i, n) &#123; var r, a, s &#x3D; (w(a &#x3D; h[&quot;_&quot; + (r &#x3D; e)], &quot;Cannot call unknown function &quot; + r + &quot;, make sure it is exported&quot;), a), c &#x3D; [], d &#x3D; 0; if (w(&quot;array&quot; !&#x3D;&#x3D; t, &#39;Return type should not be &quot;array&quot;.&#39;), i) for (var l &#x3D; 0; l &lt; i.length; l++) &#123; var u &#x3D; x[o[l]]; u ? (0 &#x3D;&#x3D;&#x3D; d &amp;&amp; (d &#x3D; je()), c[l] &#x3D; u(i[l])) : c[l] &#x3D; i[l] &#125; var f, p &#x3D; s.apply(null, c); return f &#x3D; p, p &#x3D; &quot;string&quot; &#x3D;&#x3D;&#x3D; t ? T(f) : &quot;boolean&quot; &#x3D;&#x3D;&#x3D; t ? Boolean(f) : f, 0 !&#x3D;&#x3D; d &amp;&amp; He(d), p&#125; 打印出h[&quot;_&quot; + (r = e)],进入后调用了wasm中的函数，即0005098e中的函数，截止到目前为止如果不手动新建wasm对象，逆向cKey将无法继续进行下去 wasm搜索wasm请求，下载wasm文件，该文件在web环境中作为体积小且加载快的二进制格式指令集合，我们不关心底层编译实现，直接通过api调用完成逆向分析。 1234const fs &#x3D; require(&#39;fs&#39;);var wasm_data &#x3D; fs.readFileSync(&#39;.&#x2F;ckey.wasm&#39;)var buffer &#x3D; new Uint8Array(wasm_data);var wasmobject &#x3D; new WebAssembly.Instance(new WebAssembly.Module(buffer)); 报错：WebAssembly.Instance(): Imports argument must be present and must be an object 123var wasm_env &#x3D; &#123;&#125;;var wasmobject &#x3D; new WebAssembly.Instance(new WebAssembly.Module(buffer), wasm_env); 报错：Import #0 module=&quot;env&quot; error: module is not an object or function 重点关注445: function(Ke, e, t)的return WebAssembly.instantiate(e, c) 123456789101112var s, c &#x3D; &#123; global: null, env: null, asm2wasm: g, parent: h&#125;;var g &#x3D; &#123; &quot;f64-rem&quot;: function(e, t) &#123; return e % t &#125;, debugger: function() &#123;&#125;&#125;; 123456789101112&#x2F;&#x2F; 由于h的实现太过复杂，目前只用&#123;&#125;替代var wasm_env &#x3D; &#123; global: &#123;&#125;, env: &#123;&#125;, asm2wasm: &#123; &quot;f64-rem&quot;: function(e, t) &#123; return e % t &#125;, debugger: function() &#123;&#125; &#125;, parent: &#123;&#125;&#125;; 报错：Import #0 module=&quot;env&quot; function=&quot;enlargeMemory&quot; error: function import requires a callable。在h.asmLibraryArg中查看环境变量信息，由于Ge函数只校验参数抛错，所以直接用空函数代替 1234567enlargeMemory: Kfunction K() &#123; G()&#125;function G() &#123; Ge(&quot;Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY&#x3D;X with X higher than the current value &quot; + Q + &quot;, (2) compile with -s ALLOW_MEMORY_GROWTH&#x3D;1 which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with -s ABORTING_MALLOC&#x3D;0 &quot;)&#125; 添加环境变量中的env参数enlargeMemory 1234567891011121314var fun_ &#x3D; function () &#123; &#125;;var wasm_env &#x3D; &#123; global: &#123;&#125;, env: &#123; enlargeMemory: fun_, &#125;, asm2wasm: &#123; &quot;f64-rem&quot;: function(e, t) &#123; return e % t &#125;, debugger: function() &#123;&#125; &#125;, parent: &#123;&#125;&#125;; 报错：Import #1 module=&quot;env&quot; function=&quot;getTotalMemory&quot; error: function import requires a callable,以上同理，以空函数代替 123456789101112131415161718192021222324252627282930313233343536373839404142434445var wasm_env &#x3D; &#123; global: &#123;&#125;, env: &#123; abort: fun_, assert: fun_, enlargeMemory: fun_, abortOnCannotGrowMemory: fun_, abortStackOverflow: fun_, nullFunc_ii: fun_, nullFunc_iiii: fun_, nullFunc_v: fun_, nullFunc_vi: fun_, nullFunc_viiii: fun_, nullFunc_viiiii: fun_, nullFunc_viiiiii: fun_, invoke_ii: fun_, invoke_iiii: fun_, invoke_v: fun_, invoke_vi: fun_, invoke_viiii: fun_, invoke_viiiii: fun_, invoke_viiiiii: fun_, __ZSt18uncaught_exceptionv: fun_, ___cxa_find_matching_catch: fun_, ___gxx_personality_v0: fun_, ___lock: fun_, ___resumeException: fun_, ___setErrNo: fun_, ___syscall140: fun_, ___syscall146: fun_, ___syscall54: fun_, ___syscall6: fun_, ___unlock: fun_, _abort: fun_, _emscripten_memcpy_big: fun_, flush_NO_FILESYSTEM: fun_, &#125;, asm2wasm: &#123; &quot;f64-rem&quot;: function(e, t) &#123; return e % t &#125;, debugger: function() &#123;&#125; &#125;, parent: &#123;&#125;&#125;; 报错：Import #1 module=&quot;env&quot; function=&quot;getTotalMemory&quot; error: function import requires a callable 12var Q &#x3D; 16777216getTotalMemory: function () &#123; return Q &#125;, 报错：Import #20 module=&quot;env&quot; function=&quot;_get_unicode_str&quot; error: function import requires a callable 123456789101112131415161718192021222324_get_unicode_str: function () &#123; function a(e) &#123; return e ? 48 &lt; e.length ? e.substr(0, 48) : e : &quot;&quot; &#125; var e &#x3D; function () &#123; var e &#x3D; document.URL , t &#x3D; window.navigator.userAgent.toLowerCase() , o &#x3D; &quot;&quot;; 0 &lt; document.referrer.length &amp;&amp; (o &#x3D; document.referrer); try &#123; 0 &#x3D;&#x3D; o.length &amp;&amp; 0 &lt; opener.location.href.length &amp;&amp; (o &#x3D; opener.location.href) &#125; catch (e) &#123; &#125; var i &#x3D; window.navigator.appCodeName , n &#x3D; window.navigator.appName , r &#x3D; window.navigator.platform , e &#x3D; a(e) , o &#x3D; a(o); return e + &quot;|&quot; + (t &#x3D; a(t)) + &quot;|&quot; + o + &quot;|&quot; + i + &quot;|&quot; + n + &quot;|&quot; + r &#125;() , t &#x3D; q(e) + 1, o &#x3D;Ve(t);&#x2F;&#x2F; 5250872; &#x2F;&#x2F;_malloc(t); console.log(&#39;---&#39;,t, o) return S(e, o, t + 1), o&#125;, 报错：Import #21 module=&quot;env&quot; function=&quot;memoryBase&quot; error: global import must be a number or WebAssembly.Global object 报错：Import #22 module=&quot;env&quot; function=&quot;tableBase&quot; error: global import must be a number or WebAssembly.Global object 12memoryBase: 1024,tableBase: 0, 报错：Import #23 module=&quot;env&quot; function=&quot;DYNAMICTOP_PTR&quot; error: global import must be a number or WebAssembly.Global object 报错：Import #24 module=&quot;env&quot; function=&quot;tempDoublePtr&quot; error: global import must be a number or WebAssembly.Global object 报错：Import #25 module=&quot;env&quot; function=&quot;STACKTOP&quot; error: global import must be a number or WebAssembly.Global object 报错：Import #26 module=&quot;env&quot; function=&quot;STACK_MAX&quot; error: global import must be a number or WebAssembly.Global object 1234DYNAMICTOP_PTR: 7968,tempDoublePtr: 7952,tempDoublePtr: 7952,STACK_MAX: 5250864, 报错：Import #27 module=&quot;global&quot; function=&quot;NaN&quot; error: global import must be a number or WebAssembly.Global object 1234global: &#123; NaN: NaN, Infinity: 1 &#x2F; 0&#125; 报错：Import #29 module=&quot;env&quot; function=&quot;memory&quot; error: memory import must be a WebAssembly.Memory object 搜索WebAssembly.Memory 12345var Q &#x3D; 16777216, j &#x3D; 65536;var wasmMemory &#x3D; new WebAssembly.Memory(&#123; initial: Q &#x2F; j, maximum: Q &#x2F; j&#125;) 报错：Import #30 module=&quot;env&quot; function=&quot;table&quot; error: table import requires a WebAssembly.Table 12345table: new WebAssembly.Table(&#123; initial: 99, maximum: 99, element: &quot;anyfunc&quot;&#125;), 初始化好wasm后，开始处理function u(e, t, o, i, n) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&#x2F;&#x2F; h[&quot;_&quot; + (r &#x3D; e)] &#x3D; wasm._getckey&#x2F;&#x2F; je &#x3D; wasm.stackSave&#x2F;&#x2F; He &#x3D; wasm.stackRestore&#x2F;&#x2F; Fe &#x3D; wasm.stackAlloc&#x2F;&#x2F; Ve &#x3D; wasm._malloc 修改_get_unicode_str中的Vefunction _getckey() &#123; return wasmobject.exports._getckey.apply(null, arguments)&#125;function stackSave() &#123; return wasmobject.exports.stackSave.apply(null, arguments)&#125;function stackRestore() &#123; return wasmobject.exports.stackRestore.apply(null, arguments)&#125;function stackAlloc() &#123; return wasmobject.exports.stackAlloc.apply(null, arguments)&#125;function _malloc() &#123; return wasmobject.exports._malloc.apply(null, arguments)&#125;&#x2F;&#x2F; 函数引用完成n函数 function S(e, t, o) &#123; &#x2F;&#x2F; o(a, b, c) return w(&quot;number&quot; &#x3D;&#x3D; typeof o, &quot;stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!&quot;), E(e, C, t, o)&#125;function T(e, t) &#123; if (0 &#x3D;&#x3D;&#x3D; t || !e) return &quot;&quot;; for (var o, i &#x3D; 0, n &#x3D; 0; w(e + n &lt; Q), i |&#x3D; o &#x3D; C[e + n &gt;&gt; 0], (0 !&#x3D; o || t) &amp;&amp; (n++, !t || n !&#x3D; t); ) ; t &#x3D; t || n; var r &#x3D; &quot;&quot;; if (i &lt; 128) &#123; for (var a; 0 &lt; t; ) a &#x3D; String.fromCharCode.apply(String, C.subarray(e, e + Math.min(t, 1024))), r &#x3D; r ? r + a : a, e +&#x3D; 1024, t -&#x3D; 1024; return r &#125; return _(C, e)&#125;var l &#x3D; &#123; stackSave: function() &#123; stackSave() &#125;, stackRestore: function() &#123; stackRestore() &#125;, arrayToC: function(e) &#123; var t, o, i &#x3D; stackAlloc(e.length); &#x2F;&#x2F; Fe(e.length); return o &#x3D; i, w(0 &lt;&#x3D; (t &#x3D; e).length, &quot;writeArrayToMemory array must have a length (should be an array or typed array)&quot;), R.set(t, o), i &#125;, stringToC: function(e) &#123; var t, o &#x3D; 0; return null !&#x3D; e &amp;&amp; 0 !&#x3D;&#x3D; e &amp;&amp; (t &#x3D; 1 + (e.length &lt;&lt; 2), S(e, o &#x3D; stackAlloc(t), t)), &#x2F;&#x2F;Fe(e.length); o &#125;&#125;var x &#x3D; &#123; string: l.stringToC, array: l.arrayToC&#125;function n(...args) &#123; var e &#x3D; &quot;getckey&quot; var t &#x3D; &quot;string&quot; var o &#x3D; [&quot;number&quot;, &quot;string&quot;, &quot;string&quot;, &quot;string&quot;, &quot;string&quot;, &quot;number&quot;] var i &#x3D; args var n &#x3D; undefined var r, a, s &#x3D; (w(a &#x3D; _getckey, &quot;Cannot call unknown function &quot; + r + &quot;, make sure it is exported&quot;), a), c &#x3D; [], d &#x3D; 0; &#x2F;&#x2F; var r &#x3D; &quot;getckey&quot;, a &#x3D; _getckey, s &#x3D; _getckey, c &#x3D; [], d &#x3D; 0; &#x2F;&#x2F; if (w(&quot;array&quot; !&#x3D;&#x3D; t, &#39;Return type should not be &quot;array&quot;.&#39;), &#x2F;&#x2F; i) for (var l &#x3D; 0; l &lt; i.length; l++) &#123; var u &#x3D; x[o[l]]; console.log(&quot;uuuu&quot;,u) u ? (0 &#x3D;&#x3D;&#x3D; d &amp;&amp; (d &#x3D; stackSave()), &#x2F;&#x2F; je() c[l] &#x3D; u(i[l])) : c[l] &#x3D; i[l] &#125; var f, p &#x3D; s.apply(null, c); return f &#x3D; p, p &#x3D; &quot;string&quot; &#x3D;&#x3D;&#x3D; t ? T(f) : &quot;boolean&quot; &#x3D;&#x3D;&#x3D; t ? Boolean(f) : f, 0 !&#x3D;&#x3D; d &amp;&amp; stackRestore(d), &#x2F;&#x2F; He(d) p&#125; 报错：TypeError: Cannot set property &#39;7984&#39; of undefined 说明在内存操作的时候有部分变量我们没有注意到，回到445: function(Ke, e, t)中，抽出部分值操作 12345678function X() &#123; R &#x3D; new Int8Array(k), O &#x3D; new Int16Array(k), I &#x3D; new Int32Array(k), C &#x3D; new Uint8Array(k), M &#x3D; new Uint32Array(k)&#125;X() 报错：document is not defined，window is not defined，Cannot read property &#39;userAgent&#39; of undefined… 12345678910111213var document &#x3D; &#123; URL: &quot;&quot;, referrer: &quot;&quot;&#125;var window &#x3D; &#123; document: document, navigator: &#123; userAgent: &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&quot;, appCodeName: &quot;Mozilla&quot;, appName: &quot;Netscape&quot;, platform: &quot;Win32&quot; &#125;,&#125;; node ckey_blog.js 主动调用由于公众号和正常腾讯视频中的部分参数不一致，修改function m(e) 1234567function getCKey(plateform,appVer,vid) &#123; &#x2F;&#x2F; var t &#x3D; n ? (e.encryptVer &#x3D; &quot;9.1&quot;, &#x2F;&#x2F; n(e.platform, e.appVer, e.vids || e.vid, &quot;&quot;, e.guid, e.tm)) : (e.encryptVer &#x3D; &quot;8.1&quot;, &#x2F;&#x2F; a(e.vids || e.vid, e.tm, e.appVer, e.guid, e.platform)); var t &#x3D; n(plateform, appVer, vid, &quot;&quot;, createGUID(), Date.parse(new Date()).toString().substr(0, 10)) return t&#125; ckey.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344import execjsimport reimport requestsimport jsonfrom m3u8 import M3u8Downloadwith open(&quot;ckey_blog.js&quot;, &quot;r&quot;,encoding&#x3D;&quot;utf-8&quot;) as f: js_code &#x3D; f.read()# target_url &#x3D; &quot;http:&#x2F;&#x2F;v.qq.com&#x2F;txp&#x2F;iframe&#x2F;player.html?origin&#x3D;https%3A%2F%2Fmp.weixin.qq.com&amp;chid&#x3D;17&amp;vid&#x3D;s3306hychob&amp;autoplay&#x3D;false&amp;full&#x3D;true&amp;show1080p&#x3D;false&amp;isDebugIframe&#x3D;false&quot;target_url &#x3D; &quot;https:&#x2F;&#x2F;v.qq.com&#x2F;x&#x2F;cover&#x2F;bzfkv5se8qaqel2&#x2F;j002024w2wg.html&quot;vinfoparam &#x3D; &quot;spsrt&#x3D;1&amp;charge&#x3D;0&amp;defaultfmt&#x3D;auto&amp;otype&#x3D;ojson&amp;guid&#x3D;&#123;&#125;&amp;flowid&#x3D;&#123;&#125;&amp;platform&#x3D;&#123;&#125;&amp;sdtfrom&#x3D;&#123;&#125;&amp;defnpayver&#x3D;0&amp;appVer&#x3D;&#123;&#125;&amp;host&#x3D;v.qq.com&amp;sphttps&#x3D;0&amp;tm&#x3D;1637237951&amp;spwm&#x3D;4&amp;vid&#x3D;&#123;&#125;&amp;defn&#x3D;&amp;fhdswitch&#x3D;0&amp;show1080p&#x3D;0&amp;isHLS&#x3D;1&amp;dtype&#x3D;3&amp;sphls&#x3D;1&amp;spgzip&#x3D;&amp;dlver&#x3D;&amp;hdcp&#x3D;0&amp;spau&#x3D;1&amp;spaudio&#x3D;15&amp;defsrc&#x3D;1&amp;encryptVer&#x3D;9.1&amp;cKey&#x3D;&#123;&#125;&quot;data &#x3D; &#123;&#125;data[&quot;buid&quot;] &#x3D; &quot;vinfoad&quot;guid &#x3D; execjs.compile(js_code).call(&#39;createGUID&#39;)# 区分腾讯视频还是公众号视频if &quot;mp.weixin.qq.com&quot; in target_url: vid &#x3D; re.compile(r&quot;&amp;vid&#x3D;(.*?)&amp;&quot;).findall(target_url)[0] # ?非贪婪 plateform &#x3D; &quot;70201&quot; flowid &#x3D; execjs.compile(js_code).call(&#39;createGUID&#39;) + &quot;_&quot; + plateform sdtfrom &#x3D; &quot;v1104&quot; appVer &#x3D; &quot;3.4.40&quot; ckey &#x3D; execjs.compile(js_code).call(&#39;getCKey&#39;,plateform,appVer,vid)else: vid &#x3D; target_url.split(&quot;&#x2F;&quot;)[-1].split(&quot;.&quot;)[0] plateform &#x3D; &quot;10201&quot; flowid &#x3D; execjs.compile(js_code).call(&#39;createGUID&#39;) + &quot;_&quot; + plateform sdtfrom &#x3D; &quot;v1010&quot; appVer &#x3D; &quot;3.5.57&quot; ckey &#x3D; execjs.compile(js_code).call(&#39;getCKey&#39;, plateform, appVer, vid)data[&quot;vinfoparam&quot;] &#x3D; vinfoparam.format(guid,flowid,plateform,sdtfrom,appVer,vid,ckey)result &#x3D; requests.post(&#39;http:&#x2F;&#x2F;vd.l.qq.com&#x2F;proxyhttp&#39;, data&#x3D;json.dumps(data)).json()# print(result)if result.get(&quot;errCode&quot;) &#x3D;&#x3D; 0: url_data &#x3D; json.loads(result.get(&quot;vinfo&quot;))[&quot;vl&quot;][&quot;vi&quot;][0][&quot;ul&quot;][&quot;ui&quot;][0] url &#x3D; url_data[&quot;url&quot;]+url_data[&quot;hls&quot;][&quot;pt&quot;] print(url) M3u8Download(url, &quot;test1&quot;, max_workers&#x3D;64, num_retries&#x3D;10, ) 总结针对wasm二进制方式加密的js逆向，类似安卓的so逆向，可以选择硬肛分析汇编代码，当然也可以选择Unidbg主动调用，本文利用js的WebAssembly实例化wasm并完成调用分析cKey，完成腾讯系视频的下载，至于会员视频分析logintoken参数，下次一定，下次一定。。。 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"},{"name":"wasm","slug":"wasm","permalink":"http://onejane.github.io/tags/wasm/"}]},{"title":"frida常用api大全","slug":"frida常用api大全","date":"2021-11-13T04:14:18.000Z","updated":"2022-10-19T08:04:43.244Z","comments":true,"path":"2021/11/13/frida常用api大全/","link":"","permalink":"http://onejane.github.io/2021/11/13/frida%E5%B8%B8%E7%94%A8api%E5%A4%A7%E5%85%A8/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 java type 语法 int类型 int float类型 float boolean类型 boolean string类型 java.lang.String byte类型 [B char类型 [C list结构 java.util.List 安卓上下文 android.content.Context 符号 作用 $init hook构造函数 $new() 实例化对象用户主动调用 frida中数组格式[java.lang.String; java type so type int I float F boolean Z string java.lang.String byte B long J short S double D char C 12345678910111213141516171819202122&#x2F;&#x2F; byte array to string&#x2F;&#x2F; 方法一var JavaString &#x3D; Java.use(&quot;java.lang.String&quot;);JavaString.$new(&#39;byte array&#39;).toString();&#x2F;&#x2F; 方法二var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;);&#x2F;&#x2F; 转成 hex 在转 stringByteString.of(&#39;byte array&#39;).hex();&#x2F;&#x2F; 使用 Java.cast 把 java byet 转成 java Objectvar javaBytes &#x3D; Java.use(&#39;java.lang.String&#39;).$new(&quot;aaaaa&quot;).getBytes();var javaBytesClass &#x3D; Java.cast(javaBytes, Java.use(&#39;java.lang.Object&#39;)).getClass();&#x2F;&#x2F; 使用 Java.array 把 js array 转成 java Object arrayvar params &#x3D; [ Java.use(&#39;java.lang.String&#39;).$new(&#39;str1&#39;), Java.use(&#39;java.lang.String&#39;).$new(&#39;str2&#39;), Java.use(&#39;java.lang.Boolean&#39;).$new(false), Java.use(&#39;java.lang.Integer&#39;).$new(0)];var ps &#x3D; Java.array(&#39;Ljava.lang.Object;&#39;, params); 动静态函数静态函数 use123456789101112131415161718192021222324252627282930313233function static() &#123; Java.perform(function () &#123;&#x2F;&#x2F;只要是java的代码都要跑在Java.perform里面 &#x2F;&#x2F; hook Java.use(&quot;com.example.junior.util.Utils&quot;).dip2px.implementation &#x3D; function (context, float) &#123; &#x2F;&#x2F;return null; var result &#x3D; this.dip2px(context, 100) console.log(&quot;context,float,result &#x3D;&#x3D;&gt; &quot;, context, float, result); &#x2F;&#x2F; 打印log console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return 26; &#125; Java.use(&#39;com.xx.app.ShufferMap&#39;).show.implementation &#x3D; function (map) &#123; console.log(JSON.stringify(map)); var hm &#x3D; Java.use(&#39;java.util.HashMap&#39;).$new(); hm.put(&quot;user&quot;,&quot;dajianbang&quot;); hm.put(&quot;pass&quot;,&quot;87654321&quot;); hm.put(&quot;code&quot;,&quot;123456&quot;); return this.show(hm); &#125; var myBytes &#x3D; StringClass.$new(&quot;Hello World&quot;).getBytes(); var base64Class &#x3D; Java.use(&quot;android.util.Base64&quot;); &#x2F;&#x2F; 主动调用 var result &#x3D; Java.use(&quot;com.xiaojianbang.app.RSA&quot;).encrypt(myBytes); console.log(&quot;result is :&quot;, result); console.log(JSON.stringify(result)); console.log(&quot;base64 result is :&quot;, base64Class.encodeToString(result,0)); Java.use(&quot;java.lang.String&quot;).valueOf(1); &#125;)&#125; 实例函数 choose123456789101112131415161718192021222324function dynamic()&#123; Java.perform(function()&#123; &#x2F;&#x2F; 主动调用 函数 Java.choose(&quot;com.example.junior.CalculatorActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance &#x3D;&gt;&quot;,instance); console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.clear(&quot;666&quot;)) console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.showText.value) &#125;,onComplete:function()&#123; console.log(&#39;Search complete&#39;) &#125; &#125;) Java.choose(&quot;com.xiaojianbang.app.Money&quot;,&#123; onMatch : function(instance)&#123; console.log(&quot;find it!!&quot;, instance.getInfo()); &#125;, onComplete: function()&#123; console.log(&quot;compelete!!!&quot;); &#125; &#125;) &#x2F;&#x2F; $new 实例化类 Java.use(&quot;java.lang.String&quot;).$new().toString(); &#125;)&#125; so导出函数12345678var native_func &#x3D; Module.findExportByName(&quot;$&#123;so file name&#125;&quot;, &quot;$&#123;so export function name&#125;&quot;);Interceptor.attach(native_func, &#123; &#x2F;&#x2F; 函数开始 onEnter: function (args) &#123;&#125;, &#x2F;&#x2F; 函数结束 onLeave: function (return_val) &#123;&#125;&#125;); so偏移地址123456789101112var native_func_addr &#x3D; Module.findBaseAddress(&quot;$&#123;so file name&#125;&quot;);var native_addr &#x3D; native_func_addr.add($&#123;so 函数偏移地址&#125;);Interceptor.attach(native_addr, &#123; &#x2F;&#x2F; 函数开始 onEnter: function (args) &#123; &#x2F;&#x2F; 读取 r0 的数据 this.context.r0.readCString() &#125;, &#x2F;&#x2F; 函数结束 onLeave: function (return_val) &#123;&#125;&#125;); JNIEnv函数123&#x2F;&#x2F; 获取 JNIEnvvar env &#x3D; Java.vm.getEnv();var jstring &#x3D; env.newStringUtf(&#39;xiaojianbang&#39;); 动静态变量修改静态变量 use 123456789function staticField()&#123; Java.perform(function()&#123; var divscale &#x3D; Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value; console.log(&quot;divscale1 is &#x3D;&gt;&quot;,divscale); Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value&#x3D;20; divscale &#x3D; Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value; console.log(&quot;divscale2 is &#x3D;&gt;&quot;,divscale); &#125;)&#125; 动态变量 choose 12345678910111213function dynamicField()&#123; Java.perform(function()&#123; Java.choose(&quot;com.example.junior.CalculatorActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance &#x3D;&gt;&quot;,instance); console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.showText.value) instance.showText.value &#x3D; &quot;123&quot; &#125;,onComplete:function()&#123; console.log(&#39;Search complete&#39;) &#125; &#125;) &#125;)&#125; 构造函数 实例化1234567891011&#x2F;&#x2F; Utils.test(new Money(200，&quot;美元&quot;)) Java.perform(function () &#123; var money &#x3D; Java.use(&#39;com.xx.app.Money&#39;) &#x2F;&#x2F; 如果要自定义实例化就要获取并重写 var utils &#x3D; Java.use(&#39;com.xx.app.Utils&#39;); utils.test.overload(&quot;com.xx.app.Money&quot;).implementation &#x3D; function (obj) &#123; var myBytes &#x3D; StringClass.$new(&quot;Hello World&quot;).getBytes(); &#x2F;&#x2F; 重新实例化 $new() var mon &#x3D; money.$new(999,&#39;我的天&#39;) return mon.getInfo(); &#x2F;&#x2F; 根据需求return &#125;&#125;); Hook实例化1JavaClass.$new.implementation &#x3D; function () &#123;&#125; Hook构造函数123456789101112131415161718192021222324&#x2F;&#x2F; JavaClass.$init.implementation &#x3D; function () &#123;&#125;Java.perform(function () &#123; var money &#x3D; Java.use(&#39;com.xx.app.Money&#39;); money.$init.implementation &#x3D; function (a, b) &#123; console.log(&quot;构造函数Hook中...&quot;, a, b); return this.$init(a, b); &#125; &#x2F;&#x2F; hook 构造方法 $init var MoneyClass &#x3D; Java.use(&quot;com.kevin.app.Money&quot;); MoneyClass.$init.overload().implementation &#x3D; function () &#123; console.log(&quot;hook Money $init&quot;); this.$init(); &#125; var StringClass &#x3D; Java.use(&quot;java.lang.String&quot;); var MoneyClass &#x3D; Java.use(&quot;com.xiaojianbang.app.Money&quot;); MoneyClass.$init.overload(&#39;java.lang.String&#39;, &#39;int&#39;).implementation &#x3D; function (x, y) &#123; console.log(&#39;hook Money init&#39;); var myX &#x3D; StringClass.new(&quot;Hello World!&quot;); var myY &#x3D; 9999; this.$init(myX, myY); &#125; &#125;); sleep123456789101112function sleep(numberMillis) &#123; var now &#x3D; new Date(); var exitTime &#x3D; now.getTime() + numberMillis; while (true) &#123; now &#x3D; new Date(); if (now.getTime() &gt; exitTime) return; &#125;&#125;&#x2F;&#x2F; 毫秒级别sleep(1000) 枚举类所有方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#x2F;&#x2F;Hook类的所有方法Java.perform(function()&#123; var md5 &#x3D; Java.use(&quot;com.xxx.xxx.xxx&quot;); var methods &#x3D; md5.class.getDeclaredMethods(); for(var j &#x3D; 0; j &lt; methods.length; j++)&#123; var methodName &#x3D; methods[j].getName(); console.log(methodName); &#125;&#125;);function main() &#123; Java.perform(function () &#123; &#x2F;&#x2F; return String[] class name var classList &#x3D; Java.enumerateLoadedClassesSync(); for (var i &#x3D; 0; i &lt; classList.length; i++) &#123; var targetClass &#x3D; classList[i]; if (targetClass.indexOf(&quot;com.xiaojianbang.app.Money&quot;) !&#x3D; -1) &#123; console.log(&quot;hook the class: &quot;, targetClass); var TargetClass &#x3D; Java.use(targetClass); &#x2F;&#x2F; 利用反射获取类中的所有方法 var methodsList &#x3D; TargetClass.class.getDeclaredMethods(); for (var k &#x3D; 0; k &lt; methodsList.length; k++) &#123; console.log(methodsList[k].getName()); &#x2F;&#x2F; hook methodName 这个类的所有方法（难点在于每个方法的参数是不同的） for (var k &#x3D; 0; k &lt; TargetClass[methodName].overloads.length; k++) &#123; TargetClass[methodName].overloads[k].implementation &#x3D; function () &#123; &#x2F;&#x2F; 这是 hook 逻辑 for (var i &#x3D; 0; i &lt; arguments.length; i++) &#123; console.log(arguments[i]); &#125; return this[methodName].apply(this, arguments); &#x2F;&#x2F; 重新调用 &#125; &#125; &#125; &#125; &#125; &#125;)&#125; function main()&#123; Java.perform(function()&#123; Java.enumerateLoadedClasses(&#123; onMatch: function(name,handle)&#123; if (name.indexOf(&quot;com.xiaojianbang.app.Money&quot;) !&#x3D; -1)&#123; console.log(name,handle); &#x2F;&#x2F; 利用反射 获取类中的所有方法 var TargetClass &#x3D; Java.use(name); &#x2F;&#x2F; return Method Object List var methodsList &#x3D; TargetClass.class.getDeclaredMethods(); for (var i &#x3D; 0; i &lt; methodsList.length; i++)&#123; &#x2F;&#x2F; Method Objection getName() console.log(methodsList[i].getName()); &#125; &#125; &#125;, onComplete: function()&#123; console.log(&quot;complete!!!&quot;) &#125; &#125;) &#125;)&#125; 特殊不可见字符当方法名被混淆时֏，打印出来所有的类名%D6%8F,用编码后的字符串hook 1234567891011121314151617181920Java.perform( function x() &#123; var targetClass &#x3D; &quot;com.example.hooktest.MainActivity&quot;; var hookCls &#x3D; Java.use(targetClass); var methods &#x3D; hookCls.class.getDeclaredMethods(); for (var i in methods) &#123; console.log(methods[i].toString()); console.log(encodeURIComponent(methods[i].toString().replace(&#x2F;^.*?\\.([^\\s\\.\\(\\)]+)\\(.*?$&#x2F;, &quot;$1&quot;))); &#125; hookCls[decodeURIComponent(&quot;%D6%8F&quot;)].implementation &#x3D; function (x) &#123; console.log(&quot;original call: fun(&quot; + x + &quot;)&quot;); var result &#x3D; this[decodeURIComponent(&quot;%D6%8F&quot;)](900); return result; &#125; &#125;) wallbreaker123456789101112131415161718192021222324252627282930313233function main()&#123; Java.perform(function()&#123; var Class &#x3D; Java.use(&quot;java.lang.Class&quot;); function inspectObject(obj)&#123; var obj_class &#x3D; Java.cast(obj.getClass(), Class); var fields &#x3D; obj_class.getDeclaredFields(); var methods &#x3D; obj_class.getMethods(); console.log(&quot;Inspectiong &quot; + obj.getClass().toString()); console.log(&quot;\\t Fields:&quot;) for (var i in fields)&#123; console.log(&quot;\\t\\t&quot; + fields[i].toString()); &#125; console.log(&quot;\\t Methods:&quot;) for (var i in methods)&#123; console.log(&quot;\\t\\t&quot; + methods[i].toString()) &#125; &#125; Java.choose(&quot;com.baidu.lbs.waimai.WaimaiActivity&quot;,&#123; onComplete: function()&#123; console.log(&quot;complete!&quot;); &#125;, onMatch: function(instance)&#123; console.log(&quot;find instance&quot;, instance); inspectObject(instance); &#125; &#125;) &#125;)&#125;setImmediate(main) 枚举所有类1234567891011Java.perform(function ()&#123; console.log(&quot;\\n[*] enumerating classes...&quot;); Java.enumerateLoadedClasses(&#123; onMatch: function(_className)&#123; console.log(&quot;[*] found instance of &#39;&quot;+_className+&quot;&#39;&quot;); &#125;, onComplete: function()&#123; console.log(&quot;[*] class enuemration complete&quot;); &#125; &#125;);&#125;); 枚举接口实现获取指定包下所有类的接口实现 1234567891011121314151617181920function searchInterface()&#123; Java.perform(function()&#123; Java.enumerateLoadedClasses(&#123; onComplete: function()&#123;&#125;, onMatch: function(name,handle)&#123; if (name.indexOf(&quot;com.r0ysue.a0526printout&quot;) &gt; -1) &#123; &#x2F;&#x2F; 使用包名进行过滤 console.log(&quot;find class&quot;); var targetClass &#x3D; Java.use(name); var interfaceList &#x3D; targetClass.class.getInterfaces(); &#x2F;&#x2F; 使用反射获取类实现的接口数组 if (interfaceList.length &gt; 0) &#123; console.log(name) &#x2F;&#x2F; 打印类名 for (var i in interfaceList) &#123; console.log(&quot;\\t&quot;, interfaceList[i].toString()); &#x2F;&#x2F; 直接打印接口名称 &#125; &#125; &#125; &#125; &#125;) &#125;)&#125; 多个ClassLoader时枚举指定类所有关联的接口实现和父子类关系 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Java.perform(function () &#123; console.log(&quot;start&quot;) &#x2F;&#x2F; 枚举classLoader设置含有关键类的classLoader 动态dex切换classLoader Java.enumerateClassLoaders(&#123; onMatch: function (loader) &#123; try &#123; if (loader.findClass(&quot;com.jdd.motorfans.modules.detail.RecordFinishListener&quot;)) &#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); Java.classFactory.loader &#x3D; loader; &#125; &#125; catch (error) &#123; console.log(&quot;find error:&quot; + error) &#125; &#125;, onComplete: function () &#123; console.log(&quot;end1&quot;) &#125; &#125;) &#x2F;&#x2F; 枚举所有的类 Java.enumerateLoadedClasses(&#123; onMatch: function (className) &#123; if (className.toString().indexOf(&quot;RecordFinishListener&quot;) &gt; 0 &amp;&amp; className.toString().indexOf(&quot;$&quot;) &gt; 0 ) &#123; console.log(&quot;found &#x3D;&gt; &quot;, className) &#x2F;&#x2F; 使用反射获取类实现的接口数组 var interFaces &#x3D; Java.use(className).class.getInterfaces(); if(interFaces.length&gt;0)&#123; console.log(&quot;interface is &#x3D;&gt; &quot;); for(var i in interFaces)&#123; console.log(&quot;\\t&quot;,interFaces[i].toString()) &#125; &#125; &#x2F;&#x2F; 获取该类的父类名包含指定名称 if (Java.use(className).class.getSuperclass()) &#123; var superClass &#x3D; Java.use(className).class.getSuperclass().getName(); &#x2F;&#x2F; console.log(&quot;superClass is &#x3D;&gt; &quot;,superClass); if (superClass.indexOf(&quot;XC_MethodHook&quot;) &gt; 0) &#123; console.log(&quot;found class is &#x3D;&gt; &quot;, className.toString()) traceClass(className); &#125; &#125; &#125; &#125;, onComplete: function () &#123; console.log(&quot;search completed!&quot;) &#125; &#125;) console.log(&quot;end2&quot;)&#125;) Hook Char&amp;Byte123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Java.perform(function () &#123; &#x2F;&#x2F; 调用 自写dex Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;r0gson.dex&quot;).load(); const gson &#x3D; Java.use(&#39;com.r0ysue.gson.Gson&#39;); &#x2F;&#x2F; 打印CharArray数组 Java.use(&quot;java.util.Arrays&quot;).toString.overload(&#39;[C&#39;).implementation &#x3D; function(charArray)&#123; &#x2F;&#x2F; Java.array(&#39;char&#39;, [ &#39;一&#39;,&#39;去&#39;,&#39;二&#39;,&#39;三&#39;,&#39;里&#39; ]); &#x2F;&#x2F; Java.use(&#39;java.lang.String&#39;).$new(Java.array(&#39;char&#39;, [ &#39;烟&#39;,&#39;村&#39;,&#39;四&#39;,&#39;五&#39;,&#39;家&#39;])) &#x2F;&#x2F; Java.array(&quot;java.lang.String&quot;,[&quot;一&quot;,&quot;二&quot;,&quot;三&quot;]); var result &#x3D; this.toString(charArray); var result1 &#x3D; JSON.stringify(charArray); console.log(&quot;charArray,result:&quot;,charArray,result) console.log(ArrayClass.toString(result)); console.log(&quot;charArray Object Object:&quot;,gson.$new().toJson(charArray)); return result; &#125; &#x2F;&#x2F; 打印char字符 var CharClass &#x3D; Java.use(&quot;java.lang.Character&quot;); CharClass.toString.overload(&quot;char&quot;).implementation &#x3D; function(inputChar)&#123; var result &#x3D; this.toString(inputChar); console.log(&quot;inputChar, result: &quot;, inputChar, result); return result; &#125; &#x2F;&#x2F; byteArray Java.use(&quot;java.util.Arrays&quot;).toString.overload(&#39;[B&#39;).implementation &#x3D; function(byteArray)&#123; var result &#x3D; this.toString(byteArray); var result1 &#x3D; JSON.stringify(byteArray); console.log(&quot;byteArray,result):&quot;,byteArray,result) console.log(&quot;byteArray Object Object:&quot;,gson.$new().toJson(byteArray)); return result; &#125; var StringClass &#x3D; Java.use(&quot;java.lang.String&quot;); var byteArray &#x3D; StringClass.$new(&quot;Hello World&quot;).getBytes(); Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;r0gson.dex&quot;).load(); var gson &#x3D; Java.use(&quot;com.r0ysue.gson.Gson&quot;); console.log(gson.$new().toJson(byteArray)); &#x2F;&#x2F; &#x2F;&#x2F; console byte[] var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(ByteString.of(byteArray).hex()); &#x2F;&#x2F; byte转16进制字符串 &#x2F;&#x2F; &#x2F;&#x2F; 创建自定义Java数组 并打印 var MyArray &#x3D; Java.array(&quot;byte&quot;,[13,4,4,2]); console.log(gson.$new().toJson(MyArray));&#125;); Hook Map1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162遍历打印function main() &#123; Java.perform(function () &#123; var targetClass &#x3D; Java.use(&quot;com.xiaojianbang.app.ShufferMap&quot;); targetClass.show.implementation &#x3D; function (map) &#123; &#x2F;&#x2F; 遍历 map var result &#x3D; &quot;&quot;; var it &#x3D; map.keySet().iterator(); while (it.hasNext()) &#123; var keyStr &#x3D; it.next(); var valueStr &#x3D; map.get(keyStr); result +&#x3D; valueStr; &#125; console.log(&quot;result :&quot;, result); &#x2F;&#x2F; 修改 map map.put(&quot;pass&quot;, &quot;fxxk&quot;); map.put(&quot;code&quot;, &quot;Hello World&quot;); console.log(JSON.stringify(map)); return this.show(map); &#125; &#125;)&#125;setImmediate(main);cast打印 HashMapfunction main() &#123; Java.perform(function () &#123; var HashMapNode &#x3D; Java.use(&quot;java.util.HashMap$Node&quot;); var targetClass &#x3D; Java.use(&quot;com.xiaojianbang.app.ShufferMap&quot;); var targetClass.show.implementation &#x3D; function (map) &#123; var result &#x3D; &quot;&quot;; var iterator &#x3D; map.entrySet().iterator(); while (iterator.hasNext()) &#123; console.log(&quot;entry&quot;, iterator.next()); var entry &#x3D; Java.cast(iterator.next(), HashMapNode); console.log(entry.getKey()); console.log(entry.getValue()); return +&#x3D; entry.getValue(); &#125; console.log(&quot;result is :&quot;, result); &#125; &#125;)&#125;function main()&#123; Java.perform(function()&#123; var targetClass &#x3D; Java.use(&quot;com.xiaojianbang.app.ShufferMap&quot;); var HashMap &#x3D; Java.use(&#39;java.util.HashMap&#39;); targetClass.show.implementation &#x3D; function(map)&#123; &#x2F;&#x2F; 直接调用 toString() var args_map &#x3D; Java.cast(param_hm, HashMap); console.log(&quot;打印hashmap: -&gt; &quot; + map.toString() + args_map.toString()); return this.show.apply(this,arguments); &#125; &#125;)&#125;setImmediate(main); Hook 重载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function hookdecodeimgkey() &#123; Java.perform(function () &#123; var base64 &#x3D; Java.use(&quot;android.util.Base64&quot;) Java.use(&quot;com.ilulutv.fulao2.other.i.b&quot;).b.overload(&#39;[B&#39;, &#39;[B&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function (key, iv, image) &#123; var result &#x3D; this.b(key, iv, image); console.log(&quot;key&quot;, base64.encodeToString(key, 0)); console.log(&quot;iv&quot;, base64.encodeToString(iv, 0)); return result; &#125; var UtilsClass &#x3D; Java.use(&quot;com.kevin.app.Utils&quot;); &#x2F;&#x2F; 重载无参方法 UtilsClass.test.overload().implementation &#x3D; function () &#123; console.log(&quot;hook overload no args&quot;); return this.test(); &#125; &#x2F;&#x2F; 重载有参方法 - 基础数据类型 UtilsClass.test.overload(&#39;int&#39;).implementation &#x3D; function(num)&#123; console.log(&quot;hook overload int args&quot;); var myNum &#x3D; 9999; var oriResult &#x3D; this.test(num); console.log(&quot;oriResult is :&quot; + oriResult); return this.test(myNum); &#125; &#x2F;&#x2F; 重载有参方法 - 引用数据类型 UtilsClass.test.overload(&#39;com.kevin.app.Money&#39;).implementation &#x3D; function(money)&#123; console.log(&quot;hook Money args&quot;); return this.test(money); &#125; &#x2F;&#x2F; hook 指定方法的所有重载 var ClassName &#x3D; Java.use(&quot;com.xiaojianbang.app.Utils&quot;); var overloadsLength &#x3D; ClassName.test.overloads.length; for (var i &#x3D; 0; i &lt; overloadsLength; i++)&#123; ClassName.test.overloads[i].implementation &#x3D; function () &#123; &#x2F;&#x2F; 遍历打印 arguments for (var a &#x3D; 0; a &lt; arguments.length; a++)&#123; console.log(a + &quot; : &quot; + arguments[a]); &#125; &#x2F;&#x2F; 调用原方法 return this.test.apply(this,arguments); &#125; &#125; &#125;)&#125; Hook 内部类123456789101112131415function main()&#123; Java.perfor(function()&#123; &#x2F;&#x2F; hook 内部类 &#x2F;&#x2F; 内部类使用$进行分隔 不使用. var InnerClass &#x3D; Java.use(&quot;com.xiaojianbang.app.Money$innerClass&quot;); &#x2F;&#x2F; 重写内部类的 $init 方法 InnerClass.$init.overload(&quot;java.lang.String&quot;,&quot;int&quot;).implementation &#x3D; function(x,y)&#123; console.log(&quot;x: &quot;,x); console.log(&quot;y: &quot;,y); this.$init(x,y); &#125; &#125;)&#125;setImmediate(main) Hook 匿名类12345678910111213141516&#x2F;&#x2F; 接口, 抽象类, 不可以被new&#x2F;&#x2F; 接口, 抽象类 要使用必须要实例化, 实例化不是通过new, 而是通过实现接口方法, 继承抽象类等方式&#x2F;&#x2F; new __接口__&#123;&#125; 可以理解成 new 了一个实现接口的匿名类, 在匿名类的内部(花括号内),实现了这个接口function main()&#123; Java.perform(function()&#123; &#x2F;&#x2F; hook 匿名类 &#x2F;&#x2F; 匿名类在 smail中以 $1, $2 等方式存在, 需要通过 java 行号去 smail 找到准确的匿名类名称 var NiMingClass &#x3D; Java.use(&quot;com.xiaojianbang.app.MainActivity$1&quot;); NiMingClass.getInfo.implementation &#x3D; function ()&#123; return &quot;kevin change 匿名类&quot;; &#125; &#125;)&#125;setImmediate(main) Hook 枚举类1234567891011function enumPrint()&#123; Java.perform(function()&#123; Java.choose(&quot;com.r0ysue.a0526printout.Signal&quot;,&#123; onComplete: function()&#123;&#125;, onMatch: function(instance)&#123; console.log(&#39;find it ,&#39;,instance); console.log(instance.class.getName()); &#125; &#125;) &#125;)&#125; Hook 动态加载dex1234567891011121314151617181920212223function main()&#123; Java.perform(function()&#123; Java.enumerateClassLoaders(&#123; onMatch : function(loader)&#123; try &#123; &#x2F;&#x2F; loadClass or findClass 并切换classLoader if (loader.loadClass(&quot;com.xiaojianbang.app.Dynamic&quot;))&#123; Java.classFactory.loader &#x3D; loader; var hookClass &#x3D; Java.use(&quot;com.xiaojianbang.app.Dynamic&quot;); console.log(&quot;success hook it :&quot;, hookClass); &#125; &#125; catch (error) &#123; &#125; &#125;, onComplete: function () &#123; console.log(&quot;complete !!! &quot;) &#125; &#125;) &#125;)&#125;setImmediate(main); 经常在加壳的 app 中, 没办法正确找到正常加载 app 类的 classloader 123456789101112131415function hook() &#123; Java.perform(function () &#123; Java.enumerateClassLoadersSync().forEach(function (classloader) &#123; try &#123; console.log(&quot;classloader&quot;, classloader); classloader.loadClass(&quot;com.kanxue.encrypt01.MainActivity&quot;); Java.classFactory.loader &#x3D; classloader; var mainActivityClass &#x3D; Java.use(&quot;com.kanxue.encrypt01.MainActivity&quot;); console.log(&quot;mainActivityClass&quot;, mainActivityClass); &#125; catch (error) &#123; console.log(&quot;error&quot;, error); &#125; &#125;); &#125;)&#125; trace类调用栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function uniqBy(array, key) &#123; var seen &#x3D; &#123;&#125;; return array.filter(function (item) &#123; var k &#x3D; key(item); return seen.hasOwnProperty(k) ? false : (seen[k] &#x3D; true); &#125;);&#125;&#x2F;&#x2F; trace a specific Java Methodfunction traceMethod(targetClassMethod) &#123; var delim &#x3D; targetClassMethod.lastIndexOf(&quot;.&quot;); if (delim &#x3D;&#x3D;&#x3D; -1) return; var targetClass &#x3D; targetClassMethod.slice(0, delim) var targetMethod &#x3D; targetClassMethod.slice(delim + 1, targetClassMethod.length) var hook &#x3D; Java.use(targetClass); var overloadCount &#x3D; hook[targetMethod].overloads.length; console.log(&quot;Tracing &quot; + targetClassMethod + &quot; [&quot; + overloadCount + &quot; overload(s)]&quot;); &#x2F;&#x2F; hook all class_method for (var i &#x3D; 0; i &lt; overloadCount; i++) &#123; hook[targetMethod].overloads[i].implementation &#x3D; function () &#123; console.warn(&quot;\\n*** entered &quot; + targetClassMethod); &#x2F;&#x2F; print backtrace &#x2F;&#x2F; Java.perform(function() &#123; &#x2F;&#x2F; var bt &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()); &#x2F;&#x2F; console.log(&quot;\\nBacktrace:\\n&quot; + bt); &#x2F;&#x2F; &#125;); &#x2F;&#x2F; print args if (arguments.length) console.log(); for (var j &#x3D; 0; j &lt; arguments.length; j++) &#123; console.log(&quot;arg[&quot; + j + &quot;]: &quot; + arguments[j]); &#125; &#x2F;&#x2F; print retval var retval &#x3D; this[targetMethod].apply(this, arguments); &#x2F;&#x2F; rare crash (Frida bug?) console.log(&quot;\\nretval: &quot; + retval); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.warn(&quot;\\n*** exiting &quot; + targetClassMethod); return retval; &#125; &#125; &#125;function traceClass(targetClass) &#123; &#x2F;&#x2F;Java.use是新建一个对象哈，大家还记得么？ var hook &#x3D; Java.use(targetClass); &#x2F;&#x2F;利用反射的方式，拿到当前类的所有方法 var methods &#x3D; hook.class.getDeclaredMethods(); &#x2F;&#x2F; var methods &#x3D; hook.class.getMethods(); &#x2F;&#x2F;建完对象之后记得将对象释放掉哈 hook.$dispose; &#x2F;&#x2F;将方法名保存到数组中 var parsedMethods &#x3D; []; methods.forEach(function (method) &#123; parsedMethods.push(method.toString().replace(targetClass + &quot;.&quot;, &quot;TOKEN&quot;).match(&#x2F;\\sTOKEN(.*)\\(&#x2F;)[1]); &#125;); &#x2F;&#x2F;去掉一些重复的值 var targets &#x3D; uniqBy(parsedMethods, JSON.stringify); &#x2F;&#x2F;对数组中所有的方法进行hook，traceMethod也就是第一小节的内容 targets.forEach(function (targetMethod) &#123; traceMethod(targetClass + &quot;.&quot; + targetMethod); &#125;);&#125; 调用栈打印12345678910111213function printStacks(name)&#123; console.log(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; printStacks start &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot; + name + &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;) &#x2F;&#x2F; sample 1 var throwable &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()); console.log(throwable); &#x2F;&#x2F; sample 2 var exception &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()); console.log(exception); console.log(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; printStacks end &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot; + name + &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)&#125; 手动注册类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586Java.perform(function () &#123; var Runnable &#x3D; Java.use(&quot;java.lang.Runnable&quot;); var saveImg &#x3D; Java.registerClass(&#123; name: &quot;com.roysue.runnable&quot;, implements: [Runnable], fields: &#123; bm: &quot;android.graphics.Bitmap&quot;, &#125;, methods: &#123; $init: [&#123; returnType: &quot;void&quot;, argumentTypes: [&quot;android.graphics.Bitmap&quot;], implementation: function (bitmap) &#123; this.bm.value &#x3D; bitmap; &#125; &#125;], run: function () &#123; var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot; + guid() + &quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;, path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); this.bm.value.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value, 100, fos) fos.flush(); fos.close(); &#125;, onRequest: function (request, response) &#123; &#x2F;&#x2F; 主动调用代码直接写这里 response.send(JSON.stringify(&#123; &quot;code&quot;: 0, &quot;message&quot;: &quot; 服务已经注册成功, 默认端口8181&quot; &#125;)); &#125; &#125; &#125;); Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory$Options&#39;).implementation &#x3D; function (data, offset, length, opts) &#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); var runnable &#x3D; saveImg.$new(result); runnable.run() return result; &#125;&#125;)Java.perform(function() &#123; &#x2F;&#x2F; https:&#x2F;&#x2F;developer.android.com&#x2F;reference&#x2F;android&#x2F;view&#x2F;WindowManager.LayoutParams.html#FLAG_SECURE var FLAG_SECURE &#x3D; 0x2000; var Runnable &#x3D; Java.use(&quot;java.lang.Runnable&quot;); var DisableSecureRunnable &#x3D; Java.registerClass(&#123; name: &quot;me.bhamza.DisableSecureRunnable&quot;, implements: [Runnable], fields: &#123; activity: &quot;android.app.Activity&quot;, &#125;, methods: &#123; $init: [&#123; returnType: &quot;void&quot;, argumentTypes: [&quot;android.app.Activity&quot;], implementation: function (activity) &#123; this.activity.value &#x3D; activity; &#125; &#125;], run: function() &#123; var flags &#x3D; this.activity.value.getWindow().getAttributes().flags.value; &#x2F;&#x2F; get current value flags &amp;&#x3D; ~FLAG_SECURE; &#x2F;&#x2F; toggle it this.activity.value.getWindow().setFlags(flags, FLAG_SECURE); &#x2F;&#x2F; disable it! console.log(&quot;Done disabling SECURE flag...&quot;); &#125; &#125; &#125;); Java.choose(&quot;com.example.app.FlagSecureTestActivity&quot;, &#123; &quot;onMatch&quot;: function (instance) &#123; var runnable &#x3D; DisableSecureRunnable.$new(instance); instance.runOnUiThread(runnable); &#125;, &quot;onComplete&quot;: function () &#123;&#125; &#125;); &#125;); Hook Click12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var jclazz &#x3D; null;var jobj &#x3D; null;function getObjClassName(obj) &#123; if (!jclazz) &#123; var jclazz &#x3D; Java.use(&quot;java.lang.Class&quot;); &#125; if (!jobj) &#123; var jobj &#x3D; Java.use(&quot;java.lang.Object&quot;); &#125; return jclazz.getName.call(jobj.getClass.call(obj));&#125;function watch(obj, mtdName) &#123; var listener_name &#x3D; getObjClassName(obj); var target &#x3D; Java.use(listener_name); if (!target || !mtdName in target) &#123; return; &#125; &#x2F;&#x2F; send(&quot;[WatchEvent] hooking &quot; + mtdName + &quot;: &quot; + listener_name); target[mtdName].overloads.forEach(function (overload) &#123; overload.implementation &#x3D; function () &#123; &#x2F;&#x2F;send(&quot;[WatchEvent] &quot; + mtdName + &quot;: &quot; + getObjClassName(this)); console.log(&quot;[WatchEvent] &quot; + mtdName + &quot;: &quot; + getObjClassName(this)) return this[mtdName].apply(this, arguments); &#125;; &#125;)&#125;function OnClickListener() &#123; Java.perform(function () &#123; &#x2F;&#x2F;以spawn启动进程的模式来attach的话 Java.use(&quot;android.view.View&quot;).setOnClickListener.implementation &#x3D; function (listener) &#123; if (listener !&#x3D; null) &#123; watch(listener, &#39;onClick&#39;); &#125; return this.setOnClickListener(listener); &#125;; &#x2F;&#x2F;如果frida以attach的模式进行attch的话 Java.choose(&quot;android.view.View$ListenerInfo&quot;, &#123; onMatch: function (instance) &#123; instance &#x3D; instance.mOnClickListener.value; if (instance) &#123; console.log(&quot;mOnClickListener name is :&quot; + getObjClassName(instance)); watch(instance, &#39;onClick&#39;); &#125; &#125;, onComplete: function () &#123; &#125; &#125;) &#125;)&#125;setImmediate(OnClickListener); Hook Activity12345678910111213141516171819202122Java.perform(function () &#123; var Activity &#x3D; Java.use(&quot;android.app.Activity&quot;); &#x2F;&#x2F;console.log(Object.getOwnPropertyNames(Activity)); Activity.startActivity.overload(&#39;android.content.Intent&#39;).implementation&#x3D;function(p1)&#123; console.log(&quot;Hooking android.app.Activity.startActivity(p1) successfully,p1&#x3D;&quot;+p1); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(decodeURIComponent(p1.toUri(256))); this.startActivity(p1); &#125; Activity.startActivity.overload(&#39;android.content.Intent&#39;, &#39;android.os.Bundle&#39;).implementation&#x3D;function(p1,p2)&#123; console.log(&quot;Hooking android.app.Activity.startActivity(p1,p2) successfully,p1&#x3D;&quot;+p1+&quot;,p2&#x3D;&quot;+p2); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(decodeURIComponent(p1.toUri(256))); this.startActivity(p1,p2); &#125; Activity.startService.overload(&#39;android.content.Intent&#39;).implementation&#x3D;function(p1)&#123; console.log(&quot;Hooking android.app.Activity.startService(p1) successfully,p1&#x3D;&quot;+p1); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(decodeURIComponent(p1.toUri(256))); this.startService(p1); &#125;&#125;) Hook 绕过root检测123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378&#x2F;&#x2F; $ frida -l antiroot.js -U -f com.example.app --no-pause&#x2F;&#x2F; CHANGELOG by Pichaya Morimoto (p.morimoto@sth.sh): &#x2F;&#x2F; - I added extra whitelisted items to deal with the latest versions &#x2F;&#x2F; of RootBeer&#x2F;Cordova iRoot as of August 6, 2019&#x2F;&#x2F; - The original one just fucked up (kill itself) if Magisk is installed lol&#x2F;&#x2F; Credit &amp; Originally written by: https:&#x2F;&#x2F;codeshare.frida.re&#x2F;@dzonerzy&#x2F;fridantiroot&#x2F;&#x2F;&#x2F; If this isn&#39;t working in the future, check console logs, rootbeer src, or libtool-checker.soJava.perform(function() &#123; var RootPackages &#x3D; [&quot;com.noshufou.android.su&quot;, &quot;com.noshufou.android.su.elite&quot;, &quot;eu.chainfire.supersu&quot;, &quot;com.koushikdutta.superuser&quot;, &quot;com.thirdparty.superuser&quot;, &quot;com.yellowes.su&quot;, &quot;com.koushikdutta.rommanager&quot;, &quot;com.koushikdutta.rommanager.license&quot;, &quot;com.dimonvideo.luckypatcher&quot;, &quot;com.chelpus.lackypatch&quot;, &quot;com.ramdroid.appquarantine&quot;, &quot;com.ramdroid.appquarantinepro&quot;, &quot;com.devadvance.rootcloak&quot;, &quot;com.devadvance.rootcloakplus&quot;, &quot;de.robv.android.xposed.installer&quot;, &quot;com.saurik.substrate&quot;, &quot;com.zachspong.temprootremovejb&quot;, &quot;com.amphoras.hidemyroot&quot;, &quot;com.amphoras.hidemyrootadfree&quot;, &quot;com.formyhm.hiderootPremium&quot;, &quot;com.formyhm.hideroot&quot;, &quot;me.phh.superuser&quot;, &quot;eu.chainfire.supersu.pro&quot;, &quot;com.kingouser.com&quot;, &quot;com.android.vending.billing.InAppBillingService.COIN&quot;,&quot;com.topjohnwu.magisk&quot; ]; var RootBinaries &#x3D; [&quot;su&quot;, &quot;busybox&quot;, &quot;supersu&quot;, &quot;Superuser.apk&quot;, &quot;KingoUser.apk&quot;, &quot;SuperSu.apk&quot;,&quot;magisk&quot;]; var RootProperties &#x3D; &#123; &quot;ro.build.selinux&quot;: &quot;1&quot;, &quot;ro.debuggable&quot;: &quot;0&quot;, &quot;service.adb.root&quot;: &quot;0&quot;, &quot;ro.secure&quot;: &quot;1&quot; &#125;; var RootPropertiesKeys &#x3D; []; for (var k in RootProperties) RootPropertiesKeys.push(k); var PackageManager &#x3D; Java.use(&quot;android.app.ApplicationPackageManager&quot;); var Runtime &#x3D; Java.use(&#39;java.lang.Runtime&#39;); var NativeFile &#x3D; Java.use(&#39;java.io.File&#39;); var String &#x3D; Java.use(&#39;java.lang.String&#39;); var SystemProperties &#x3D; Java.use(&#39;android.os.SystemProperties&#39;); var BufferedReader &#x3D; Java.use(&#39;java.io.BufferedReader&#39;); var ProcessBuilder &#x3D; Java.use(&#39;java.lang.ProcessBuilder&#39;); var StringBuffer &#x3D; Java.use(&#39;java.lang.StringBuffer&#39;); var loaded_classes &#x3D; Java.enumerateLoadedClassesSync(); send(&quot;Loaded &quot; + loaded_classes.length + &quot; classes!&quot;); var useKeyInfo &#x3D; false; var useProcessManager &#x3D; false; send(&quot;loaded: &quot; + loaded_classes.indexOf(&#39;java.lang.ProcessManager&#39;)); if (loaded_classes.indexOf(&#39;java.lang.ProcessManager&#39;) !&#x3D; -1) &#123; try &#123; &#x2F;&#x2F;useProcessManager &#x3D; true; &#x2F;&#x2F;var ProcessManager &#x3D; Java.use(&#39;java.lang.ProcessManager&#39;); &#125; catch (err) &#123; send(&quot;ProcessManager Hook failed: &quot; + err); &#125; &#125; else &#123; send(&quot;ProcessManager hook not loaded&quot;); &#125; var KeyInfo &#x3D; null; if (loaded_classes.indexOf(&#39;android.security.keystore.KeyInfo&#39;) !&#x3D; -1) &#123; try &#123; &#x2F;&#x2F;useKeyInfo &#x3D; true; &#x2F;&#x2F;var KeyInfo &#x3D; Java.use(&#39;android.security.keystore.KeyInfo&#39;); &#125; catch (err) &#123; send(&quot;KeyInfo Hook failed: &quot; + err); &#125; &#125; else &#123; send(&quot;KeyInfo hook not loaded&quot;); &#125; PackageManager.getPackageInfo.overload(&#39;java.lang.String&#39;, &#39;int&#39;).implementation &#x3D; function(pname, flags) &#123; var shouldFakePackage &#x3D; (RootPackages.indexOf(pname) &gt; -1); if (shouldFakePackage) &#123; send(&quot;Bypass root check for package: &quot; + pname); pname &#x3D; &quot;set.package.name.to.a.fake.one.so.we.can.bypass.it&quot;; &#125; return this.getPackageInfo.call(this, pname, flags); &#125;; NativeFile.exists.implementation &#x3D; function() &#123; var name &#x3D; NativeFile.getName.call(this); var shouldFakeReturn &#x3D; (RootBinaries.indexOf(name) &gt; -1); if (shouldFakeReturn) &#123; send(&quot;Bypass return value for binary: &quot; + name); return false; &#125; else &#123; return this.exists.call(this); &#125; &#125;; var exec &#x3D; Runtime.exec.overload(&#39;[Ljava.lang.String;&#39;); var exec1 &#x3D; Runtime.exec.overload(&#39;java.lang.String&#39;); var exec2 &#x3D; Runtime.exec.overload(&#39;java.lang.String&#39;, &#39;[Ljava.lang.String;&#39;); var exec3 &#x3D; Runtime.exec.overload(&#39;[Ljava.lang.String;&#39;, &#39;[Ljava.lang.String;&#39;); var exec4 &#x3D; Runtime.exec.overload(&#39;[Ljava.lang.String;&#39;, &#39;[Ljava.lang.String;&#39;, &#39;java.io.File&#39;); var exec5 &#x3D; Runtime.exec.overload(&#39;java.lang.String&#39;, &#39;[Ljava.lang.String;&#39;, &#39;java.io.File&#39;); exec5.implementation &#x3D; function(cmd, env, dir) &#123; if (cmd.indexOf(&quot;getprop&quot;) !&#x3D; -1 || cmd &#x3D;&#x3D; &quot;mount&quot; || cmd.indexOf(&quot;build.prop&quot;) !&#x3D; -1 || cmd &#x3D;&#x3D; &quot;id&quot; || cmd &#x3D;&#x3D; &quot;sh&quot;) &#123; var fakeCmd &#x3D; &quot;grep&quot;; send(&quot;Bypass &quot; + cmd + &quot; command&quot;); return exec1.call(this, fakeCmd); &#125; if (cmd &#x3D;&#x3D; &quot;su&quot;) &#123; var fakeCmd &#x3D; &quot;justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled&quot;; send(&quot;Bypass &quot; + cmd + &quot; command&quot;); return exec1.call(this, fakeCmd); &#125; if (cmd &#x3D;&#x3D; &quot;which&quot;) &#123; var fakeCmd &#x3D; &quot;justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled&quot;; send(&quot;Bypass which command&quot;); return exec1.call(this, fakeCmd); &#125; return exec5.call(this, cmd, env, dir); &#125;; exec4.implementation &#x3D; function(cmdarr, env, file) &#123; for (var i &#x3D; 0; i &lt; cmdarr.length; i &#x3D; i + 1) &#123; var tmp_cmd &#x3D; cmdarr[i]; if (tmp_cmd.indexOf(&quot;getprop&quot;) !&#x3D; -1 || tmp_cmd &#x3D;&#x3D; &quot;mount&quot; || tmp_cmd.indexOf(&quot;build.prop&quot;) !&#x3D; -1 || tmp_cmd &#x3D;&#x3D; &quot;id&quot; || tmp_cmd &#x3D;&#x3D; &quot;sh&quot;) &#123; var fakeCmd &#x3D; &quot;grep&quot;; send(&quot;Bypass &quot; + cmdarr + &quot; command&quot;); return exec1.call(this, fakeCmd); &#125; if (tmp_cmd &#x3D;&#x3D; &quot;su&quot;) &#123; var fakeCmd &#x3D; &quot;justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled&quot;; send(&quot;Bypass &quot; + cmdarr + &quot; command&quot;); return exec1.call(this, fakeCmd); &#125; &#125; return exec4.call(this, cmdarr, env, file); &#125;; exec3.implementation &#x3D; function(cmdarr, envp) &#123; for (var i &#x3D; 0; i &lt; cmdarr.length; i &#x3D; i + 1) &#123; var tmp_cmd &#x3D; cmdarr[i]; if (tmp_cmd.indexOf(&quot;getprop&quot;) !&#x3D; -1 || tmp_cmd &#x3D;&#x3D; &quot;mount&quot; || tmp_cmd.indexOf(&quot;build.prop&quot;) !&#x3D; -1 || tmp_cmd &#x3D;&#x3D; &quot;id&quot; || tmp_cmd &#x3D;&#x3D; &quot;sh&quot;) &#123; var fakeCmd &#x3D; &quot;grep&quot;; send(&quot;Bypass &quot; + cmdarr + &quot; command&quot;); return exec1.call(this, fakeCmd); &#125; if (tmp_cmd &#x3D;&#x3D; &quot;su&quot;) &#123; var fakeCmd &#x3D; &quot;justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled&quot;; send(&quot;Bypass &quot; + cmdarr + &quot; command&quot;); return exec1.call(this, fakeCmd); &#125; &#125; return exec3.call(this, cmdarr, envp); &#125;; exec2.implementation &#x3D; function(cmd, env) &#123; if (cmd.indexOf(&quot;getprop&quot;) !&#x3D; -1 || cmd &#x3D;&#x3D; &quot;mount&quot; || cmd.indexOf(&quot;build.prop&quot;) !&#x3D; -1 || cmd &#x3D;&#x3D; &quot;id&quot; || cmd &#x3D;&#x3D; &quot;sh&quot;) &#123; var fakeCmd &#x3D; &quot;grep&quot;; send(&quot;Bypass &quot; + cmd + &quot; command&quot;); return exec1.call(this, fakeCmd); &#125; if (cmd &#x3D;&#x3D; &quot;su&quot;) &#123; var fakeCmd &#x3D; &quot;justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled&quot;; send(&quot;Bypass &quot; + cmd + &quot; command&quot;); return exec1.call(this, fakeCmd); &#125; return exec2.call(this, cmd, env); &#125;; exec.implementation &#x3D; function(cmd) &#123; for (var i &#x3D; 0; i &lt; cmd.length; i &#x3D; i + 1) &#123; var tmp_cmd &#x3D; cmd[i]; if (tmp_cmd.indexOf(&quot;getprop&quot;) !&#x3D; -1 || tmp_cmd &#x3D;&#x3D; &quot;mount&quot; || tmp_cmd.indexOf(&quot;build.prop&quot;) !&#x3D; -1 || tmp_cmd &#x3D;&#x3D; &quot;id&quot; || tmp_cmd &#x3D;&#x3D; &quot;sh&quot;) &#123; var fakeCmd &#x3D; &quot;grep&quot;; send(&quot;Bypass &quot; + cmd + &quot; command&quot;); return exec1.call(this, fakeCmd); &#125; if (tmp_cmd &#x3D;&#x3D; &quot;su&quot;) &#123; var fakeCmd &#x3D; &quot;justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled&quot;; send(&quot;Bypass &quot; + cmd + &quot; command&quot;); return exec1.call(this, fakeCmd); &#125; &#125; return exec.call(this, cmd); &#125;; exec1.implementation &#x3D; function(cmd) &#123; if (cmd.indexOf(&quot;getprop&quot;) !&#x3D; -1 || cmd &#x3D;&#x3D; &quot;mount&quot; || cmd.indexOf(&quot;build.prop&quot;) !&#x3D; -1 || cmd &#x3D;&#x3D; &quot;id&quot; || cmd &#x3D;&#x3D; &quot;sh&quot;) &#123; var fakeCmd &#x3D; &quot;grep&quot;; send(&quot;Bypass &quot; + cmd + &quot; command&quot;); return exec1.call(this, fakeCmd); &#125; if (cmd &#x3D;&#x3D; &quot;su&quot;) &#123; var fakeCmd &#x3D; &quot;justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled&quot;; send(&quot;Bypass &quot; + cmd + &quot; command&quot;); return exec1.call(this, fakeCmd); &#125; return exec1.call(this, cmd); &#125;; String.contains.implementation &#x3D; function(name) &#123; if (name &#x3D;&#x3D; &quot;test-keys&quot;) &#123; send(&quot;Bypass test-keys check&quot;); return false; &#125; return this.contains.call(this, name); &#125;; var get &#x3D; SystemProperties.get.overload(&#39;java.lang.String&#39;); get.implementation &#x3D; function(name) &#123; if (RootPropertiesKeys.indexOf(name) !&#x3D; -1) &#123; send(&quot;Bypass &quot; + name); return RootProperties[name]; &#125; return this.get.call(this, name); &#125;; Interceptor.attach(Module.findExportByName(&quot;libc.so&quot;, &quot;fopen&quot;), &#123; onEnter: function(args) &#123; var path1 &#x3D; Memory.readCString(args[0]); var path &#x3D; path1.split(&quot;&#x2F;&quot;); var executable &#x3D; path[path.length - 1]; var shouldFakeReturn &#x3D; (RootBinaries.indexOf(executable) &gt; -1) if (shouldFakeReturn) &#123; Memory.writeUtf8String(args[0], &quot;&#x2F;ggezxxx&quot;); send(&quot;Bypass native fopen &gt;&gt; &quot;+path1); &#125; &#125;, onLeave: function(retval) &#123; &#125; &#125;); Interceptor.attach(Module.findExportByName(&quot;libc.so&quot;, &quot;fopen&quot;), &#123; onEnter: function(args) &#123; var path1 &#x3D; Memory.readCString(args[0]); var path &#x3D; path1.split(&quot;&#x2F;&quot;); var executable &#x3D; path[path.length - 1]; var shouldFakeReturn &#x3D; (RootBinaries.indexOf(executable) &gt; -1) if (shouldFakeReturn) &#123; Memory.writeUtf8String(args[0], &quot;&#x2F;ggezxxx&quot;); send(&quot;Bypass native fopen &gt;&gt; &quot;+path1); &#125; &#125;, onLeave: function(retval) &#123; &#125; &#125;); Interceptor.attach(Module.findExportByName(&quot;libc.so&quot;, &quot;system&quot;), &#123; onEnter: function(args) &#123; var cmd &#x3D; Memory.readCString(args[0]); send(&quot;SYSTEM CMD: &quot; + cmd); if (cmd.indexOf(&quot;getprop&quot;) !&#x3D; -1 || cmd &#x3D;&#x3D; &quot;mount&quot; || cmd.indexOf(&quot;build.prop&quot;) !&#x3D; -1 || cmd &#x3D;&#x3D; &quot;id&quot;) &#123; send(&quot;Bypass native system: &quot; + cmd); Memory.writeUtf8String(args[0], &quot;grep&quot;); &#125; if (cmd &#x3D;&#x3D; &quot;su&quot;) &#123; send(&quot;Bypass native system: &quot; + cmd); Memory.writeUtf8String(args[0], &quot;justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled&quot;); &#125; &#125;, onLeave: function(retval) &#123; &#125; &#125;); &#x2F;* TO IMPLEMENT: Exec Family int execl(const char *path, const char *arg0, ..., const char *argn, (char *)0); int execle(const char *path, const char *arg0, ..., const char *argn, (char *)0, char *const envp[]); int execlp(const char *file, const char *arg0, ..., const char *argn, (char *)0); int execlpe(const char *file, const char *arg0, ..., const char *argn, (char *)0, char *const envp[]); int execv(const char *path, char *const argv[]); int execve(const char *path, char *const argv[], char *const envp[]); int execvp(const char *file, char *const argv[]); int execvpe(const char *file, char *const argv[], char *const envp[]); *&#x2F; BufferedReader.readLine.overload().implementation &#x3D; function() &#123; var text &#x3D; this.readLine.call(this); if (text &#x3D;&#x3D;&#x3D; null) &#123; &#x2F;&#x2F; just pass , i know it&#39;s ugly as hell but test !&#x3D; null won&#39;t work :( &#125; else &#123; var shouldFakeRead &#x3D; (text.indexOf(&quot;ro.build.tags&#x3D;test-keys&quot;) &gt; -1); if (shouldFakeRead) &#123; send(&quot;Bypass build.prop file read&quot;); text &#x3D; text.replace(&quot;ro.build.tags&#x3D;test-keys&quot;, &quot;ro.build.tags&#x3D;release-keys&quot;); &#125; &#125; return text; &#125;; var executeCommand &#x3D; ProcessBuilder.command.overload(&#39;java.util.List&#39;); ProcessBuilder.start.implementation &#x3D; function() &#123; var cmd &#x3D; this.command.call(this); var shouldModifyCommand &#x3D; false; for (var i &#x3D; 0; i &lt; cmd.size(); i &#x3D; i + 1) &#123; var tmp_cmd &#x3D; cmd.get(i).toString(); if (tmp_cmd.indexOf(&quot;getprop&quot;) !&#x3D; -1 || tmp_cmd.indexOf(&quot;mount&quot;) !&#x3D; -1 || tmp_cmd.indexOf(&quot;build.prop&quot;) !&#x3D; -1 || tmp_cmd.indexOf(&quot;id&quot;) !&#x3D; -1) &#123; shouldModifyCommand &#x3D; true; &#125; &#125; if (shouldModifyCommand) &#123; send(&quot;Bypass ProcessBuilder &quot; + cmd); this.command.call(this, [&quot;grep&quot;]); return this.start.call(this); &#125; if (cmd.indexOf(&quot;su&quot;) !&#x3D; -1) &#123; send(&quot;Bypass ProcessBuilder &quot; + cmd); this.command.call(this, [&quot;justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled&quot;]); return this.start.call(this); &#125; return this.start.call(this); &#125;; if (useProcessManager) &#123; var ProcManExec &#x3D; ProcessManager.exec.overload(&#39;[Ljava.lang.String;&#39;, &#39;[Ljava.lang.String;&#39;, &#39;java.io.File&#39;, &#39;boolean&#39;); var ProcManExecVariant &#x3D; ProcessManager.exec.overload(&#39;[Ljava.lang.String;&#39;, &#39;[Ljava.lang.String;&#39;, &#39;java.lang.String&#39;, &#39;java.io.FileDescriptor&#39;, &#39;java.io.FileDescriptor&#39;, &#39;java.io.FileDescriptor&#39;, &#39;boolean&#39;); ProcManExec.implementation &#x3D; function(cmd, env, workdir, redirectstderr) &#123; var fake_cmd &#x3D; cmd; for (var i &#x3D; 0; i &lt; cmd.length; i &#x3D; i + 1) &#123; var tmp_cmd &#x3D; cmd[i]; if (tmp_cmd.indexOf(&quot;getprop&quot;) !&#x3D; -1 || tmp_cmd &#x3D;&#x3D; &quot;mount&quot; || tmp_cmd.indexOf(&quot;build.prop&quot;) !&#x3D; -1 || tmp_cmd &#x3D;&#x3D; &quot;id&quot;) &#123; var fake_cmd &#x3D; [&quot;grep&quot;]; send(&quot;Bypass &quot; + cmdarr + &quot; command&quot;); &#125; if (tmp_cmd &#x3D;&#x3D; &quot;su&quot;) &#123; var fake_cmd &#x3D; [&quot;justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled&quot;]; send(&quot;Bypass &quot; + cmdarr + &quot; command&quot;); &#125; &#125; return ProcManExec.call(this, fake_cmd, env, workdir, redirectstderr); &#125;; ProcManExecVariant.implementation &#x3D; function(cmd, env, directory, stdin, stdout, stderr, redirect) &#123; var fake_cmd &#x3D; cmd; for (var i &#x3D; 0; i &lt; cmd.length; i &#x3D; i + 1) &#123; var tmp_cmd &#x3D; cmd[i]; if (tmp_cmd.indexOf(&quot;getprop&quot;) !&#x3D; -1 || tmp_cmd &#x3D;&#x3D; &quot;mount&quot; || tmp_cmd.indexOf(&quot;build.prop&quot;) !&#x3D; -1 || tmp_cmd &#x3D;&#x3D; &quot;id&quot;) &#123; var fake_cmd &#x3D; [&quot;grep&quot;]; send(&quot;Bypass &quot; + cmdarr + &quot; command&quot;); &#125; if (tmp_cmd &#x3D;&#x3D; &quot;su&quot;) &#123; var fake_cmd &#x3D; [&quot;justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled&quot;]; send(&quot;Bypass &quot; + cmdarr + &quot; command&quot;); &#125; &#125; return ProcManExecVariant.call(this, fake_cmd, env, directory, stdin, stdout, stderr, redirect); &#125;; &#125; if (useKeyInfo) &#123; KeyInfo.isInsideSecureHardware.implementation &#x3D; function() &#123; send(&quot;Bypass isInsideSecureHardware&quot;); return true; &#125; &#125;&#125;); frida主线程运行使用一些方法的时候出现报错 on a thread that has not called Looper.prepare() 12345678910Java.perform(function() &#123; var Toast &#x3D; Java.use(&#39;android.widget.Toast&#39;); &#x2F;&#x2F; 获取 androidcontext var currentApplication &#x3D; Java.use(&#39;android.app.ActivityThread&#39;).currentApplication(); var context &#x3D; currentApplication.getApplicationContext(); Java.scheduleOnMainThread(function() &#123; Toast.makeText(context, &quot;Hello World&quot;, Toast.LENGTH_LONG.value).show(); &#125;)&#125;) 过滤打印123456789101112131415161718192021222324252627282930function hook_lnf() &#123; var activate &#x3D; false; Java.perform(function()&#123; var hashmapClass &#x3D; Java.use(&quot;java.util.HashMap&quot;); hashmapClass.put.implementation &#x3D; function(key,value)&#123; if (activate)&#123; console.log(&quot;key:&quot;, key, &quot;value:&quot;, value); &#125; return this.put(key,value); &#125;; &#125;); Java.perform(function () &#123; var lnfClazz &#x3D; Java.use(&quot;tb.lnf&quot;); lnfClazz.a.overload(&#39;java.util.HashMap&#39;, &#39;java.util.HashMap&#39;, &#39;java.lang.String&#39;, &#39;java.lang.String&#39;, &#39;boolean&#39;).implementation &#x3D; function (hashmap, hashmap2, str, str2, z) &#123; printHashMap(&quot;hashmap&quot;, hashmap); printHashMap(&quot;hashmap2&quot;, hashmap2); console.log(&quot;str&quot;, str); console.log(&quot;str2&quot;, str2); console.log(&quot;boolean&quot;, z); activate &#x3D; true; var result &#x3D; this.a(hashmap, hashmap2, str, str2, z); activate &#x3D; false printHashMap(&quot;result&quot;, result); return result; &#125;; &#125;)&#125; 禁止退出123456789101112function hookExit()&#123; Java.perform(function()&#123; console.log(&quot;[*] Starting hook exit&quot;); var exitClass &#x3D; Java.use(&quot;java.lang.System&quot;); exitClass.exit.implementation &#x3D; function()&#123; console.log(&quot;[*] System.exit.called&quot;); &#125; console.log(&quot;[*] hooking calls to System.exit&quot;); &#125;)&#125;setImmediate(hookExit); 修改设备参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#x2F;&#x2F; frida hook 修改设备参数Java.perform(function() &#123; var TelephonyManager &#x3D; Java.use(&quot;android.telephony.TelephonyManager&quot;); &#x2F;&#x2F;IMEI hook TelephonyManager.getDeviceId.overload().implementation &#x3D; function () &#123; console.log(&quot;[*]Called - getDeviceId()&quot;); var temp &#x3D; this.getDeviceId(); console.log(&quot;real IMEI: &quot;+temp); return &quot;867979021642856&quot;; &#125;; &#x2F;&#x2F; muti IMEI TelephonyManager.getDeviceId.overload(&#39;int&#39;).implementation &#x3D; function (p) &#123; console.log(&quot;[*]Called - getDeviceId(int) param is&quot;+p); var temp &#x3D; this.getDeviceId(p); console.log(&quot;real IMEI &quot;+p+&quot;: &quot;+temp); return &quot;867979021642856&quot;; &#125;; &#x2F;&#x2F;IMSI hook TelephonyManager.getSimSerialNumber.overload().implementation &#x3D; function () &#123; console.log(&quot;[*]Called - getSimSerialNumber(String)&quot;); var temp &#x3D; this.getSimSerialNumber(); console.log(&quot;real IMSI: &quot;+temp); return &quot;123456789&quot;; &#125;; &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;&#x2F;ANDOID_ID hook var Secure &#x3D; Java.use(&quot;android.provider.Settings$Secure&quot;); Secure.getString.implementation &#x3D; function (p1,p2) &#123; if(p2.indexOf(&quot;android_id&quot;)&lt;0) return this.getString(p1,p2); console.log(&quot;[*]Called - get android_ID, param is:&quot;+p2); var temp &#x3D; this.getString(p1,p2); console.log(&quot;real Android_ID: &quot;+temp); return &quot;844de23bfcf93801&quot;; &#125; &#x2F;&#x2F;android的hidden API，需要通过反射调用 var SP &#x3D; Java.use(&quot;android.os.SystemProperties&quot;); SP.get.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (p1) &#123; var tmp &#x3D; this.get(p1); console.log(&quot;[*]&quot;+p1+&quot; : &quot;+tmp); return tmp; &#125; SP.get.overload(&#39;java.lang.String&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function (p1,p2) &#123; var tmp &#x3D; this.get(p1,p2) console.log(&quot;[*]&quot;+p1+&quot;,&quot;+p2+&quot; : &quot;+tmp); return tmp; &#125; &#x2F;&#x2F; hook MAC var wifi &#x3D; Java.use(&quot;android.net.wifi.WifiInfo&quot;); wifi.getMacAddress.implementation &#x3D; function () &#123; var tmp &#x3D; this.getMacAddress(); console.log(&quot;[*]real MAC: &quot;+tmp); return tmp; &#125; &#125;) 请求调用栈1234567891011var class_Socket &#x3D; Java.use(&quot;java.net.Socket&quot;);class_Socket.getOutputStream.overload().implementation &#x3D; function()&#123; send(&quot;getOutputSteam&quot;); var result &#x3D; this.getOutputStream(); var bt &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString( Java.use(&quot;java.lang.Exception&quot;).$new(); ) console.log(&quot;Backtrace:&quot; + bt); send(result); return result;&#125; 上下文Context1234567891011function getContext()&#123; Java.perform(function()&#123; var currentApplication &#x3D; Java.use(&quot;android.app.ActivityThread&quot;).currentApplication(); console.log(currentApplication); var context &#x3D; currentApplication.getApplicationContext(); console.log(context); var packageName &#x3D; context.getPackageName(); console.log(packageName); console.log(currentApplication.getPackageName()); &#125;)&#125; RPC123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778frida 传递参数function main()&#123; Java.perform(function () &#123; console.log(&quot;enter perform&quot;); &#x2F;&#x2F; 获取要hook的类 var TextViewClass &#x3D; Java.use(&quot;android.widget.TextView&quot;); &#x2F;&#x2F; 要hook的方法 TextViewClass.setText.overload(&#39;java.lang.CharSequence&#39;).implementation &#x3D; function (ori_input) &#123; console.log(&#39;enter&#39;, &#39;java.lang.CharSequence&#39;); console.log(&#39;ori_input&#39;,ori_input.toString()); &#x2F;&#x2F; 定义用于接受python传参的data var receive_data; &#x2F;&#x2F; 将原参数传递给python 在python中进行处理 send(ori_input.toString()); &#x2F;&#x2F; recv 从python接收传递的内容 默认传过来的是个json对象 recv(function (json_data) &#123; console.log(&#39;data from python &#39; + json_data.data); receive_data &#x3D; json_data.data; console.log(typeof (receive_data)); &#125;).wait(); &#x2F;&#x2F;wait() 等待python处理 阻塞 &#x2F;&#x2F; 转java字符串 receive_data &#x3D; Java.use(&quot;java.lang.String&quot;).$new(receive_data); this.setText(receive_data); &#125;; &#125;)&#125;setImmediate(main);python 处理收到的参数# -*- coding: utf-8 -*-__author__ &#x3D; &quot;K&quot;__time__ &#x3D; &quot;2020-08-06 09:48&quot;import sysimport timeimport base64import fridafrom loguru import loggerdef on_message(message,data): logger.info(str(message)) # dict logger.info(str(data) if data else &quot;None&quot;) if message[&#39;type&#39;] &#x3D;&#x3D; &#39;error&#39;: logger.error(&#39;error:&#39; + str(message[&#39;description&#39;])) logger.error(&#39;stack: &#39; + str(message[&#39;stack&#39;])) if message[&#39;type&#39;] &#x3D;&#x3D; &#39;send&#39;: logger.info(&#39;get message [*] --&gt; &#39; + message[&#39;payload&#39;]) payload &#x3D; message[&#39;payload&#39;] # 处理逻辑 sending to the server: YWFhOmJiYg&#x3D;&#x3D; tmp &#x3D; payload.split(&#39;:&#39;) sts &#x3D; tmp[0] need_to_db64 &#x3D; tmp[1] user_pass &#x3D; base64.b64decode(need_to_db64.encode()).decode() mine_str &#x3D; &#39;admin&#39; + &#39;:&#39; + user_pass.split(&#39;:&#39;)[-1] mine_b64_str &#x3D; base64.b64encode(mine_str.encode()).decode() mine_b64_str &#x3D; sts + mine_b64_str logger.info(mine_b64_str) # python返回数据给js script.post script.post(&#123;&#39;data&#39;:mine_b64_str&#125;) logger.info(&#39;python complete&#39;)device &#x3D; frida.get_usb_device()# pid &#x3D; device.spawn([&#39;com.kevin.demo04&#39;])# time.sleep(1)session &#x3D; device.attach(&#39;com.kevin.demo02&#39;)with open(&#39;.&#x2F;hulianhutong.js&#39;,&#39;r&#39;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot;,on_message)script.load()input() 强制类型转换12345678910111213141516171819202122&#x2F;&#x2F; Java.cast() 子类可以强转成父类, 父类不能转成子类&#x2F;&#x2F; 可以使用Java.cast()将子类强转成父类, 再调用父类的动态方法function castDemo()&#123; Java.perform(function()&#123; var JuiceHandle &#x3D; null; &#x2F;&#x2F; 用来存储内存中找到的Juice对象 var WaterClass &#x3D; Java.use(&quot;com.r0ysue.a0526printout.Water&quot;); Java.choose(&quot;com.r0ysue.a0526printout.Juice&quot;,&#123; onComplete: function()&#123;&#125;, onMatch: function(instance)&#123; JuiceHandle &#x3D; instance; console.log(&quot;instance:&quot;, instance); &#x2F;&#x2F; 调用Juice对象的方法 console.log(JuiceHandle.fillEnergy()); &#x2F;&#x2F; 子类Juice转父类Water 并调用父类的动态方法 var WaterInstance &#x3D; Java.cast(JuiceHandle,WaterClass); console.log(WaterInstance.still(WaterInstance)); &#125; &#125;) &#125;)&#125; map2json1234567891011121314function map2json(mapSet) &#123; try &#123; var result &#x3D; &#123;&#125;; var key_set &#x3D; mapSet.keySet(); var it &#x3D; key_set.iterator(); while (it.hasNext()) &#123; var key_str &#x3D; it.next().toString(); result[key_str] &#x3D; mapSet.get(key_str).toString(); &#125; return result &#125; catch (error) &#123; return mapSet &#125;&#125; bytes2Hex12345678910111213141516171819202122function bytes2Hex(arrBytes)&#123; var str &#x3D; &quot;&quot;; for (var i &#x3D; 0; i &lt; arrBytes.length; i++) &#123; var tmp; var num &#x3D; arrBytes[i]; if (num &lt; 0) &#123; &#x2F;&#x2F;此处填坑，当byte因为符合位导致数值为负时候，需要对数据进行处理 tmp &#x3D; (255 + num + 1).toString(16); &#125; else &#123; tmp &#x3D; num.toString(16); &#125; if (tmp.length &#x3D;&#x3D; 1) &#123; tmp &#x3D; &quot;0&quot; + tmp; &#125; if(i&gt;0)&#123; str +&#x3D; &quot; &quot;+tmp; &#125;else&#123; str +&#x3D; tmp; &#125; &#125; return str;&#125; string2Bytes123456789101112131415161718192021222324function string2Bytes(str) &#123; var bytes &#x3D; new Array(); var len, c; len &#x3D; str.length; for(var i &#x3D; 0; i &lt; len; i++) &#123; c &#x3D; str.charCodeAt(i); if(c &gt;&#x3D; 0x010000 &amp;&amp; c &lt;&#x3D; 0x10FFFF) &#123; bytes.push(((c &gt;&gt; 18) &amp; 0x07) | 0xF0); bytes.push(((c &gt;&gt; 12) &amp; 0x3F) | 0x80); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); &#125; else if(c &gt;&#x3D; 0x000800 &amp;&amp; c &lt;&#x3D; 0x00FFFF) &#123; bytes.push(((c &gt;&gt; 12) &amp; 0x0F) | 0xE0); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); &#125; else if(c &gt;&#x3D; 0x000080 &amp;&amp; c &lt;&#x3D; 0x0007FF) &#123; bytes.push(((c &gt;&gt; 6) &amp; 0x1F) | 0xC0); bytes.push((c &amp; 0x3F) | 0x80); &#125; else &#123; bytes.push(c &amp; 0xFF); &#125; &#125; return bytes;&#125; bytes2String123456789101112131415161718192021222324252627282930313233function bytes2String(arr) &#123; if(typeof arr &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123; return arr; &#125; var str &#x3D; &#39;&#39;, _arr &#x3D; arr; for(var i &#x3D; 0; i &lt; _arr.length; i++) &#123; var one &#x3D; _arr[i].toString(2), v &#x3D; one.match(&#x2F;^1+?(?&#x3D;0)&#x2F;); if(v &amp;&amp; one.length &#x3D;&#x3D; 8) &#123; var bytesLength &#x3D; v[0].length; var store &#x3D; _arr[i].toString(2).slice(7 - bytesLength); for(var st &#x3D; 1; st &lt; bytesLength; st++) &#123; store +&#x3D; _arr[st + i].toString(2).slice(2); &#125; try &#123; str +&#x3D; String.fromCharCode(parseInt(store, 2)); &#125; catch (error) &#123; str +&#x3D; parseInt(store, 2).toString(); console.log(error); &#125; i +&#x3D; bytesLength - 1; &#125; else &#123; try &#123; str +&#x3D; String.fromCharCode(_arr[i]); &#125; catch (error) &#123; str +&#x3D; parseInt(store, 2).toString(); console.log(error); &#125; &#125; &#125; return str;&#125; bytes2Base6412345678910111213141516171819202122232425function bytes2Base64(e) &#123; var base64EncodeChars &#x3D; &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&#39;; var r, a, c, h, o, t; for (c &#x3D; e.length, a &#x3D; 0, r &#x3D; &#39;&#39;; a &lt; c;) &#123; if (h &#x3D; 255 &amp; e[a++], a &#x3D;&#x3D; c) &#123; r +&#x3D; base64EncodeChars.charAt(h &gt;&gt; 2), r +&#x3D; base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4), r +&#x3D; &#39;&#x3D;&#x3D;&#39;; break &#125; if (o &#x3D; e[a++], a &#x3D;&#x3D; c) &#123; r +&#x3D; base64EncodeChars.charAt(h &gt;&gt; 2), r +&#x3D; base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4), r +&#x3D; base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2), r +&#x3D; &#39;&#x3D;&#39;; break &#125; t &#x3D; e[a++], r +&#x3D; base64EncodeChars.charAt(h &gt;&gt; 2), r +&#x3D; base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4), r +&#x3D; base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2 | (192 &amp; t) &gt;&gt; 6), r +&#x3D; base64EncodeChars.charAt(63 &amp; t) &#125; return r&#125; 常见算法hook123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156Java.perform(function () &#123; var secretKeySpec &#x3D; Java.use(&#39;javax.crypto.spec.SecretKeySpec&#39;); secretKeySpec.$init.overload(&#39;[B&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function (a, b) &#123; showStacks(); var result &#x3D; this.$init(a, b); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;算法名：&quot; + b + &quot;|Dec密钥:&quot; + bytesToString(a)); send(&quot;算法名：&quot; + b + &quot;|Hex密钥:&quot; + bytesToHex(a)); return result; &#125; var mac &#x3D; Java.use(&#39;javax.crypto.Mac&#39;); mac.getInstance.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (a) &#123; showStacks(); var result &#x3D; this.getInstance(a); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;算法名：&quot; + a); return result; &#125; mac.update.overload(&#39;[B&#39;).implementation &#x3D; function (a) &#123; showStacks(); this.update(a); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;update:&quot; + bytesToString(a)) &#125; mac.update.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (a, b, c) &#123; showStacks(); this.update(a, b, c) send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c); &#125; mac.doFinal.overload().implementation &#x3D; function () &#123; showStacks(); var result &#x3D; this.doFinal(); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;doFinal结果:&quot; + bytesToHex(result)); send(&quot;doFinal结果:&quot; + bytesToBase64(result)); return result; &#125; mac.doFinal.overload(&#39;[B&#39;).implementation &#x3D; function (a) &#123; showStacks(); var result &#x3D; this.doFinal(a); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;doFinal参数:&quot; + bytesToString(a)); send(&quot;doFinal结果:&quot; + bytesToHex(result)); send(&quot;doFinal结果:&quot; + bytesToBase64(result)); return result; &#125; var md &#x3D; Java.use(&#39;java.security.MessageDigest&#39;); md.getInstance.overload(&#39;java.lang.String&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function (a, b) &#123; showStacks(); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;算法名：&quot; + a); return this.getInstance(a, b); &#125; md.getInstance.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (a) &#123; showStacks(); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;算法名：&quot; + a); return this.getInstance(a); &#125; md.update.overload(&#39;[B&#39;).implementation &#x3D; function (a) &#123; showStacks(); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;update:&quot; + bytesToString(a)) return this.update(a); &#125; md.update.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (a, b, c) &#123; showStacks(); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c); return this.update(a, b, c); &#125; md.digest.overload().implementation &#x3D; function () &#123; showStacks(); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); var result &#x3D; this.digest(); send(&quot;digest结果:&quot; + bytesToHex(result)); send(&quot;digest结果:&quot; + bytesToBase64(result)); return result; &#125; md.digest.overload(&#39;[B&#39;).implementation &#x3D; function (a) &#123; showStacks(); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;digest参数:&quot; + bytesToString(a)); var result &#x3D; this.digest(a); send(&quot;digest结果:&quot; + bytesToHex(result)); send(&quot;digest结果:&quot; + bytesToBase64(result)); return result; &#125; var ivParameterSpec &#x3D; Java.use(&#39;javax.crypto.spec.IvParameterSpec&#39;); ivParameterSpec.$init.overload(&#39;[B&#39;).implementation &#x3D; function (a) &#123; showStacks(); var result &#x3D; this.$init(a); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;iv向量:&quot; + bytesToString(a)); send(&quot;iv向量:&quot; + bytesToHex(a)); return result; &#125; var cipher &#x3D; Java.use(&#39;javax.crypto.Cipher&#39;); cipher.getInstance.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (a) &#123; showStacks(); var result &#x3D; this.getInstance(a); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;模式填充:&quot; + a); return result; &#125; cipher.update.overload(&#39;[B&#39;).implementation &#x3D; function (a) &#123; showStacks(); var result &#x3D; this.update(a); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;update:&quot; + bytesToString(a)); return result; &#125; cipher.update.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (a, b, c) &#123; showStacks(); var result &#x3D; this.update(a, b, c); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c); return result; &#125; cipher.doFinal.overload().implementation &#x3D; function () &#123; showStacks(); var result &#x3D; this.doFinal(); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;doFinal结果:&quot; + bytesToHex(result)); send(&quot;doFinal结果:&quot; + bytesToBase64(result)); return result; &#125; cipher.doFinal.overload(&#39;[B&#39;).implementation &#x3D; function (a) &#123; showStacks(); var result &#x3D; this.doFinal(a); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;doFinal参数:&quot; + bytesToString(a)); send(&quot;doFinal结果:&quot; + bytesToHex(result)); send(&quot;doFinal结果:&quot; + bytesToBase64(result)); return result; &#125; var x509EncodedKeySpec &#x3D; Java.use(&#39;java.security.spec.X509EncodedKeySpec&#39;); x509EncodedKeySpec.$init.overload(&#39;[B&#39;).implementation &#x3D; function (a) &#123; showStacks(); var result &#x3D; this.$init(a); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); send(&quot;RSA密钥:&quot; + bytesToBase64(a)); return result; &#125; var rSAPublicKeySpec &#x3D; Java.use(&#39;java.security.spec.RSAPublicKeySpec&#39;); rSAPublicKeySpec.$init.overload(&#39;java.math.BigInteger&#39;, &#39;java.math.BigInteger&#39;).implementation &#x3D; function (a, b) &#123; showStacks(); var result &#x3D; this.$init(a, b); send(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;send(&quot;RSA密钥:&quot; + bytesToBase64(a)); send(&quot;RSA密钥N:&quot; + a.toString(16)); send(&quot;RSA密钥E:&quot; + b.toString(16)); return result; &#125;&#125;); base64实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding: utf-8 -*-import base64DEFAULT &#x3D; 0 # 默认模式, 每行不超过76个字符NO_PADDING &#x3D; 1 # 移除最后的&#x3D;NO_WRAP &#x3D; 2 # 不换行，一行输出CRLF &#x3D; 4 # 采用win上的换行符URL_SAVE &#x3D; 8 # 采用urlsafedef decode(content: str, flag: int) -&gt; bytes: missing_padding &#x3D; len(content) % 4 if missing_padding !&#x3D; 0: content &#x3D; content.ljust(len(content) + (4 - missing_padding), &quot;&#x3D;&quot;) if flag &amp; URL_SAVE: result &#x3D; base64.urlsafe_b64decode(content.encode(&quot;utf-8&quot;)) else: result &#x3D; base64.b64decode(content.encode(&quot;utf-8&quot;)) return resultdef encode(content: bytes, flag: int) -&gt; str: need_wrap &#x3D; True need_padding &#x3D; True lf &#x3D; &quot;\\n&quot; if flag &amp; NO_WRAP: need_wrap &#x3D; False if flag &amp; NO_PADDING: need_padding &#x3D; False if flag &amp; CRLF: lf &#x3D; &quot;\\r\\n&quot; if flag &amp; URL_SAVE: result &#x3D; base64.urlsafe_b64encode(content).decode(&quot;utf-8&quot;) else: result &#x3D; base64.b64encode(content).decode(&quot;utf-8&quot;) if not need_padding: result &#x3D; result.rstrip(&quot;&#x3D;&quot;) if need_wrap: n &#x3D; 76 output &#x3D; lf.join([result[i:i + n] for i in range(0, len(result), n)]) else: output &#x3D; result return output 常用转换模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377&#x2F;&#x2F;工具相关函数var base64EncodeChars &#x3D; &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&#39;, base64DecodeChars &#x3D; new Array((-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), 62, (-1), (-1), (-1), 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, (-1), (-1), (-1), (-1), (-1), (-1), (-1), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, (-1), (-1), (-1), (-1), (-1), (-1), 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, (-1), (-1), (-1), (-1), (-1));function stringToBase64(e) &#123; var r, a, c, h, o, t; for (c &#x3D; e.length, a &#x3D; 0, r &#x3D; &#39;&#39;; a &lt; c;) &#123; if (h &#x3D; 255 &amp; e.charCodeAt(a++), a &#x3D;&#x3D; c) &#123; r +&#x3D; base64EncodeChars.charAt(h &gt;&gt; 2), r +&#x3D; base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4), r +&#x3D; &#39;&#x3D;&#x3D;&#39;; break &#125; if (o &#x3D; e.charCodeAt(a++), a &#x3D;&#x3D; c) &#123; r +&#x3D; base64EncodeChars.charAt(h &gt;&gt; 2), r +&#x3D; base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4), r +&#x3D; base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2), r +&#x3D; &#39;&#x3D;&#39;; break &#125; t &#x3D; e.charCodeAt(a++), r +&#x3D; base64EncodeChars.charAt(h &gt;&gt; 2), r +&#x3D; base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4), r +&#x3D; base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2 | (192 &amp; t) &gt;&gt; 6), r +&#x3D; base64EncodeChars.charAt(63 &amp; t) &#125; return r&#125;function base64ToString(e) &#123; var r, a, c, h, o, t, d; for (t &#x3D; e.length, o &#x3D; 0, d &#x3D; &#39;&#39;; o &lt; t;) &#123; do r &#x3D; base64DecodeChars[255 &amp; e.charCodeAt(o++)]; while (o &lt; t &amp;&amp; r &#x3D;&#x3D; -1); if (r &#x3D;&#x3D; -1) break; do a &#x3D; base64DecodeChars[255 &amp; e.charCodeAt(o++)]; while (o &lt; t &amp;&amp; a &#x3D;&#x3D; -1); if (a &#x3D;&#x3D; -1) break; d +&#x3D; String.fromCharCode(r &lt;&lt; 2 | (48 &amp; a) &gt;&gt; 4); do &#123; if (c &#x3D; 255 &amp; e.charCodeAt(o++), 61 &#x3D;&#x3D; c) return d; c &#x3D; base64DecodeChars[c] &#125; while (o &lt; t &amp;&amp; c &#x3D;&#x3D; -1); if (c &#x3D;&#x3D; -1) break; d +&#x3D; String.fromCharCode((15 &amp; a) &lt;&lt; 4 | (60 &amp; c) &gt;&gt; 2); do &#123; if (h &#x3D; 255 &amp; e.charCodeAt(o++), 61 &#x3D;&#x3D; h) return d; h &#x3D; base64DecodeChars[h] &#125; while (o &lt; t &amp;&amp; h &#x3D;&#x3D; -1); if (h &#x3D;&#x3D; -1) break; d +&#x3D; String.fromCharCode((3 &amp; c) &lt;&lt; 6 | h) &#125; return d&#125;function hexToBase64(str) &#123; return base64Encode(String.fromCharCode.apply(null, str.replace(&#x2F;\\r|\\n&#x2F;g, &quot;&quot;).replace(&#x2F;([\\da-fA-F]&#123;2&#125;) ?&#x2F;g, &quot;0x$1 &quot;).replace(&#x2F; +$&#x2F;, &quot;&quot;).split(&quot; &quot;)));&#125;function base64ToHex(str) &#123; for (var i &#x3D; 0, bin &#x3D; base64Decode(str.replace(&#x2F;[ \\r\\n]+$&#x2F;, &quot;&quot;)), hex &#x3D; []; i &lt; bin.length; ++i) &#123; var tmp &#x3D; bin.charCodeAt(i).toString(16); if (tmp.length &#x3D;&#x3D;&#x3D; 1) tmp &#x3D; &quot;0&quot; + tmp; hex[hex.length] &#x3D; tmp; &#125; return hex.join(&quot;&quot;);&#125;function hexToBytes(str) &#123; var pos &#x3D; 0; var len &#x3D; str.length; if (len % 2 !&#x3D; 0) &#123; return null; &#125; len &#x2F;&#x3D; 2; var hexA &#x3D; new Array(); for (var i &#x3D; 0; i &lt; len; i++) &#123; var s &#x3D; str.substr(pos, 2); var v &#x3D; parseInt(s, 16); hexA.push(v); pos +&#x3D; 2; &#125; return hexA;&#125;function bytesToHex(arr) &#123; var str &#x3D; &#39;&#39;; var k, j; for (var i &#x3D; 0; i &lt; arr.length; i++) &#123; k &#x3D; arr[i]; j &#x3D; k; if (k &lt; 0) &#123; j &#x3D; k + 256; &#125; if (j &lt; 16) &#123; str +&#x3D; &quot;0&quot;; &#125; str +&#x3D; j.toString(16); &#125; return str;&#125;function stringToHex(str) &#123; var val &#x3D; &quot;&quot;; for (var i &#x3D; 0; i &lt; str.length; i++) &#123; if (val &#x3D;&#x3D; &quot;&quot;) val &#x3D; str.charCodeAt(i).toString(16); else val +&#x3D; str.charCodeAt(i).toString(16); &#125; return val&#125;function stringToBytes(str) &#123; var ch, st, re &#x3D; []; for (var i &#x3D; 0; i &lt; str.length; i++) &#123; ch &#x3D; str.charCodeAt(i); st &#x3D; []; do &#123; st.push(ch &amp; 0xFF); ch &#x3D; ch &gt;&gt; 8; &#125; while (ch); re &#x3D; re.concat(st.reverse()); &#125; return re;&#125;&#x2F;&#x2F;将byte[]转成String的方法function bytesToString(arr) &#123; var str &#x3D; &#39;&#39;; arr &#x3D; new Uint8Array(arr); for (var i in arr) &#123; str +&#x3D; String.fromCharCode(arr[i]); &#125; return str;&#125;function bytesToBase64(e) &#123; var r, a, c, h, o, t; for (c &#x3D; e.length, a &#x3D; 0, r &#x3D; &#39;&#39;; a &lt; c;) &#123; if (h &#x3D; 255 &amp; e[a++], a &#x3D;&#x3D; c) &#123; r +&#x3D; base64EncodeChars.charAt(h &gt;&gt; 2), r +&#x3D; base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4), r +&#x3D; &#39;&#x3D;&#x3D;&#39;; break &#125; if (o &#x3D; e[a++], a &#x3D;&#x3D; c) &#123; r +&#x3D; base64EncodeChars.charAt(h &gt;&gt; 2), r +&#x3D; base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4), r +&#x3D; base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2), r +&#x3D; &#39;&#x3D;&#39;; break &#125; t &#x3D; e[a++], r +&#x3D; base64EncodeChars.charAt(h &gt;&gt; 2), r +&#x3D; base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4), r +&#x3D; base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2 | (192 &amp; t) &gt;&gt; 6), r +&#x3D; base64EncodeChars.charAt(63 &amp; t) &#125; return r&#125;function base64ToBytes(e) &#123; var r, a, c, h, o, t, d; for (t &#x3D; e.length, o &#x3D; 0, d &#x3D; []; o &lt; t;) &#123; do r &#x3D; base64DecodeChars[255 &amp; e.charCodeAt(o++)]; while (o &lt; t &amp;&amp; r &#x3D;&#x3D; -1); if (r &#x3D;&#x3D; -1) break; do a &#x3D; base64DecodeChars[255 &amp; e.charCodeAt(o++)]; while (o &lt; t &amp;&amp; a &#x3D;&#x3D; -1); if (a &#x3D;&#x3D; -1) break; d.push(r &lt;&lt; 2 | (48 &amp; a) &gt;&gt; 4); do &#123; if (c &#x3D; 255 &amp; e.charCodeAt(o++), 61 &#x3D;&#x3D; c) return d; c &#x3D; base64DecodeChars[c] &#125; while (o &lt; t &amp;&amp; c &#x3D;&#x3D; -1); if (c &#x3D;&#x3D; -1) break; d.push((15 &amp; a) &lt;&lt; 4 | (60 &amp; c) &gt;&gt; 2); do &#123; if (h &#x3D; 255 &amp; e.charCodeAt(o++), 61 &#x3D;&#x3D; h) return d; h &#x3D; base64DecodeChars[h] &#125; while (o &lt; t &amp;&amp; h &#x3D;&#x3D; -1); if (h &#x3D;&#x3D; -1) break; d.push((3 &amp; c) &lt;&lt; 6 | h) &#125; return d&#125;&#x2F;&#x2F; 打印logfunction showStacks() &#123; Java.perform(function () &#123; send(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new())); &#125;);&#125;&#x2F;&#x2F; 字节数组转hex字符串function bytesToHex(arr) &#123; var str &#x3D; &quot;&quot;; for (var i &#x3D; 0; i &lt; arr.length; i++) &#123; var tmp &#x3D; arr[i]; if (tmp &lt; 0) &#123; tmp &#x3D; (255 + tmp + 1).toString(16); &#125; else &#123; tmp &#x3D; tmp.toString(16); &#125; if (tmp.length &#x3D;&#x3D; 1) &#123; tmp &#x3D; &quot;0&quot; + tmp; &#125; str +&#x3D; tmp; &#125; return str;&#125;function bytesToBase64(arr) &#123; var str &#x3D; &quot;&quot;; for (var i &#x3D; 0; i &lt; arr.length; i++) &#123; var tmp &#x3D; arr[i]; if (tmp &lt; 0) &#123; tmp &#x3D; (255 + tmp + 1).toString(16); &#125; else &#123; tmp &#x3D; tmp.toString(16); &#125; if (tmp.length &#x3D;&#x3D; 1) &#123; tmp &#x3D; &quot;0&quot; + tmp; &#125; str +&#x3D; tmp; &#125; return str;&#125;function bytesToString(arr) &#123; var str &#x3D; &quot;&quot;; for (var i &#x3D; 0; i &lt; arr.length; i++) &#123; var tmp &#x3D; arr[i]; if (tmp &lt; 0) &#123; tmp &#x3D; (255 + tmp + 1).toString(16); &#125; else &#123; tmp &#x3D; tmp.toString(16); &#125; if (tmp.length &#x3D;&#x3D; 1) &#123; tmp &#x3D; &quot;0&quot; + tmp; &#125; str +&#x3D; tmp; &#125; return str;&#125;function byteToHexString(uint8arr) &#123; if (!uint8arr) &#123; return &#39;&#39;; &#125; var hexStr &#x3D; &#39;&#39;; for (var i &#x3D; 0; i &lt; uint8arr.length; i++) &#123; var hex &#x3D; (uint8arr[i] &amp; 0xff).toString(16); hex &#x3D; (hex.length &#x3D;&#x3D;&#x3D; 1) ? &#39;0&#39; + hex : hex; hexStr +&#x3D; hex; &#125; return hexStr.toUpperCase();&#125;function stringToUint8Array(str)&#123; var arr &#x3D; []; for (var i &#x3D; 0, j &#x3D; str.length; i &lt; j; ++i) &#123; arr.push(str.charCodeAt(i)); &#125; var tmpUint8Array &#x3D; new Uint8Array(arr); return tmpUint8Array&#125;function str2arraybffer(str) &#123; var buf &#x3D; new ArrayBuffer(str.length * 2); &#x2F;&#x2F; 每个字符占用2个字节 var bufView &#x3D; new Uint16Array(buf); for (var i &#x3D; 0, strLen &#x3D; str.length; i &lt; strLen; i++) &#123; bufView[i] &#x3D; str.charCodeAt(i); &#125; return buf;&#125;function printBytes(b)&#123; var hexstr &#x3D; &quot;&quot;; for (var i&#x3D;0; i&lt; b.length; i++) &#123; var uByte &#x3D; (b[i]&gt;&gt;&gt;0)&amp;0xff; var n &#x3D; uByte.toString(16); hexstr +&#x3D; &quot;0x&quot; + (&quot;00&quot; + n).slice(-2)+&quot;, &quot;; &#125; return hexstr;&#125;&#x2F;&#x2F;字节数组转十六进制字符串，对负值填坑&#x2F;&#x2F; 二进制数据（包括内存地址）在计算机中一般以16进制的方式表示function Bytes2HexString(arrBytes) &#123; var str &#x3D; &quot;&quot;; for (var i &#x3D; 0; i &lt; arrBytes.length; i++) &#123; var tmp; var num&#x3D;arrBytes[i]; if (num &lt; 0) &#123; &#x2F;&#x2F;此处填坑，当byte因为符合位导致数值为负时候，需要对数据进行处理 tmp &#x3D;(255+num+1).toString(16); &#125; else &#123; tmp &#x3D; num.toString(16); &#125; if (tmp.length &#x3D;&#x3D; 1) &#123; tmp &#x3D; &quot;0&quot; + tmp; &#125; str +&#x3D; tmp; &#125; return str;&#125;&#x2F;&#x2F; 会转成有符号的数字 JSON.stringify(bytes)function HexString2Bytes(str) &#123; var pos &#x3D; 0; var len &#x3D; str.length; if (len % 2 !&#x3D; 0) &#123; return null; &#125; len &#x2F;&#x3D; 2; var arrBytes &#x3D; new Array(); for (var i &#x3D; 0; i &lt; len; i++) &#123; var s &#x3D; str.substr(pos, 2); var v &#x3D; parseInt(s, 16); &#x2F;&#x2F; 转成有符号的 10进制 if (v &gt; 127) &#123; v &#x3D; v - 256 &#125; &#x2F;&#x2F; end arrBytes.push(v); pos +&#x3D; 2; &#125; return arrBytes;&#125;function jstring2Str(jstring) &#123; var ret; Java.perform(function() &#123; var String &#x3D; Java.use(&quot;java.lang.String&quot;); ret &#x3D; Java.cast(jstring, String); &#125;); return ret;&#125; function jbyteArray2Array(jbyteArray) &#123; var ret; Java.perform(function() &#123; var b &#x3D; Java.use(&#39;[B&#39;); var buffer &#x3D; Java.cast(jbyteArray, b); ret &#x3D; Java.array(&#39;byte&#39;, buffer); &#125;); return ret;&#125;function getParamType(obj) &#123; return obj &#x3D;&#x3D; null ? String(obj) : Object.prototype.toString.call(obj).replace(&#x2F;\\[object\\s+(\\w+)\\]&#x2F;i, &quot;$1&quot;) || &quot;object&quot;;&#125; 打印class12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function printClass(c)&#123; var str &#x3D; &quot;-------------------------------\\n&quot;; str +&#x3D; &quot;|&quot; + JSON.stringify(c) + &quot;\\n&quot;; var fields &#x3D; c.getClass().getFields(); for(var index in fields)&#123; var field &#x3D; fields[index]; var fieldName &#x3D; &quot;&quot;; var value &#x3D; &quot;&quot;; try&#123; fieldName &#x3D; field.getName(); value &#x3D; field.get(c); &#125;catch(e)&#123; &#125; if(fieldName &#x3D;&#x3D; &quot;&quot;)&#123; continue; &#125; str +&#x3D; &quot;|&quot; + fieldName + &quot;:&quot; + printValue(value) + &quot;\\n&quot;; &#125; str +&#x3D; &quot;------------------------------\\n\\n\\n&quot;; return str;&#125;function printValue(value)&#123; try&#123; var newValue &#x3D; Java.cast(value, Java.use(&quot;java.lang.Object&quot;)) switch(newValue.getClass().getName())&#123; case &quot;[B&quot;: return printBytes(value) &#125; return value; &#125;catch(e)&#123; return value; &#125;&#125;function printBytes(result)&#123; try&#123; var ByteArrayOutputStreamClass &#x3D; Java.use(&quot;java.io.ByteArrayOutputStream&quot;); var out &#x3D; ByteArrayOutputStreamClass.$new() var ObjectOutputStreamClass &#x3D; Java.use(&quot;java.io.ObjectOutputStream&quot;); var sOut &#x3D; ObjectOutputStreamClass.$new(out); sOut.writeObject(result); sOut.flush(); var bytes &#x3D; out.toByteArray(); var argsArray &#x3D; []; for(var i &#x3D; 0; i &lt; bytes.length; i++) &#123; argsArray.push(bytes[i]); &#125; return &quot;[&quot;+argsArray.join(&quot;,&quot;)+&quot;]&quot;; &#125;catch(e)&#123; console.log(e); return result; &#125;&#125; var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"SO逆向之最右sign分析","slug":"SO逆向之最右sign分析","date":"2021-11-11T06:39:23.000Z","updated":"2022-10-20T15:40:30.996Z","comments":true,"path":"2021/11/11/SO逆向之最右sign分析/","link":"","permalink":"http://onejane.github.io/2021/11/11/SO%E9%80%86%E5%90%91%E4%B9%8B%E6%9C%80%E5%8F%B3sign%E5%88%86%E6%9E%90/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 抓包最右5.7.3.apk 启动charles，开始socks抓包 postern配置代理 postern配置规则 开启vpn开始抓包 Fridajadx反编译搜索sign= 主动调用a方法，构造字符串和字节数组参数，打印返回结果 1234567function callSign()&#123; Java.perform(function () &#123; var plainTextBytes &#x3D; Java.use(&quot;java.lang.String&quot;).$new(&quot;onejane&quot;).getBytes(&quot;UTF-8&quot;); var result &#x3D; Java.use(&quot;com.izuiyou.network.NetCrypto&quot;).a(&quot;12345&quot;, plainTextBytes); console.log(result); &#125;);&#125; 堆栈跟踪12objection -g cn.xiaochuankeji.tieba explore -P ~&#x2F;.objection&#x2F;plugins android hooking watch class_method com.izuiyou.network.NetCrypto.a --dump-args --dump-backtrace --dump-return 除了使用objection，也可以通过frida脚本打印堆栈 1234567891011121314151617181920212223242526272829setImmediate(function()&#123; Java.perform(function () &#123; var threadef &#x3D; Java.use(&#39;java.lang.Thread&#39;); var threadinstance &#x3D; threadef.$new(); function Where(stack)&#123; var at &#x3D; &quot;&quot; for(var i &#x3D; 0; i &lt; stack.length; ++i)&#123; at +&#x3D; stack[i].toString() + &quot;\\n&quot; &#125; return at &#125; var ZYNetCrypto &#x3D; Java.use(&quot;com.izuiyou.network.NetCrypto&quot;); ZYNetCrypto.sign.implementation &#x3D; function(arg1, arg2)&#123; console.log(&quot;\\nNetCrypto.sign\\n&quot;); &#x2F;&#x2F; 打印入参信息 &#x2F;&#x2F; console.log(&quot;str&#x3D;&quot; + arg1 + &quot;\\nbuf&#x3D;&quot; + printBytes(arg2) + &quot;\\nbuf2&#x3D;&quot; + Bytes2HexString(arg2) + &quot;\\njson&#x3D;&quot; + JSON.stringify(arg2)); var result &#x3D; this.sign(arg1, arg2); console.log(&quot;\\nOut Rc&#x3D;&quot; + result); var stack &#x3D; threadinstance.currentThread().getStackTrace(); console.log(&quot;Full call stack:&quot; + Where(stack)); return result; &#125; &#125;);&#125;); 通过objection和frida堆栈跟踪，jeb打开搜索k46 byte[] v1_2 = NetCrypto.encodeAES(v3_4.toString().getBytes(Charset.forName(&quot;UTF-8&quot;))); 接下来hook NetCrypto.encodeAES并打印出入参 123456789101112131415setImmediate(function () &#123; Java.perform(function () &#123; var ZYNetCrypto &#x3D; Java.use(&quot;com.izuiyou.network.NetCrypto&quot;); ZYNetCrypto.encodeAES.implementation &#x3D; function (arg1) &#123; &#x2F;&#x2F; console.log(&quot;\\nNetCrypto.encodeAES &quot; + arg1.length + &quot;\\n&quot;); &#x2F;&#x2F; console.log(&quot;encodeAES &gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + JSON.stringify(arg1)); var strIn &#x3D; Java.use(&#39;java.lang.String&#39;); var outStr &#x3D; strIn.$new(arg1); &#x2F;&#x2F; console.log(outStr); var result &#x3D; this.encodeAES(arg1); console.log(outStr + &quot; &#x3D; &quot; + printBytes(result)); return result; &#125; &#125;);&#125;); 图中圈出的字符串即为V1_2，拿到了协议的明文，主要逻辑就是通过aes加密后的字符串结合请求地址利用so中的sign函数完成签名校验。 rpc调用123byte[] encodeAES &#x3D; NetCrypto.encodeAES(jSONObject.toString().getBytes(Charset.forName(&quot;UTF-8&quot;)));String a2 &#x3D; NetCrypto.a(build.toString(), encodeAES);newBuilder.url(a2).addHeader(&quot;X-Xc-Proto-Req&quot;, NetCrypto.getProtocolKey()).post(RequestBody.create(b(), encodeAES)); 以上需要关注的函数有NetCrypto.encodeAES，NetCrypto.a，NetCrypto.getProtocolKey,在NetCrypto.a还有NetCrypto.sign，返回结果是加密的需要NetCrypto.decodeAES解密 zuiyouSign.js 对NetCrypto.sign进行hook打印出入参 123456789101112131415function hookSign() &#123; Java.perform(function () &#123; var ZYNetCrypto &#x3D; Java.use(&quot;com.izuiyou.network.NetCrypto&quot;); ZYNetCrypto.sign.implementation &#x3D; function (arg1, arg2) &#123; console.log(&quot;\\nNetCrypto.sign\\n&quot;); console.log(&quot;str&#x3D;&quot; + arg1 + &quot;\\nbuf&#x3D;&quot; + printBytes(arg2) + &quot;\\nbuf2&#x3D;&quot; + byteToHexString(arg2) + &quot;\\njson&#x3D;&quot; + JSON.stringify(arg2)); var result &#x3D; this.sign(arg1, arg2); console.log(&quot;\\nOut Rc&#x3D;&quot; + result); return result; &#125; &#125;)&#125;setImmediate(hookSign) frida -UF cn.xiaochuankeji.tieba -l zuiyouSign.js 根据返回结果可以得知同一个请求每次返回的sign是一样的，第一个参数为请求地址。 callSignFunZy.js 主动调用入参中的的byte数组返回sign 1234567891011121314151617181920function callSignFunZy(str, buf) &#123; var result &#x3D; &#39;null&#39;; console.log(str); var arr &#x3D; HexString2Bytes(buf); Java.perform(function () &#123; var ZYNetCrypto &#x3D; Java.use(&quot;com.izuiyou.network.NetCrypto&quot;); var res &#x3D; ZYNetCrypto.sign(str, arr); result &#x3D; res; &#125;); return result;&#125;rpc.exports &#x3D; &#123; callzyfun: callSignFunZy, &#x2F;&#x2F; 导出名不可以有大写字母和下划线&#125;; hookSign.py 1234567891011121314151617181920212223from flask import Flask, jsonifyimport fridaapp &#x3D; Flask(__name__)global gScriptdevice &#x3D; frida.get_usb_device()pid&#x3D;device.get_frontmost_application().pid session &#x3D; device.attach(pid)with open(&quot;agent&#x2F;zuiyouSign.js&quot;) as f: gScript &#x3D; session.create_script(f.read())gScript.load()@app.route(&#39;&#x2F;sign&#39;)def zy_test(): str &#x3D; &#39;https:&#x2F;&#x2F;api.izuiyou.com&#x2F;my&#x2F;profile&#39; buf &#x3D; bytearray([0xf6, 0x01, 0xc4, 0xd4, 0xe3, 0xf3, 0x03, 0x13, 0x13, 0xa2, 0xd1, ...]) res &#x3D; gScript.exports.callzyfun(str, buf.hex()) return jsonify(res)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.run(host&#x3D;&#39;0.0.0.0&#39;, port&#x3D;1234, debug&#x3D;True) python hookSign.py 发起请求127.0.0.1:1234/sign获取sign 完整实现 Frida结合 Magisk Hide报错：try disabling Magisk Hide in case it is active Magisk Manager &gt; Settings &gt;Magisk &gt; Magisk Hide，用来隐藏ROOT，避免部分app检测ROOT zuiyouSign.js 实现加密解密签名等函数的定义和导出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&#x2F;&#x2F; 加密 encodeAES函数的参数和返回值都是byte数组，转成hex字符串&#x2F;&#x2F; byte[] encodeAES &#x3D; NetCrypto.encodeAES(jSONObject.toString().getBytes(Charset.forName(&quot;UTF-8&quot;)));function callEncodeAes(strData)&#123; var result &#x3D; &#39;null&#39;; Java.perform(function() &#123; var ZYNetCrypto &#x3D; Java.use(&quot;com.izuiyou.network.NetCrypto&quot;); &#x2F;&#x2F; 入参转成字节数组 jSONObject.toString().getBytes(Charset.forName(&quot;UTF-8&quot;)) var strIn &#x3D; Java.use(&#39;java.lang.String&#39;); var byteIn &#x3D; strIn.$new(strData).getBytes(); &#x2F;&#x2F; 开始加密 var res &#x3D; ZYNetCrypto.encodeAES(byteIn); result &#x3D; Bytes2HexString(res); &#125;); return result; &#125;&#x2F;&#x2F; 解密&#x2F;&#x2F; NetCrypto.decodeAES(v7, true)function callDecodeAes(dataBuf)&#123; var rc &#x3D; &#39;null&#39;; var arr &#x3D; HexString2Bytes(dataBuf); Java.perform(function() &#123; var ZYNetCrypto &#x3D; Java.use(&quot;com.izuiyou.network.NetCrypto&quot;); var res &#x3D; ZYNetCrypto.decodeAES(arr,true); rc &#x3D; Bytes2HexString(res); &#125;); return rc;&#125;&#x2F;&#x2F; 签名function callSignFun(str,buf)&#123; var result &#x3D; &#39;null&#39;; var arr &#x3D; HexString2Bytes(buf); Java.perform(function () &#123; var ZYNetCrypto &#x3D; Java.use(&quot;com.izuiyou.network.NetCrypto&quot;); var res &#x3D; ZYNetCrypto.sign(str,arr) ; result &#x3D; res; &#125;); return result; &#125;&#x2F;&#x2F; 当前使用的keyfunction callGetProtocolKey()&#123; var result &#x3D; &#39;null&#39;; Java.perform(function () &#123; var ZYNetCrypto &#x3D; Java.use(&quot;com.izuiyou.network.NetCrypto&quot;); var res &#x3D; ZYNetCrypto.getProtocolKey() ; result &#x3D; res; &#125;); return result; &#125;&#x2F;&#x2F; 设置当前使用的keyfunction callSetProtocolKey(strKey)&#123; var result &#x3D; &#39;null&#39;; Java.perform(function () &#123; var ZYNetCrypto &#x3D; Java.use(&quot;com.izuiyou.network.NetCrypto&quot;); ZYNetCrypto.setProtocolKey(strKey) ; &#125;); return result; &#125;rpc.exports &#x3D; &#123; callgetkey : callGetProtocolKey, callsetkey : callSetProtocolKey, calldecaes : callDecodeAes, callencaes : callEncodeAes, callsignfun : callSignFun&#125;; python hookSign.py hook 通过frida rpc方式调用js中的hook 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding: utf-8 -*-from __future__ import print_function# Python 2.x &amp; 3.x compatible# from distutils.log import warn as printimport sysimport fridaimport codecsimport threadingimport timeimport reimport base64import jsonfrom flask import Flask, jsonify, requestif sys.version_info &lt; (3, 0): reload(sys) sys.setdefaultencoding(&#39;utf-8&#39;)global gScriptHOOK_JS &#x3D; &#39;.&#x2F;agent&#x2F;zuiyouSign.js&#39;ZY_NAME &#x3D; u&#39;最右&#39;ZY_FRONTBOARD &#x3D; &#39;cn.xiaochuankeji.tieba&#39; def bytesToHexString(bs): return &#39;&#39;.join([&#39;%02X &#39; % b for b in bs])#系统标准输出，支持grepdef outWrite(text): sys.stdout.write((text.encode(&#39;utf8&#39;) + b&#39;\\n&#39; ).decode());#带颜色打印输出def colorPrint(color, s): return &quot;%s[31;%dm%s%s[0m&quot; % (chr(27), color, s , chr(27))#获取第一个USB连接的设备def get_usb_iphone(): Type &#x3D; &#39;usb&#39; if int(frida.__version__.split(&#39;.&#39;)[0]) &lt; 12: Type &#x3D; &#39;tether&#39; device_manager &#x3D; frida.get_device_manager() changed &#x3D; threading.Event() def on_changed(): changed.set() device_manager.on(&#39;changed&#39;, on_changed) device &#x3D; None while device is None: devices &#x3D; [dev for dev in device_manager.enumerate_devices() if dev.type &#x3D;&#x3D; Type] if len(devices) &#x3D;&#x3D; 0: print (&#39;Waiting for USB device...&#39;) changed.wait() else: device &#x3D; devices[0] device_manager.off(&#39;changed&#39;, on_changed) return device#枚举运行进程信息def listRunningProcess(): device &#x3D; get_usb_iphone(); processes &#x3D; device.enumerate_processes(); processes.sort(key &#x3D; lambda item : item.pid) outWrite(&#39;%-10s\\t%s&#39; % (&#39;pid&#39;, &#39;name&#39;)) for process in processes: outWrite(&#39;%-10s\\t%s&#39; % (str(process.pid),process.name))#枚举某个进程的所有模块信息def listModulesoOfProcess(session): moduels &#x3D; session.enumerate_modules() moduels.sort(key &#x3D; lambda item : item.base_address) for module in moduels: outWrite(&#39;%-40s\\t%-10s\\t%-10s\\t%s&#39; % (module.name, hex(module.base_address), hex(module.size), module.path)) session.detach()#从JS接受信息def on_message(message, data): print(message) if message.has_key(&#39;payload&#39;): payload &#x3D; message[&#39;payload&#39;] if isinstance(payload, dict): deal_message(payload) else: print (payload)#加载JS文件脚本def loadJsFile(session, filename): source &#x3D; &#39;&#39; with codecs.open(filename, &#39;r&#39;, &#39;utf-8&#39;) as f: source &#x3D; source + f.read() script &#x3D; session.create_script(source) script.on(&#39;message&#39;, on_message) #接收js脚本的消息 script.load() return scriptapp &#x3D; Flask(__name__)@app.route(&#39;&#x2F;aesenc&#39;, methods&#x3D;[&#39;POST&#39;]) # 数据加密def zy_aesenc(): global gScript data &#x3D; request.get_data() res &#x3D; gScript.exports.callencaes(data.decode(&quot;utf-8&quot;)) return res@app.route(&#39;&#x2F;aesdec&#39;, methods&#x3D;[&#39;POST&#39;]) # 数据解密def zy_aesdec(): global gScript data &#x3D; request.get_data() res &#x3D; gScript.exports.calldecaes(data.decode(&quot;utf-8&quot;)) return res@app.route(&#39;&#x2F;sign&#39;, methods&#x3D;[&#39;POST&#39;]) # 数据签名def zy_sign(): global gScript data &#x3D; request.get_data() print(data.decode(&quot;utf-8&quot;)) res &#x3D; gScript.exports.callsignfun(&#39;http:&#x2F;&#x2F;api.izuiyou.com&#x2F;&#39;,data.decode(&quot;utf-8&quot;)) return res@app.route(&#39;&#x2F;setkey&#39;, methods&#x3D;[&#39;POST&#39;]) # 设置keydef zy_setKey(): global gScript data &#x3D; request.get_data() res &#x3D; gScript.exports.callsetkey(data); return res@app.route(&#39;&#x2F;getkey&#39;) # 获取当前keydef zy_getKey(): global gScript res &#x3D; gScript.exports.callgetkey() return resdef main(): global session global appname global gScript # 1. 获取USB设备 device &#x3D; get_usb_iphone() if len(sys.argv)&gt;2: appname &#x3D; sys.argv[2] else: appname &#x3D; ZY_NAME print(&#39;设备信息:&#39; + str(device)) if sys.argv[1]&#x3D;&#x3D;&#39;ps&#39;: # 枚举运行进程信息 print (&#39;ps&#39;) listRunningProcess() elif sys.argv[1]&#x3D;&#x3D;&#39;hook&#39;: # 动态Hook print (&#39;zyhook&#39;) pid &#x3D; device.spawn(ZY_FRONTBOARD) session &#x3D; device.attach(pid) print(&quot;[*] Attach Application id:&quot;,pid) device.resume(pid) print(&quot;[*] Application onResume&quot;) gScript &#x3D; loadJsFile(session, HOOK_JS) # sys.stdin.read() # 启动web服务 app.run() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: try: main() except KeyboardInterrupt: if session: session.detach() sys.exit() else: pass finally: pass 在源码中encodeAES的参数中jSONObject的值由mt8.Z返回，所以我们通过objection内存搜索打印返回即可 123objection -g cn.xiaochuankeji.tieba explore -P ~&#x2F;.objection&#x2F;plugins android hooking list class_methods mt8android hooking watch class_method mt8.Z --dump-args --dump-backtrace --dump-return python run.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103from __future__ import print_function# Python 2.x &amp; 3.x compatible# from distutils.log import warn as printimport sysimport requestsfrom requests import RequestExceptionimport hashlibimport timeimport jsonif sys.version_info &lt; (3, 0): reload(sys) sys.setdefaultencoding(&#39;utf-8&#39;)def get_frida_rpc(url,msg): try: r &#x3D; requests.post(url,data&#x3D;msg.encode(&#39;utf-8&#39;)) # 这里可以做一些返回值的错误处理 return r.text except RequestException as e: print(e) # 首页推荐内容解析def dataAesEnc(msg): return get_frida_rpc(&#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;aesenc&#39;,msg)def dataAesDec(msg): return get_frida_rpc(&#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;aesdec&#39;,msg)def dataSign(msg): return get_frida_rpc(&#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;sign&#39;,msg)def dataGetKey(): r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;getkey&#39;) return r.textdef dataSetKey(msg): return get_frida_rpc(&#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;setkey&#39;,msg) # 获取数据def get_data(uri, msg): postData &#x3D; dataAesEnc(msg) # print(postData) sign &#x3D; dataSign(postData) # print(sign) protocolKey &#x3D; dataGetKey() # print(protocolKey) url &#x3D; uri + str(sign) headers &#x3D; &#123; &#39;ZYP&#39;: &#39;mid&#x3D;239631186&#39;, &#39;X-Xc-Agent&#39; : &#39;av&#x3D;5.5.11,dt&#x3D;0&#39;, &#39;User-Agent&#39;: &#39;okhttp&#x2F;3.12.2 Zuiyou&#x2F;5.5.11 (Android&#x2F;27)&#39;, &#39;X-Xc-Proto-Req&#39; : protocolKey, &#39;Request-Type&#39; : &#39;text&#x2F;json&#39;, &#39;Content-Type&#39; : &#39;application&#x2F;xcp&#39;, &#125; # 将十六进制字符串转字节数组 b&#39;&#x2F;\\x07\\xc5\\xf4\\x143\\xc2\\xe1\\x01... byte_data &#x3D; bytes.fromhex(postData) # proxies &#x3D; &#123;&#39;http&#39;: &#39;127.0.0.1:8888&#39;, # &#39;https&#39;: &#39;127.0.0.1:8888&#39; # &#125; try: # ,proxies&#x3D;proxies r &#x3D; requests.post(url, headers&#x3D;headers, data&#x3D;byte_data, verify&#x3D;False,stream&#x3D;True,timeout&#x3D;15) # print(r.headers[&#39;X-Xc-Proto-Res&#39;]) # key是 cat开头的就需要把返回包里面的duck key设置进去， if protocolKey.find(&#39;cat&#39;) &#x3D;&#x3D; 0: print(protocolKey) print(r.headers[&#39;X-Xc-Proto-Res&#39;]) dataSetKey(r.headers[&#39;X-Xc-Proto-Res&#39;]) # 这里要做一些错误处理 bufRc &#x3D; r.raw.read(); rcStr &#x3D; dataAesDec(bufRc.hex()) rc &#x3D; bytes.fromhex(rcStr).decode(&quot;utf-8&quot;) return rc except RequestException as e: print(e) def main(): # 手机端首页推荐地址 uri &#x3D; &#39;http:&#x2F;&#x2F;api.izuiyou.com&#x2F;index&#x2F;recommend?sign&#x3D;&#39; msg &#x3D; &#39;&#123;&quot;filter&quot;:&quot;all&quot;,&quot;auto&quot;:0,&quot;tab&quot;:&quot;推荐&quot;,&quot;direction&quot;:&quot;down&quot;,&quot;c_types&quot;:[1,2,11,15,16,51,17,52,53,40,50,41,22,25,27],&quot;sdk_ver&quot;:&#123;&quot;tt&quot;:&quot;3.1.0.3&quot;,&quot;tx&quot;:&quot;4.211.1081&quot;,&quot;bd&quot;:&quot;5.86&quot;,&quot;mimo&quot;:&quot;5.0.3&quot;,&quot;tt_aid&quot;:&quot;5004095&quot;,&quot;tx_aid&quot;:&quot;1106701465&quot;,&quot;bd_aid&quot;:&quot;c8655095&quot;,&quot;mimo_aid&quot;:&quot;2882303761518470184&quot;&#125;,&quot;ad_wakeup&quot;:1,&quot;h_ua&quot;:&quot;Mozilla\\&#x2F;5.0 (Linux; Android 8.1.0; Redmi 6A Build\\&#x2F;O11019; wv) AppleWebKit\\&#x2F;537.36 (KHTML, like Gecko) Version\\&#x2F;4.0 Chrome\\&#x2F;62.0.3202.84 Mobile Safari\\&#x2F;537.36&quot;,&quot;manufacturer&quot;:&quot;Xiaomi&quot;,&quot;h_av&quot;:&quot;5.5.11&quot;,&quot;h_dt&quot;:0,&quot;h_os&quot;:27,&quot;h_app&quot;:&quot;zuiyou&quot;,&quot;h_model&quot;:&quot;Redmi 6A&quot;,&quot;h_did&quot;:&quot;866655030396869&quot;,&quot;h_nt&quot;:1,&quot;h_m&quot;:239631186,&quot;h_ch&quot;:&quot;xiaomi&quot;,&quot;h_ts&quot;:1603179121590,&quot;token&quot;:&quot;T7K4Nnqg98_aFV9JwkfuiZtvPrRJ02EXxbnm7TXr3qiIWWaT1vjNNNCpcUu112TDw_VXu&quot;,&quot;android_id&quot;:&quot;57b9b8465c2e440b&quot;,&quot;h_ids&quot;:&#123;&quot;imei2&quot;:&quot;878739042239784&quot;,&quot;meid&quot;:&quot;98001184062989&quot;,&quot;imei1&quot;:&quot;878739042239776&quot;,&quot;imei&quot;:&quot;98001184062989&quot;&#125;,&quot;h_os_type&quot;:&quot;miui&quot;&#125;&#39; items &#x3D; get_data(uri, msg) print(items) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: j &#x3D; 1 while True: print(&quot;第&#123;&#125;次加载的段子\\n&quot;.format(j)) main() j +&#x3D; 1 # 测试程序，加载3次 if j &gt;1 : break print(&quot;加载完毕&quot;) XposedAndroid Studio新建Empty Activity–OneJaneXposed,删除默认MainActivity和AndroidManifest.xml中的activity AndroidManifest.xml 1234567891011&lt;meta-data android:name&#x3D;&quot;xposedmodule&quot; android:value&#x3D;&quot;true&quot; &#x2F;&gt;&lt;meta-data android:name&#x3D;&quot;xposeddescription&quot; android:value&#x3D;&quot;zy hook&quot; &#x2F;&gt;&lt;meta-data android:name&#x3D;&quot;xposedminversion&quot; android:value&#x3D;&quot;53&quot; &#x2F;&gt; app\\build.gradle 1234dependencies &#123; compileOnly &#39;de.robv.android.xposed:api:82&#39; compileOnly &#39;de.robv.android.xposed:api:82:sources&#39;&#125; app\\src\\main\\java\\com\\example\\onejanexposed\\HookLoader.java 12345678910111213141516public class HookLoader implements IXposedHookLoadPackage &#123; private final static String TAG &#x3D; &quot;onejane&quot;; public static void log(String s) &#123; Log.i(TAG, s); &#125; public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; log(&quot;Im comming Frist&quot;+loadPackageParam.packageName); XposedBridge.log(&quot;zzx zy has Hooked Frist!&quot;); if (loadPackageParam.packageName.equals(&quot;cn.xiaochuankeji.tieba&quot;)) &#123; log(TAG+&quot;Im comming zy 3&quot;); &#125; &#125;&#125; app\\src\\main\\assets\\xposed_init 配置xposed入口类 1com.example.onejanexposed.HookLoader 在xposed中启动该模块即可 完整xposed实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148public class HookLoader implements IXposedHookLoadPackage &#123; private final static String TAG &#x3D; &quot;onejane&quot;; public static void log(String s) &#123; Log.i(TAG, s); &#125; public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; log(&quot;Im comming &quot;+loadPackageParam.packageName); XposedBridge.log(&quot;xposed log Hooked Frist!&quot;); if (loadPackageParam.packageName.equals(&quot;cn.xiaochuankeji.tieba&quot;)) &#123; log(&quot;Im comming zy 3&quot;); &#x2F;&#x2F; http server class myHttpServer extends NanoHTTPD &#123; private static final String REQUEST_ROOT &#x3D; &quot;&#x2F;&quot;; public myHttpServer() throws IOException &#123; &#x2F;&#x2F; 端口是8088，也就是说要通过http:&#x2F;&#x2F;127.0.0.1:8088来访当问 super(8888); start(NanoHTTPD.SOCKET_READ_TIMEOUT, true); log(&quot;---fenfei Server---&quot;); &#125; @Override public Response serve(IHTTPSession session) &#123; &#x2F;&#x2F; log(&quot;serve&quot;); &#x2F;&#x2F;这个就是之前分析，重写父类的一个参数的方法， &#x2F;&#x2F;这里边已经把所有的解析操作已经在这里执行了 return super.serve(session); &#125; @Override public Response serve(String uri, Method method, Map&lt;String, String&gt; headers, Map&lt;String, String&gt; parms, Map&lt;String, String&gt; files) &#123; &#x2F;&#x2F; log(&quot;serve xxx&quot;); &#x2F;&#x2F;这就是上边的serve方法最后一行调用的那个过时的方法，这里简单的做个判断就好了 &#x2F;&#x2F; if (!method.equals(Method.POST)) &#123;&#x2F;&#x2F;判断请求方式是否争取 &#x2F;&#x2F; return newFixedLengthResponse(&quot;the request method is incoorect&quot;); &#x2F;&#x2F; &#125; log(uri); for (Map.Entry&lt;String, String&gt; entry : files.entrySet()) &#123; log(&quot;Key &#x3D; &quot; + entry.getKey() + &quot;, Value &#x3D; &quot; + entry.getValue()); &#125; Class&lt;?&gt; clazzZy &#x3D; null; try &#123; clazzZy &#x3D; loadPackageParam.classLoader.loadClass(&quot;com.izuiyou.network.NetCrypto&quot;); log(&quot;load class:&quot; + clazzZy); &#125; catch (Exception e) &#123; log(&quot;load class err:&quot; + Log.getStackTraceString(e)); return newFixedLengthResponse(&quot;load class is null&quot;); &#125; if (StringUtils.containsIgnoreCase(uri, &quot;getkey&quot;)) &#123;&#x2F;&#x2F;判断uri是否正确 return getKey(clazzZy); &#125; if (StringUtils.containsIgnoreCase(uri, &quot;setkey&quot;)) &#123;&#x2F;&#x2F;判断uri是否正确 String postData &#x3D; files.get(&quot;postData&quot;); if (!StringUtils.isEmpty(postData)) &#123;&#x2F;&#x2F;判断post过来的数据是否正确 return setkey(clazzZy,postData); &#125;else&#123; return newFixedLengthResponse(&quot;postData is null&quot;); &#125; &#125; if (StringUtils.containsIgnoreCase(uri, &quot;sign&quot;)) &#123; String postData &#x3D; files.get(&quot;postData&quot;); if (!StringUtils.isEmpty(postData)) &#123; return sign(clazzZy,postData); &#125;else&#123; return newFixedLengthResponse(&quot;postData is null&quot;); &#125; &#125; if (StringUtils.containsIgnoreCase(uri, &quot;aesenc&quot;)) &#123; String postData &#x3D; files.get(&quot;postData&quot;); if (!StringUtils.isEmpty(postData)) &#123; return aesenc(clazzZy,postData); &#125;else&#123; return newFixedLengthResponse(&quot;postData is null&quot;); &#125; &#125; if (StringUtils.containsIgnoreCase(uri, &quot;aesdec&quot;)) &#123;&#x2F;&#x2F;判断uri是否正确 String postData &#x3D; files.get(&quot;postData&quot;); if (!StringUtils.isEmpty(postData)) &#123;&#x2F;&#x2F;判断post过来的数据是否正确 return aesdec(clazzZy,postData); &#125;else&#123; return newFixedLengthResponse(&quot;postData is null&quot;); &#125; &#125; &#x2F;&#x2F;判断完了开始解析数据，如果是你想要的数据，那么你就给返回一个正确的格式就好了 &#x2F;&#x2F;举个栗子：return newFixedLengthResponse(&quot;&#123;\\&quot;result\\&quot;:0,\\&quot;success\\&quot;:true&#125;&quot;); return super.serve(uri, method, headers, parms, files); &#125; public Response sign(Class&lt;?&gt; clazzUse,String strData)&#123; byte[] inBuf &#x3D; Hex.hex2Byte(strData); String rc &#x3D; (String) XposedHelpers.callStaticMethod(clazzUse, &quot;sign&quot;,&quot;http:&#x2F;&#x2F;api.izuiyou.com&#x2F;&quot;,inBuf); log(&quot;sign &#x3D; &quot;+rc); return newFixedLengthResponse(rc); &#125; public Response aesenc(Class&lt;?&gt; clazzUse,String strData)&#123; byte[] inBuf &#x3D; strData.getBytes() ; byte[] rc &#x3D; (byte[])XposedHelpers.callStaticMethod(clazzUse, &quot;encodeAES&quot;,inBuf); String rcStr &#x3D; Hex.byte2Hex(rc); log(&quot;aesenc &#x3D; &quot;+ rcStr); return newFixedLengthResponse(rcStr); &#125; public Response aesdec(Class&lt;?&gt; clazzUse,String strData)&#123; byte[] inBuf &#x3D; Hex.hex2Byte(strData); byte[] rc &#x3D; (byte[])XposedHelpers.callStaticMethod(clazzUse, &quot;decodeAES&quot;,inBuf,true); String rcStr &#x3D; Hex.byte2Hex(rc); log(&quot;aesdec &#x3D; &quot;+ rcStr); return newFixedLengthResponse(rcStr); &#125; public Response setkey(Class&lt;?&gt; clazzUse,String strKey)&#123; XposedHelpers.callStaticMethod(clazzUse, &quot;setProtocolKey&quot;,strKey); log(&quot;setkey &#x3D; &quot;+strKey); return newFixedLengthResponse(&quot;set key ok&quot;); &#125; public Response getKey(Class&lt;?&gt; clazzUse)&#123; String rc &#x3D; (String) XposedHelpers.callStaticMethod(clazzUse, &quot;getProtocolKey&quot;); log(&quot;getkey &#x3D; &quot;+rc); return newFixedLengthResponse(rc); &#125; &#125; new myHttpServer(); &#125; &#125;&#125; build.gradle 12implementation &#39;org.apache.commons:commons-lang3:3.7&#39;implementation &#39;org.nanohttpd:nanohttpd:2.3.1&#39; 结合run.py修改请求地址为172.20.103.67:8888，以上只是通过objection内存漫游拿到的参数借助xposed或者frida主动调用so层函数，实现在python的rpc调用sign参数的加密。 Unidbg12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ZuiYouSign extends AbstractJni &#123; public static void main(String[] args) throws IOException &#123; &#x2F;&#x2F; 1、需要调用的Apk文件所在路径 String apkFilePath &#x3D; &quot;right573.apk&quot;; &#x2F;&#x2F; 2、需要调用函数所在的Java类完整路径，比如a&#x2F;b&#x2F;c&#x2F;d等等，注意需要用&#x2F;代替. String classPath &#x3D; &quot;com&#x2F;izuiyou&#x2F;network&#x2F;NetCrypto&quot;; ZuiYouSign runZyObj &#x3D; new ZuiYouSign(apkFilePath, classPath); runZyObj.destroy(); &#125; &#x2F;&#x2F; ARM模拟器 private final ARMEmulator emulator; &#x2F;&#x2F; vm private final VM vm; &#x2F;&#x2F; 载入的模块 private final Module module; private final DvmClass TTEncryptUtils; public ZuiYouSign(String apkFilePath, String classPath) throws IOException &#123; &#x2F;&#x2F; 创建app进程，包名可任意写 emulator &#x3D; AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;com.onejane.RunZy&quot;).build(); &#x2F;&#x2F; 创建模拟器实例，要模拟32位或者64位，在这里区分 final Memory memory &#x3D; emulator.getMemory(); &#x2F;&#x2F; 模拟器的内存操作接口 &#x2F;&#x2F; 作者支持19和23两个sdk memory.setLibraryResolver(new AndroidResolver(23)); &#x2F;&#x2F; 创建DalvikVM，利用apk本身，可以为null vm &#x3D; ((AndroidARMEmulator) emulator).createDalvikVM(new File(apkFilePath)); vm.setVerbose(true); vm.setJni(this); new AndroidModule(emulator, vm).register(memory); &#x2F;&#x2F; （关键处1）加载so，填写so的文件路径 或者vm.loadLibrary(new File(&quot;net_crypto.so&quot;), true) DalvikModule dm &#x3D; vm.loadLibrary(&quot;net_crypto&quot;, false); &#x2F;&#x2F; 调用jni dm.callJNI_OnLoad(emulator); module &#x3D; dm.getModule(); &#x2F;&#x2F; （关键处2）加载so文件中的哪个类，填写完整的类路径 TTEncryptUtils &#x3D; vm.resolveClass(classPath); &#125; &#x2F;** * 关闭模拟器 * @throws IOException *&#x2F; private void destroy() throws IOException &#123; emulator.close(); System.out.println(&quot;emulator destroy...&quot;); &#125;&#125; 在JNIOnLoad时对函数进行了动态注册，当loadLibrary时不执行init相关函数，即第二个参数为false时输出结果乱码，因为so对字符串做了混淆加密，一般在Init array节或者JNIOnLoad，总之在字符串使用前的任何一个时机点都有可能。IDA打开libnet_crypto.so，shift+F7找到节区中的init_array，解密逻辑就在图中的函数中，如果模拟执行时加载so不执行init相关函数，导致so字符串没有被解密，输出乱码。 public static { we5.a(ContextProvider.get(), &quot;net_crypto&quot;); NetCrypto.native_init(); } 加载完net_crypto后，执行native_init() 12345runZyObj.initCall();private void initCall() &#123; &#x2F;&#x2F; jeb反编译的smali指令 .method public static native native_init()V TTEncryptUtils.callStaticJniMethod(emulator, &quot;native_init()V&quot;);&#125; 或者通过地址调用 12345678910DalvikModule dm &#x3D; vm.loadLibrary(new File(&quot;libnet_crypto.so&quot;), true); &#x2F;&#x2F; 加载so到虚拟内存module &#x3D; dm.getModule(); &#x2F;&#x2F;获取本SO模块的句柄public void native_init()&#123; &#x2F;&#x2F; 0x4a069 是native_init动态注册的地址 List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;(10); list.add(vm.getJNIEnv()); &#x2F;&#x2F; 第一个参数是env list.add(0); &#x2F;&#x2F; 第二个参数，实例方法是jobject，静态方法是jclass，直接填0，一般用不到。 module.callFunction(emulator, 0x4a069, list.toArray());&#125; 报错如下： java.lang.UnsupportedOperationException: com/izuiyou/common/base/BaseApplication-&gt;getAppContext()Landroid/content/Context;at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:426) 补环境重写 callStaticObjectMethodV 123456789@Overridepublic DvmObject&lt;?&gt; callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;com&#x2F;izuiyou&#x2F;common&#x2F;base&#x2F;BaseApplication-&gt;getAppContext()Landroid&#x2F;content&#x2F;Context;&quot;: return vm.resolveClass(&quot;android&#x2F;content&#x2F;Context&quot;, vm.resolveClass(&quot;android&#x2F;content&#x2F;ContextWrapper&quot;, vm.resolveClass(&quot;android&#x2F;content&#x2F;Context&quot;))).newObject(signature); &#125; return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList);&#125; 调用sign 12345678910111213141516&#x2F;&#x2F; 3、jadx中smali invoke-static &#123;p0, p1&#125;, Lcom&#x2F;izuiyou&#x2F;network&#x2F;NetCrypto;-&gt;sign(Ljava&#x2F;lang&#x2F;String;[B)Ljava&#x2F;lang&#x2F;String;String methodSign &#x3D; &quot;sign(Ljava&#x2F;lang&#x2F;String;[B)Ljava&#x2F;lang&#x2F;String;&quot;;String InBuf &#x3D; &quot;50027f7...&quot;;&#x2F;&#x2F;输出方法调用结果String ret &#x3D; runZyObj.getSign(methodSign , new StringObject(runZyObj.vm, &quot;https:&#x2F;&#x2F;zyadapi.izuiyou.com&#x2F;ad&#x2F;popup_ad&quot;) &#x2F;&#x2F;&quot;https:&#x2F;&#x2F;api.izuiyou.com&#x2F;index&#x2F;recommend&quot;) , hexStringToBytes(InBuf));&#x2F;&#x2F; Out Rc&#x3D;v2-1ff7402d2b4fa9a4c39b3853262f18fdSystem.out.printf(&quot;ret:%s\\n&quot;, ret);private String getSign(String methodSign, Object... args) &#123; &#x2F;&#x2F; 使用jni调用传入的函数签名对应的方法（） Object value &#x3D; TTEncryptUtils.callStaticJniMethodObject(emulator, methodSign, args).getValue(); return value.toString();&#125; 或者通过地址调用 1234567891011private String callSign()&#123; &#x2F;&#x2F; 准备入参 0x4a28D是sign动态注册的地址 List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;(10); list.add(vm.getJNIEnv()); &#x2F;&#x2F; 第一个参数是env list.add(0); &#x2F;&#x2F; 第二个参数，实例方法是jobject，静态方法是jclass，直接填0，一般用不到。 list.add(vm.addLocalObject(new StringObject(vm, &quot;12345&quot;))); ByteArray plainText &#x3D; new ByteArray(vm, &quot;onejane&quot;.getBytes(StandardCharsets.UTF_8)); list.add(vm.addLocalObject(plainText)); Number number &#x3D; module.callFunction(emulator, 0x4a28D, list.toArray())[0]; return vm.getObject(number.intValue()).getValue().toString();&#125;; 报错如下： java.lang.UnsupportedOperationException: android/content/Context-&gt;getClass()Ljava/lang/Class; at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:373) 补环境重写getClass 12345678@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;android&#x2F;content&#x2F;Context-&gt;getClass()Ljava&#x2F;lang&#x2F;Class;&quot;: return vm.resolveClass(&quot;java&#x2F;lang&#x2F;Class&quot;); &#125; return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125; 报错如下： java.lang.UnsupportedOperationException: java/lang/Class-&gt;getSimpleName()Ljava/lang/String; at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:373) getSimpleName 是个类名，根据之前的报错逻辑，com/izuiyou/common/base/BaseApplication-&gt;getAppContext()获取到Context后，通过android/content/Context-&gt;getClass()获取到类，最终获取类名，之前补环境虽然只补了类型，只要最终返回的结果正确即可。根据objection内存漫游拿到完整类名就是cn.xiaochaunkeji.tieba.AppController，getSimpleName就是AppController 或者通过frida主动调用静态函数获取getSimpleName的返回结果 12345678910setImmediate(function()&#123; Java.perform(function()&#123; var BaseApplication &#x3D; Java.use(&quot;com.izuiyou.common.base.BaseApplication&quot;).getAppContext().getClass(); var methods &#x3D; BaseApplication.class.getDeclaredMethods(); for(var j &#x3D; 0; j &lt; methods.length; j++)&#123; var methodName &#x3D; methods[j].getName(); console.log(methodName); &#125; &#125;);&#125;) 遍历该类中的方法确实存在一个叫getSimpleName() 123456setImmediate(function()&#123; Java.perform(function()&#123; var BaseApplication &#x3D; Java.use(&quot;com.izuiyou.common.base.BaseApplication&quot;).getAppContext().getClass(); console.log(BaseApplication.getSimpleName()) &#125;);&#125;) 返回结果就是AppController 补环境 12345678910@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;android&#x2F;content&#x2F;Context-&gt;getClass()Ljava&#x2F;lang&#x2F;Class;&quot;: return vm.resolveClass(&quot;java&#x2F;lang&#x2F;Class&quot;); case &quot;java&#x2F;lang&#x2F;Class-&gt;getSimpleName()Ljava&#x2F;lang&#x2F;String;&quot;: return new StringObject(vm, &quot;AppController&quot;); &#125; return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125; 报错如下： java.lang.UnsupportedOperationException: cn/xiaochuankeji/tieba/common/debug/AppLogReporter-&gt;reportAppRuntime(Ljava/lang/String;Ljava/lang/String;)V at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticVoidMethodV(AbstractJni.java:612) reportAppRuntime没有返回值，直接return 12345678@Overridepublic void callStaticVoidMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;cn&#x2F;xiaochuankeji&#x2F;tieba&#x2F;common&#x2F;debug&#x2F;AppLogReporter-&gt;reportAppRuntime(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)V&quot;: return; &#125; throw new UnsupportedOperationException(signature);&#125; 报错如下： java.lang.UnsupportedOperationException: android/content/Context-&gt;getFilesDir()Ljava/io/File; at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:373) 读取文件直接返回java/io/File 123456789101112@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;android&#x2F;content&#x2F;Context-&gt;getClass()Ljava&#x2F;lang&#x2F;Class;&quot;: return vm.resolveClass(&quot;java&#x2F;lang&#x2F;Class&quot;); case &quot;java&#x2F;lang&#x2F;Class-&gt;getSimpleName()Ljava&#x2F;lang&#x2F;String;&quot;: return new StringObject(vm, &quot;AppController&quot;); case &quot;android&#x2F;content&#x2F;Context-&gt;getFilesDir()Ljava&#x2F;io&#x2F;File;&quot;: return vm.resolveClass(&quot;java&#x2F;io&#x2F;File&quot;); &#125; return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125; 报错如下： java.lang.UnsupportedOperationException: java/lang/Class-&gt;getAbsolutePath()Ljava/lang/String; at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:373) 获取绝对路径，直接返回/sdcard 1234567891011121314@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;android&#x2F;content&#x2F;Context-&gt;getClass()Ljava&#x2F;lang&#x2F;Class;&quot;: return vm.resolveClass(&quot;java&#x2F;lang&#x2F;Class&quot;); case &quot;java&#x2F;lang&#x2F;Class-&gt;getSimpleName()Ljava&#x2F;lang&#x2F;String;&quot;: return new StringObject(vm, &quot;AppController&quot;); case &quot;android&#x2F;content&#x2F;Context-&gt;getFilesDir()Ljava&#x2F;io&#x2F;File;&quot;: return vm.resolveClass(&quot;java&#x2F;io&#x2F;File&quot;); case &quot;java&#x2F;lang&#x2F;Class-&gt;getAbsolutePath()Ljava&#x2F;lang&#x2F;String;&quot;: return new StringObject(vm, &quot;&#x2F;sdcard&quot;); &#125; return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125; 报错如下： java.lang.UnsupportedOperationException: android/os/Debug-&gt;isDebuggerConnected()Z at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticBooleanMethodV(AbstractJni.java:169) 判断是否调试，直接return false 12345678@Overridepublic boolean callStaticBooleanMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;android&#x2F;os&#x2F;Debug-&gt;isDebuggerConnected()Z&quot;: return Boolean.FALSE; &#125; return super.callStaticBooleanMethodV(vm,dvmClass,signature,vaList);&#125; 报错如下： java.lang.UnsupportedOperationException: android/os/Process-&gt;myPid()I at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticIntMethodV(AbstractJni.java:189) 需要pid 123456789@Overridepublic int callStaticIntMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123; switch (signature) &#123; case &quot;android&#x2F;os&#x2F;Process-&gt;myPid()I&quot;: &#x2F;&#x2F;return 123; return emulator.getPid(); &#125; return super.callStaticIntMethodV(vm,dvmClass,signature,vaList);&#125; 算法还原Hook由于返回值固定为32位，且输入不变输出不变，可能是哈希算法中的md5算法，不过libnet_crypto.so做了一定的OLLVM混淆，借助IDA-Edit-Plugins-FindHash对哈希算法进行正则匹配，对函数逐个反编译。 1234567PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains pyenv install 3.9.1pyenv local 3.9.1proxychains4 pip install objection&#x3D;&#x3D;1.11.0adb push frida-server-15.1.12-android-arm64 &#x2F;data&#x2F;local&#x2F;tmpmv frida-server-15.1.12-android-arm64 fs15112arm64chmod 777 fs15112arm64.&#x2F;fs15112arm64 frida -UF cn.xiaochuankeji.tieba -l libnet_crypto_findhash_1637807043.js 刷新页面触发sign生成 IDA快捷键 G 跳转到65540，F5跳转到伪C代码， 尝试hook该函数，这三个参数不确定是指针还是数值，所以先全部做为数值处理，作为long类型看待，防止整数溢出 1234567891011121314151617181920212223242526public void hook65540()&#123; &#x2F;&#x2F; 加载HookZz IHookZz hookZz &#x3D; HookZz.getInstance(emulator); hookZz.wrap(module.base + 0x65540 + 1, new WrapCallback&lt;HookZzArm32RegisterContext&gt;() &#123; &#x2F;&#x2F; inline wrap导出函数 @Override &#x2F;&#x2F; 类似于 frida onEnter public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) &#123; &#x2F;&#x2F; 类似于Frida args[0] System.out.println(ctx.getR0Long()); System.out.println(ctx.getR1Long()); System.out.println(ctx.getR2Long()); &#125;; @Override &#x2F;&#x2F; 类似于 frida onLeave public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) &#123; &#125; &#125;);&#125;public static void main(String[] args) throws Exception &#123; zuiyou test &#x3D; new zuiyou(); test.hook65540(); test.native_init(); System.out.println(test.callSign());&#125; 打印入参 322122318873221223060 参数2应该是数组，参数1和3则像是地址 1234567891011121314151617181920public void hook65540()&#123; &#x2F;&#x2F; 加载HookZz IHookZz hookZz &#x3D; HookZz.getInstance(emulator); hookZz.wrap(module.base + 0x65540 + 1, new WrapCallback&lt;HookZzArm32RegisterContext&gt;() &#123; &#x2F;&#x2F; inline wrap导出函数 @Override &#x2F;&#x2F; 类似于 frida onEnter public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) &#123; &#x2F;&#x2F; 类似于Frida args[0] Inspector.inspect(ctx.getR0Pointer().getByteArray(0, 0x10), &quot;Arg1&quot;); System.out.println(ctx.getR1Long()); Inspector.inspect(ctx.getR2Pointer().getByteArray(0, 0x10), &quot;Arg3&quot;); &#125;; @Override &#x2F;&#x2F; 类似于 frida onLeave public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) &#123; &#125; &#125;);&#125; 打印地址所指向的内存，类似frida中的dexdump，第二个参数总是和入参的长度一致，默认作为长度。 第一个参数就是我们传入的onejane,即public static native String sign(String str, byte[] bArr)第二个参数 HookZz在执行前，push保存参数，在后面再pop取出参数，我们观察下参数3 12345678910111213141516171819202122232425public void hook65540()&#123; &#x2F;&#x2F; 加载HookZz IHookZz hookZz &#x3D; HookZz.getInstance(emulator); hookZz.wrap(module.base + 0x65540 + 1, new WrapCallback&lt;HookZzArm32RegisterContext&gt;() &#123; &#x2F;&#x2F; inline wrap导出函数 @Override &#x2F;&#x2F; 类似于 frida onEnter public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) &#123; &#x2F;&#x2F; 类似于Frida args[0] Inspector.inspect(ctx.getR0Pointer().getByteArray(0, 0x10), &quot;Arg1&quot;); System.out.println(ctx.getR1Long()); Inspector.inspect(ctx.getR2Pointer().getByteArray(0, 0x10), &quot;Arg3&quot;); &#x2F;&#x2F; push ctx.push(ctx.getR2Pointer()); &#125;; @Override &#x2F;&#x2F; 类似于 frida onLeave public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) &#123; &#x2F;&#x2F; pop 取出 Pointer output &#x3D; ctx.pop(); Inspector.inspect(output.getByteArray(0, 0x10), &quot;Arg3 after function&quot;); &#125; &#125;);&#125; md5有四个iv，该函数中确实也有四个数值，通过H键转成十六进制，和默认的iv值不一致，说明md5算法被魔改了。 将md5.py中的四个iv改成样本中的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158# codeing&#x3D;utf-8# 引入math模块，因为要用到sin函数import math# 定义常量，用于初始化128位变量，注意字节顺序，文中的A&#x3D;0x01234567，这里低值存放低字节，即01 23 45 67，所以运算时A&#x3D;0x67452301，其他类似。# 这里用字符串的形势，是为了和hex函数的输出统一，hex(10)输出为&#39;0xA&#39;,注意结果为字符串。A &#x3D; &#39;0x67552301&#39; # &#39;0x67452301&#39;B &#x3D; &#39;0xEDCDAB89&#39; # &#39;0xefcdab89&#39;C &#x3D; &#39;0x98BADEFE&#39; # &#39;0x98badcfe&#39;D &#x3D; &#39;0x16325476&#39; # &#39;0x10325476&#39;# 定义每轮中用到的函数。L为循环左移，注意左移之后可能会超过32位，所以要和0xffffffff做与运算，确保结果为32位。F &#x3D; lambda x, y, z: ((x &amp; y) | ((~x) &amp; z))G &#x3D; lambda x, y, z: ((x &amp; z) | (y &amp; (~z)))H &#x3D; lambda x, y, z: (x ^ y ^ z)I &#x3D; lambda x, y, z: (y ^ (x | (~z)))L &#x3D; lambda x, n: (((x &lt;&lt; n) | (x &gt;&gt; (32 - n))) &amp; (0xffffffff))# 定义每轮中循环左移的位数，这里用4个元组表示,用元组是因为速度比列表快。shi_1 &#x3D; (7, 12, 17, 22) * 4shi_2 &#x3D; (5, 9, 14, 20) * 4shi_3 &#x3D; (4, 11, 16, 23) * 4shi_4 &#x3D; (6, 10, 15, 21) * 4# 定义每轮中用到的M[i]次序。m_1 &#x3D; (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)m_2 &#x3D; (1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12)m_3 &#x3D; (5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2)m_4 &#x3D; (0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9)# 定义函数，用来产生常数T[i]，常数有可能超过32位，同样需要&amp;0xffffffff操作。注意返回的是十进制的数。def T(i): result &#x3D; (int(4294967296 * abs(math.sin(i)))) &amp; 0xffffffff return result# 定义函数，用来将列表中的元素循环右移。原因是在每轮操作中，先运算A的值，然后是D，C，B，16轮之后右恢复原来顺序，所以只要每次操作第一个元素即可。def shift(shift_list): shift_list &#x3D; [shift_list[3], shift_list[0], shift_list[1], shift_list[2]] return shift_list# 定义主要的函数，参数为当做种子的列表，每轮用到的F，G，H，I，生成的M[]，以及循环左移的位数。该函数完成一轮运算。def fun(fun_list, f, m, shi): count &#x3D; 0 global Ti_count # 引入全局变量，T(i)是从1到64循环的。 while count &lt; 16: xx &#x3D; int(fun_list[0], 16) + f(int(fun_list[1], 16), int(fun_list[2], 16), int(fun_list[3], 16)) + int(m[count], 16) + T( Ti_count) xx &#x3D; xx &amp; 0xffffffff ll &#x3D; L(xx, shi[count]) # fun_list[0] &#x3D; hex((int(fun_list[1],16) + ll)&amp;(0xffffffff))[:-1] fun_list[0] &#x3D; hex((int(fun_list[1], 16) + ll) &amp; (0xffffffff)) # 最后的[:-1]是为了去除类似&#39;0x12345678L&#39;最后的&#39;L&#39; fun_list &#x3D; shift(fun_list) count +&#x3D; 1 Ti_count +&#x3D; 1 # print (fun_list) return fun_list# 该函数生成每轮需要的M[]，最后的参数是为了当有很多分组时，进行偏移。def genM16(order, ascii_list, f_offset): ii &#x3D; 0 m16 &#x3D; [0] * 16 f_offset &#x3D; f_offset * 64 for i in order: i &#x3D; i * 4 m16[ii] &#x3D; &#39;0x&#39; + &#39;&#39;.join((ascii_list[i + f_offset] + ascii_list[i + 1 + f_offset] + ascii_list[ i + 2 + f_offset] + ascii_list[i + 3 + f_offset]).split(&#39;0x&#39;)) ii +&#x3D; 1 for c in m16: ind &#x3D; m16.index(c) m16[ind] &#x3D; reverse_hex(c) return m16# 翻转十六进制数的顺序：&#39;0x01234567&#39; &#x3D;&gt; &#39;0x67452301&#39;def reverse_hex(hex_str): hex_str &#x3D; hex_str[2:] hex_str_list &#x3D; [] for i in range(0, len(hex_str), 2): hex_str_list.append(hex_str[i:i + 2]) hex_str_list.reverse() hex_str_result &#x3D; &#39;0x&#39; + &#39;&#39;.join(hex_str_list) return hex_str_result# 显示结果函数，将最后运算的结果列表进行翻转，合并成字符串的操作。def show_result(f_list): result &#x3D; &#39;&#39; f_list1 &#x3D; [0] * 4 for i in f_list: f_list1[f_list.index(i)] &#x3D; reverse_hex(i)[2:] result &#x3D; result + f_list1[f_list.index(i)] return result# 程序主循环while True: abcd_list &#x3D; [A, B, C, D] Ti_count &#x3D; 1 # input_m &#x3D; raw_input(&#39;msg&gt;&gt;&gt;&#39;) input_m &#x3D; input(&#39;msg&gt;&gt;&gt;&#39;) # 对每一个输入先添加一个&#39;0x80&#39;，即&#39;10000000&#39; ascii_list &#x3D; list((map(hex, map(ord, input_m)))) # print(&#39;ascii_list:&#39;,ascii_list) msg_lenth &#x3D; len(ascii_list) * 8 ascii_list.append(&#39;0x80&#39;) # 补充0 while (len(ascii_list) * 8 + 64) % 512 !&#x3D; 0: ascii_list.append(&#39;0x00&#39;) # 最后64为存放消息长度，注意长度存放顺序低位在前。 # 例如，消息为&#39;a&#39;，则长度为&#39;0x0800000000000000&#39; msg_lenth_0x &#x3D; hex(msg_lenth)[2:] msg_lenth_0x &#x3D; &#39;0x&#39; + msg_lenth_0x.rjust(16, &#39;0&#39;) msg_lenth_0x_big_order &#x3D; reverse_hex(msg_lenth_0x)[2:] msg_lenth_0x_list &#x3D; [] for i in range(0, len(msg_lenth_0x_big_order), 2): msg_lenth_0x_list.append(&#39;0x&#39; + msg_lenth_0x_big_order[i:i + 2]) ascii_list.extend(msg_lenth_0x_list) # print (ascii_list) # 对每个分组进行4轮运算 for i in range(0, len(ascii_list) &#x2F;&#x2F; 64): # 将最初128位种子存放在变量中， aa, bb, cc, dd &#x3D; abcd_list # 根据顺序产生每轮M[]列表 order_1 &#x3D; genM16(m_1, ascii_list, i) order_2 &#x3D; genM16(m_2, ascii_list, i) order_3 &#x3D; genM16(m_3, ascii_list, i) order_4 &#x3D; genM16(m_4, ascii_list, i) # 主要四轮运算，注意打印结果列表已经被进行过右移操作！ abcd_list &#x3D; fun(abcd_list, F, order_1, shi_1) # print (&#39;--------------------------------------&#39;) abcd_list &#x3D; fun(abcd_list, G, order_2, shi_2) # print (&#39;--------------------------------------&#39;) abcd_list &#x3D; fun(abcd_list, H, order_3, shi_3) # print (&#39;--------------------------------------&#39;) abcd_list &#x3D; fun(abcd_list, I, order_4, shi_4) # print (&#39;--------------------------------------&#39;) # 将最后输出与最初128位种子相加，注意，最初种子不能直接使用abcd_list[0]等，因为abcd_list已经被改变 output_a &#x3D; hex((int(abcd_list[0], 16) + int(aa, 16)) &amp; 0xffffffff) output_b &#x3D; hex((int(abcd_list[1], 16) + int(bb, 16)) &amp; 0xffffffff) output_c &#x3D; hex((int(abcd_list[2], 16) + int(cc, 16)) &amp; 0xffffffff) output_d &#x3D; hex((int(abcd_list[3], 16) + int(dd, 16)) &amp; 0xffffffff) # 将输出放到列表中，作为下一次128位种子 abcd_list &#x3D; [output_a, output_b, output_c, output_d] # 将全局变量Ti_count恢复，一遍开始下一个分组的操作。 Ti_count &#x3D; 1 # 最后调用函数，格式化输出 print(&#39;md5&gt;&gt;&gt;&#39; + show_result(abcd_list)) # 0CC175B9C0F1B6A831C399E269772661 break msg&gt;&gt;&gt;onejanemd5&gt;&gt;&gt;abb01439f7c91b4a4aa431a4dee8aba0 返回的结果和unidbg中的Arg3的结果一致，AB B0 14 39 F7 C9 1B 4A 4A A4 31 A4 DE E8 AB A0 ...9...JJ.1.....，因此可以断定，此处魔改确实只魔改了IV的md5算法。 主动调用Unidbg1234567891011121314151617181920212223242526272829public void callMd5()&#123; List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;(10); &#x2F;&#x2F; arg1 String input &#x3D; &quot;onejane&quot;; &#x2F;&#x2F; malloc memory MemoryBlock memoryBlock1 &#x3D; emulator.getMemory().malloc(16, false); &#x2F;&#x2F; get memory pointer UnidbgPointer input_ptr&#x3D;memoryBlock1.getPointer(); &#x2F;&#x2F; write plainText on it input_ptr.write(input.getBytes(StandardCharsets.UTF_8)); &#x2F;&#x2F; arg2 int input_length &#x3D; input.length(); &#x2F;&#x2F; arg3 -- buffer MemoryBlock memoryBlock2 &#x3D; emulator.getMemory().malloc(16, false); UnidbgPointer output_buffer&#x3D;memoryBlock2.getPointer(); &#x2F;&#x2F; 填入参入 list.add(input_ptr); list.add(input_length); list.add(output_buffer); &#x2F;&#x2F; run module.callFunction(emulator, 0x65540 + 1, list.toArray()); &#x2F;&#x2F; print arg3 Inspector.inspect(output_buffer.getByteArray(0, 0x10), &quot;output&quot;);&#125;; Frida1234567891011121314151617181920function call_65540(base_addr)&#123; &#x2F;&#x2F; 函数在内存中的地址 var real_addr &#x3D; base_addr.add(0x65541) var md5_function &#x3D; new NativeFunction(real_addr, &quot;int&quot;, [&quot;pointer&quot;, &quot;int&quot;, &quot;pointer&quot;]) &#x2F;&#x2F; 参数1 明文字符串的指针 var input &#x3D; &quot;onejane&quot;; var arg1 &#x3D; Memory.allocUtf8String(input); &#x2F;&#x2F; 参数2 明文长度 var arg2 &#x3D; input.length; &#x2F;&#x2F; 参数3，存放结果的buffer var arg3 &#x3D; Memory.alloc(16); md5_function(arg1, arg2, arg3); console.log(hexdump(arg3,&#123;length:0x10&#125;));&#125; function callMd5()&#123; &#x2F;&#x2F; 确定SO 的基地址 var base_addr &#x3D; Module.findBaseAddress(&quot;libnet_crypto.so&quot;); call_65540(base_addr);&#125; 总结本文针对最右app的sign进行抽丝剥茧的分析，利用Frida的Hook及RPC主动调用，Xposed函数调用，Unidbg补环境模拟执行so等手段实现so逆向分析，最终得出核心算法通过魔改md5实现算法还原。 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"unidbg","slug":"unidbg","permalink":"http://onejane.github.io/tags/unidbg/"},{"name":"ida","slug":"ida","permalink":"http://onejane.github.io/tags/ida/"}]},{"title":"SO逆向之微博国际版登陆分析","slug":"SO逆向之微博国际版登陆分析","date":"2021-11-09T11:53:46.000Z","updated":"2022-02-05T08:13:06.631Z","comments":true,"path":"2021/11/09/SO逆向之微博国际版登陆分析/","link":"","permalink":"http://onejane.github.io/2021/11/09/SO%E9%80%86%E5%90%91%E4%B9%8B%E5%BE%AE%E5%8D%9A%E5%9B%BD%E9%99%85%E7%89%88%E7%99%BB%E9%99%86%E5%88%86%E6%9E%90/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 抓包Charles本地证书 系统证书目录：/system/etc/security/cacerts/ 其中的每个证书的命名规则如下： . 文件名是一个Hash值，而后缀是一个数字。 文件名可以用下面的命令计算出来： openssl x509 -subject_hash_old -in 后缀名的数字是为了防止文件名冲突的，比如如果两个证书算出的Hash值是一样的话，那么一个证书的后缀名数字可以设置成0，而另一个证书的后缀名数字可以设置成1 安卓8 1234567cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o remount,rw &#x2F;mount -o remount,rw &#x2F;systemchmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o remount,ro &#x2F;mount -o remount,ro &#x2F;system 安卓7 1234567cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o rw,remount &#x2F;systemmount -o rw,remount &#x2F;chmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o ro,remount &#x2F;systemmount -o ro,remount &#x2F; 安卓10 Move_Certificates-v1.9 直接面具插件安排，重启即可 重启 ssl pinning xposed+justTrustMe.apk破解ssl pinning 抓包登录http://api.weibo.cn/2/account/login，账户密码为188888888/123456 参数 值 c weicoabroad i 3655223 s 7c5edcf8 u 188888888 p bFbQbLlD4PMcp8gOTSxh3NFS4g2VJIh5Vw6k62wAq49BLlQaeeVDAYBL4iqwY7AHup8LZRGrfHsf+/zP246oBg+LV3UqK+3IpZ6qP654NkEUH/YNzg+JP8WbMmxTE4mZsddMReBquawLm1WwN86m7WRiVO0GBxznHvyK/h5uhmk= getuser 1 getoauth 1 getcookie 1 lang zh_CN_#Hans 分析微博1.7.1.apk，多次抓包发现除了p其他值都不变，p看起来像是RSA加密，目标参数i和s 12.&#x2F;fs1280arm64frida -U com.weico.international -l hookEvent.js 事件hook，点击登录后触发点击事件 12android hooking watch class com.weico.international.activity.SinaLoginMainActivity --dump-args --dump-backtrace --dump-return 对该类进行hook，重新点击登录android hooking watch class_method com.weico.international.activity.SinaLoginMainActivity.refreshSinaToken --dump-args --dump-backtrace --dump-return 对refreshSinaToken进行hook 打开jadx查看refreshSinaToken 1234567891011121314151617181920private static void refreshSinaToken(String userName, String password, String sValue, String cpt, String cptcode, WeicoCallbackString callback) &#123; Object iValue &#x3D; WeiboSecurityUtils.getIValue(WApplication.cContext); Map&lt;String, Object&gt; maps &#x3D; new LinkedHashMap&lt;&gt;(); maps.put(SinaRetrofitAPI.ParamsKey.c, KeyUtil.WEICO_C_VALUE); maps.put(SinaRetrofitAPI.ParamsKey.i, iValue); maps.put(SinaRetrofitAPI.ParamsKey.s, sValue); maps.put(&quot;u&quot;, userName); maps.put(&quot;p&quot;, password); maps.put(&quot;getuser&quot;, 1); maps.put(&quot;getoauth&quot;, 1); maps.put(&quot;getcookie&quot;, 1); maps.put(&quot;lang&quot;, Utils.getLocalLanguage()); if (!TextUtils.isEmpty(cpt)) &#123; maps.put(&quot;cpt&quot;, cpt); &#125; if (!TextUtils.isEmpty(cptcode)) &#123; maps.put(&quot;cptcode&quot;, cptcode); &#125; SinaRetrofitAPI.getWeiboSinaService().login(maps, callback);&#125; 以上说明在调用refreshSinaToken时加密参数有password，sValue。userName为登录名，cpt为none，cptcode为none。对应请求参数中u对应userName，c=weicoabroad，i=WeiboSecurityUtils.getIValue(WApplication.cContext)，getuser=getoauth=getcookie=1，lang=zh_CN_#Hans，p=password，s=sValue。 在doLogin中调用了refreshSinaToken，同时也生成了password和sValue的值。 1234567891011121314151617181920212223242526272829303132333435private void doLogin(String cpt, String cptcode) &#123; this.loadingDialog &#x3D; new EasyDialog.Builder(this.me).progress(true, 0).canceledOnTouchOutside(false).progressColor(Res.getColor(R.color.card_content_text)).show(); final String userName &#x3D; this.loginNameEditText.getText().toString(); String password &#x3D; this.loginPasswordEditText.getText().toString(); final String psd &#x3D; WeicoSecurityUtils.securityPsd(password); try &#123; String decode &#x3D; WeicoSecurityUtils.decode(KeyUtil.WEICO_PIN); LogUtil.d(&quot;decode &quot; + decode + decode.equals(&quot;CypCHG2kSlRkdvr2RG1QF8b2lCWXl7k7&quot;)); final String sValue &#x3D; WeiboSecurityUtils.calculateSInJava(getApplicationContext(), userName + password, decode); refreshSinaToken(userName, psd, sValue, cpt, cptcode, new WeicoCallbackString() &#123; &#x2F;* class com.weico.international.activity.SinaLoginMainActivity.AnonymousClass10 *&#x2F; @Override &#x2F;&#x2F; com.weibo.sdk.android.api.WeicoCallbackString public void onSuccess(String str, Object bak) &#123; try &#123; SinaLoginMainActivity.this.loadingDialog.dismiss(); SinaLoginMainActivity.this.parseAccount(SinaLoginMainActivity.this.checkLoginResponseForWeibo(str), userName, psd, sValue); &#125; catch (Exception e) &#123; SinaLoginMainActivity.this.weibofail(); UIManager.showSystemToast(e.getMessage()); &#125; &#125; @Override &#x2F;&#x2F; com.weibo.sdk.android.api.WeicoCallbackString public void onFail(Exception e, Object bak) &#123; LogUtil.e(e); SinaLoginMainActivity.this.loadingDialog.dismiss(); SinaLoginMainActivity.this.weibofail(); UIManager.showSystemToast((int) R.string.Login_failed); &#125; &#125;); &#125; catch (Exception e) &#123; UIManager.showSystemToast((int) R.string.process_fail); &#125;&#125; password在WeicoSecurityUtils.securityPsd(password)中将代码拷出来配合android.util.Base64即可完成加密拿到password。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class WeiboSecurityUtils &#123; &#x2F;&#x2F; password private static final String KEY_ALGORITHM &#x3D; &quot;RSA&quot;; private static final String KEY_CIPHER_ALGORITHM &#x3D; &quot;RSA&#x2F;ECB&#x2F;PKCS1Padding&quot;; private static final int MAX_DECRYPT_BLOCK &#x3D; 128; private static final int MAX_ENCRYPT_BLOCK &#x3D; 117; private static String publicKeyInner &#x3D; &quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDWcQcgj60fU8fFev9RlvFPg0GcRgHyGFTN9ytE\\nLujvfCwGt7n54Q9+k1rDDo+sRQeYdTwA7ZMS8n1RHjZATgmHw9rBBzk&#x2F;cHXAVIgrJrZ5txDdW1i4\\n8ZxEarcdSrmlk9ZFSsvGXE8&#x2F;0fZYHM0mr4WaIh2y9E0CNkd0rU9VKAR9RQIDAQAB&quot;; private static final String publicKeyString &#x3D; &quot;iMxVDGf9f5Z3P3NsFac7tM7SC6DZDJY+H&#x2F;vXc+xv3HlT2E&#x2F;LUzWf5fct2P0VauekLzNAaNsH93SZ\\n2Z3jUc&#x2F;0x81FLThPwI8cexCuRT7P1bdnmcwhjZmW3Lc1FCu2K6iBuVQ9I51TR9eTU2lNcq4AW8WV\\nEWtwIj6EpLFzQ3qOm3AY4UNgcGrNYYBbF+SiUkchdXbxYRBNFkguDiayaJzMC&#x2F;5WmTrEnQ0xXwmy\\nA2lWpZ6+sUlyDRU&#x2F;HvPh5Oto0xpuLc6bIjfl0b+PSjxh5e&#x2F;7&#x2F;4jXoYoUfdm3r2FtPKJtQ2NeKnsp\\nOCdk6HNULtk5WSnkBKjufQqoZblvdrEiixnogQ&quot;; public static final String WEICO_PIN &#x3D; &quot;Fp1vyiH7EkHmHl6ixX9RmVYy5ynZDnmDZZgp7s7vNq2wfV5aLrM4dPCQiI6jboMS4zu19F66OucE\\n9HTRWsC9ksQxuhhsBeBUWJTNeojX076C9gmOGESKJczQPFx1RxJfUfTGeGYAvoTSExo1wVa98v3z\\nE5gl&#x2F;uaAdduDI59yOZI&quot;; final static BASE64Encoder encoder &#x3D; new BASE64Encoder(); final static BASE64Decoder decoder &#x3D; new BASE64Decoder(); public static String securityPsd(String password) &#123; try &#123; return new String(Base64.encode(encryptByPublicKey(password.getBytes(), decode(publicKeyString)), 2)); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; private static byte[] encryptByPublicKey(byte[] data, String publicKey) throws Exception &#123; byte[] cache; PublicKey publicK &#x3D; KeyFactory.getInstance(KEY_ALGORITHM).generatePublic(new X509EncodedKeySpec(Base64.decode(publicKey.getBytes(), 2))); Cipher cipher &#x3D; Cipher.getInstance(KEY_CIPHER_ALGORITHM); cipher.init(1, publicK); int inputLen &#x3D; data.length; ByteArrayOutputStream out &#x3D; new ByteArrayOutputStream(); int offSet &#x3D; 0; int i &#x3D; 0; while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) &#123; cache &#x3D; cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK); &#125; else &#123; cache &#x3D; cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet &#x3D; i * MAX_ENCRYPT_BLOCK; &#125; byte[] encryptedData &#x3D; out.toByteArray(); out.close(); return encryptedData; &#125; public static String decode(String encryptedStr) throws Exception &#123; return new String(decryptByPublicKey(Base64.decode(encryptedStr, 1), publicKeyInner)); &#125; public static byte[] decryptByPublicKey(byte[] encryptedData, String publicKey) throws Exception &#123; byte[] cache; Key publicK &#x3D; KeyFactory.getInstance(KEY_ALGORITHM).generatePublic(new X509EncodedKeySpec(Base64.decode(publicKey, 1))); Cipher cipher &#x3D; Cipher.getInstance(KEY_CIPHER_ALGORITHM); cipher.init(2, publicK); int inputLen &#x3D; encryptedData.length; ByteArrayOutputStream out &#x3D; new ByteArrayOutputStream(); int offSet &#x3D; 0; int i &#x3D; 0; while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; 128) &#123; cache &#x3D; cipher.doFinal(encryptedData, offSet, 128); &#125; else &#123; cache &#x3D; cipher.doFinal(encryptedData, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet &#x3D; i * 128; &#125; byte[] decryptedData &#x3D; out.toByteArray(); out.close(); return decryptedData; &#125;&#125; sValue跟进final String sValue = WeiboSecurityUtils.calculateSInJava(getApplicationContext(), userName + password, decode);参数分别为context，账户+密码，decode = WeicoSecurityUtils.decode(KeyUtil.WEICO_PIN)，直接用上面扣出的加解密逻辑即可。 123456789101112131415public static String calculateSInJava(Context context, String srcArray, String pin) &#123; String str; synchronized (mCalculateSLock) &#123; if (srcArray.equals(sSeed) &amp;&amp; !TextUtils.isEmpty(sValue)) &#123; str &#x3D; sValue; &#125; else if (context !&#x3D; null) &#123; sSeed &#x3D; srcArray; sValue &#x3D; getInstance().calculateS(context.getApplicationContext(), srcArray, pin); str &#x3D; sValue; &#125; else &#123; str &#x3D; &quot;&quot;; &#125; &#125; return str;&#125; 跟进getInstance().calculateS 1234static &#123; System.loadLibrary(&quot;utility&quot;);&#125;public native String calculateS(Context context, String str, String str2); 可以知道该方法定义在了libutility.so中，引出今天的分析so，该方法中参数一是Context上下文，参数二是传入的明文，参数三是固定的值，返回值是8位的Sign，且输入不变的情况下，输出也固定不变。 静态绑定，F5查看C伪代码，y设置type为JNIEnv* 12345678910111213141516171819202122232425262728293031323334353637383940414243if ( sub_1C60(a1, a3) )&#123; if ( (*a1)-&gt;PushLocalFrame(a1, 16) &gt;&#x3D; 0 ) &#123; v6 &#x3D; (*a1)-&gt;GetStringUTFChars(a1, a5, 0); v18 &#x3D; (char *)(*a1)-&gt;GetStringUTFChars(a1, a4, 0); v7 &#x3D; j_strlen(v18); v8 &#x3D; v7 + j_strlen(v6) + 1; v9 &#x3D; j_malloc(v8); j_memset(v9, 0, v8); j_strcpy((char *)v9, v18); j_strcat((char *)v9, v6); v10 &#x3D; (_BYTE *)MDStringOld(v9); v11 &#x3D; (char *)j_malloc(9u); *v11 &#x3D; v10[1]; v11[1] &#x3D; v10[5]; v11[2] &#x3D; v10[2]; v11[3] &#x3D; v10[10]; v11[4] &#x3D; v10[17]; v11[5] &#x3D; v10[9]; v11[6] &#x3D; v10[25]; v12 &#x3D; v10[27]; v11[8] &#x3D; 0; v11[7] &#x3D; v12; v21 &#x3D; (*a1)-&gt;FindClass(a1, &quot;java&#x2F;lang&#x2F;String&quot;); v22 &#x3D; (*a1)-&gt;GetMethodID(a1, v21, &quot;&lt;init&gt;&quot;, &quot;([BLjava&#x2F;lang&#x2F;String;)V&quot;); v13 &#x3D; j_strlen(v11); v19 &#x3D; (*a1)-&gt;NewByteArray(a1, v13); v14 &#x3D; j_strlen(v11); (*a1)-&gt;SetByteArrayRegion(a1, v19, 0, v14, v11); v15 &#x3D; (*a1)-&gt;NewStringUTF(a1, &quot;utf-8&quot;); v16 &#x3D; (*a1)-&gt;NewObject(a1, v21, v22, v19, v15); j_free(v11); j_free(v9); (*a1)-&gt;ReleaseStringUTFChars(a1, (jstring)a4, v18); a4 &#x3D; (int)(*a1)-&gt;PopLocalFrame(a1, v16); &#125; else &#123; a4 &#x3D; 0; &#125;&#125;return a4; sub_1C60如果返回0，直接返回0，挂了，想必整个if逻辑才是实现加密的流程。 Unidbg搭建Unidbg框架，不过没有JNI OnLoad 1234567891011121314151617181920212223242526272829public class sina extends AbstractJni&#123; private final AndroidEmulator emulator; private final VM vm; private final Module module; sina() &#123; &#x2F;&#x2F; 创建模拟器实例,进程名建议依照实际进程名填写，可以规避针对进程名的校验 emulator &#x3D; AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;com.sina.International&quot;).build(); &#x2F;&#x2F; 获取模拟器的内存操作接口 final Memory memory &#x3D; emulator.getMemory(); &#x2F;&#x2F; 设置系统类库解析 memory.setLibraryResolver(new AndroidResolver(23)); &#x2F;&#x2F; 创建Android虚拟机,传入APK，Unidbg可以替我们做部分签名校验的工作 vm &#x3D; emulator.createDalvikVM(new File(&quot;sinaInternational.apk&quot;)); &#x2F;&#x2F; 加载目标SO DalvikModule dm &#x3D; vm.loadLibrary(new File(&quot;libutility.so&quot;), true); &#x2F;&#x2F; 加载so到虚拟内存 &#x2F;&#x2F;获取本SO模块的句柄,后续需要用它 module &#x3D; dm.getModule(); vm.setJni(this); &#x2F;&#x2F; 设置JNI vm.setVerbose(true); &#x2F;&#x2F; 打印日志 &#x2F;&#x2F; 样本连JNI OnLoad都没有 &#x2F;&#x2F; dm.callJNI_OnLoad(emulator); &#x2F;&#x2F; 调用JNI OnLoad &#125;; public static void main(String[] args) &#123; sina test &#x3D; new sina(); &#125;&#125; alt+g 查看修改当前指令模式，1是Thumb，0是Arm模式，Thumb 指令看作ARM指令压缩形式的子集，添加一个calculateS函数，依然是地址方式调用，ARM32有Thumb和ARM两种指令模式，此处是thumb模式，所以hook的时候地址要在start基础上+1。 ARM模式指令总是4字节长度，Thumb指令长度多数为2字节，少部分指令是4字节。右键查看Text view，IDA-Options-General 指令大多为两个字节长度，那就是Thumb 除了基本类型，比如int，long等，其他的对象类型一律要手动 addLocalObject。 1234567891011121314151617public String calculateS() throws Exception &#123; List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;(10); list.add(vm.getJNIEnv()); &#x2F;&#x2F; 第一个参数是env list.add(0); &#x2F;&#x2F; 第二个参数，实例方法是jobject，静态方法是jclazz，直接填0，一般用不到。 DvmObject&lt;?&gt; context &#x3D; vm.resolveClass(&quot;android&#x2F;content&#x2F;Context&quot;).newObject(null);&#x2F;&#x2F; context list.add(vm.addLocalObject(context)); list.add(vm.addLocalObject(new StringObject(vm, &quot;188888888123456&quot;))); list.add(vm.addLocalObject(new StringObject(vm, WeiboSecurityUtils.decode(WeiboSecurityUtils.WEICO_PIN)))); Number number &#x3D; module.callFunction(emulator, 0x1E7C + 1, list.toArray())[0]; String result &#x3D; vm.getObject(number.intValue()).getValue().toString(); return result;&#125;public static void main(String[] args) &#123; sina test &#x3D; new sina(); System.out.println(test.calculateS());&#125; 运行报错如下，显示的报错所处地址0x2c8d g跳转到0x2c8d，F5查看C伪代码，将a1使用快捷键y转成JNI Env，所属函数jbyte *__fastcall sub_2C3C(JNIEnv *a1, int a2) 这地方出现Signature一定是签名校验了 x交叉引用 进入第一条后发现之前的函数sub_1C60，该函数一旦返回0，直接gg，校验成功返回1，继续x交叉引用 跳转到了一开始的函数Java_com_sina_weibo_security_WeiboSecurityUtils_calculateS Tab查看Text View，sub_1C60地址为FF F7 EB FE ARM参数传递规则 r0:参数1，返回时作为返回值1用，通用寄存器1 r1:参数2，返回值，通用寄存器2 r2:参数3，通用寄存器 r3:参数4，通用寄存器 r4 ~ r8:变量寄存器1，2，3，4，5 r9:平台寄存器，该寄存器的意义由平台标准定义 r10,r11:变量寄存器 r12:内部过程调用寄存器 r13:栈寄存器SP r14:link寄存器 r15:PC 我们可以通过mov r0,1实现不执行这个函数，并给出正确的返回值。且这个函数并没有产生一些之后需要使用的值或者中间变量，所以这让我们不需要管别的寄存器。 arm转hex，可以讲hex和arm互相转换 将sub_1C60地址FF F7 EB FE改为4F F0 01 00，我们可以调用Unicorn对虚拟内存进行patch，Thumb的+1只在运行和Hook时需要考虑，patch不用。 12345678910public void patchVerify()&#123; int patchCode &#x3D; 0x4FF00100; emulator.getMemory().pointer(module.base + 0x1E86).setInt(0,patchCode);&#125;public static void main(String[] args) &#123; sina test &#x3D; new sina(); test.patchVerify(); System.out.println(test.calculateS()); &#x2F;&#x2F; 7c5edcf8&#125; 当需要动态patch的时候就不能以来网站转换arm来拿到hex了，可以使用Unidbg给我们封装的Patch方法。找到FF F7 EB FE，再用Keystone 把patch代码”mov r0,1”转成机器码，填进去，校验一下长度是否相等即可。 1234567891011121314151617public void patchVerifyS()&#123; &#x2F;&#x2F; 0x1E86为sub_1C60的地址 Pointer pointer &#x3D; UnidbgPointer.pointer(emulator, module.base + 0x1E86); assert pointer !&#x3D; null; byte[] code &#x3D; pointer.getByteArray(0, 4); if (!Arrays.equals(code, new byte[]&#123; (byte)0xFF, (byte) 0xF7, (byte) 0xEB, (byte) 0xFE &#125;)) &#123; &#x2F;&#x2F; FF F7 EB FE BL sub_1C60 throw new IllegalStateException(Inspector.inspectString(code, &quot;patch32 code&#x3D;&quot; + Arrays.toString(code))); &#125; try (Keystone keystone &#x3D; new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb)) &#123; KeystoneEncoded encoded &#x3D; keystone.assemble(&quot;mov r0,1&quot;); byte[] patch &#x3D; encoded.getMachineCode(); if (patch.length !&#x3D; code.length) &#123; throw new IllegalStateException(Inspector.inspectString(patch, &quot;patch32 length&#x3D;&quot; + patch.length)); &#125; pointer.write(0, patch, 0, patch.length); &#125;&#125; 根据伪C代码分析，利用Unidbg实现算法，将text和key拼接起来，然后放到MDStringOld函数中，出来的结果，从中分别抽出第1，5，2，10，17，9，25，27位就是结果了。 双击进入MDStringOld,tab进入Text View，hook地址为0x1BD0+1 Unidbg内嵌了多种Hook工具，目前主要是四种，Dobby，HookZz，xHook，Whale xHook 是爱奇艺开源的基于PLT HOOK的Hook框架，它无法Hook不在符号表里的函数，也不支持inline hook，这在我们的逆向分析中是无法忍受的，所以在这里不去理会它。 Whale 在Unidbg的测试用例中只有对符号表函数的Hook，没看到Inline Hook 或者 非导出函数的Hook，所以也不去考虑。 HookZz是Dobby的前身，两者都可以Hook 非导出表中的函数，即IDA中显示为sub_xxx的函数，也都可以进行inline hook，所以二选一就行了。我喜欢HookZz这个名字，所以就HookZz了。使用HookZz hook MDStringOld函数，MDStringOld是导出函数，可以传入符号名，解析地址，但管他什么findsymbol，findExport呢，我就认准地址，地址，yyds。 123456789101112131415161718192021222324252627public void HookMDStringold()&#123; &#x2F;&#x2F; 加载HookZz IHookZz hookZz &#x3D; HookZz.getInstance(emulator); hookZz.wrap(module.base + 0x1BD0 + 1, new WrapCallback&lt;HookZzArm32RegisterContext&gt;() &#123; &#x2F;&#x2F; inline wrap导出函数 @Override &#x2F;&#x2F; 类似于 frida onEnter public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) &#123; &#x2F;&#x2F; 类似于Frida args[0] Pointer input &#x3D; ctx.getPointerArg(0); System.out.println(&quot;input:&quot; + input.getString(0)); &#125;; @Override &#x2F;&#x2F; 类似于 frida onLeave public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) &#123; Pointer result &#x3D; ctx.getPointerArg(0); System.out.println(&quot;input:&quot; + result.getString(0)); &#125; &#125;);&#125;public static void main(String[] args) &#123; sina test &#x3D; new sina(); test.patchVerify1(); test.HookMDStringold(); System.out.println(test.calculateS());&#125; Frida打印MDStringOld的参数和返回值，其中0x1BD0为MDStringOld起始地址。 123456789101112function hookMDStringOld() &#123; var baseAddr &#x3D; Module.findBaseAddress(&quot;libutility.so&quot;) var MDStringOld &#x3D; baseAddr.add(0x1BD0).add(0x1) Interceptor.attach(MDStringOld, &#123; onEnter: function (args) &#123; console.log(&quot;input:\\n&quot;, hexdump(this.arg0)) &#125;, onLeave: function (retval) &#123; console.log(&quot;result:\\n&quot;, hexdump(retval)) &#125; &#125;)&#125; iValue跟进Object iValue = WeiboSecurityUtils.getIValue(WApplication.cContext); 12345678910111213141516171819public static String getIValue(Context context) &#123; if (!TextUtils.isEmpty(sIValue)) &#123; return sIValue; &#125; String deviceSerial &#x3D; getImei(context); if (TextUtils.isEmpty(deviceSerial)) &#123; deviceSerial &#x3D; getWifiMac(context); &#125; if (TextUtils.isEmpty(deviceSerial)) &#123; deviceSerial &#x3D; &quot;000000000000000&quot;; &#125; if (context &#x3D;&#x3D; null || TextUtils.isEmpty(deviceSerial)) &#123; return &quot;&quot;; &#125; String iValue &#x3D; getInstance().getIValue(context.getApplicationContext(), deviceSerial); sIValue &#x3D; iValue; return iValue;&#125;public native String getIValue(Context context, String str); 以上逻辑中参数deviceSerial通过getWifiMac或者getImei获取，使用Frida主动调用 123456789101112131415161718192021222324function getDeviceSerial()&#123; Java.perform(function()&#123; Java.choose(&quot;com.sina.weibo.security.WeiboSecurityUtils&quot;,&#123; onMatch:function(ins)&#123; &#x2F;&#x2F; 获取context var current_application &#x3D; Java.use(&#39;android.app.ActivityThread&#39;).currentApplication(); var context &#x3D; current_application.getApplicationContext(); &#x2F;&#x2F; 动态方法choose onMatch找到实例进行调用 console.log(&quot;found ins &#x3D;&gt; &quot;,ins); &#x2F;&#x2F; smali或objection看真实方法名 console.log(&quot;imei&quot;,ins.getImei(context)) console.log(&quot;getWifiMac&quot;,ins.getWifiMac(context)) &#125;, onComplete:function()&#123; console.log(&quot;Search completed!&quot;) &#125; &#125;) &#125;)&#125;function main()&#123; console.log(&quot;Start hook&quot;) getDeviceSerial()&#125;setImmediate(main) 拿到了imei作为deviceSerial，IDA中该搜索getIValue，1EF4为起始地址 设置type为JNIEnv* 12345678910111213141516public String calculateI()&#123; List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;(10); list.add(vm.getJNIEnv()); &#x2F;&#x2F; 第一个参数是env list.add(0); &#x2F;&#x2F; 第二个参数，实例方法是jobject，静态方法是jclazz，直接填0，一般用不到。 DvmObject&lt;?&gt; context &#x3D; vm.resolveClass(&quot;android&#x2F;content&#x2F;Context&quot;).newObject(null);&#x2F;&#x2F; context list.add(vm.addLocalObject(context)); &#x2F;&#x2F; imei list.add(vm.addLocalObject(new StringObject(vm, &quot;352530084364850&quot;))); Number number &#x3D; module.callFunction(emulator, 0x1FE4 + 1, list.toArray())[0]; String result &#x3D; vm.getObject(number.intValue()).getValue().toString(); return result;&#125;public static void main(String[] args) throws Exception &#123; sina test &#x3D; new sina(); System.out.println(test.calculateI());&#125; 报错位置在0x2c8d g跳转过去 F5查看源码在方法jbyte *__fastcall sub_2C3C(JNIEnv *a1, int a2)中，x交叉引用 看到熟悉的sub_1C60，继续x交叉引用，找到getIValue中的sub_1C60 ​ tab进入汇编模式.text:00001FFE FF F7 2F FE BL sub_1C60，降sub_1C60改为1即可， 123456789101112131415161718public void patchVerifyI()&#123; &#x2F;&#x2F; Java_com_sina_weibo_security_WeiboSecurityUtils_getIValue中的sub_1C60 &#x2F;&#x2F; 00001FFE FF F7 2F FE BL sub_1C60 Pointer pointer &#x3D; UnidbgPointer.pointer(emulator, module.base + 0x1FFE); assert pointer !&#x3D; null; byte[] code &#x3D; pointer.getByteArray(0, 4); if (!Arrays.equals(code, new byte[]&#123; (byte)0xFF, (byte) 0xF7, (byte) 0x2F, (byte) 0xFE &#125;)) &#123; throw new IllegalStateException(Inspector.inspectString(code, &quot;patch32 code&#x3D;&quot; + Arrays.toString(code))); &#125; try (Keystone keystone &#x3D; new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb)) &#123; KeystoneEncoded encoded &#x3D; keystone.assemble(&quot;mov r0,1&quot;); byte[] patch &#x3D; encoded.getMachineCode(); if (patch.length !&#x3D; code.length) &#123; throw new IllegalStateException(Inspector.inspectString(patch, &quot;patch32 length&#x3D;&quot; + patch.length)); &#125; pointer.write(0, patch, 0, patch.length); &#125;&#125; 接下来双击dword_7068找到地址00007068，修改为0x0 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void patchVerifyI()&#123; &#x2F;&#x2F; Java_com_sina_weibo_security_WeiboSecurityUtils_getIValue中的sub_1C60 &#x2F;&#x2F; 00001FFE FF F7 2F FE BL sub_1C60 Pointer pointer &#x3D; UnidbgPointer.pointer(emulator, module.base + 0x1FFE); assert pointer !&#x3D; null; byte[] code &#x3D; pointer.getByteArray(0, 4); if (!Arrays.equals(code, new byte[]&#123; (byte)0xFF, (byte) 0xF7, (byte) 0x2F, (byte) 0xFE &#125;)) &#123; throw new IllegalStateException(Inspector.inspectString(code, &quot;patch32 code&#x3D;&quot; + Arrays.toString(code))); &#125; try (Keystone keystone &#x3D; new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb)) &#123; KeystoneEncoded encoded &#x3D; keystone.assemble(&quot;mov r0,1&quot;); byte[] patch &#x3D; encoded.getMachineCode(); if (patch.length !&#x3D; code.length) &#123; throw new IllegalStateException(Inspector.inspectString(patch, &quot;patch32 length&#x3D;&quot; + patch.length)); &#125; pointer.write(0, patch, 0, patch.length); &#125; UnidbgPointer basePoint &#x3D; new UnidbgPointer(emulator,(module.base)+0x7068,4); int[] javmarr &#x3D; &#123;(int)(0x0)&#125;; basePoint.write(0,javmarr,0,1);&#125;public static void main(String[] args) throws Exception &#123; Map&lt;String, Object&gt; param &#x3D; new HashMap&lt;&gt;(); sina test &#x3D; new sina(); test.patchVerifyI(); test.HookMDStringold(); test.patchVerifyS(); param.put(&quot;c&quot;, &quot;weicoabroad&quot;); param.put(&quot;i&quot;, test.calculateI()); param.put(&quot;s&quot;, test.calculateS()); param.put(&quot;u&quot;, &quot;188888888&quot;); param.put(&quot;p&quot;, WeiboSecurityUtils.securityPsd(&quot;123456&quot;)); param.put(&quot;getuser&quot;, &quot;1&quot;); param.put(&quot;getoauth&quot;, &quot;1&quot;); param.put(&quot;getcookie&quot;, &quot;1&quot;); param.put(&quot;lang&quot;, &quot;zh_CN_#Hans&quot;); for (Map.Entry&lt;String, Object&gt; entry : param.entrySet()) &#123; System.out.println(entry.getKey() + &quot;---&gt;&quot; + entry.getValue()); &#125; String result &#x3D; HttpUtils.postRequest(&quot;http:&#x2F;&#x2F;api.weibo.cn&#x2F;2&#x2F;account&#x2F;login&quot;, param); System.out.println(result);&#125; 总结本次案例中使用xposed破解ssl pinning反抓包，结合objection，frida和unidbg针对so层修改opcode，完成参数的逆向分析和主动调用。 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"unidbg","slug":"unidbg","permalink":"http://onejane.github.io/tags/unidbg/"},{"name":"ida","slug":"ida","permalink":"http://onejane.github.io/tags/ida/"}]},{"title":"SO逆向之Unidbg模拟执行入门","slug":"SO逆向之Unidbg模拟执行入门","date":"2021-11-03T08:13:41.000Z","updated":"2021-12-12T03:09:39.277Z","comments":true,"path":"2021/11/03/SO逆向之Unidbg模拟执行入门/","link":"","permalink":"http://onejane.github.io/2021/11/03/SO%E9%80%86%E5%90%91%E4%B9%8BUnidbg%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C%E5%85%A5%E9%97%A8/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 抓包Charles本地证书安卓8 12345cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o remount,rw &#x2F;chmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o remount,ro &#x2F; 安卓7 12345cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o rw,remount &#x2F;systemchmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o ro,remount &#x2F;system ssl pinning xposed+justTrustMe.apk破解ssl pinning 绿洲3.5.8com.weibo.xvideo.NativeApi.s分析根据白龙大佬的博客，绿洲app脱壳后拿到target.dex 该函数位于 oasiscore即liboasiscore.so中，ida打开该so，搜索不到函数，说明非静态绑定，因为静态绑定的函数需要以固定格式明明。该目标方法是以动态绑定的方式，所以需要先找到so中动态绑定目标的地址，才能定位目标方法的实现。 native方法动态绑定的实现都放在JNI_OnLoad方法中，首先定位到JNI_OnLoad方法，再去找动态绑定的实现，搜索JNI进入后F5反会汇编发现已经被OLLVM混淆的亲妈都不认识了 通常使用hook_RegisterNatives获取动态绑定的地址，本文使用Unidbg方法，项目中的src/test/java/com/bytedance/frameworks/core/encrypt路径中有一个TTEncrypt测试用例，直接执行其中的main方法，说明项目导入成功。 Unidbg搭建模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.array.ByteArray;import com.github.unidbg.memory.Memory;import java.io.File;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;&#x2F;&#x2F; 继承AbstractJni类public class LvZhou extends AbstractJni&#123; private final AndroidEmulator emulator; private final VM vm; private final Module module; LvZhou() &#123; &#x2F;&#x2F; 创建模拟器实例,进程名建议依照实际进程名填写，可以规避针对进程名的校验 emulator &#x3D; AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;com.sina.oasis&quot;).build(); &#x2F;&#x2F; 获取模拟器的内存操作接口 final Memory memory &#x3D; emulator.getMemory(); &#x2F;&#x2F; 设置系统类库解析 memory.setLibraryResolver(new AndroidResolver(23)); &#x2F;&#x2F; 创建Android虚拟机,传入APK，Unidbg可以替我们做部分签名校验的工作 vm &#x3D; emulator.createDalvikVM(new File(&quot;unidbg-android\\\\src\\\\test\\\\resources\\\\demo\\\\lvzhou\\\\lvzhou.apk&quot;)); &#x2F;&#x2F; 加载目标SO DalvikModule dm &#x3D; vm.loadLibrary(new File(&quot;unidbg-android\\\\src\\\\test\\\\resources\\\\demo\\\\lvzhou\\\\liboasiscore.so&quot;), true); &#x2F;&#x2F; 加载so到虚拟内存 &#x2F;&#x2F;获取本SO模块的句柄,后续需要用它 module &#x3D; dm.getModule(); vm.setJni(this); &#x2F;&#x2F; 设置JNI vm.setVerbose(true); &#x2F;&#x2F; 打印日志 dm.callJNI_OnLoad(emulator); &#x2F;&#x2F; 调用JNI OnLoad &#125;; public static void main(String[] args) &#123; LvZhou test &#x3D; new LvZhou(); &#125;&#125; 运行LvZhou.main后打印log中发现JNI OnLoad中主要做了签名校验和动态绑定。在emulator.createDalvikVM不传入apk时填入null，样本在JNI OnLoad中所做的签名校验，就需要我们手动补环境校验了。 Unidbg封装了相关方法执行JNI函数以及有符号函数等，但需要区分类方法和实例方法 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123; LvZhou test &#x3D; new LvZhou(); System.out.println(&quot;Native方法返回值：&quot; + test.call_native_s());&#125;&#x2F;** * public final native String s(@NotNull byte[] bArr, boolean z) * 字节数组需要裹上unidbg的包装类，并加到本地变量里 * @return *&#x2F;public String call_native_s()&#123; &#x2F;&#x2F; 构造jni方法的参数 List&lt;Object&gt; arg_list &#x3D; new ArrayList&lt;&gt;(10); &#x2F;&#x2F; 参数1：JNIEnv *env arg_list.add(vm.getJNIEnv()); &#x2F;&#x2F; 参数2：jobject或jclass 一般用不到,直接填0即可 arg_list.add(0); &#x2F;&#x2F; 参数3：bytes String input &#x3D; &quot;aid&#x3D;01A-khBWIm48A079Pz_DMW6PyZR8&quot; + &quot;uyTumcCNm4e8awxyC2ANU.&amp;cfrom&#x3D;28B529501&quot; + &quot;0&amp;cuid&#x3D;5999578300&amp;noncestr&#x3D;46274W9279Hr1&quot; + &quot;X49A5X058z7ZVz024&amp;platform&#x3D;ANDROID&amp;timestamp&quot; + &quot;&#x3D;1621437643609&amp;ua&#x3D;Xiaomi-MIX2S__oasis__3.5.8_&quot; + &quot;_Android__Android10&amp;version&#x3D;3.5.8&amp;vid&#x3D;10190135&quot; + &quot;94003&amp;wm&#x3D;20004_90024&quot;; byte[] input_bytes &#x3D; input.getBytes(StandardCharsets.UTF_8); ByteArray input_byte_array &#x3D; new ByteArray(vm,input_bytes); arg_list.add(vm.addLocalObject(input_byte_array)); &#x2F;&#x2F; 参数4：boolean false 填入0 arg_list.add(0); &#x2F;&#x2F; 参数准备完毕 调用目标方法 Number number &#x3D; module.callFunction(emulator,0xc365,arg_list.toArray())[0]; return vm.getObject(number.intValue()).getValue().toString();&#125; 运行测试 ExAndroidNativeEmu1234git clone git@github.com:maiyao1988&#x2F;ExAndroidNativeEmu.gitset https_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080set http_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080pip install -r requirements.txt lvzhou.py 12345678910111213141516171819202122232425262728import posixpathfrom androidemu.emulator import Emulator, loggerfrom androidemu.java.classes.string import String# Initialize emulatoremulator &#x3D; Emulator( vfp_inst_set&#x3D;True, vfs_root&#x3D;posixpath.join(posixpath.dirname(__file__), &quot;vfs&quot;))# 加载SOlib_module &#x3D; emulator.load_library(&quot;lib\\\\liboasiscore.so&quot;)# find My modulefor module in emulator.modules: if &quot;liboasiscore&quot; in module.filename: base_address &#x3D; module.base logger.info(&quot;base_address&#x3D;&gt; 0x%08x - %s&quot; % (module.base, module.filename)) break# run jni onloademulator.call_symbol(lib_module, &#39;JNI_OnLoad&#39;, emulator.java_vm.address_ptr, 0x00)# 准备参数a1 &#x3D; &quot;aid&#x3D;01A-khBWIm48A079Pz_DMW6PyZR8uyTumcCNm4e8awxyC2ANU.&amp;cfrom&#x3D;28B5295010&amp;cuid&#x3D;5999578300&amp;noncestr&#x3D;46274W9279Hr1X49A5X058z7ZVz024&amp;platform&#x3D;ANDROID&amp;timestamp&#x3D;1621437643609&amp;ua&#x3D;Xiaomi-MIX2S__oasis__3.5.8__Android__Android10&amp;version&#x3D;3.5.8&amp;vid&#x3D;1019013594003&amp;wm&#x3D;20004_90024&quot;# 通过地址直接调用result &#x3D; emulator.call_native(module.base + 0xC365, emulator.java_vm.jni_env.address_ptr, 0x00, String(a1).getBytes(emulator, String(&quot;utf-8&quot;)), 0)# 打印结果print(&quot;result:&quot;+ result._String__str) 结果和Unidbg一致。 FindHash输出为32位字符串，可能是哈希算法。 将findhash.xml和findhash.py放到IDA的plugins目录下，使用IDA7.5加载完so后，在IDA工具栏依次点击edit-&gt;plugin-&gt;findhash即可运行 12adb shell dumpsys activity top 查看包名为com.sina.oasisfrida -U -f com.sina.oasis -l liboasiscore_findhash_1636100950.js --no-pause 修改frida脚本中setImmediate(main,5000);由于刚启动时，此时目标so还没有加载到内存中，修改后在目标so加载完成后进行hook。根据输出找到对应的函数并分析，很快就定位到0x8AB2这个函数，并且它是MD5_Update函数。 1234567891011121314151617function hook_md5_update()&#123; var targetSo &#x3D; Module.findBaseAddress(&quot;liboasiscore.so&quot;); let relativePtr &#x3D; 0x8AB2 + 1; console.log(&quot;Enter&quot;); let funcPtr &#x3D; targetSo.add(relativePtr); Interceptor.attach(funcPtr,&#123; onEnter:function (args) &#123; &#x2F;&#x2F; console.log(args[0]); console.log(args[2]); console.log(hexdump(args[1],&#123;length:args[2].toInt32()&#125;)); &#125;,onLeave:function (retval)&#123; &#125; &#125;)&#125;frida -UF -l hookComputeMd5.js 结果如下 1234567891011121314151617181920212223242526 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEFb2fa5800 59 50 31 56 74 79 26 24 58 6d 2a 6b 4a 6b 6f 52 YP1Vty&amp;$Xm*kJkoRb2fa5810 2c 4f 70 6b 26 61 69 64 3d 30 31 41 2d 6b 68 42 ,Opk&amp;aid&#x3D;01A-khBb2fa5820 57 49 6d 34 38 41 30 37 39 50 7a 5f 44 4d 57 36 WIm48A079Pz_DMW6b2fa5830 50 79 5a 52 38 75 79 54 75 6d 63 43 4e 6d 34 65 PyZR8uyTumcCNm4eb2fa5840 38 61 77 78 79 43 32 41 4e 55 2e 26 63 66 72 6f 8awxyC2ANU.&amp;cfrob2fa5850 6d 3d 32 38 42 35 32 39 35 30 31 30 26 63 75 69 m&#x3D;28B5295010&amp;cuib2fa5860 64 3d 35 39 39 39 35 37 38 33 30 30 26 6e 6f 6e d&#x3D;5999578300&amp;nonb2fa5870 63 65 73 74 72 3d 4a 32 33 33 39 67 41 43 79 30 cestr&#x3D;J2339gACy0b2fa5880 44 35 6b 33 32 39 35 33 71 30 31 67 74 66 36 78 D5k32953q01gtf6xb2fa5890 30 38 31 39 26 70 6c 61 74 66 6f 72 6d 3d 41 4e 0819&amp;platform&#x3D;ANb2fa58a0 44 52 4f 49 44 26 74 69 6d 65 73 74 61 6d 70 3d DROID&amp;timestamp&#x3D;b2fa58b0 31 36 32 31 35 32 36 32 39 38 31 32 37 26 75 61 1621526298127&amp;uab2fa58c0 3d 58 69 61 6f 6d 69 2d 4d 49 58 32 53 5f 5f 6f &#x3D;Xiaomi-MIX2S__ob2fa58d0 61 73 69 73 5f 5f 33 2e 35 2e 38 5f 5f 41 6e 64 asis__3.5.8__Andb2fa58e0 72 6f 69 64 5f 5f 41 6e 64 72 6f 69 64 31 30 26 roid__Android10&amp;b2fa58f0 76 65 72 73 69 6f 6e 3d 33 2e 35 2e 38 26 76 69 version&#x3D;3.5.8&amp;vib2fa5900 64 3d 31 30 31 39 30 31 33 35 39 34 30 30 33 26 d&#x3D;1019013594003&amp;b2fa5910 77 6d 3d 32 30 30 30 34 5f 39 30 30 32 34 wm&#x3D;20004_900240x1a 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEFbbe3c322 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................bbe3c332 00 00 00 00 00 00 00 00 00 00 ..........0x8 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEFbae15ed8 f0 08 00 00 00 00 00 00 明文是从aid开始的，前面多了一块，这一块每次运行都不变，所以猜测它是盐，使用逆向之友Cyberchef测试一下 Frida123456789101112131415function hookSign()&#123; Java.perform(function () &#123; var NativeApi &#x3D; Java.use(&#39;com.weibo.xvideo.NativeApi&#39;); &#x2F;&#x2F; 使用系统工具类将byte数组转成hex、utf8. var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); NativeApi.s.implementation &#x3D; function (str1, str2)&#123; var result &#x3D; this.s(str1, str2); console.log(&quot;str:&quot;+ByteString.of(str1).utf8()) console.log(&quot;hex:&quot;+ByteString.of(str1).hex()) console.log(result); return result; &#125; &#125;);&#125;frida -UF -l hookAndCallLvzhou.js var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"unidbg","slug":"unidbg","permalink":"http://onejane.github.io/tags/unidbg/"},{"name":"ida","slug":"ida","permalink":"http://onejane.github.io/tags/ida/"},{"name":"ExAndroidNativeEmu","slug":"ExAndroidNativeEmu","permalink":"http://onejane.github.io/tags/ExAndroidNativeEmu/"}]},{"title":"SO逆向之IDA过CrackMe反调试","slug":"SO逆向之IDA过CrackMe反调试","date":"2021-10-28T05:13:55.000Z","updated":"2022-10-30T03:44:17.850Z","comments":true,"path":"2021/10/28/SO逆向之IDA过CrackMe反调试/","link":"","permalink":"http://onejane.github.io/2021/10/28/SO%E9%80%86%E5%90%91%E4%B9%8BIDA%E8%BF%87CrackMe%E5%8F%8D%E8%B0%83%E8%AF%95/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 样本来自阿里聚安全的Crackme，自毁程序密码_1.0原版.apk 随机输入密码后报错验证码校验失败，通过jadx-1.2.0搜索后发现调用了校验逻辑在SO层的securityCheck中 SO分析解压该apk后IDA打开自毁程序密码_1.0原版\\lib\\armeabi\\libcrackme.so，搜索java找到securityCheck导出函数 通过F5将汇编转成伪C代码，分析大致逻辑后点击v3通过JNIEnv*还原指令 或者通过Y修改参数类型 int __fastcall Java_com_yaotong_crackme_MainActivity_securityCheck(JNIEnv *a1, jobject a2, jstring a3) 还原后使用/添加注释，n修改别名为易读变量，输入的字符串和密码逐位对比， 动态调试将IDA中的D:\\IDA 7.0\\dbgsrv\\android_server拷贝到真机/data/local/tmp下 123456adb push android_server &#x2F;data&#x2F;local&#x2F;tmpcd &#x2F;data&#x2F;local&#x2F;tmp&#x2F;mv android_server as7.0chmod 777 as7.0.&#x2F;as7.0 在23946端口启动adb forward tcp:23946 tcp:23946 端口转发 新建IDA的Instance，打开该app后以attach附加调试 ctrl+s找到需要调试的so，ctrl+f搜索so名，找到第一个带x权限的so文件双击进入 函数在内存中绝对地址=so文件基地址+函数地址偏移量，即EF0DD000+11A8=EF0DE1A8 g跳转到该函数的内存地址中EF0DE1A8，进入该函数中右键加上断点，F8单步不进入函数调试，F7单步进入函数调试 F8单步调试或者点击左上角绿色三角按钮，闪退并报错FFFFFFFF，目测加了反调试。 一般检测是否可调试的技术方案是通过linux系统的ptrace实现，当当应用被调试时应用内存里的TracerPid字段就不为0，只要是不为0的时候，就会直接的退出程序，达到反调试的目的。端点调试报错FFFFFFFF后该TracerPid变成了0。 反反调试附加调试System.loadLibrary()加载so文件流程 先读取so文件的.init_array段 再执行JNI_OnLoad函数 JNI_ONLoad是.so文件的初始函数 然后调用具体的native方法 程序的so文件在加载阶段会先执行JNI_OnLoad，之后就不再执行，在程序的so文件加载阶段才能给JNI_OnLoad打断点调试即可，首先需要将app回编译添加可调试权限。 修改回编译打包 12345apktool b 青青草视频&#x2F; 回编译cd 青青草视频&#x2F;dist 编译完成的apkkeytool -genkey -alias abc.keystore -keyalg RSA -validity 20000 -keystore abc.keystorejarsigner -verbose -keystore abc.keystore -signedjar qqc2_signed.apk 青青草视频.apk abc.keystore 重签名adb install -r qqc2_signed.apk 或者配置Android Killer 在application中添加**android:debuggable=”true”**，保存后编译生成新apk，卸载原apk后重新安装 12345adb shellcd &#x2F;data&#x2F;local&#x2F;tmp&#x2F;.&#x2F;as7.0 启动安卓server，在ida目录下adb forward tcp:23946 tcp:23946adb shell am start -D -n com.yaotong.crackme&#x2F;.MainActivity 以debug方式启动 123adb shell ps | findstr com.yaotong.crackme 找到进程id为14383u0_a72 14383 589 1619304 37312 futex_wait 00f263141c S com.yaotong.crackmeadb forward tcp:8700 jdwp:14383 端口转发 Debugger-Debugger options 点击左上角启动 1234jdb -connect com.sun.jdi.SocketAttach:hostname&#x3D;127.0.0.1,port&#x3D;8700 转发8700端口，继续运行程序设置未捕获的java.lang.Throwable设置延迟的未捕获的java.lang.Throwable正在初始化jdb... 寻找JNI_Onload内存计算点击左上角运行，直到ctrl+s找到so被加载的时候，找到crackme.so的第一个可执行时机，双击进入找到该so的偏移量 通过静态分析的JNI_OnLoad地址，相加得到JNI_Onload的内存地址=EF09AB9C g跳转到JNI_OnLoad地址EF09AB9C,F2打断点,F8单步执行，鼠标一到寄存器R值可以显示字符串的值 IDA搜索Modules中搜索crack，进入so后搜索JNI找到EF09AB9C SO修复 通过下一步反复调试发现在图中断点出BLX R7的位置跳出报错FFFFFFFF，期间ctrl+s可以不断尝试看libcrackme.so是否出现，此处应该就是就是反调试检测位置了 双击或者右侧打开R7寄存器，出现pthread_create新建一个线程不停的检测TracerPid这个字段是否不为0， 不为0，就立即退出程序。 我们可以通过修改R7为00 00 00 00直接nop掉该指令，因为删除的话so文件有固定格式，多段内容的偏移值容易发生错乱。 在静态调试页面中找到BLX R7位置，进入Hex View-1，修改指令 或者ultraedit直接修改保存即可，将修改后的so替换原Android Killer中的so，并重新签名打包安装。 破解密码12.&#x2F;as7.0adb forward tcp:23946 tcp:23946 启动好该app后，获取该app的进程id并进程转发 123adb shell ps | findstr com.yaotong.crackmeadb forward tcp:8700 jdwp:8741jdb -connect com.sun.jdi.SocketAttach:hostname&#x3D;127.0.0.1,port&#x3D;8700 进入断点后，在Modules中搜索crack，直接找到securityCheck函数并g定位到该函数的具体地址EF0DF1A8 结合静态分析，找到判断的位置并打上断点，这个R3相比就是真实的密码了 点击左上角启动，输入onejane确认后R0就是我们输入的密码 F5进入C伪代码后鼠标悬浮查看v6 = off_EF0E428C密码为aiyou,bucuoo。 重新输入密码完成So层的逆向。 总结利用Android Killer回编译，IDA逆向SO层转汇编为伪C代码进行动静态分析调试，SO修复反反调试等手段完成该Crackme的逆向。 01:17 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"SO","slug":"SO","permalink":"http://onejane.github.io/tags/SO/"},{"name":"IDA","slug":"IDA","permalink":"http://onejane.github.io/tags/IDA/"}]},{"title":"猿人学之雪碧图样式干扰","slug":"猿人学之雪碧图样式干扰","date":"2021-09-17T08:22:57.000Z","updated":"2021-12-12T03:09:39.336Z","comments":true,"path":"2021/09/17/猿人学之雪碧图样式干扰/","link":"","permalink":"http://onejane.github.io/2021/09/17/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8B%E9%9B%AA%E7%A2%A7%E5%9B%BE%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 题目https://match.yuanrenxue.com/match/4 抓包https://match.yuanrenxue.com/api/match/4 分析 该页面每个td中img个数和实际展示个数不一致，且部分img被display: none;属性隐藏后个数一致，但img排列组合顺序和实际展示不一致，目测和style中的left属性有关。 通过抓包分析以上请求中返回的info属性，通过html格式化后，发现是多个td中包裹多个img标签，不过个数和展示的个数不一致，且src中的内容是data:image/png;base64,开头的图片转为base64形式。通过分析将对应的图片转为数字字典如下 123456789101112image_dict &#x3D; &#123; &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUh...&#39;: 0, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAd...&#39;: 6, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAY...&#39;: 8, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAcCAYAAAC...&#39;: 1, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABQA...&#39;: 9, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAbC...&#39;: 4, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCA...&#39;: 2, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABQA...&#39;: 3, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5...&#39;: 7, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAcCAY...&#39;: 5&#125; 将格式化后的html中的base64图片转为数字 对比得到两个结论，首先class中去除一个加密字符串的属性，且style中部分标签加上了display: none;属性。说明拿到服务端返回结果后，js中为style加上了display为none的属性。 全局搜索&#39;display&#39;,&#39;none&#39;或者&#39;display&#39;, &#39;none&#39; 其中data.info就是获取返回内容中info的部分,也就是&lt;td&gt;标签里面的内容，通过JQuery的选择器,选择标签中有number的元素,并将&lt;td&gt;标签的内容添加进去，通过获取data中key和value中的值,并替换一些字符,最后经过md5算法加密,得到一串密文，在密文前面加上一个.,并赋值给变量j_key，通过选择器,选择有密文这个属性的标签,并将其样式设置成display:none,最终再删除属性中的密文 爬虫123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103image_dict &#x3D; &#123; &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUh...&#39;: 0, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAd...&#39;: 6, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAY...&#39;: 8, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAcCAYAAAC...&#39;: 1, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABQA...&#39;: 9, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAbC...&#39;: 4, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCA...&#39;: 2, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABQA...&#39;: 3, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5...&#39;: 7, &#39;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAcCAY...&#39;: 5&#125;answer_num_list &#x3D; []def get_base64_data(page_num): url &#x3D; &#39;http:&#x2F;&#x2F;match.yuanrenxue.com&#x2F;api&#x2F;match&#x2F;4?page&#x3D;&#123;&#125;&#39;.format(page_num) headers &#x3D; &#123; &#39;Host&#39;: &#39;match.yuanrenxue.com&#39;, &#39;Pragma&#39;: &#39;no-cache&#39;, &#39;Referer&#39;: &#39;http:&#x2F;&#x2F;match.yuanrenxue.com&#x2F;match&#x2F;4&#39;, &#39;User-Agent&#39;: &#39;yuanrenxue.project&#39;, &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39; &#125; res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers) # print(res.text) return res.json()[&#39;info&#39;], res.json()[&#39;key&#39;], res.json()[&#39;value&#39;]def b642jpg(b64str, name): data &#x3D; base64.b64decode(b64str) with open(&#39;&#123;&#125;.jpg&#39;.format(name), &#39;wb&#39;) as f: f.write(data) print(&#39;打印完毕&#39;)# var j_key &#x3D; &#39;.&#39; + hex_md5(btoa(data.key + data.value).replace(&#x2F;&#x3D;&#x2F;g, &#39;&#39;));# 利用key和value计算出属性为display&#x3D;none的md5索引值def get_j_key(key, value): return hashlib.md5(base64.b64encode((key + value).encode()).replace(b&#39;&#x3D;&#39;, b&#39;&#39;)).hexdigest()# 获取td中4个图片def parse_every_group_nums(info_data): pattern &#x3D; re.compile(r&#39;&lt;td&gt;(.*?)&lt;&#x2F;td&gt;&#39;) every_group_nums_list &#x3D; pattern.findall(info_data) return every_group_nums_list# 利用j_key和每个图片对应的hash值,确定出要被用的所有数字子图片,及其相对位置偏移值def parse_real_use_num_info(every_group_nums, j_key): # 找到base64 pattern &#x3D; re.compile(r&#39;img_number (.*?)&quot;&#39;) img_number_list &#x3D; pattern.findall(every_group_nums) # 找到图片 pattern &#x3D; re.compile(r&#39;base64,(.*?)&quot;&#39;) ba64_str_list &#x3D; pattern.findall(every_group_nums) # 找到样式 pattern &#x3D; re.compile(r&#39;style&#x3D;&quot;(.*?)&quot;&#39;) number_style_list &#x3D; pattern.findall(every_group_nums) # 寻找所有要用的子图 ba64_str_list &#x3D; [ba64_str_list[index] for index, img_number in enumerate(img_number_list) if img_number !&#x3D; j_key] num_list &#x3D; [image_dict[&#39;data:image&#x2F;png;base64,&#39; + __] for __ in ba64_str_list] # 匹配每个子图实际对应的偏移量 6801 -&gt; [&#39;0&#39;, &#39;11.5&#39;, &#39;-11.5&#39;, &#39;0.0&#39;] number_style_list &#x3D; [number_style_list[index].replace(&#39;left:&#39;, &#39;&#39;).replace(&#39;px&#39;, &#39;&#39;) for index, img_number in enumerate(img_number_list) if img_number !&#x3D; j_key] # 根据偏移值，计算真实的数字顺序 ture_order_list &#x3D; caculate_css_left(number_style_list, num_list) # 将每小组数字拼接并保存 temp_num &#x3D; 0 for index, num in enumerate(ture_order_list[::-1]): temp_num +&#x3D; num * 10 ** index answer_num_list.append(temp_num)# 根据图片映射的数字和图片的偏移值，计算出数字的真实顺序，列表排序返回def caculate_css_left(number_style_list, num_list): # [0, 1, -1, 0] number_style_list &#x3D; [round(float(__) &#x2F; 11) for __ in number_style_list] # 定义数组 ture_order_list &#x3D; [&#39;&#39;]*len(number_style_list) for index, number_style in enumerate(number_style_list): ture_order_list[int(index + number_style)] &#x3D; num_list[index] return ture_order_listif __name__ &#x3D;&#x3D; &#39;__main__&#39;: # info, _, __ &#x3D; get_base64_data(1) # # &lt;td&gt;有10组 left有63个 display有0个，需要md5计算进行拼接base64 ed501a5e229d41330bee8399441bfbfb有39次 57feebf056bfb527e9ad8561e0694b0a有24次 # &#39;&#39;&#39; # b642jpg(b64str, &#39;test&#39;) for page_num in range(1, 6): info_data, key, value &#x3D; get_base64_data(page_num) j_key &#x3D; get_j_key(key, value) every_group_nums_list &#x3D; parse_every_group_nums(info_data) for every_group_nums in every_group_nums_list: parse_real_use_num_info(every_group_nums, j_key) print(sum(answer_num_list)) var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"猿人学之乱码增强","slug":"猿人学之乱码增强","date":"2021-09-11T02:12:16.000Z","updated":"2021-12-12T03:09:39.335Z","comments":true,"path":"2021/09/11/猿人学之乱码增强/","link":"","permalink":"http://onejane.github.io/2021/09/11/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8B%E4%B9%B1%E7%A0%81%E5%A2%9E%E5%BC%BA/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 题目https://match.yuanrenxue.com/match/5 抓包cookie有两种获取方式，一种是服务器返回，一种是本地js生成。 60秒后点击下一页弹窗cookie已失效，并刷新网页，导致之前设置的断点或者hook被清掉，重新发起请求。 https://match.yuanrenxue.com/api/match/5?m=1631326686273&amp;f=1631326686000 m和f明显就是时间戳，cookie中Hm开头的是浏览器设置的，主要关注m和RM4hZBv0dDon443M的内容。通过搜索m的值发现从一开始没有返回突然就出现了该cookie，即本地js生成的cookie，也有可能chrome看不到某些请求的preview返回的数据，RM4hZBv0dDon443M同理。 题目中表明了cookie只有50秒的有效期，不会再次生成了，因为如果每次请求都重新生成， 肯定是一直有效的了，大概是失效之后，带着该cookie重新reload网页请求时计算cookie才重新生成。 分析每次刷新后只会刷新到第一页，搜索cookie已失效,发现location.reload()不论本地是否缓存js或css都会重新请求，彻底刷新。 搜索RM4hZBv0dDon443M又搜不到，有可能字符串拼接或混淆了，搜索m =，m=，m:匹配条数太多，搜索cookie出现位置也很多，再通过回溯定位request方法 该调用栈中只有m和f的定义，未出现cookie的定义位置 只好再次通过hook找到document.cookie在赋值前注入进去我们的js，直接注入是无法注入的，因为网页刷新会清除cookie，所以需要先找到在网页已经刷新但是还没有加载cookie发送请求之前的断点。 清除页面cookie，刷新页面后，进入该断点 123456789101112131415161718(function () &#123; &#x2F;&#x2F;严谨模式 检查所有错误 &#39;use strict&#39;; &#x2F;&#x2F;document 为要hook的对象 这里是hook的cookie Object.defineProperty(document, &#39;cookie&#39;, &#123; &#x2F;&#x2F;hook set方法也就是赋值的方法 &#x2F;&#x2F;当前也可以hook get方法 set: function (val) &#123; &#x2F;&#x2F;这样就可以快速给下面这个代码行下断点 &#x2F;&#x2F;从而快速定位设置cookie的代码 if (val.indexOf(&#39;RM4hZBv0dDon443M&#39;) !&#x3D; -1) &#123; debugger; &#125; console.log(&#39;Hook捕获到cookie设置-&gt;&#39;, val); return val; &#125; &#125;);&#125;)(); 如果找不到该断点的时候，即部分请求一开始就加载了该cookie，可以通过fd正则匹配地址添加hook 过了多次debugger后直到遇到val有值的时候，根据右侧调用栈回溯 第二层时发现该js是动态生成的虚拟js，且RM4hZBv0dDon443M被分割成一个一个字母，所以搜不到，而_0x4e96b4就是window对象， 接下来再通过hook找到window._$ss赋值的地方 12345678910111213141516(function () &#123; &#x2F;&#x2F;严谨模式 检查所有错误 &#39;use strict&#39;; &#x2F;&#x2F;document 为要hook的对象 这里是hook的cookie Object.defineProperty(window, &#39;_$ss&#39;, &#123; &#x2F;&#x2F;hook set方法也就是赋值的方法 &#x2F;&#x2F;当前也可以hook get方法 set: function (val) &#123; &#x2F;&#x2F;这样就可以快速给下面这个代码行下断点 &#x2F;&#x2F;从而快速定位设置cookie的代码 debugger; console.log(&#39;Hook捕获到cookie设置-&gt;&#39;, val); return val; &#125; &#125;);&#125;)(); 看到mode，padding 31:04 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之反调试入门","slug":"JS逆向之反调试入门","date":"2021-08-30T13:14:18.000Z","updated":"2021-12-12T03:09:39.226Z","comments":true,"path":"2021/08/30/JS逆向之反调试入门/","link":"","permalink":"http://onejane.github.io/2021/08/30/JS%E9%80%86%E5%90%91%E4%B9%8B%E5%8F%8D%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 反爬对抗过debugger debugger行右键Edit breakpoint修改为false 动态调试时，循环debugger可能有setInterval定时器， 根据调用栈找到第一次循环调用debugger的方法=function(){} 直接到栈底就是定时器中调用处的入参=function(){} 在定时器运行前打上断点，将setInterval=function(){} 拷贝到本地后，格式化并删除debugger，再运行如果卡死说明做了防格式化，可以在头部加上debugger，重新到浏览器运行，单步跟踪判断哪里利用防格式化卡死代码(toString后通过正则RegExp防止代码格式化)，尝试在每个正则位置校验换行断点，返回值改为true。或者手动在RegExp下添加debugger检查对哪个函数做换行校验，将该函数还原一行即可。 while(true) function x(){xx()} function xx(){x()} 反反混淆判断window.info在哪里设置的值时，可以通过在js顶部加上hook实现，根据堆栈找到设置info时的位置。 1234567891011121314151617(function () &#123; &#39;use strict&#39;; var a; Object.defineProperty(window, &#39;info&#39;, &#123; set: function (val) &#123; console.log(&#39;Hook捕获到setinfo设置-&gt;&#39;, val); debugger; a &#x3D; val; return val; &#125;, get: function (val) &#123; console.log(&#39;Hook捕获到getinfo设置-&gt;&#39;, val); return a; &#125;, &#125;);&#125;)(); 常规结构是参数+方法名+加密后数据-&gt;垃圾代码-&gt;解密代码+检测-&gt;真实代码-&gt;计时器检测-&gt;死代码注入+初始化相关 抓包优先清空所有cookie 防DDOS服务端返回503资源受限，浏览器为了提高响应速度自动清理缓存，被服务端状态码欺骗，导致所有参数都不会被搜索到，浏览器拿不到源码可以通过fiddler追寻历史发包记录，找到503、521记录大多返回包含混淆后的fuckjs中即可找到参数内容，逐段fuckjs(避免脱机)只可以通过浏览器自动运行解密识别，还原替换到原js中。 5s防护加头从fiddler中的503、521请求返回中获取未直接返回的加密参数生成逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var ja_ &#x3D; &#123; value: &quot;&quot; &#x2F;&#x2F;这个是取值用的&#125;;var location &#x3D; &#123; hash:&quot;&quot; &#x2F;&#x2F;这个不用管，取值用的&#125;;var k_ &#x3D; &#123; innerHTML:&quot;[k的那串fuck代码]&quot; &#x2F;&#x2F;k的那串fuck代码，带k值的5s防护&#125;;var document &#x3D; &#123; createElement: function(xd) &#123; if (xd &#x3D;&#x3D; &#39;div&#39;) &#123; return &#123; innerHTML: &quot;&quot;, firstChild: &#123; href: &quot;http:&#x2F;&#x2F;www.itorrents.org&#x2F;&quot; &#x2F;&#x2F;这个链接根据需要修改 &#125; &#125; &#125; return &#123;&#125; &#125;, getElementById: function(x) &#123; if (x &#x3D;&#x3D; &#39;jschl-answer&#39;) &#123; &#x2F;&#x2F;这个名字根据需要修改 return ja_; &#125; if (x &#x3D;&#x3D; &#39;challenge-form&#39;) &#123;&#x2F;&#x2F;这个名字根据需要修改 return &#123; &#x2F;&#x2F;这里是个form表单，根据需要修改 action: &quot;&quot;, submit: function() &#123;&#125; &#125; &#125; else&#123; return k_ &#x2F;&#x2F;这里就是多出来的k的值,带k值的5s防护 &#125; return &#123;&#125; &#125;&#125;;&#x2F;&#x2F; 补头function getno5s()&#123; !function() &#123; &#x2F;&#x2F;setTimeout 里的代码 &#125;() return ja_.value &#x2F;&#x2F;这里取值用的&#125;&#x2F;&#x2F;自执行!(function()&#123; ... t &#x3D; document.createElement(&#39;div&#39;); t.innerHTML&#x3D;&#39;&lt;a href&#x3D;&#39;&#x2F;&#39;&gt;x&lt;&#x2F;a&gt;; t &#x3D; t.firstChild.href;r&#x3D;t.match(&#x2F;https?:\\&#x2F;\\&#x2F;&#x2F;)[0] t &#x3D; t.substr(r.length); t &#x3D; t.substr(0,t.length-1);k&#x3D;&#39;cf-dn-tPaJV&#39;; a &#x3D; document.getElementById(&#39;jschl-answer&#39;); f &#x3D; document.getElementById(&#39;challenge-form&#39;); ... a.value &#x3D; ... f.action +&#x3D; location.hash; f.submit();&#125;)() 加速乐localtion.href改为a.b，eval改为console.log将解密后的代码拷贝出来补头 12345678910111213141516171819202122232425262728293031323334var window &#x3D; &#123; addEventListener: function()&#123;&#125;&#125;var document &#x3D; &#123; addEventListener:function(x,x1,x2)&#123; if(x &#x3D;&#x3D; &quot;DOMContentLoaded&quot;) &#123; x1(); &#125; &#125;, addEventListener:function(x,x1,x2)&#123; if(x &#x3D;&#x3D; &quot;onreadystatechange&quot;) &#123; x1(); &#125; &#125;, cookie:&quot;&quot;&#125;var setTimeout &#x3D; function(x,x1)&#123;&#125;&#x2F;&#x2F; 补头var _9 &#x3D; function() &#123; setTimeout(&#39;location.href&#x3D;...&#39;,1500); document.cookie &#x3D; &#39;__jsl_clearance...&#39;&#125;if((function()&#123; try&#123; return !!window.addEventListener; &#125; catch(e)&#123; return false; &#125;&#125;)()) &#123; document.addEventListener(&#39;DOMContentLoaded&#39;, _9, false)&#125; else &#123; document.attachEvent(&#39;onreadystatechange&#39;, _9)&#125; document.cookie即可拿到加密后的值 验证码网易易盾， 腾讯防水墙，极验，本文以网易易盾为例，实现验证码加密的逆向分析。 抓包通过抓包https://c.dun.163.com/api/v2/get生成验证码入参对比，token可有可无 返回值为携带token的json 1234567891011121314151617&#123; \"data\": &#123; \"bg\": [ \"https://necaptcha.nosdn.127.net/92790c370aaa4e83ab122927096375d1.jpg\", \"https://nos.netease.com/necaptcha/92790c370aaa4e83ab122927096375d1.jpg\" ], \"front\": [ \"https://necaptcha.nosdn.127.net/d040ca01b02c4d5493b90cf50f066213.png\", \"https://nos.netease.com/necaptcha/d040ca01b02c4d5493b90cf50f066213.png\" ], \"token\": \"fa17e8710a7f40beb760d2398f3890a5\", \"type\": 2, \"zoneId\": \"CN31\" &#125;, \"error\": 0, \"msg\": \"ok\"&#125; 通过抓包滑动验证码https://c.dun.163.com/api/v2/check，其中的token参数为get包返回的fa17e8710a7f40beb760d2398f3890a5 滑动成功后将返回validate字符串 12345678910&#123; &quot;data&quot;: &#123; &quot;result&quot;: true, &quot;zoneId&quot;: &quot;CN31&quot;, &quot;token&quot;: &quot;2ce6fe0684804245a795d584395487b5&quot;, &quot;validate&quot;: &quot;8gxMgwjCs36ABQyKiWXApPYj4qmeePZtNacdk+33&#x2F;pWyyVk9xmp6Fe6etQ75HC&#x2F;G&#x2F;p4SqUksSPlt8+SstaDC3Eve43eTujSRtRjRkjwxQHpQ&#x2F;lDjwKTb2VfYqnObIYge5b29Di6sbOKMlDTLiDqVGcyrENpDdPSiOkrTu3zS30w&#x3D;&quot; &#125;, &quot;error&quot;: 0, &quot;msg&quot;: &quot;ok&quot;&#125; 通过c.dun.163.com/api/v2过滤生成和滑动验证码的包。 分析fp进入Initiator调用栈并打上断点，，滑动滑块进行check后重新获取图。该js动态生成因为追加时间戳可以通过xhr断点跟踪~~ 在t参数中找到了fp已经被加密，根据右侧调用栈 逐步向上追溯到fp定义的位置，即n.fingerprint 在当前页面中搜索fingerprint，找到该参数赋值的地方，即 window.gdxidpyhxde 由于cookie中有gdxidpyhxdE的值，清除缓存后，利用hook实现window.gdxidpyhxde的定位 控制台打印be的值正是gdxidpyhxde，接下来判断be是在哪里塞入fp的值，由于core.v2.15.2.min.js每次动态生成，所以每次都需要重新下断点跟踪。 单步跟踪到h赋值时，重新回到了hook函数，再观察h的值，有加密串:时间戳组成。找到了加密的大致流程，追溯上层调用栈后，以上的function都包含于于一个大自执行的多层自执行function，接下来就是把大外层的function扣出来了。 ![GIF 2021-9-6 8-06-35](JS逆向之反调试入门/GIF 2021-9-6 8-06-35.gif) 去除自执行函数，将W()中的h结果返回出来就是我们所需要的的fp，接下来将代码拷贝到js引擎中运行。报错引用错误: window 未定义，补头var window = this;，报错类型错误: 无法读取属性 &#39;cookie&#39; of undefined，直接干掉G[u[160]] || 报错类型错误: Cannot set property &#39;cookie&#39; of undefined，由于在加载滑块过程中没有被调用，直接干掉该方法，同理引用到的函数也一并干掉 重新运行getfp() 虽然有了结果，不过该值是不正确的，以下位置取的指纹信息，而v8执行是拿不到指纹的，所以直接把该值输出后替换到扣出的js中，var w = [&quot;6762186695653&quot;, &quot;39753334585035&quot;];。 针对不同的站，host不一样，在W()中修改 12var _host &#x3D; &quot;dun.163.com&quot;;i[u[61]] &#x3D; _host; 接下来通过Initiator栈中f.src的fp的值由undefined改为上面的加密值编码后的结果 cbInitiator断点，滑动滑块触发check后，再次调用get 当滑动滑块时，第一次check完成，获取第二次get的调用栈中找到了cb的定义位置 跟进s()后 1234function s() &#123; var e &#x3D; X.uuid(32); return P(e)&#125; 其中uuid抠出来可以直接运行调用 其中P函数所在大function抠出来 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之调试反爬hook加密技巧","slug":"JS逆向之调试反爬hook加密技巧","date":"2021-08-02T11:33:18.000Z","updated":"2021-12-12T03:09:39.274Z","comments":true,"path":"2021/08/02/JS逆向之调试反爬hook加密技巧/","link":"","permalink":"http://onejane.github.io/2021/08/02/JS%E9%80%86%E5%90%91%E4%B9%8B%E8%B0%83%E8%AF%95%E5%8F%8D%E7%88%AChook%E5%8A%A0%E5%AF%86%E6%8A%80%E5%B7%A7/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 js语法作用域局部变量 1234function jb()&#123; var a &#x3D; &quot;局部变量&quot; return a&#125; 全局变量 12345var a &#x3D; &quot;全局变量&quot;function qj()&#123; console.log(a)&#125;console.log(a) 自执行函数js加载自动运行 123!(function()&#123; console.log(2)&#125;)() 外部调用内部函数 123456789var _hex_md5;function xx()&#123; var hex_md5 &#x3D; function()&#123; console.log(&quot;111&quot;) &#125; _hex_md5 &#x3D; hex_md5&#125;xx()_hex_md5() 改成自执行 12345678var _hex_md5;!(function xx()&#123; var hex_md5 &#x3D; function()&#123; console.log(&quot;111&quot;) &#125; c &#x3D; hex_md5&#125;)()_hex_md5() 很多情况函数定义在对象中 12345678910var _hex_md5;function xx()&#123; var j &#x3D; &#123; hex_md5: function()&#123; console.log(&quot;111&quot;) &#125; &#125; _hex_md5&#x3D;j;&#125;想要调用时需要先调用外部方法赋值再调用j中的hex_md5 改成自执行 12345678910var _hex_md5;!(function xx()&#123; var j &#x3D; &#123; hex_md5: function()&#123; console.log(&quot;111&quot;) &#125; &#125; _hex_md5&#x3D;j;&#125;)()_hex_md5.hex_md5() define函数自动创建执行，但是纯js环境没有该函数。该函数调用jquery定义函数md5的js将后面的内容函数命名为md5。扣代码时创建对象变量var md5;，原define改成自执行函数!(function(){})()，其中j对象中包含需要调用的md5:function(s)，修改导出语法module.exports=j为md5=j赋值为新定义的对象，即可使用md5.md5(&quot;123&quot;)调用扣出想要的js函数。 浏览器环境BOM补头，脱离浏览器在外部不可被直接调用 12345window &#x3D; &#123; &#x2F;&#x2F; window是全局变量 location:&#123; href: &quot;chrome:&#x2F;&#x2F;newtab&#x2F;&quot; &#125;&#125; html渲染环境DOMjs引擎自带(v8) 123456document &#x3D; &#123; &#x2F;&#x2F; document是全局变量，hook掉原有方法 write:function()&#123; &#125;&#125;document.write.toString &#x3D; function()&#123;return &quot;function write()&#123; [native code] &#125;&quot;&#125;] 点击鼠标 登录 网页加载 浏览器指纹（检测是否同一用户），收集是否为浏览器环境 图像加载 浏览器指纹 滑块图片还原 鼠标移动 浏览器指纹 无感验证 123var p &#x3D; document.createElement(&quot;p&quot;)p.className &#x3D; &quot;onejane&quot;document.body.appendChild(p) 实战Preserve log 禁止清除缓存Disable cache 禁止缓存ctrl+shift+f 搜索password找到对应js，左下角format格式化，排除vue，axios，jquery 16位 32位加密串 md5 40位加密串 sha1 通过乐易编程助手实现各种加密方案 定位 搜索关键参数password:,password=,password = 请求url，搜索方法var submit或者function submit或者submit: dom元素事件监听，Remove准确定位触发js位置 xhr断点，定位发包函数跟栈，复制网址请求路径到Sources下的XHR/fetch Breakpoints，支持正则。 Network下的发包请求的Initiator，如jquery堆栈的顶层断点(可能会请求多次，找到发包请求时进入的断点)，重新请求找到堆栈中属于目标网站的js格式化断点。 fiddler 版本必须 &gt;= v4.6.3，复制Fiddler 编程猫专用插件到fiddler程序目录下的Scripts目录中示例: C:\\Program Files (x86)\\Fiddler2\\Scripts 覆盖原函数 12345678910function xxx()&#123; console.log(&quot;1111&quot;)&#125;var xxx_ &#x3D; xxx;xxx &#x3D; function()&#123; console.log(&quot;2222&quot;)&#125;window.alert &#x3D; function()&#123;console.log(&quot;?&quot;)&#125;console.clear &#x3D; function()&#123;console.log(&quot;?&quot;)&#125;setInterval &#x3D; function()&#123;&#125; Object.defineProperty替换对象属性(getter.setter) 123456789101112131415(function () &#123; var a &#x3D; &quot;&quot;; Object.defineProperty(document, &#39;cookie&#39;, &#123; set: function (val) &#123; console.log(&#39;Hook捕获到cookie设置-&gt;&#39;, val); a &#x3D; val; return val; &#125;, get: function()&#123; return a; &#125; &#125;);&#125;)();document.cookie &#x3D; &quot;1&quot; &#x2F;&#x2F; 设置document.cookie &#x2F;&#x2F; 获取 hook的时机在控制台注入的hook，刷新网页就失效了，过滤Network的js找到第一个加载的js，右键Open in Sources panel格式化，第一行断点，不过有些cookie可能异步可能在html中js生成，在控制台中注入以上hook，清除cookie，手动注入hook，控制台中找到VM虚拟机找到我们的hook的js打上断点，，每次hook都会经过set，右侧就可以查看调用栈，追溯cookie的来源与加密方式。(有可能注入hook的时机会晚于部分异步请求或者html中的js) 利用fiddler代理所有请求替换响应,编程猫专用工具注入hook 123456789101112(function () &#123; &#39;use strict&#39;; Object.defineProperty(document, &#39;cookie&#39;, &#123; set: function (val) &#123; if (val.indexOf(&quot;__dfp&quot;) !&#x3D; -1) &#123; debugger; &#125; console.log(&#39;Hook捕获到cookie设置-&gt;&#39;, val); return val; &#125; &#125;);&#125;)(); 接下来查看调用栈，最终保存到window.name中。 123456789101112131415(function () &#123; &#39;use strict&#39;; var a &#x3D; &quot;&quot;; Object.defineProperty(window, &#39;name&#39;, &#123; set: function (val) &#123; debugger; a &#x3D; val; console.log(&#39;Hook捕获到cookie设置-&gt;&#39;, val); return val; &#125;, get: function()&#123; return a; &#125; &#125;);&#125;)(); 重新进入iqiyi，断点完成hook定位。 中烟新商盟元素监听定位，如果出现多个js，尝试Remove再点击看是否报错触发登录定位到事件最终触发的js，尽可能将多个地方打上断点 直接找到对应js位置，先左下角format格式化，ctrl+shift+f打开js页面的控制台，在js页面ctrl查看所有变量值 鼠标悬停，或者控制台打印出来，点击进入方法声明时打上断点，为同一行中的函数打上断点，F8单步调试 to8to抓包https://www.to8to.com/new_login.php，在Element面板中搜索new_login.php ctrl+shift+f 搜索loginCheck 该方法中jq(&#39;#rsa_userNum&#39;).val(rsaString(password));，调用rsaString方法加密密码 123function rsaString(str) &#123; return encodeURIComponent(RSAUtilszb.encryptfun(str));&#125; 进入encryptfun定义的js中，rsa加密最少2000行，该方法不过163行，拷贝该js通过编程猫专用工具中的JS调试工具，加载代码，报错引用错误: window 未定义，添加var window = this;,报错引用错误: JSEncrypt 未定义,添加原js中var JSEncrypt = JSEncryptExports.JSEncrypt;，报错引用错误: JSEncryptExports 未定义,搜索var JSEncryptExports，将var JSEncryptExports = {}; 添加到JS调试工具，报错类型错误: JSEncrypt is not a constructor 尝试打上断点，但是每次都不能进入断点，说明肯定是动态加载的js，且每次刷新js后缀会有时间戳。勾选Disable cache,打开fiddler抓包，将js拷贝到本地实现http欺骗，选中该请求点击AutoResponder-Add Rule下拉选择Find a File,找到本地保存的js并开启规则 由于每次js请求地址不一样，使用正则匹配regex:https://static\\.to8to\\.com/gb_js/to8torsaszb\\.js\\?_=\\d+并保存规则重新发起请求https://static.to8to.com/gb_js/to8torsaszb.js?_=1628128571412，使用本地js欺骗网络请求js 将整个js格式化找到之前报错JSEncrypt is not a constructor是从上面的压缩的js中export出来的 将上面压缩的代码添加到编程猫的JS调试工具中加载代码，报错引用错误: navigator 未定义，添加var navigator = {}，报错引用错误: window 未定义，添加var window =this,因为如果用window ={}报错ASN1 未定义,而用this则可以拿到当前js中所有的变量函数。 升学e网通登录抓包，打开Initiator，进入堆栈顶层定位的代码行 打上断点，查看右侧调用栈，逐个方法往底层去调用，直到react库js找到了preLogin，找到出现password的位置，打上断点 再次登录时，进入断点，找到password 进入加密方法中，aes加密 打开WT-JS中的Crypto类复制key和iv，输出以HEX的十六进制格式，对比结果是标准的AES加密。 基于base64或十六进制的AES加解密实现见aes.js 长房集团 搜索j_password后打断点，重新登录 进入desEncrypt中，大致加密完成逻辑就在该函数中 加密逻辑中首先根据SECURITYKEY.get()获取到key，首先通过请求后端拿到str，判断加密类型是否为aes后截取字符串通过toHexString转成十六进制拿到key和iv和security 整理完逻辑扣出js报错CryptoJS is not defined,点击进入 CryptoJS.AES.encrypt扣出来源码，完整见changfang.js webpack遇到webpack的RSA站无脑搜setPublicKey,遇到定义变量时n(“…”)，无脑跳到n的js中把RSA的头部拷贝出来 拼装成如下模板，将含有setPublicKey的js最外层的{}包括起来的函数拷贝到上面的函数定义中，并导出函数名 1234567891011121314151617var _c; // 定义变量(function (e) &#123; function c(t) &#123; // if (i[t]) return i[t].exports; var n = /*i[t] = */ &#123; i: t, l: !1, exports: &#123;&#125; &#125;; return e[t].call(n.exports, n, n.exports, c), n.l = !0, n.exports &#125; _c = c; // 导出函数&#125;)(&#123; \"0022\" : function(t,e,n)&#123;...&#125;&#125;) 拷贝到Sources中的Snippets中自动加载 获取publickey的时候，打上断点，在setPublicKey时使用 添加换行后，完成解密 G妹游戏 首先搜索password发现出现的点太多，尝试使用initiator的第一个js位置 格式化后直接下断点，直接过滤掉jquery库，查看网站自己的js代码并打上断点，在第二次时才进入真实的发送登录请求的send方法 webpack特征格式 1234567891011function(x) &#123; function xx(yy)&#123; x[yy].call(xxx,xxx,xxx); &#x2F;&#x2F; 必有一个加载模块的方法 call apply &#125;&#125;([ &#x2F;&#x2F; 数组 &#125;([ 对象 &#125;(&#123; function(x1,x2,x3)&#123;&#125;, function(x1,x2,x3)&#123;&#125;, function(x1,x2,x3)&#123;&#125;, function(x1,x2,x3)&#123;&#125;, function(x1,x2,x3)&#123;&#125;]); 上面选择方法，下面定义方法。解决webpack框架可以先找到加载模块的方法，找到调用的模块，构造一个自执行方法 ![GIF 2021-8-14 21-37-22](JS逆向之调试反爬hook加密技巧/GIF 2021-8-14 21-37-22.gif) 123456789101112131415!function(i) &#123; var s &#x3D; &#123;&#125;; function n(t) &#123; if (s[t]) return s[t].exports; var e &#x3D; s[t] &#x3D; &#123; i: t, l: !1, exports: &#123;&#125; &#125;; return i[t].call(e.exports, e, e.exports, n), e.l &#x3D; !0, e.exports &#125;&#125;() 以上完成了找到加载模块的方法，构造一个自执行方法。接下来查看加密password的地方 进入g.encode方法中，想必完整的加密逻辑存在this.jsencrypt.encrypt(i)中 打上断点后重新登录，进入该断点时，进入jsencrypt.encrypt,发现存在于function(t, e, i)中 ![GIF 2021-8-14 21-49-44](JS逆向之调试反爬hook加密技巧/GIF 2021-8-14 21-49-44.gif) 将整个function(t, e, i)(包含qe.prototype.encrypt = function(t) {的password加密方法)拷贝下来，并定义函数名为jsencrypt，完成调用模块的扣取。 12345678910111213141516171819!function(i) &#123; var s &#x3D; &#123;&#125;; function n(t) &#123; if (s[t]) return s[t].exports; var e &#x3D; s[t] &#x3D; &#123; i: t, l: !1, exports: &#123;&#125; &#125;; return i[t].call(e.exports, e, e.exports, n), e.l &#x3D; !0, e.exports &#125;&#125;( &#123; jsencrypt: function(t, e, i) &#123;...&#125; &#125;) 该加密函数在外层被调用，需要在webpack模板中引入 123456789101112131415161718192021222324252627282930313233343536!function(i) &#123; var s &#x3D; &#123;&#125;; function n(t) &#123; if (s[t]) return s[t].exports; var e &#x3D; s[t] &#x3D; &#123; i: t, l: !1, exports: &#123;&#125; &#125;; return i[t].call(e.exports, e, e.exports, n), e.l &#x3D; !0, e.exports &#125;&#125;( &#123; jsencrypt: function(t, e, i) &#123;...&#125;, jiami: function(t, e, r) &#123; &#x2F;&#x2F; 其中调用了jsencrypt var i; (i &#x3D; function(t, e, i) &#123; var s &#x3D; r(3); function n() &#123; void 0 !&#x3D;&#x3D; s &amp;&amp; (this.jsencrypt &#x3D; new s.JSEncrypt, this.jsencrypt.setPublicKey(&quot;-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDq04c6My441Gj0UFKgrqUhAUg+kQZeUeWSPlAU9fr4HBPDldAeqzx1UR92KJHuQh&#x2F;zs1HOamE2dgX9z&#x2F;2oXcJaqoRIA&#x2F;FXysx+z2YlJkSk8XQLcQ8EBOkp&#x2F;&#x2F;MZrixam7lCYpNOjadQBb2Ot0U&#x2F;Ky+jF2p+Ie8gSZ7&#x2F;u+Wnr5grywIDAQAB-----END PUBLIC KEY-----&quot;)) &#125; n.prototype.encode &#x3D; function(t, e) &#123; var i &#x3D; e ? e + &quot;|&quot; + t : t; return encodeURIComponent(this.jsencrypt.encrypt(i)) &#125; , i.exports &#x3D; n &#125; .call(e, r, e, t)) &#x3D;&#x3D;&#x3D; undefined || (t.exports &#x3D; i) &#125; &#125;) var s = r(3);中的r是function模块传入的第三个参数，由于模块在加载器加载call时调用，不论e.exports，e都不是方法，n是方法且只有一个参数，所以r=n，将加载函数传给了模块，让模块也有了加载的功能。将r(3)改为r(&quot;jsencrypt&quot;) 1234567891011121314151617181920212223242526272829303132333435363738var _n; &#x2F;&#x2F; 导出n加载器!function(i) &#123; var s &#x3D; &#123;&#125;; function n(t) &#123; if (s[t]) return s[t].exports; var e &#x3D; s[t] &#x3D; &#123; i: t, l: !1, exports: &#123;&#125; &#125;; return i[t].call(e.exports, e, e.exports, n), e.l &#x3D; !0, e.exports &#125; _n &#x3D; n;&#125;( &#123; jsencrypt: function(t, e, i) &#123;...&#125;, jiami: function(t, e, r) &#123; &#x2F;&#x2F; 其中调用了jsencrypt var i; (i &#x3D; function(t, e, i) &#123; var s &#x3D; r(&quot;jsencrypt&quot;); function n() &#123; void 0 !&#x3D;&#x3D; s &amp;&amp; (this.jsencrypt &#x3D; new s.JSEncrypt, this.jsencrypt.setPublicKey(&quot;-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDq04c6My441Gj0UFKgrqUhAUg+kQZeUeWSPlAU9fr4HBPDldAeqzx1UR92KJHuQh&#x2F;zs1HOamE2dgX9z&#x2F;2oXcJaqoRIA&#x2F;FXysx+z2YlJkSk8XQLcQ8EBOkp&#x2F;&#x2F;MZrixam7lCYpNOjadQBb2Ot0U&#x2F;Ky+jF2p+Ie8gSZ7&#x2F;u+Wnr5grywIDAQAB-----END PUBLIC KEY-----&quot;)) &#125; n.prototype.encode &#x3D; function(t, e) &#123; var i &#x3D; e ? e + &quot;|&quot; + t : t; return encodeURIComponent(this.jsencrypt.encrypt(i)) &#125; , i.exports &#x3D; n &#125; .call(e, r, e, t)) &#x3D;&#x3D;&#x3D; undefined || (t.exports &#x3D; i) &#125; &#125;) 调用_n(&quot;jiami&quot;)返回一个对象，prototype为对象新增方法属性，所以var a = (new _n(&quot;jiami&quot;)),a对象可以调用encode方法 12345function getKey(pass,time) &#123; var jiami_ &#x3D; _n(&quot;jiami&quot;) var _jiami &#x3D; (new jiami_); return _jiami.encode(pass,time)&#125; 放到fd中运行报错navigator未定义,定义var navigator={}，报错windows未定义，定义var window=this，开始运行getKey(&quot;123456&quot;,&quot;1628957324&quot;)完成password加密逻辑 极电竞比分网 看起来被URL编码过，解码后2N1SAJY4LOPJc8gB4WeLYBVD/iB905uUz3VuZjOHMeo=,看着像base64，在base64的js原生实现中var base64hash = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;，可以在整个网站搜该特征码 Base64是以下(AES DES RSA)算法的实现，这几个算法都和base64有关，定位到base64后可以逐步确认关键算法。 利用XHR定位法，格式化该js后打上断点 逐个调用栈查看参数信息，判断sign生成的具体位置 直到追溯到异步调用栈时最后一步，参数中都没有出现sign的值，点击单步进入逐步调试，找到出现sign值的时机的上一调用栈 回过头来关注n = n.then(e.shift(), e.shift()),异步执行e中的方法并删除，尝试通过e数组逐个方法进入js的实现 e数组的第一个js方法中找到了sign的赋值位置 一般then前明文，结束后密文，需要格外关注then异步调用时的函数做了什么处理。 观察n字符串的words数组表示已经加密完成，sigBytes为32位，一个int占4字节，长度是8位，4*8=32，有可能是md5。 n = i()(t)观察该js源码中i定义为i = n.n(a)，而a = n(156)，上面再也找不到n的定义点了，打上断点。 进入n的函数定义，webpack格式雏形出现 将整个js拷贝下来扣除无用代码并整理成如下格式 123456789101112131415!function(e) &#123; var n &#x3D; &#123;&#125; function d(t) &#123; if (n[t]) return n[t].exports; var r &#x3D; n[t] &#x3D; &#123; i: t, l: !1, exports: &#123;&#125; &#125;; return e[t].call(r.exports, r, r.exports, d), r.l &#x3D; !0, r.exports &#125;&#125;(&#123;&#125;); 回到网页，继续在return e[t].call(r.exports, r, r.exports, d)打上断点，通过控制台打印获取a = n(156)方法 点击进去e[156],将该方法拷贝出来到webpack模板中 由于其中有n(148)，修改为n(&quot;_148&quot;)，n就是webpack定义的函数自己d，通过正则匹配该js中是否有其他n调用的函数，n\\(\\d+)，不存在其他调用处。在控制台中输入e[148]，将该方法拷贝出来到webpack模板中 回到上面i = n.n(a),断点进入发现就是返回参数a自己，脱裤子放屁 导出webpack模板的方法 将该js复制到浏览器中运行 接下来就是扣取encodeURIComponent(s.a.stringify(n))) 同理，再去return e[t].call(r.exports, r, r.exports, d)寻找157方法,将代码拷贝到webpack模板中 对比之前的加密逻辑 1234567function getSign(param)&#123; &#x2F;&#x2F; param &#x3D; timestamp&#x3D;1629589453737&amp;secret&#x3D;aHVheWluZ19zZWNyZXRfYXBp var i &#x3D; fff(&quot;_156&quot;) &#x2F;&#x2F;a &#x3D; n(156), i &#x3D; n.n(a) 获取到了i变量 var n &#x3D; i(param) &#x2F;&#x2F; i()(t) var s &#x3D; fff(&quot;_157&quot;) &#x2F;&#x2F; c &#x3D; n(157), s &#x3D; n.n(c) return s.stringify(n)&#125; 总结s.a.stringify(n)),就是就是上面脱裤子放屁的方法，s.a就是s自己。 推推99方法定义一般分成三种 var JSEncrypt = function(a){} 搜索 var JSEncrypt JSEncrypt: funtion(a){} 搜索JSEncrypt: JSEncrypt.prototype.encrypt = function(a) {} 搜索 .JSEncrypt 该登录将跳出滑块，最终请求check_login.html?c=0&amp;random=234,获取该请求的initiator调用栈，打上断点后重新登录找到上两层调用栈中l_submit 进入该加密方法,并将jsencrypt.min.js:formatted该加密文件拷贝到fd中运行，报错navigator 未定义,添加var navigator = {}，报错window 未定义,添加var window = this,添加调用方法 通过断点debug获取setPublicKey时塞入的值 123456&#x2F;&#x2F; 由于该js通过exports.JSEncrypt &#x3D; JSEncrypt;导出了该函数，通过new的方式调用该对象中的方法function getP(password)&#123; var encrypt &#x3D; new JSEncrypt() encrypt.setPublicKey(...) return encrypt.encrypt(password)&#125; 由于该自执行函数exports=JSEncryptExports,所以通过JSEncryptExports.name 即可拿到aa 1234var JSEncryptExports &#x3D; &#123;&#125;!(function(exports) &#123; exports.name &#x3D; &#39;aa&#39;&#125;)(JSEncryptExports); 故而可以在最上面定义var jiami;，在var JSEncrypt = function(a)之后加入jiami = JSEncrypt导出对象 12345function getP(password)&#123; var encrypt &#x3D; new jiami() encrypt.setPublicKey(...) return encrypt.encrypt(password)&#125; 拍拍贷 看起来像是RSA，所以搜索setpublicKey,混淆的话可能搜不到。 图中一个加密方法，一个解密方法，在加密方法的地方断点，找到调用栈上一层checkImgValidateCode,定位到加密位置 可以找到该段js最上面把加载器拷贝出来，按照之前的解决webpack模板方案解决或者通过系统网页js环境模板.txt拼接js解决。 本文将通过最原始的方案，首先将.prototype.decrypt = function所在js全部抠出来，在notepad++中语言选择JavaScript，视图中选择折叠所有层次，搜索加密代码return u(this.getKey().encrypt(t)),将本段function扣取出来 12345678910111213141516171819202122232425262728var jsss &#x3D; function(t, e, n) &#123; &quot;use strict&quot;; function r(t) &#123; return t &amp;&amp; t.__esModule ? t : &#123; default: t &#125; &#125; var i, o, a, s &#x3D; n(65), c &#x3D; r(s), u &#x3D; n(110), l &#x3D; r(u), d &#x3D; n(111), p &#x3D; r(d), f &#x3D; n(114), h &#x3D; r(f); !function(n, r) &#123; &quot;object&quot; &#x3D;&#x3D; (0, h.default)(e) &amp;&amp; void 0 !&#x3D;&#x3D; t ? r(e) : (o &#x3D; [e], i &#x3D; r, void 0 !&#x3D;&#x3D; (a &#x3D; &quot;function&quot; &#x3D;&#x3D; typeof i ? i.apply(e, o) : i) &amp;&amp; (t.exports &#x3D; a)) &#125;(0, function(t) &#123;...&#125;&#125;var e &#x3D; [jsss]function t(r) &#123; var o &#x3D; &#123; exports: &#123;&#125;, id: r, loaded: !1 &#125;; return e[r].call(o.exports,o,o.exports,t), o.loaded &#x3D; !0, o.exports &#125;t(0) 报错Cannot read property &#39;call&#39; of undefined,查看报错的位置 在追究n(65),n(110)之前，下面是一个自执行函数，n=0,r=function(t){…}，而r(e)中的e作为参数传到var jsss = function(t, e, n) 中交给e[r].call(o.exports,o,o.exports,t),调用e[0].call传参数，其中的e作为第二个参数，即o.exports，即{} 所以上面代码无效，自执行函数主要执行function(t) {...}并把e传入处理。 接下来将function(e){…}抠出来并修改为自执行并传入e!(function(t) {...})({})，放到控制台中运行报错Uncaught ReferenceError: p is not defined 去掉p.default ||重新运行 断点debug获取到publicKey后开启加密 123var aaa &#x3D; new window.JSEncryptaaa.setPublicKey(&quot;...&quot;)aaa.encrypt(&quot;123456&quot;) var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"},{"name":"fiddler","slug":"fiddler","permalink":"http://onejane.github.io/tags/fiddler/"}]},{"title":"某摩托的逆向分析","slug":"某摩托的逆向分析","date":"2021-07-27T10:16:18.000Z","updated":"2021-12-12T03:09:39.294Z","comments":true,"path":"2021/07/27/某摩托的逆向分析/","link":"","permalink":"http://onejane.github.io/2021/07/27/%E6%9F%90%E6%91%A9%E6%89%98%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 apk放入jadx-1.2.0中很明显被奇虎360加固了 使用PKiD再次确认 脱壳环境安卓8.1+fs128arm64+pyenv local 3.8.2 adb install 摩托邦4.8.0.2021070601.apk FRIDA-DEXDump对于完整的 dex，采用暴力搜索 DEX.035 即可找到。而对于抹头的 dex，通过匹配一些特征来找到。FRIDA-DEXDump纯粹的利用特征从内存中检索已经加载的 DEX 文件，而不需要拦截任何的函数得到一些结构体，并从中获取 DEX 的内存地址或其他相关信息。 12git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;FRIDA-DEXDump.git 支持搜索没有文件头的 DEX 文件python main.py 前台运行需要脱壳的app，将dump下的dex放到jadx-1.2.0中反编译 FART在设置中找到需要脱壳的应用配置sdcard存储空间权限，否则只能存到var savepath = &quot;/data/data/com.motoband&quot;;首先拷贝fart.so和fart64.so到/data/app目录下(权限不足就先放到/data/local/tmp再转移目录)，并使用chmod 777 设置好权限 frida_fart_reflection.js 用反射的方式实现的函数粒度的脱壳，与使用hook方式实现的方法不同,可以使用spawn和attach两种方式使用 调用dump(classname),传入要处理的类名，只完成对某一个类下的所有函数的CodeItem完成dump，效率更高，dump下来的类函数的所有CodeItem在含有类名的bin文件中 frida_fart_hook.js 使用hook的方式实现的函数粒度的脱壳，仅仅是对类中的所有函数进行了加载，但依然可以解决绝大多数的抽取保护,需要以spawn方式启动app，等待app进入Activity界面后，执行fart()函数即可 如果发现某个类中的函数的CodeItem没有dump下来，可以调用dump(classname),传入要处理的类名，完成对该类下的所有函数体的dump,dump下来的函数体会追加到bin文件当中 12345git clone https:&#x2F;&#x2F;github.com&#x2F;hanbinglengyue&#x2F;FART.gitfrida -UF -l frida_fart_reflection.jsfrida -U -f com.motoband -l frida_fart_reflection.js --no-pausefrida -U -f com.motoband -l frida_fart_hook.js --no-pausemv dex &#x2F;sdcard&#x2F;com.motoband&#x2F; 在使用爱莫助手下载 Youpk仅限机型pixel 1代，效果最好，脱的裤衩都没了 1237z x Youpk_sailfish.zip adb reboot bootloadercd sailfish-nzh54d &amp;&amp; sh flash-all.sh 安装apk后在Settings-Apps-摩托邦-Permissions启动存储权限 1234567adb shell &quot;echo com.motoband &gt;&gt; &#x2F;data&#x2F;local&#x2F;tmp&#x2F;unpacker.config&quot; 启动apk等待脱壳,每隔10秒将自动重新脱壳(已完全dump的dex将被忽略), 当日志打印unpack end时脱壳完成adb pull &#x2F;data&#x2F;data&#x2F;com.motoband&#x2F;unpacker pull出dump文件, dump文件路径为 &#x2F;data&#x2F;data&#x2F;包名&#x2F;unpackerjava -jar dexfixer.jar &#x2F;data&#x2F;data&#x2F;com.motoband&#x2F;unpacker &#x2F;data&#x2F;data&#x2F;com.motoband&#x2F;output 调用修复工具 dexfixer.jar, 两个参数, 第一个为dump文件目录(必须为有效路径), 第二个为重组后的DEX目录(不存在将会创建)adb install wifiadb.apkadb tcpip 5555 免root执行tcpip调试模式adb connect 172.20.103.254:5555 适用场景 整体加固 抽取: nop占坑型(类似某加密) naitve化, 在&lt;clinit&gt;中解密(类似早期阿里) goto解密型(类似新版某加密?najia) AUPK抓包charles+postern SSL handshake with client failed: An unknown issue occurred processing the certificate (certificate_unknown)看起来做了证书绑定，使用r0capture开启dump证书也未dump下来，无法正常抓包 ./fs1280arm64 启动frida，netstat -tnlp|grep 27042 查看占用端口 frida_ssl_logger核心原理就是对SSL_read和SSL_write进行hook，得到其收发包的明文数据 12python ssl_logger.py -U -f com.motobandpython ssl_logger.py -U -f com.motoband -p motoband.pcap 生成的pcap通过wireshark打开 OkHttpLogger-Frida由于所有使用的okhttp框架的App发出的请求都是通过RealCall.java发出的，那么我们可以hook此类拿到request和response,也可以缓存下来每一个请求的call对象，进行再次请求，所以选择了此处进行hook 12adb push okhttpfind.dex &#x2F;data&#x2F;local&#x2F;tmpfrida -U -l okhttp_poker.js -f com.motoband --no-pause 可追加 -o [output filepath]保存到文件 判断是否混淆，如果混淆需要修改okhttp_poker.js中的混淆后的变量 开启抓包 r0capture./fs14216arm64pyenv local 3.9.0 12345adb shell dumpsys activity activities 查看前台app包名python r0capture.py -U -f com.motoband -vpython r0capture.py -U -f com.motoband -v -p motoband.pcappython r0capture.py -U -f com.motoband -v &gt;&gt;motoband.txtfrida -U -f com.motoband -l script.js --no-pause -o motoband.txt ctrl+shift+o获取请求与请求头 ctrl+shift+o获取请求参数 拼装到postman中 分析通过Youpk脱下的dex一起放到jdax-1.2.0中，搜索seriesinfo @POST(&quot;car/seriesinfo&quot;) Observable&lt;ResponseBody&gt; motoInfo(@Body RequestBody requestBody); 查找用例位于com.motoband.core.manager.ChooseCarManager public Observable&lt;MotorbikeSeriesModel&gt; requestMotorInfo(String str, int i) { HashMap hashMap = new HashMap(); hashMap.put(IntentConstants.MODELID, str); hashMap.put(&quot;source&quot;, Integer.valueOf(i)); return RetrofitHelper.getObjectObservable(((ChooseCarService) RetrofitHelper.getRetrofit().create(ChooseCarService.class)).motoInfo(RetrofitHelper.getRequestBody(hashMap)), MotorbikeSeriesModel.class).observeOn(AndroidSchedulers.mainThread()).doOnNext($$Lambda$ChooseCarManager$XcbjKQVeNSK4TPlk0mzi1vIv6Z0.INSTANCE); } 显然getRequestBody就是生成众多加密参数的方法，位于com.motoband.core.http.RetrofitHelper public static RequestBody getRequestBody(Map&lt;String, Object&gt; map) { if (map == null) { map = new HashMap&lt;&gt;(); } long currentTimeMillis = System.currentTimeMillis(); map.put(&quot;token&quot;, UserInfo.getInstance().getToken()); map.put(MBRequestConstants.REQUEST_REQUESTID, CommonUtil.getRequestId(currentTimeMillis)); map.put(MBRequestConstants.REQUEST_CTYPE, &quot;2&quot;); map.put(MBRequestConstants.REQUEST_CVERSION, AppUtils.getAppVersionName()); map.put(&quot;citycode&quot;, UserInfo.getInstance().getCitycode()); if (!map.containsKey(&quot;userid&quot;)) { map.put(&quot;userid&quot;, UserInfo.getInstance().getUserid()); } if (!map.containsKey(MBRequestConstants.REQUEST_LONLAT)) { map.put(MBRequestConstants.REQUEST_LONLAT, UserInfo.getInstance().getLonlatStr()); } map.put(MBRequestConstants.REQUEST_PUSH_ID, JPushInterface.getRegistrationID(MBUtil.getContext())); ArrayList&lt;String&gt; arrayList = new ArrayList(); for (String str : map.keySet()) { if (map.get(str) == null) { arrayList.add(str); } } for (String str2 : arrayList) { map.remove(str2); } String str3 = null; try { str3 = RSAUtil.rsaSign(EncryptUtils.encryptMD5ToString(RSAUtil.getSignContent(map)).toLowerCase(), Constants.CLIENT_PRIVATE_KEY); } catch (Exception e) { e.printStackTrace(); System.out.println(MBResponseCode.RSA_SIGN_ERROR); } map.put(&quot;sign&quot;, str3); return RequestBody.create(MediaType.parse(HttpConstants.MediaType_Json), JSON.toJSONString(map)); } 多进程保护由于摩托邦存在多进程保护，基于信号的发送和接收，实现相互的保护防止被动态攻击。简单的双进程保护就是从原进程再fork一个空进程出来,让逆向分析的时候附加到空进程中导致hook不上。 双进程进程保护主要功能： 1、保护父进程，ptrace所有线程，防止被附加、调试、暂停； 2、保护子进程，防止被暂停、异常退出； objection附加双进程保护的app的时候报错,一般双进程保护,先把app关掉直接用spwan模式就能附加上。 查看frida源码和objection源码： frida附加的顺序:spawn-&gt;resume-&gt;attachobjection附加的顺序:spawn-&gt;attach-&gt;resume 123vim &#x2F;root&#x2F;.pyenv&#x2F;versions&#x2F;3.8.2&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;objection&#x2F;utils&#x2F;agent.py 添加如下代码 debug_print(&#39;Resuming PID test &#96;&#123;pid&#125;&#96;&#39;.format(pid&#x3D;self.spawned_pid)) self.device.resume(self.spawned_pid) 1234注释如下代码 #if not self.exports().ping(): # click.secho(&#39;Failed to ping the agent&#39;, fg&#x3D;&#39;red&#39;) # raise Exception(&#39;Failed to communicate with agent&#39;) 实际就是把resume放到步骤的中间,如果不行的话适当加个sleep就能附加上了 内存漫游123objection -g com.motoband explore -P ~&#x2F;.objection&#x2F;pluginsandroid hooking search classes com.motoband.core.manager.ChooseCarManager 搜索类android hooking list class_methods com.motoband.core.manager.ChooseCarManager 列出类方法 12plugin wallbreaker classdump com.motoband.core.http.RetrofitHelper 根据指定类dump类结构plugin wallbreaker objectdump --fullname 0x3576 查看类的值 123plugin wallbreaker classsearch com.motoband.core.http.RetrofitHelper 搜索所有相关类plugin wallbreaker objectsearch com.motoband.core.http.RetrofitHelper$1$1 搜索内存中指定类返回地址plugin wallbreaker objectdump --fullname 0x2d9a 根据地址dump类所有方法 1android hooking watch class_method com.motoband.core.manager.ChooseCarManager.requestMotorInfo --dump-backtrace --dump-args --dump-return hook指定方法requestMotorInfo，打印参数返回值调用栈 以上hook说明在requestMotorInfo中传入品牌型号3334后进入getRequestBody函数 12jobs list 查看进程中的任务jobs kill id 杀死hook任务 参数分析根据以上Jadx中的分析，App在请求car/seriesinfo时调用了RetrofitHelper.getRequestBody(hashMap))，在函数getRequestBody中对不同参数包括token,sign等进行了加密，并RequestBody.create(MediaType.parse(HttpConstants.MediaType_Json), JSON.toJSONString(map));最终将请求参数的HashMap转成JSONString作为create传递参数。 那么即可通过主动调用getRequestBody的同时hook函数RequestBody.create拿到第二个参数作为请求参数，由于headers中数据一致，加上请求url即可完成数据抓取。 1234567891011121314151617181920212223function hook_RequestBody_create()&#123; Java.perform(function()&#123; Java.use(&quot;okhttp3.RequestBody&quot;).create.overload(&#39;okhttp3.MediaType&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function(mediaType,str)&#123; var result &#x3D; this.create(mediaType,str) console.log(&quot;params&#x3D;&#x3D;&#x3D;&#x3D;&quot;,str) return result; &#125; &#125;)&#125;function Initiative_getRequestBody()&#123; Java.perform(function()&#123; var map &#x3D; Java.use(&#39;java.util.HashMap&#39;).$new(); var StringClass &#x3D; Java.use(&quot;java.lang.String&quot;); map.put(&quot;modelid&quot;, StringClass.$new(&quot;3334&quot;)); var RetrofitHelper &#x3D; Java.use(&quot;com.motoband.core.http.RetrofitHelper&quot;); RetrofitHelper.getRequestBody(map); &#125;)&#125;function main()&#123; console.log(&quot;Main&quot;) hook_RequestBody_create(); &#125;setImmediate(main) 以上完成绕过so层通过主动调用和hook的方式获取请求参数，接下来就是完成爬虫的具体逻辑。 抓包通过python r0capture.py -U com.motoband -v -p moto.pcap抓包分析各个页面请求并使用python实现，headers可以通过请求头加引号.py自动生成 选车列表12345678910111213141516headers &#x3D; &#123; &#39;Source&#39;: &#39;source&#39;, &#39;Date&#39;: &#39;Wed, 28 Jul 2021 10:42:37 GMT&#39;, &#39;Authorization&#39;: &#39;hmac id&#x3D;&quot;AKIDKpo6me25b14nzcNefQeoqR95syh2ayx97s0g&quot;, algorithm&#x3D;&quot;hmac-sha1&quot;, headers&#x3D;&quot;date source&quot;, signature&#x3D;&quot;LueIYYQhihnHza8ZIzzH3X1J6xM&#x3D;&quot;&#39;, &#39;Content-Type&#39;: &#39;application&#x2F;json; charset&#x3D;utf-8&#39;, &#39;Content-Length&#39;: &#39;396&#39;, &#39;Host&#39;: &#39;api.motuobang.com&#39;, &#39;Connection&#39;: &#39;Keep-Alive&#39;, &#39;Accept-Encoding&#39;: &#39;gzip&#39;, &#39;User-Agent&#39;: &#39;okhttp&#x2F;3.14.9&#39;&#125;param_str &#x3D; &#39;&#123;&quot;jpushregistrationid&quot;:&quot;18071adc03d4364a59f&quot;,&quot;ctype&quot;:&quot;2&quot;,&quot;citycode&quot;:&quot;0512&quot;,&quot;requestid&quot;:&quot;10120210728184237309B6FABE44946F25C3&quot;,&quot;brandid&quot;:0,&quot;sign&quot;:&quot;Un9ld6EYErQmE2ab0CgGP4pbqGKz8taTYlT2d4vgJlR1e6N3vp2Ld&#x2F;YHpZVHLAYQgdYxmHDPDmdPiapY&#x2F;Irewg&#x3D;&#x3D;&quot;,&quot;type&quot;:0,&quot;cversion&quot;:&quot;4.8.0.2021070601&quot;,&quot;userid&quot;:&quot;53AEB07289854E91A74DA4718D86617F&quot;,&quot;token&quot;:&quot;6A057F7AB0654DEBA3A9BAFE51A17D62&quot;,&quot;lonlat&quot;:&quot;[120.670592,31.295319]&quot;&#125;&#39;data &#x3D; requests.post(&#39;http:&#x2F;&#x2F;api.motuobang.com&#x2F;release&#x2F;car&#x2F;brandinfo&#39;, data&#x3D;param_str, headers&#x3D;headers).json()[&quot;data&quot;]brandlist &#x3D; json.loads(data)[&quot;brandlist&quot;] 品牌列表12345678910111213141516headers &#x3D; &#123; &#39;Source&#39;: &#39;source&#39;, &#39;Date&#39;: &#39;Wed, 28 Jul 2021 11:02:48 GMT&#39;, &#39;Authorization&#39;: &#39;hmac id&#x3D;&quot;AKIDKpo6me25b14nzcNefQeoqR95syh2ayx97s0g&quot;, algorithm&#x3D;&quot;hmac-sha1&quot;, headers&#x3D;&quot;date source&quot;, signature&#x3D;&quot;xUe79aim7V1Nur4J8DfN9KSDU0Q&#x3D;&quot;&#39;, &#39;Content-Type&#39;: &#39;application&#x2F;json; charset&#x3D;utf-8&#39;, &#39;Content-Length&#39;: &#39;396&#39;, &#39;Host&#39;: &#39;api.motuobang.com&#39;, &#39;Connection&#39;: &#39;Keep-Alive&#39;, &#39;Accept-Encoding&#39;: &#39;gzip&#39;, &#39;User-Agent&#39;: &#39;okhttp&#x2F;3.14.9&#39;&#125;param_str &#x3D; &#39;&#123;&quot;jpushregistrationid&quot;:&quot;18071adc03d4364a59f&quot;,&quot;searchcar&quot;:&quot;&#123;\\\\&quot;brandids\\\\&quot;:[28],\\\\&quot;haveabs\\\\&quot;:0,\\\\&quot;maxcc\\\\&quot;:0.0,\\\\&quot;maxmaxpower\\\\&quot;:0.0,\\\\&quot;maxprice\\\\&quot;:0,\\\\&quot;maxsitheight\\\\&quot;:0,\\\\&quot;maxxuhanglicheng\\\\&quot;:0,\\\\&quot;maxzuigaochesu\\\\&quot;:0,\\\\&quot;mincc\\\\&quot;:0.0,\\\\&quot;minmaxpower\\\\&quot;:0.0,\\\\&quot;minprice\\\\&quot;:0,\\\\&quot;minsitheight\\\\&quot;:0,\\\\&quot;minxuhanglicheng\\\\&quot;:0,\\\\&quot;minzuigaochesu\\\\&quot;:0,\\\\&quot;modelid\\\\&quot;:-1,\\\\&quot;month\\\\&quot;:0,\\\\&quot;pagenum\\\\&quot;:0,\\\\&quot;pagesize\\\\&quot;:200,\\\\&quot;searchtype\\\\&quot;:0,\\\\&quot;source\\\\&quot;:0,\\\\&quot;store\\\\&quot;:0,\\\\&quot;year\\\\&quot;:0&#125;&quot;,&quot;ctype&quot;:&quot;2&quot;,&quot;citycode&quot;:&quot;0512&quot;,&quot;requestid&quot;:&quot;10120210728190247800B530F6E7211E0724&quot;,&quot;sign&quot;:&quot;BeHwJ+uZ0BK7bR9z6Q4XifFqp0crBtwDouA3BxYYU7br2XQvwehJPrkfnn9MV&#x2F;PezYqMawUZI6zEDiplwJ49ug&#x3D;&#x3D;&quot;,&quot;cversion&quot;:&quot;4.8.0.2021070601&quot;,&quot;userid&quot;:&quot;53AEB07289854E91A74DA4718D86617F&quot;,&quot;token&quot;:&quot;5100BF109300497C83A51614C58314FD&quot;,&quot;lonlat&quot;:&quot;[120.67073,31.295348]&quot;&#125;&#39;data &#x3D; requests.post(&#39;http:&#x2F;&#x2F;api.motuobang.com&#x2F;release&#x2F;car&#x2F;searchv2&#39;, data&#x3D;param_str, headers&#x3D;headers).json()[&quot;data&quot;]print(json.loads(data)[&quot;serieslist&quot;]) 品牌详情12345678910111213141516headers &#x3D; &#123; &#39;Source&#39;: &#39;source&#39;, &#39;Date&#39;: &#39;Mon, 26 Jul 2021 05:47:06 GMT&#39;, &#39;Authorization&#39;: &#39;hmac id&#x3D;&quot;AKIDKpo6me25b14nzcNefQeoqR95syh2ayx97s0g&quot;, algorithm&#x3D;&quot;hmac-sha1&quot;, headers&#x3D;&quot;date source&quot;, signature&#x3D;&quot;jmwgtLvjj06A&#x2F;M&#x2F;TNcCqL72GRsk&#x3D;&quot;&#39;, &#39;Content-Type&#39;: &#39;application&#x2F;json; charset&#x3D;utf-8 &#39;, &#39;Content-Length&#39;: &#39;403&#39;, &#39;Host&#39;: &#39;api.motuobang.com&#39;, &#39;Connection&#39;: &#39;Keep-Alive&#39;, &#39;Accept-Encoding&#39;: &#39;gzip&#39;, &#39;User-Agent&#39;: &#39;okhttp&#x2F;3.14.&#39;&#125;param_str &#x3D; &#39;&#123;&quot;jpushregistrationid&quot;:&quot;1104a89792736fd015f&quot;,&quot;lonlat&quot;:&quot;[120.670593,31.295318]&quot;,&quot;ctype&quot;:&quot;2&quot;,&quot;sign&quot;:&quot;SJxFIJSEi7BwlnPLC&#x2F;6j3RfyxsR2EEEC2uWGpfC3&#x2F;MQl&#x2F;8gSCS5GcqSbre&#x2F;S3Jrrws+&#x2F;LYQzGE08T+Gv+tIIAg&#x3D;&#x3D;&quot;,&quot;source&quot;:0,&quot;token&quot;:&quot;89DFF7721007455D806E282F8195B0EF&quot;,&quot;requestid&quot;:&quot;10120210726134706717A11599A619EBCF39&quot;,&quot;citycode&quot;:&quot;0512&quot;,&quot;cversion&quot;:&quot;4.8.0.2021070601&quot;,&quot;userid&quot;:&quot;53AEB07289854E91A74DA4718D86617F&quot;,&quot;modelid&quot;:&quot;3387&quot;&#125;&#39;data &#x3D; requests.post(&#39;http:&#x2F;&#x2F;api.motuobang.com&#x2F;release&#x2F;car&#x2F;seriesinfo&#39;, data&#x3D;param_str, headers&#x3D;headers).json()[&quot;data&quot;]print(json.loads(data)[&quot;seriesinfo&quot;]) frida rpc 数据传递hook RequestBody.create由于RequestBody.create(MediaType.parse(HttpConstants.MediaType_Json), JSON.toJSONString(map));，hook create即可拿到入参=请求头加密参数。 1234567891011121314function hook_body_create()&#123; Java.perform(function()&#123; Java.use(&quot;okhttp3.RequestBody&quot;).create.overload(&#39;okhttp3.MediaType&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function(mediaType,str)&#123; var result &#x3D; this.create(mediaType,str) send(str) return result; &#125; &#125;)&#125;function main()&#123; console.log(&quot;Main&quot;) hook_body_create(); &#125;setImmediate(main) 主动调用searchv2查看选车列表时，搜索brandinfo @POST(&quot;car/brandinfo&quot;) Observable&lt;ResponseBody&gt; refreshBrandInfo(@Body RequestBody requestBody); 查找用例com.motoband.core.manager.MotoBrandManager 12android hooking watch class com.motoband.core.manager.MotoBrandManager --dump-args --dump-backtrace --dump-return 将整个类hook，点击触发类实现android hooking watch class_method com.motoband.core.manager.MotoBrandManager.requestBrandDetail --dump-args --dump-backtrace --dump-return hook触发的类方法并拿到参数为brandid 查看品牌列表时，搜索searchv2 @POST(&quot;car/searchv2&quot;) Observable&lt;ResponseBody&gt; searchNewMotoModelsV2(@Body RequestBody requestBody); 查找用例时有多个方法中调用，不过只有两个类，接下来通过objection hook上这两个类中的所有方法，点击指定品牌，触发car/searchv2 12android hooking watch class com.motoband.core.manager.ChooseCarManager --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method com.motoband.core.manager.ChooseCarManager.brandSeries --dump-args --dump-backtrace --dump-return 以上分析得知触发了com.motoband.core.manager.ChooseCarManager.brandSeries方法，传递第一个参数为brandid，结合jadx分析 public Observable&lt;CarFilterSearchModel&gt; brandSeries(String str, boolean z) { HashMap hashMap = new HashMap(); hashMap.put(&quot;searchcar&quot;, SearchMotoFilterModel.toBrandSeriesJson(Integer.parseInt(str), z)); return RetrofitHelper.getObjectObservable(((ChooseCarService) RetrofitHelper.getRetrofit().create(ChooseCarService.class)).searchNewMotoModelsV2(RetrofitHelper.getRequestBody(hashMap)), CarFilterSearchModel.class).observeOn(AndroidSchedulers.mainThread()); } 拼接searchcar到map中，通过getRequestBody获取加密请求参数。接下来尝试hook SearchMotoFilterModel.toBrandSeriesJson 拿到入参，利用frida实现主动调用。 123456789101112131415function hook_searchv2(id)&#123; Java.perform(function()&#123; var search_map &#x3D; Java.use(&#39;java.util.HashMap&#39;).$new(); var StringClass &#x3D; Java.use(&quot;java.lang.String&quot;); var IntegerClass &#x3D; Java.use(&quot;java.lang.Integer&quot;); var BooleanClass &#x3D; Java.use(&quot;java.lang.Boolean&quot;); var SearchMotoFilterModel &#x3D; Java.use(&#39;com.motoband.core.model.SearchMotoFilterModel&#39;).$new(); &#x2F;&#x2F; for brandinfo &#x2F;&#x2F; search_map.put(&quot;type&quot;, IntegerClass.$new(1)); &#x2F;&#x2F; search_map.put(&quot;brandid&quot;, StringClass.$new(id)); search_map.put(&quot;searchcar&quot;,SearchMotoFilterModel.toBrandSeriesJson(id,false)); var RetrofitHelper &#x3D; Java.use(&quot;com.motoband.core.http.RetrofitHelper&quot;); RetrofitHelper.getRequestBody(search_map); &#125;)&#125; 主动调用serials_info查看品牌详情时，搜索seriesinfo @POST(&quot;car/seriesinfo&quot;) Observable&lt;ResponseBody&gt; motoInfo(@Body RequestBody requestBody); 查找用例 public Observable&lt;MotorbikeSeriesModel&gt; requestMotorInfo(String str, int i) { HashMap hashMap = new HashMap(); hashMap.put(IntentConstants.MODELID, str); hashMap.put(&quot;source&quot;, Integer.valueOf(i)); return RetrofitHelper.getObjectObservable(((ChooseCarService) RetrofitHelper.getRetrofit().create(ChooseCarService.class)).motoInfo(RetrofitHelper.getRequestBody(hashMap)), MotorbikeSeriesModel.class).observeOn(AndroidSchedulers.mainThread()).doOnNext($$Lambda$ChooseCarManager$XcbjKQVeNSK4TPlk0mzi1vIv6Z0.INSTANCE); } hook实现 123456789function hook_seriesinfo(id)&#123; Java.perform(function()&#123; var map &#x3D; Java.use(&#39;java.util.HashMap&#39;).$new(); var StringClass &#x3D; Java.use(&quot;java.lang.String&quot;); map.put(&quot;modelid&quot;, StringClass.$new(id)); var RetrofitHelper &#x3D; Java.use(&quot;com.motoband.core.http.RetrofitHelper&quot;); RetrofitHelper.getRequestBody(map); &#125;)&#125; rpc调用frida主动调用各个方法时，同时间hook RequestBody.create方法，拿到关键加密参数，rpc发送给python，完成爬虫数据拼装，实现数据抓取。 js 12345rpc.exports &#x3D; &#123; hookseriesinfo: hook_seriesinfo, hooksearchv2: hook_searchv2, hookbodybreate: hook_body_create&#125; python 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import time import fridaimport requestsimport jsondef my_message_handler(message, payload): if message[&quot;type&quot;] &#x3D;&#x3D; &quot;send&quot;: # print(&quot;payload如下:&quot;,message[&quot;payload&quot;]) payload &#x3D; json.loads(message[&quot;payload&quot;]) if &quot;searchcar&quot; in payload: # searchv2 print(&quot;searchv2&quot;) serials &#x3D; searchv2(payload) for s in serials: brandname &#x3D; s[&#39;brandname&#39;] name &#x3D; s[&#39;name&#39;] modelid &#x3D; s[&#39;modelid&#39;] name_model_dict[brandname+&quot;_&quot;+name] &#x3D; modelid else: # seriesinfo print(&quot;seriesinfo&quot;) serialsinfo &#x3D; seriesinfo(payload) pdfurl &#x3D; serialsinfo[&quot;pdfurl&quot;] name &#x3D; serialsinfo[&quot;name&quot;] brandname &#x3D; serialsinfo[&quot;brandname&quot;] print(&quot;pdfurl:&quot;,pdfurl) if not pdfurl.isspace(): down_res &#x3D; requests.get(url&#x3D;pdfurl) with open(brandname+&quot;_&quot;+name+&quot;.pdf&quot;,&quot;wb&quot;) as f: f.write(down_res.content) # input()device &#x3D; frida.get_usb_device()# pid &#x3D; device.spawn([&quot;com.motoband&quot;])# device.resume(pid)# time.sleep(10)session &#x3D; device.attach(&quot;com.motoband&quot;)with open(&quot;motoband.js&quot;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot;, my_message_handler) script.load()# request for brandinfo headers &#x3D; &#123; &#39;Source&#39;: &#39;source&#39;, &#39;Date&#39;: &#39;Wed, 28 Jul 2021 10:42:37 GMT&#39;, &#39;Authorization&#39;: &#39;hmac id&#x3D;&quot;AKIDKpo6me25b14nzcNefQeoqR95syh2ayx97s0g&quot;, algorithm&#x3D;&quot;hmac-sha1&quot;, headers&#x3D;&quot;date source&quot;, signature&#x3D;&quot;LueIYYQhihnHza8ZIzzH3X1J6xM&#x3D;&quot;&#39;, &#39;Content-Type&#39;: &#39;application&#x2F;json;*&#x2F;jg charset&#x3D;utf-8&#39;, &#39;Content-Length&#39;: &#39;396&#39;, &#39;Host&#39;: &#39;api.motuobang.com&#39;, &#39;Connection&#39;: &#39;Keep-Alive&#39;, &#39;Accept-Encoding&#39;: &#39;gzip&#39;, &#39;User-Agent&#39;: &#39;okhttp&#x2F;3.14.9&#39;&#125;param_str &#x3D; &#39;&#123;&quot;jpushregistrationid&quot;:&quot;18071adc03d4364a59f&quot;,&quot;ctype&quot;:&quot;2&quot;,&quot;citycode&quot;:&quot;0512&quot;,&quot;requestid&quot;:&quot;10120210728184237309B6FABE44946F25C3&quot;,&quot;brandid&quot;:0,&quot;sign&quot;:&quot;Un9ld6EYErQmE2ab0CgGP4pbqGKz8taTYlT2d4vgJlR1e6N3vp2Ld&#x2F;YHpZVHLAYQgdYxmHDPDmdPiapY&#x2F;Irewg&#x3D;&#x3D;&quot;,&quot;type&quot;:0,&quot;cversion&quot;:&quot;4.8.0.2021070601&quot;,&quot;userid&quot;:&quot;53AEB07289854E91A74DA4718D86617F&quot;,&quot;token&quot;:&quot;6A057F7AB0654DEBA3A9BAFE51A17D62&quot;,&quot;lonlat&quot;:&quot;[120.670592,31.295319]&quot;&#125;&#39;data &#x3D; requests.post(&#39;http:&#x2F;&#x2F;api.motuobang.com&#x2F;release&#x2F;car&#x2F;brandinfo&#39;, data&#x3D;param_str,headers&#x3D;headers).json()[&quot;data&quot;]brandlist &#x3D; json.loads(data)[&quot;brandlist&quot;]for brand in brandlist: brandname &#x3D; brand[&quot;name&quot;] brandid &#x3D; str(brand[&quot;brandid&quot;]) # 1.创建文件夹 # 2.request for searchv2 script.exports.hooksearchv2(brandid) # print(name_model_dict) # 3.request for seriesinfo for (key,value) in name_model_dict.items(): # print(key+&quot;:&quot;+str(value)) script.exports.hookseriesinfo(str(value)) # input() var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"rpc","slug":"rpc","permalink":"http://onejane.github.io/tags/rpc/"}]},{"title":"NDK开发详解之NDK开发简介","slug":"NDK开发详解之NDK开发简介","date":"2021-07-25T13:22:20.000Z","updated":"2022-04-30T09:50:53.038Z","comments":true,"path":"2021/07/25/NDK开发详解之NDK开发简介/","link":"","permalink":"http://onejane.github.io/2021/07/25/NDK%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3%E4%B9%8BNDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 JNI简述JNI：Java Native Interface的缩写，通常翻译为JAVA本地 接口。从Java1.1开始，Java Native Interface(JNI)标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为本地已编译语言，尤其是 C和C++而设计的，但是它并不妨碍你使用其他语言，只要调用约定受支持就可以了。 JNI不是Android特有，windows、linux等凡是有JVM的地方都支持JNI。Android的Dalvik/ART虚拟机同样支持JNI标准。通过JNI，便可以打通Android里的两个世界：JAVA世界和Native世界。可以说，JNI是Java和Native世界的桥梁。而背后的一切都由Dalvik/ART虚拟机来驱动。 JAVA特点特性：简单、面向对象、分布式、编译和解释性、健壮性、跨平台性（Write Once，Run Anywhere）、多线程、动态性等等 但是：性能较低、易于逆向分析等问题。 因此，如何能够提高java程序的性能以及如何能够实现对海量已有C/C++代码库的复用问题？ NDK简述NDK 即Native Development Kit，因此称为“NDK”， 完成使用JNI提供的接口与java层的交互。 NDK是一系列工具的集合。 NDK提供了工具链，帮助开发者快速开发以及调试C（或C++）的动态库。 NDK提供了一份稳定、功能有限的API库。 不同于linux的glibc，Android采用的是Google Bionic Libc，大部分api是一致的。 一些重要逻辑、算法可以采用C/C++、甚至是汇编的形式通过NDK的工具链最终编译生成动态库，最后通过JNI完成和Dalvik/ART虚拟机环境中的Java代码的交互 使用NDK开发的so不再具有跨平台特性，需要编译提供不同平台支持。ABI：ApplicationBinary Interface 优点 运行效率高：Android开发的原生代码不需要在Dalvik/ART虚拟机下运行，直接运行的汇编代码 代码安全性高：Java层代码很容易被反编译，而C/C++反编译难度较大，代码混淆比如使用ollvm，字符串加密等保护汇编代码。同时，相对于针对Java代码的混淆保护来说，可以运用当前一切C/C++代码保护技术，如控制流混淆，加壳等； 易于移植，可复用海量代码库：当时用第三方 C/C++开源库时便于移植，可以充分复用C/C++海量代码库 缺点 开发效率低：和Android的Java世界(Dalvik/ART)交互繁琐，无法直接使用Android系统框架提供的丰富API 开发难度大：对于当前市面的APP开发人员来说掌握JNI开发存在一定困难 稳定性难以保证：对开发人员要求较高，如存在内存泄漏出现的频率搞，修正bug困难。 对于Android中的java函数，在Dalvik时代分为解释模式和JIT模式，JIT根据代码运行过程中的频度进行编译提升运行效率，4.4后的art中新增dex2oat流程，直接对dex中所有的函数进行编译，而不是像4.4在运行过程中JIT对热点代码编译。在app在运行前将字节码编译成汇编代码，能够提升app运行效率，必然在安装时需要对dex中函数编译很耗时，耗电，因此生成代码量很大，占用很大的内存，安装耗时，如在dexclassloader动态加载时dex2oat编译过程很耗时，很耗电，很占存储。在7.0后结合AOT和AIT混合编译。 ART 的运作方式 最初安装应用时不进行任何 AOT 编译。应用前几次运行时，系统会对其进行解译，并对经常执行的方法进行 JIT 编译。 当设备闲置和充电时，编译守护程序会运行，以便根据在应用前几次运行期间生成的配置文件对常用代码进行 AOT 编译。 下一次重新启动应用时将会使用配置文件引导型代码，并避免在运行时对已经过编译的方法进行 JIT 编译。在应用后续运行期间经过 JIT 编译的方法将会添加到配置文件中，然后编译守护程序将会对这些方法进行 AOT 编译。 Java函数运行模式 纯解释模式下执行 JIT模式 经过dex2oat编译后在quick模式下运行 注意：Android 7.0（代号Nougat，简称N）开始结合用AOT，即时（JIT编译和配置文件引导型编译）。因此一个java函数可能运行在解释模式，JIT或者quick模式 JNI与NDK的关系 NDK开发1as新建项目类型选择Native C++，项目名为ndk01 extern C : 由于C++支持重载，C++类中的函数会有name mangling jni函数的参数问题：JNIEnv* 和jobject以及JNIEnv*和jclass JNICALL: 空宏 JNIEXPORT: __attribute__((visibility(“default”)))，代表当前函数符号需要导出，与之对应的为hidden隐藏符号信息 AndroidStudio默认生成函数名很长，如：Java_com_kanxue_ndk01_MainActivity_stringFromJN 12cp &#x2F;system&#x2F;lib&#x2F;libc.so &#x2F;sdcardadb pull &#x2F;sdcard&#x2F;libc.so 使用ida打开后查看fopen MainActivity.java 123int result &#x3D; this.myfirstjni(10); 在onCreate中调用public native String stringFromJNI();public native int myfirstjni(int a); 一般函数修改native-lib.cpp.cpp编译后打开libnative-lib.so 1234567891011121314151617&#x2F;&#x2F; 对函数名称按照c++的name mangling编译后修改函数名int add(int a, int b) &#123; return a + b;&#125;&#x2F;&#x2F; 按照c风格保留函数符号名extern &quot;C&quot; int add1(int a, int b) &#123; return a + b;&#125;&#x2F;&#x2F; 以C函数形式编译，JNIEXPORT告知编译器编译后导出函数名保留，IDA打开so后显示相同的静态注册的函数名，在IDA中左侧搜索Java检索到该方法&#x2F;&#x2F; 该函数静态注册，art中对jni函数查询过程决定以下划线拼接这么长的函数名extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_kanxue_ndk01_MainActivity_stringFromJNI( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; std::string hello &#x3D; &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str());&#125; JNIEnv: 是一个JNI接口指针，指向了本地方法的函数表，该函数表中每一个成员指向了一个JNI函数。 静态函数testc.h 1234567#ifndef NDK01_TESTC_H#define NDK01_TESTC_H#endif &#x2F;&#x2F;NDK01_TESTC_H#include &lt;stdio.h&gt;int add_c(int a,int b); testc.c 1234567891011#include &lt;stdbool.h&gt;#include &quot;testc.h&quot;#include &quot;jni.h&quot;int add_c(int a,int b)&#123; return a+b;&#125;jboolean testc(JNIEnv* env,jobject obj,jstring c)&#123; (*env)-&gt;GetStringUTFChars(env,c,NULL); return true;&#125; native-lib.cpp 1234567891011extern &quot;C&quot; &#123;#include &quot;testc.h&quot;&#125;extern &quot;C&quot; JNIEXPORT void JNICALLJava_com_kanxue_ndk01_MainActivity_staticfunc(JNIEnv *env, jclass &#x2F;* this *&#x2F;) &#123;&#x2F;&#x2F; __android_log_print(int prio, const char* tag, const char* fmt, ...) int result &#x3D; add_c(4, 6); __android_log_print(ANDROID_LOG_INFO, &quot;JNI&quot;, &quot;JNI-&gt;%d&quot;, result);&#125; MainActivity.java 123456789String gbkStr &#x3D; &quot;中国人民&quot;; &#x2F;&#x2F;源码文件是GBK格式，或者这个字符串是从GBK文件中读取出来的, 转换为string 变成unicode格式&#x2F;&#x2F;利用getBytes将unicode字符串转成UTF-8格式的字节数组byte[] utf8Bytes &#x3D; gbkStr.getBytes(&quot;UTF-8&quot;);&#x2F;&#x2F;然后用utf-8 对这个字节数组解码成新的字符串String utf8Str &#x3D; new String(utf8Bytes, &quot;UTF-8&quot;);MainActivity.testString(utf8Str);public static native void staticfunc(); JNI类型映射基础数据类型Native Type这8种数据类型可以C/C++中直接使用,包括域描述符,类描述符斜杠区分，函数描述符（参数域描述符叠加）返回类型描述符 Java类型 本地类型（Native Type） 描述 域描述符 boolean jboolean C/C++无符号8位整型(unsigned char) Z byte jbyte C/C++带符号8位整型(char) B char jchar C/C++无符号8位整型(unsigned short) C short jshort C/C++带符号8位整型(short) S int jint C/C++带符号8位整型(int) I long jlong C/C++带符号8位整型(long) J float jfloat C/C++32位浮点型(float) F double jdouble C/C++64位浮点型(double) D 引用数据类型为L+该类型的类描述符+;String类型域描述符为Ljava/lang/String, int[]描述符为[I, float[]描述符为[F,String[]描述符为[Ljava/lang/String;,Object[]域描述符为[Ljava/lang/Object;,int[][] [][]描述符为[[I,float[][]描述符为[[F 引用数据类型 JNI数据类型 java数据类型 jobject java.lang.Object jclass java.lang.Class jstring java.lang.String jthrowable java.lang.Throwable MainActivity.java 123public native int myfirstjni(int a);public native boolean booleantest(boolean a); native-lib.cpp 123456789101112extern &quot;C&quot; JNIEXPORT jint JNICALLJava_com_kanxue_ndk01_MainActivity_myfirstjni(JNIEnv *env, jobject &#x2F;* this *&#x2F;, jint a) &#123; int result &#x3D; 0; for (int i &#x3D; 1; i &lt; a; i++) &#123; result &#x3D; result + i; &#125; return result;&#125;extern &quot;C&quot; JNIEXPORT jboolean JNICALLJava_com_kanxue_ndk01_MainActivity_booleantest(JNIEnv *env, jobject &#x2F;* this *&#x2F;, jboolean a) &#123; return a;&#125; JNI其他类型123456789101112131415成员域ID,成员方法IDstruct _jfieldId; typedef struct _jfieldID* jfieldId;struct _jmethodID;typedef struct_jmethodID* jmethodId;typedef union jvalue&#123; jboolean z; jbyte b; jshort s; jint i; jlong j; jfloat f; jdouble d; jobject l;&#125;jvalue; jni字符串操作jstring NewStringUTF( const char* bytes)):函数使用给定的C字符串创建一个新的JNI字符串( jstring),不能为构造的 java. lang String分配足够的内存, NewStringUTF会抛出一个 OutOfMemoryError异常,并返回一个NULL const char* GetStringUTFChars(jstring string, boolean* is Copy):函数可用于从给定的Java的 jstring创建新的C字符串(char*)。如果无法分配内存,则该函数返回NULL。检査NULL是一个好习惯。不要忘记检查。因为该函数需要为新诞生的UTF8字符串分配内存,这个操作有可能因为内存太少而失败。失败时, GetStringUTFChars会返回NULL,并抛出一个 OutofMemoryError异常,在不使用 GetStringUTFChars()返回的字符串时,需要来释放内存和引用以便可以对其进行垃圾回收,因此之后应始终调用 ReleaseStringUTFChars() jsize GetStringUTFLength(jstring string):用于获取 jstring的长度 MainActivity.java 1234String resultString&#x3D;testjstringapis(&quot;hello from java&quot;); 在onCreate中调用Log.i(&quot;kanxue&quot;, &quot;result:&quot; + resultString);public native String testjstringapis(String content); native-lib.cpp 123456789101112131415extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_kanxue_performancetest01_MainActivity_testjstringapis( JNIEnv *env, jobject &#x2F;* this *&#x2F;,jstring content) &#123; const char* a&#x3D;env-&gt;GetStringUTFChars(content,nullptr); &#x2F;&#x2F; 将java中字符串转成c&#x2F;c++使用的char * int jstring_size&#x3D;env-&gt;GetStringUTFLength(content); &#x2F;&#x2F; 获取jstring长度 if(a!&#x3D; nullptr)&#123; __android_log_print(ANDROID_LOG_INFO,&quot;kanxue&quot;, &quot;char content:%s,size:%d&quot;, a,jstring_size); &#125; env-&gt;ReleaseStringUTFChars(content,a); &#x2F;&#x2F; 不使用该字符串手动释放内存 jstring result&#x3D;env-&gt;NewStringUTF(&quot;Hello from jni&quot;); &#x2F;&#x2F; 创建新字符串 return result; &#x2F;&#x2F; 返回给java层&#125; api如下 12345678jstring(* NewString)(JNIEnv*, const char*,jsize);&#x2F;&#x2F;新建一个 unicode编码字符串jsize(* GetStringLength)(JNIEnv*, jstring);&#x2F;)回 unicode编码的字符串的长度const jchar*(* GetStringChars)(JNIEnv*, jstring, jboolean*);&#x2F;&#x2F;返回一个 unicode编码的 jstring的 char指针void(* Release String Chars)(JNIEnv*, jstring, const jchar*):&#x2F;释放使用 Newstring时分配的内存string(* NewStringUTF)(JNIEnv*, const char*);&#x2F;&#x2F;char为1个字节,ut8编码字符串jsize(* GetStringUTFLength)(JNIEnv*, jstring);&#x2F;返回utf8编码的字符串的字节长度,字符个数const char*(*GetStringUTFChars)(JNIEnv*, jstring, jboolean*);void (*ReleaseStringUTFChars( JNIEnv*, jstring, const char*);&#x2F;释放使用 NewStringUTFChars时分配的内存 NDK开发2ANDROID: 使用OATDUMP反编译OAT文件：用来对dex2oat编译生成oat文件进行反汇编，看到dex2oat编译的结果 as新建项目类型选择Native C++，项目名为PerformanceTest01 MainActivity.java 123456789int result &#x3D; java_add(1000000); &#x2F;&#x2F; 在onCreate中调用public int java_add(int num) &#123; int result &#x3D; 0; for (int i &#x3D; 0; i &lt;&#x3D; num; i++) &#123; result &#x3D; result + i; &#125; return result;&#125; 编译好后安装到手机上，ls /data/app/com.kanxue.performancetest01-*/oat/arm64可以看到base.dex和base.vdex ART 包括一个编译器（dex2oat 工具）和一个为启动 Zygote 而加载的运行时 (libart.so)。dex2oat 工具接受一个 APK 文件，并生成一个或多个编译工件文件，然后运行时将会加载这些文件。文件的个数、扩展名和名称因版本而异，但在 Android O 版本中，将会生成以下文件： .vdex：其中包含 APK 的未压缩 DEX 代码，以及一些旨在加快验证速度的元数据。 .odex：其中包含 APK 中已经过 AOT 编译的方法代码。 .art (optional)：其中包含 APK 中列出的某些字符串和类的 ART 内部表示，用于加快应用启动速度。 12adb pull &#x2F;sdcard&#x2F;base.dex010Editor base.vdex 删除dex.035.前面的内容,保存为dex文件解析并可以查看函数列表，改名vdex为dex使用jadx打开 123oatdump --oat-file&#x3D;base.dex &gt;&gt; &#x2F;sdcard&#x2F;oatdump1.txtadb pull &#x2F;sdcard&#x2F;oatdump1.txt010Editor oatdump1.txt 输出函数的smali指令，编译函数后的偏移，dex2oat生成的汇编指令 说明还没有被dex2oat编译。nexus 6p默认Android7.0在最初安装时不进行AOT编译，通过查看7.0以前nexus 5的ART来对比编译后的汇编代码，安装完直接编译。编译好后安装到手机上，ls /data/app/com.kanxue.performancetest01-*/oat/arm可以看到base.odex 123oatdump --oat-file&#x3D;base.dex &gt;&gt; &#x2F;sdcard&#x2F;6.0oatdump.txtadb pull &#x2F;sdcard&#x2F;0oatdump.txt010Editor 0oatdump.txt 输出函数的smali指令，编译函数后的偏移，dex2oat生成的汇编 说明6.0时smali正常显示，CODE部分已经编译生成汇编代码，当6.0安装完该函数必然运行在quick下，并不会解释执行原有的java代码。 解释模式MainActivity.java 123456789101112在onCreate中调用两个函数对比时间效率long start &#x3D; System.nanoTime();int result &#x3D; java_add(1000000);long end &#x3D; System.nanoTime();Log.i(&quot;kanxue&quot;, &quot;result:&quot; + result + &quot;--&quot; + (end - start));start &#x3D; System.nanoTime();result &#x3D; jni_add(1000000);end &#x3D; System.nanoTime();Log.i(&quot;kanxue&quot;, &quot;result:&quot; + result + &quot;--&quot; + (end - start));public native int jni_add(int num); native-lib.cpp 123456789101112131415extern &quot;C&quot; JNIEXPORT jint JNICALLJava_com_kanxue_performancetest01_MainActivity_jni_1add( JNIEnv *env, jobject obj&#x2F;* this *&#x2F;, jint num) &#123; jclass thisclazz&#x3D;env-&gt;GetObjectClass(obj); jmethodID add_mid&#x3D;env-&gt;GetMethodID(thisclazz,&quot;add&quot;,&quot;()V&quot;); jint result &#x3D; 0; for (int i &#x3D; 0; i &lt;&#x3D; num; i++) &#123; result &#x3D; result + i; &#125; return result;&#125; 首先比较在纯解释模式下运行java函数和jni函数花销，自然不能让art下的dex2oat的编译流程完成对java函数的编译。在8.0后app安装完后的函数还是没有被编译，运行在解释模式下的。运行了一定时间后，某些函数就已经被编译了。自然导致在7.0以后函数运行在不同模式下都有可能。首先要让函数运行在解释模式下，可以通过禁用art下的dex2oat的编译流程， 或者使用4.4之前的dalvik的执行环境，必然是在一个解释模式下的。那么使用4.4的hammerhead安装该app，自然默认运行在dalvik下。 12result:1784293664--23747499 smali指令在纯解释模式，jni大致是java函数的5倍result:1784293664--4924895 quick模式接下来对比art下经过dex2oat编译后的quick模式下java函数执行的时间花销和jni函数的时间花销，首先保证java函数被dex2oat编译，且函数运行在quick模式下，也就是编译后的汇编代码。7.0以后一开始是没有编译，是在解释模式下，只有在运行一段时间后，调用频率比较高时在充电或者闲置时会被编译。自然确保确实被编译运行在dex2oat的quick模式下，可以使用7.0以前的art测试，可以使用6.0的hammerhead，安装好app后这个时候运行的java函数就会被编译成了汇编了。 12result:1784293664--5778594 java函数经过dex2oat编译以后运行在quick模式下时花销是jni花销的一倍多一点result:1784293664--3798072 性能提升总结以上分别比较相同代码逻辑的java函数和jni函数的时间代价。 java函数运行模式 在4.4以前的dalvik下运行或者art下利用hook禁用掉dex2oat过程强制让其运行在解释模式 使用Android6.0测试java函数在quick模式（运行dex2oat编译以后的汇编代码） jni函数实现 和java函数相同的逻辑，纯C/C++实现 和java函数相同的逻辑，经过JNI提供的接口频繁调用java函数 Java反射java反射:java反射机制是在运行状态中,对于任意类,都能够知道这个类的所有属性和方法;对于任意类的静态属性和方法,都能够完成对静态属性的获取和设置以及静态方法的调用;对于任意个对象,都能够调用它的任意方法和属性;这种动态获取信息以及动态调用对象方法的功能称为ava语言的反射机制。 在日常的第三方应用开发过程中,经常会遇到某类的某个成员变量、方法或是属性是私有的或是只对系统应用开放,这时候就可以利用Java的反射机制通过反射来获取所需的私有成员或是方法。而对于public类型的成员变量和方法和属性都可以使用反射来进行访问。 类名 用途 Class类 代表类的实体，在运行的Java应用程序中表示类和接口 Field类 代表类的成员变量（成员变量也成为了类的属性） Method类 代表类的方法 Constructor类 代表类的构造方法 Class代表类的实体，在运行的Java应用程序中表示类和接口。在类中提供了很多有用的方法。 获取类中属性相关方法 获取类中注解相关方法 获取类中构造器相关方法 获取类中方法的相关方法 获取类中其他重要的方法 FieldField代表类的成员变量（成员变量也称为类的属性） Method Constructor 破坏本身的封装性和安全性,访问 private域和方法类 AccessibleObject中有函数 public void setAccessible( boolean flag),该函数在传入tue作为参数后,让访问 private修饰的域和函数成为可能。而Method、Feld和 Constructot类共同继承了 AccessibleObject类,该基类有两个 setAccessible方法能在运行时压制Java语言访问控制检查(Javalanguage access control checks),从而能任意调用被私有化保护的方法域和构造方法 新建C++项目ReflectionTest3 Test.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class Test &#123; public String flag &#x3D; null; public int[] intarray &#x3D; null; public Test() &#123; flag &#x3D; &quot;Test()&quot;; intarray &#x3D; new int[10]; for (int i &#x3D; 0; i &lt; 10; i++) &#123; intarray[i] &#x3D; i; &#125; &#125; public Test(String arg) &#123; flag &#x3D; &quot;Test(String arg)&quot;; intarray &#x3D; new int[10]; for (int i &#x3D; 0; i &lt; 10; i++) &#123; intarray[i] &#x3D; i; &#125; &#125; public Test(String arg, int arg2) &#123; flag &#x3D; &quot;Test(String arg,int arg2)&quot;; intarray &#x3D; new int[10]; for (int i &#x3D; 0; i &lt; 10; i++) &#123; intarray[i] &#x3D; i; &#125; &#125; public static String publicStaticField &#x3D; &quot;i am a publicStaticField&quot;; public static int publicStaticField_int &#x3D; 100; public String publicField &#x3D; &quot;i am a publicField&quot;; private static String privateStaticField &#x3D; &quot;i am a privateStaticField&quot;; private String privateField &#x3D; &quot;i am a privateField&quot;; private int privateField_int &#x3D; 200; public static void publicStaticFunc() &#123; Log.i(&quot;kanxue&quot;, &quot;i am from publicStaticFunc&quot;); &#125; public static int publicStaticFunc_int(int a) &#123; Log.i(&quot;kanxue&quot;, &quot;i am from publicStaticFunc_int&quot;); return 100 + a; &#125; public static String publicStaticFunc_string(String arg) &#123; Log.i(&quot;kanxue&quot;, &quot;i am from publicStaticFunc_int&quot;); return &quot;publicStaticFunc_string-&gt;&quot; + arg; &#125; public void publicFunc() &#123; Log.i(&quot;kanxue&quot;, &quot;i am from publicFunc&quot;); &#125; &#x2F;&#x2F;add private String privatetest(int a, String b) &#123; Log.i(&quot;kanxue&quot;, &quot;privatetest func is called:&quot; + a + &quot;---&quot; + b); return b + a; &#125; private static void privateStaticFunc() &#123; Log.i(&quot;kanxue&quot;, &quot;i am from privateStaticFunc&quot;); &#125; private int[] privateFunc_array(int num) &#123; Log.i(&quot;kanxue&quot;, &quot;i am from privateStaticFunc&quot;); int array[] &#x3D; new int[num]; for (int i &#x3D; 0; i &lt; array.length; i++) &#123; array[i] &#x3D; i; &#125; return array; &#125; private static void privateFunc() &#123; Log.i(&quot;kanxue&quot;, &quot;i am from privateStaticFunc&quot;); &#125;&#125; MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137testField(); 在onCreate中调用testMethod();public void testField() &#123; Test a_obj &#x3D; new Test(); Test b_obj &#x3D; new Test(&quot;test&quot;); Test c_obj &#x3D; new Test(&quot;test&quot;, 2); Class testClazz &#x3D; null; try &#123; testClazz &#x3D; MainActivity.class.getClassLoader().loadClass(&quot;com.kanxue.reflectiontest.Test&quot;); Log.i(&quot;kanxue&quot;, &quot;ClassLoader.loadClass-&gt;&quot; + testClazz); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Class testClazz2; try &#123; testClazz2 &#x3D; Class.forName(&quot;com.kanxue.reflectiontest.Test&quot;); Log.i(&quot;kanxue&quot;, &quot;Class.forName-&gt;&quot; + testClazz2); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Class testClazz3 &#x3D; Test.class; Log.i(&quot;kanxue&quot;, &quot;Test.class-&gt;&quot; + testClazz); try &#123; Field publicStaticField_field &#x3D; testClazz3.getDeclaredField(&quot;publicStaticField&quot;); Log.i(&quot;kanxue&quot;, &quot;getDeclaredField-&gt;&quot; + publicStaticField_field); String content &#x3D; (String) publicStaticField_field.get(null); Log.i(&quot;kanxue&quot;, &quot;publicStaticField-&gt;&quot; + content); content &#x3D; (String) publicStaticField_field.get(a_obj); Log.i(&quot;kanxue&quot;, &quot;publicStaticField-&gt;a_obj&quot; + content); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;privateField try &#123; Field privateStaticField_field &#x3D; testClazz3.getDeclaredField(&quot;privateStaticField&quot;); Log.i(&quot;kanxue&quot;, &quot;getDeclaredField-&gt;&quot; + privateStaticField_field); privateStaticField_field.setAccessible(true); privateStaticField_field.set(null, &quot;modified&quot;); String content &#x3D; (String) privateStaticField_field.get(null); Log.i(&quot;kanxue&quot;, &quot;privateStaticField_field-&gt;&quot; + content); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; try &#123; Field privateField_field &#x3D; testClazz3.getField(&quot;privateField&quot;); Log.i(&quot;kanxue&quot;, &quot;getField-&gt;&quot; + privateField_field); &#125; catch (Error | NoSuchFieldException e) &#123; e.printStackTrace(); &#125; Field[] fields &#x3D; testClazz3.getDeclaredFields(); for (Field i : fields) &#123; Log.i(&quot;kanxue&quot;, &quot;getDeclaredFields-&gt;&quot; + i); &#125; Field[] fields_1 &#x3D; testClazz3.getFields(); for (Field i : fields_1) &#123; Log.i(&quot;kanxue&quot;, &quot;getFields-&gt;&quot; + i); &#125;&#125;public void testMethod() &#123; Class testClazz &#x3D; Test.class; Method publicStaticFunc_method &#x3D; null; try &#123; publicStaticFunc_method &#x3D; testClazz.getDeclaredMethod(&quot;publicStaticFunc&quot;); publicStaticFunc_method.invoke(null); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; Log.i(&quot;kanxue&quot;, &quot;getDeclaredMethod-&gt;&quot; + publicStaticFunc_method); Method privateStaticFunc_method &#x3D; null; try &#123; privateStaticFunc_method &#x3D; testClazz.getDeclaredMethod(&quot;privateStaticFunc&quot;); privateStaticFunc_method.setAccessible(true); privateStaticFunc_method.invoke(null); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; Log.i(&quot;kanxue&quot;, &quot;getDeclaredMethod-&gt;&quot; + privateStaticFunc_method); Method[] methods &#x3D; testClazz.getDeclaredMethods(); for (Method i : methods) &#123; Log.i(&quot;kanxue&quot;, &quot;getDeclaredMethods-&gt;&quot; + i); &#125; Method[] methods_1 &#x3D; testClazz.getMethods(); for (Method i : methods_1) &#123; Log.i(&quot;kanxue&quot;, &quot;getMethods-&gt;&quot; + i); &#125; Constructor[] constructors &#x3D; testClazz.getDeclaredConstructors(); for (Constructor i : constructors) &#123; Log.i(&quot;kanxue&quot;, &quot;getDeclaredConstructors-&gt;&quot; + i); &#125; try &#123; Constructor constructor &#x3D; testClazz.getDeclaredConstructor(String.class, int.class); Object testobj &#x3D; constructor.newInstance(&quot;test&quot;, 666); Field privateField_field &#x3D; testClazz.getDeclaredField(&quot;privateField&quot;); privateField_field.setAccessible(true); String privateField_String &#x3D; (String) privateField_field.get(testobj); Log.i(&quot;kanxue&quot;, &quot;privateField-&gt;&quot; + privateField_String); Log.i(&quot;kanxue&quot;, &quot;getDeclaredConstructor-&gt;&quot; + constructor); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125;&#125;public native String stringFromJNI(); native-lib.cpp 1234567891011121314151617extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_kanxue_reflectiontest_MainActivity_stringFromJNI( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;Java_com_kanxue_reflectiontest_MainActivity_stringFromJNI-&gt;%p&quot;, env); std::string hello &#x3D; &quot;Hello from C++&quot;; jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); jfieldID publicStaticField_jfieldID &#x3D; env-&gt;GetStaticFieldID(TestJclass, &quot;publicStaticField&quot;,&quot;Ljava&#x2F;lang&#x2F;String;&quot;); jstring publicStaticField_content &#x3D; (jstring) env-&gt;GetStaticObjectField(TestJclass,publicStaticField_jfieldID); const char *content_ptr &#x3D; env-&gt;GetStringUTFChars(publicStaticField_content, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, content_ptr); return env-&gt;NewStringUTF(hello.c_str());&#125; JavaVM与JNIEnvJNIEnv：指Java Native Interface Environment，是一个JNI接口指针，指向了本地方法 的一个函数表，该函数表中的每一个成员指向了一个JNI函数，本地方法通过JNI函数 来访问JVM中的数据结构。 JNIEnv 表示 Java 调用 native 语言的环境，是一个封装了几乎全部 JNI 方法的指针。 JNIEnv 只在创建它的线程生效，不能跨线程传递，不同线程的 JNIEnv 彼此独立。 native 环境中创建的线程，如果需要访问 JNI，必须要调用 AttachCurrentThread 关联，并使用 DetachCurrentThread 解除链接 JavaVM 和 JNIEnv 在 C 语言环境下和 C++ 环境下调用是有区别的，在C的定义中,env是一个两级指针,而在C++的定义中,env是个一级指针，主要表现在： 12C风格：(*env)-&gt;NewStringUTF(env, “Hellow World!”); C++风格：env-&gt;NewStringUTF(“Hellow World!”); JavaVM获取方式有两种，1-在JNI_Onload中作为参数获得，2-通过JNIEnv的GetJavaVM函数获得 12JavaVM *globalVM &#x3D; nullptr;env-&gt;GetJavaVM(&amp;globalVM); JNIEnv获取方式有三种， 1-如果当前线程绑定了一个JNIEnv，可以通过JavaVM获取比如主线程中的JNI_Onload内容 12JNIEnv* env &#x3D; NULL;if(vm-&gt;GetEnv(reinterpret_case&lt;void**&gt;(&amp;env),JNI_VERSION_1_6)!&#x3D;JNI_OK)&#123; return -1;&#125; 2-通过JNI函数的参数传入获取，对于任何一个JNI函数来说，第一个参数都是JNIEnv指针 3-在非主线程中时需要通过当前进程的JavaVM调用AttachCurrentThread(&amp;env,NULL )来获取 注意： JNIEnv是与一个ClassLoader绑定的，当时用env-&gt;FindClass()进行类的查询和加载时便是时用的这个ClassLoader JNIEnv是当前Java线程的执行环境，一个JVM对应一个JavaVM结构，而一个JVM中可能创建多个Java线程，时用pthread_create新建的线程当时用AttachCurrentThread(&amp;env, NULL)获取到JNIEnv后，该JNIEnv的ClassLoader并不是主线程的ClassLoader，因此也无法加载app自己的class。 JNIEnv 和 JavaVM 其实只是对 JNINativeInterface 和 JNIInvokeInterface 的一层封装，实际调用和操作的还是 JNINativeInterface 和 JNIInvokeInterface 里的方法。 C实现 1234567891011121314151617181920212223242526272829&#x2F;&#x2F;extern &quot;C&quot;JNIEXPORT jstring JNICALLJava_com_kanxue_reflectiontest_MainActivity_stringFromJNIC( JNIEnv *env, jobject thisobj&#x2F;* this *&#x2F;) &#123;&#x2F;* jint GetVersion() &#123; return functions-&gt;GetVersion(this); &#125; jclass DefineClass(const char *name, jobject loader, const jbyte* buf, jsize bufLen) &#123; return functions-&gt;DefineClass(this, name, loader, buf, bufLen); &#125; jclass FindClass(const char* name) &#123; return functions-&gt;FindClass(this, name); &#125;*&#x2F; const char* hello &#x3D; &quot;Hello from C&quot;; &#x2F;&#x2F;publicStaticField jclass TestJclass &#x3D; (*env)-&gt;FindClass(env,&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); &#x2F;&#x2F;jfieldID GetStaticFieldID(jclass clazz, const char* name, const char* sig) jfieldID publicStaticField_jfieldID &#x3D; (*env)-&gt;GetStaticFieldID(env,TestJclass, &quot;publicStaticField&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); &#x2F;&#x2F;jobject GetStaticObjectField(jclass clazz, jfieldID fieldID) jstring publicStaticField_content &#x3D; (jstring) (*env)-&gt;GetStaticObjectField(env,TestJclass, publicStaticField_jfieldID); const char *content_ptr &#x3D; (*env)-&gt;GetStringUTFChars(env,publicStaticField_content, NULL); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, content_ptr); return (*env)-&gt;NewStringUTF(env,hello);&#125; C++实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132JavaVM *globalVM &#x3D; nullptr;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_kanxue_reflectiontest_MainActivity_stringFromJNI( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; JavaVM *thisvm &#x3D; nullptr; env-&gt;GetJavaVM(&amp;thisvm); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;env-&gt;GetJavaVM(&amp;thisvm)-&gt;%p&quot;, thisvm); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;Java_com_kanxue_reflectiontest_MainActivity_stringFromJNI-&gt;%p&quot;, env); &#x2F;* jint GetVersion() &#123; return functions-&gt;GetVersion(this); &#125; jclass DefineClass(const char *name, jobject loader, const jbyte* buf,jsize bufLen) &#123; return functions-&gt;DefineClass(this, name, loader, buf, bufLen); &#125; jclass FindClass(const char* name) &#123; return functions-&gt;FindClass(this, name); &#125;*&#x2F; std::string hello &#x3D; &quot;Hello from C++&quot;; &#x2F;&#x2F;publicStaticField jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); &#x2F;&#x2F;jfieldID GetStaticFieldID(jclass clazz, const char* name, const char* sig) jfieldID publicStaticField_jfieldID &#x3D; env-&gt;GetStaticFieldID(TestJclass, &quot;publicStaticField&quot;,&quot;Ljava&#x2F;lang&#x2F;String;&quot;); &#x2F;&#x2F;jobject GetStaticObjectField(jclass clazz, jfieldID fieldID) jstring publicStaticField_content &#x3D; (jstring) env-&gt;GetStaticObjectField(TestJclass,publicStaticField_jfieldID); const char *content_ptr &#x3D; env-&gt;GetStringUTFChars(publicStaticField_content, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, content_ptr); return env-&gt;NewStringUTF(hello.c_str());&#125;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_kanxue_reflectiontest_MainActivity_getFields( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; std::string hello &#x3D; &quot;Hello from C++&quot;;&#125;&#x2F;&#x2F; 新建线程 AttachCurrentThread 才能获取JNIEnvvoid *threadtest(void *args) &#123; for (int i &#x3D; 0; i &lt; 10; i++) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s,%d&quot;, &quot;I am from threadtest&quot;, i); &#125; JNIEnv *threadenv &#x3D; nullptr; if (globalVM-&gt;GetEnv((void **) &amp;threadenv, JNI_VERSION_1_6) &#x3D;&#x3D; JNI_OK) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, &quot;globalVM-&gt;GetEnv((void**)&amp;threadenv,JNI_VERSION_1_6)&#x3D;&#x3D;JNI_OK success&quot;); &#125; else &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;,&quot;globalVM-&gt;GetEnv((void**)&amp;threadenv,JNI_VERSION_1_6)&#x3D;&#x3D;JNI_OK failed&quot;); &#125; int result &#x3D; globalVM-&gt;AttachCurrentThread(&amp;threadenv, nullptr); if (result &#x3D;&#x3D; JNI_OK) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;,&quot; globalVM-&gt;AttachCurrentThread(&amp;threadenv, nullptr)&#x3D;&#x3D;JNI_OK success&quot;); jstring jstring1 &#x3D; threadenv-&gt;NewStringUTF(&quot;threadtest jstring&quot;); const char *content &#x3D; threadenv-&gt;GetStringUTFChars(jstring1, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, content); threadenv-&gt;ReleaseStringUTFChars(jstring1, content); &#125; else &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;,&quot; globalVM-&gt;AttachCurrentThread(&amp;threadenv, nullptr)&#x3D;&#x3D;JNI_OK failed&quot;); &#125; &#x2F;&#x2F;publicStaticField jclass TestJclass &#x3D; threadenv-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); threadenv-&gt;ExceptionDescribe(); threadenv-&gt;ExceptionClear(); if (TestJclass &#x3D;&#x3D; nullptr) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, &quot;TestJclass is nullptr&quot;); &#125; else &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, &quot;TestJclass is not nullptr&quot;); &#x2F;&#x2F;jfieldID GetStaticFieldID(jclass clazz, const char* name, const char* sig) jfieldID publicStaticField_jfieldID &#x3D; threadenv-&gt;GetStaticFieldID(TestJclass, &quot;publicStaticField&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); &#x2F;&#x2F;jobject GetStaticObjectField(jclass clazz, jfieldID fieldID) jstring publicStaticField_content &#x3D; (jstring) threadenv-&gt;GetStaticObjectField(TestJclass, publicStaticField_jfieldID); const char *content_ptr &#x3D; threadenv-&gt;GetStringUTFChars(publicStaticField_content, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, content_ptr); &#125;; &#x2F;&#x2F;globalVM-&gt;AttachCurrentThread() globalVM-&gt;DetachCurrentThread(); pthread_exit(0);&#125;JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) &#123; globalVM &#x3D; vm; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;JNI_OnLoad(JavaVM *vm, void *reserved)-&gt;%p&quot;, vm); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, &quot;JNI_OnLoad is called&quot;); jint result &#x3D; 0; JNIEnv *env &#x3D; nullptr; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) &#x3D;&#x3D; JNI_OK) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, &quot;vm-&gt;GetEnv((void**)&amp;env,JNI_VERSION_1_6) success&quot;); &#125; &#x2F;&#x2F;publicStaticField jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); &#x2F;&#x2F;jfieldID GetStaticFieldID(jclass clazz, const char* name, const char* sig) jfieldID publicStaticField_jfieldID &#x3D; env-&gt;GetStaticFieldID(TestJclass, &quot;publicStaticField&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); &#x2F;&#x2F;jobject GetStaticObjectField(jclass clazz, jfieldID fieldID) jstring publicStaticField_content &#x3D; (jstring) env-&gt;GetStaticObjectField(TestJclass, publicStaticField_jfieldID); const char *content_ptr &#x3D; env-&gt;GetStringUTFChars(publicStaticField_content, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, content_ptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;GetEnv((void**)&amp;env,JNI_VERSION_1_6)-&gt;%p&quot;, env); &#x2F;&#x2F;int pthread_create(pthread_t* __pthread_ptr, pthread_attr_t const* __attr, void* (*__start_routine)(void*), void*); pthread_t thread; &#x2F;&#x2F;pthread_create(&amp;thread, nullptr,threadtest, nullptr); pthread_create(&amp;thread, nullptr, threadtest, nullptr); pthread_join(thread, nullptr); &#x2F;* jint DestroyJavaVM() &#123; return functions-&gt;DestroyJavaVM(this); &#125; jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) &#123; return functions-&gt;AttachCurrentThread(this, p_env, thr_args); &#125; jint DetachCurrentThread() &#123; return functions-&gt;DetachCurrentThread(this); &#125; jint GetEnv(void** env, jint version) &#123; return functions-&gt;GetEnv(this, env, version); &#125; jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args) &#123; return functions-&gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); &#125;*&#x2F; result &#x3D; JNI_VERSION_1_6; return result;&#125; JavaVM 是虚拟机在 JNI 层的代表，一个进程只有一个 JavaVM，所有 的线程共用一个 JavaVM。 JNIInvokeInterface_结构封装和JVM相关的功能函数，如销毁JVM，获得当前线程的Java执行环境。 在C和C++中JavaVM的定义有所不同，在C中JavaVM是JNIInvokeInterface_类型指针，而在C++中又对 JNIInvokeInterface_进行了一次封装。 推荐用C++来编写JNI代码，比C中少了一个参数 虚拟机是唯一的，但是可以有很多线程，所以使用JNIEnv和一个线程绑定。 1.1. 如果当前线程已绑定了一个JNIEnv，可以通过jint (JNICALL GetEnv)(JavaVM vm, voidpenv, jint version); 获取。 1.2. 如果未绑定，调用jint (JNICALL AttachCurrentThread)(JavaVM *vm,void *penv, void *args); 主动绑定，线程结束或者不需要的话解除绑定。 JNIEnv是当前Java线程的执行环境，一个JVM对应一个JavaVM结构，而一个JVM中可能创建多个Java线程，每个线程对应一个JNIEnv结构，它们保存在线程本地存储中。因此，不同的线程的JNIEnv是不同，也不能相互共享使用。 JNIEnv结构也是一个函数表(可以这么理解)，在Native代码中通过JNIEnv的函数表来操作Java数据或调用Java方法。 子线程和主线程的JNIEnv并不是都在调用方的ClassLoader当中，因此，需要特别注意env-&gt;FindClass的用法 JNI新建对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194extern &quot;C&quot; JNIEXPORT void JNICALLJava_com_kanxue_reflectiontest_MainActivity_newObject( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; &#x2F;&#x2F;NewObject创建对象构造方法的方法返回值类型前面始终为void jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;);&#x2F;&#x2F;public Test(String arg)&#x2F;&#x2F; jmethodID GetMethodID(jclass clazz, const char* name, const char* sig) jmethodID con_mid &#x3D; env-&gt;GetMethodID(TestJclass, &quot;&lt;init&gt;&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;)V&quot;); jstring arg &#x3D; env-&gt;NewStringUTF(&quot;I am From Jni&quot;); &#x2F;&#x2F;jobject NewObject(jclass clazz, jmethodID methodID, ...) jobject testobj &#x3D; env-&gt;NewObject(TestJclass, con_mid, arg); if (testobj !&#x3D; nullptr) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, &quot;NewObject success!&quot;); &#125; &#x2F;&#x2F;AllocObject 根据传入的jclass创建一个费初始化的JAVA对象，需要用CallNonvirtualVoidMethod初始化，可以延迟构造函数的调用 &#x2F;&#x2F;jclass clazz_str &#x3D; env-&gt;FindClass(&quot;java&#x2F;lang&#x2F;String&quot;); &#x2F;&#x2F;jmethodID methodID_str &#x3D; env-&gt;GetMethodID(clazz_str ,&quot;&lt;init&gt;&quot;, &quot;()V&quot;); jobject testobj2 &#x3D; env-&gt;AllocObject(TestJclass); jstring arg1 &#x3D; env-&gt;NewStringUTF(&quot;I am From Jni-&gt;AllocObject&quot;); env-&gt;CallNonvirtualVoidMethod(testobj2, TestJclass, con_mid, arg1); if (testobj2 !&#x3D; nullptr) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, &quot;AllocObject success!&quot;); &#125;&#125;获取静态域extern &quot;C&quot; JNIEXPORT void JNICALLJava_com_kanxue_reflectiontest_MainActivity_getStaticField( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; &#x2F;&#x2F;private static jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); &#x2F;&#x2F; public static String publicStaticField &#x3D; &quot;i am a publicStaticField&quot;; &#x2F;&#x2F; jfieldID GetStaticFieldID(jclass clazz, const char* name, const char* sig) jfieldID publicStaticField_fid &#x3D; env-&gt;GetStaticFieldID(TestJclass, &quot;publicStaticField&quot;,&quot;Ljava&#x2F;lang&#x2F;String;&quot;); &#x2F;*jstring publicStaticField_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetStaticObjectField(TestJclass,publicStaticField_fid)); const char *publicStaticField_content &#x3D; env-&gt;GetStringUTFChars(publicStaticField_obj, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;publicStaticField_obj-&gt;%s&quot;, publicStaticField_content);*&#x2F; jstring setjstring &#x3D; env-&gt;NewStringUTF(&quot;modified by jni&quot;); &#x2F;&#x2F; void SetStaticObjectField(jclass clazz, jfieldID fieldID, jobject value) env-&gt;SetStaticObjectField(TestJclass, publicStaticField_fid, setjstring); jstring publicStaticField_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetStaticObjectField(TestJclass,publicStaticField_fid)); const char *publicStaticField_content &#x3D; env-&gt;GetStringUTFChars(publicStaticField_obj, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;publicStaticField_obj-&gt;%s&quot;, publicStaticField_content);&#x2F;&#x2F;private static String privateStaticField &#x3D; &quot;i am a privateStaticField&quot;; jfieldID privateStaticField_fid &#x3D; env-&gt;GetStaticFieldID(TestJclass, &quot;privateStaticField&quot;,&quot;Ljava&#x2F;lang&#x2F;String;&quot;); jstring privateStaticField_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetStaticObjectField(TestJclass,privateStaticField_fid)); const char *privateStaticField_content &#x3D; env-&gt;GetStringUTFChars(privateStaticField_obj,nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;privateStaticField_obj-&gt;%s&quot;, privateStaticField_content); &#x2F;&#x2F; public static int publicStaticField_int &#x3D; 100; jfieldID publicStaticField_int_fid &#x3D; env-&gt;GetStaticFieldID(TestJclass, &quot;publicStaticField_int&quot;,&quot;I&quot;); env-&gt;SetStaticIntField(TestJclass, publicStaticField_int_fid, 200); jint publicStaticField_int_value &#x3D; env-&gt;GetStaticIntField(TestJclass, publicStaticField_int_fid); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;publicStaticField_int_value-&gt;%d&quot;, publicStaticField_int_value);&#x2F;* jobject GetStaticObjectField(jclass clazz, jfieldID fieldID) &#123; return functions-&gt;GetStaticObjectField(this, clazz, fieldID); &#125; jboolean GetStaticBooleanField(jclass clazz, jfieldID fieldID) &#123; return functions-&gt;GetStaticBooleanField(this, clazz, fieldID); &#125; jbyte GetStaticByteField(jclass clazz, jfieldID fieldID) &#123; return functions-&gt;GetStaticByteField(this, clazz, fieldID); &#125; jchar GetStaticCharField(jclass clazz, jfieldID fieldID) &#123; return functions-&gt;GetStaticCharField(this, clazz, fieldID); &#125; jshort GetStaticShortField(jclass clazz, jfieldID fieldID) &#123; return functions-&gt;GetStaticShortField(this, clazz, fieldID); &#125; jint GetStaticIntField(jclass clazz, jfieldID fieldID) &#123; return functions-&gt;GetStaticIntField(this, clazz, fieldID); &#125; jlong GetStaticLongField(jclass clazz, jfieldID fieldID) &#123; return functions-&gt;GetStaticLongField(this, clazz, fieldID); &#125; jfloat GetStaticFloatField(jclass clazz, jfieldID fieldID) &#123; return functions-&gt;GetStaticFloatField(this, clazz, fieldID); &#125; jdouble GetStaticDoubleField(jclass clazz, jfieldID fieldID) &#123; return functions-&gt;GetStaticDoubleField(this, clazz, fieldID); &#125;*&#x2F;&#x2F;* void SetStaticObjectField(jclass clazz, jfieldID fieldID, jobject value) &#123; functions-&gt;SetStaticObjectField(this, clazz, fieldID, value); &#125; void SetStaticBooleanField(jclass clazz, jfieldID fieldID, jboolean value) &#123; functions-&gt;SetStaticBooleanField(this, clazz, fieldID, value); &#125; void SetStaticByteField(jclass clazz, jfieldID fieldID, jbyte value) &#123; functions-&gt;SetStaticByteField(this, clazz, fieldID, value); &#125; void SetStaticCharField(jclass clazz, jfieldID fieldID, jchar value) &#123; functions-&gt;SetStaticCharField(this, clazz, fieldID, value); &#125; void SetStaticShortField(jclass clazz, jfieldID fieldID, jshort value) &#123; functions-&gt;SetStaticShortField(this, clazz, fieldID, value); &#125; void SetStaticIntField(jclass clazz, jfieldID fieldID, jint value) &#123; functions-&gt;SetStaticIntField(this, clazz, fieldID, value); &#125; void SetStaticLongField(jclass clazz, jfieldID fieldID, jlong value) &#123; functions-&gt;SetStaticLongField(this, clazz, fieldID, value); &#125; void SetStaticFloatField(jclass clazz, jfieldID fieldID, jfloat value) &#123; functions-&gt;SetStaticFloatField(this, clazz, fieldID, value); &#125; void SetStaticDoubleField(jclass clazz, jfieldID fieldID, jdouble value) &#123; functions-&gt;SetStaticDoubleField(this, clazz, fieldID, value); &#125;*&#x2F;&#125;获取非静态域extern &quot;C&quot; JNIEXPORT void JNICALLJava_com_kanxue_reflectiontest_MainActivity_getNonStaticField( JNIEnv *env, jobject obj, jobject testobj) &#123; &#x2F;&#x2F; private String privateField &#x3D; &quot;i am a privateField&quot;; jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); jfieldID privateField_fid &#x3D; env-&gt;GetFieldID(TestJclass, &quot;privateField&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); &#x2F;&#x2F; jobject GetObjectField(jobject obj, jfieldID fieldID) jstring privateField_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetObjectField(testobj, privateField_fid));&#x2F;* const char *privateField_obj_content &#x3D; env-&gt;GetStringUTFChars(privateField_obj, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;privateField_obj-&gt;%s&quot;, privateField_obj_content);*&#x2F; &#x2F;&#x2F; jstring newString &#x3D; env-&gt;NewStringUTF(&quot;Modified by jni&quot;); env-&gt;SetObjectField(testobj, privateField_fid, newString); privateField_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetObjectField(testobj, privateField_fid)); const char *privateField_obj_content &#x3D; env-&gt;GetStringUTFChars(privateField_obj, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;privateField_obj-&gt;%s&quot;, privateField_obj_content);&#x2F;* void SetObjectField(jobject obj, jfieldID fieldID, jobject value) &#123; functions-&gt;SetObjectField(this, obj, fieldID, value); &#125; void SetBooleanField(jobject obj, jfieldID fieldID, jboolean value) &#123; functions-&gt;SetBooleanField(this, obj, fieldID, value); &#125; void SetByteField(jobject obj, jfieldID fieldID, jbyte value) &#123; functions-&gt;SetByteField(this, obj, fieldID, value); &#125; void SetCharField(jobject obj, jfieldID fieldID, jchar value) &#123; functions-&gt;SetCharField(this, obj, fieldID, value); &#125; void SetShortField(jobject obj, jfieldID fieldID, jshort value) &#123; functions-&gt;SetShortField(this, obj, fieldID, value); &#125; void SetIntField(jobject obj, jfieldID fieldID, jint value) &#123; functions-&gt;SetIntField(this, obj, fieldID, value); &#125; void SetLongField(jobject obj, jfieldID fieldID, jlong value) &#123; functions-&gt;SetLongField(this, obj, fieldID, value); &#125; void SetFloatField(jobject obj, jfieldID fieldID, jfloat value) &#123; functions-&gt;SetFloatField(this, obj, fieldID, value); &#125; void SetDoubleField(jobject obj, jfieldID fieldID, jdouble value) &#123; functions-&gt;SetDoubleField(this, obj, fieldID, value); &#125;*&#x2F;&#x2F;&#x2F; private int privateField_int &#x3D; 200; jfieldID privateField_int_fid &#x3D; env-&gt;GetFieldID(TestJclass, &quot;privateField_int&quot;, &quot;I&quot;);&#x2F;* jint privateField_int_value &#x3D; env-&gt;GetIntField(testobj, privateField_int_fid); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;privateField_int_value-&gt;%d&quot;, privateField_int_value);*&#x2F; env-&gt;SetIntField(testobj, privateField_int_fid, 300); jint privateField_int_value &#x3D; env-&gt;GetIntField(testobj, privateField_int_fid); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;privateField_int_value-&gt;%d&quot;, privateField_int_value); &#x2F;&#x2F; public int[] intarray &#x3D; null; jfieldID intarray_fid&#x3D;env-&gt;GetFieldID(TestJclass,&quot;intarray&quot;,&quot;[I&quot;); jintArray intarray_obj&#x3D; static_cast&lt;jintArray&gt;(env-&gt;GetObjectField(testobj, intarray_fid)); &#x2F;&#x2F; 获取数组长度 int arraylength&#x3D;env-&gt;GetArrayLength(intarray_obj); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;arraylength-&gt;%d&quot;, arraylength);&#x2F;* int* array&#x3D;env-&gt;GetIntArrayElements(intarray_obj, nullptr); for(int i&#x3D;0;i&lt;arraylength;i++)&#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;array[%d]-&gt;%d&quot;, i,array[i]); &#125;*&#x2F; &#x2F;&#x2F; void SetIntArrayRegion(jintArray array, jsize start, jsize len,const jint* buf) jint jni_array[arraylength]; for(int j&#x3D;0;j&lt;arraylength;j++)&#123; jni_array[j]&#x3D;10-j; &#125; const jint* ptr&#x3D;jni_array; env-&gt;SetIntArrayRegion(intarray_obj,0,arraylength,ptr); &#x2F;&#x2F; 获取数组的指针 int* array&#x3D;env-&gt;GetIntArrayElements(intarray_obj, nullptr); &#x2F;&#x2F; 遍历数组每个元素 for(int i&#x3D;0;i&lt;arraylength;i++)&#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;array[%d]-&gt;%d&quot;, i,array[i]); &#125; &#x2F;&#x2F;env-&gt;SetIntArrayRegion()&#125; JNI访问函数和Java反射类访问类属性的对比： 1.Java反射中获取属性时只需要传入属性名即可，而jni中还需要传入该属性的签名信息 2.Java反射中在对private类型属性访问时需要先取消安全检查，即调用setAccessible(true)才能访问，而jni中不需要 3.Java反射中对普通函数使用Method，而对构造函数使用Contructor，在jni中构造函数也是普通函数，依然使用jmethodID，只不过函数名是&lt;init&gt; 构造函数对于构造函数的调用来说只能通过NewObject和AllocObject来调用，因为构造函数本身首先不是静态函数，自然不能通过类名进行调用；其次如果按照一般的函数进行调用，需要传入对象，而此时还没有对象，因此只能是一种特例。 Test testobj = (Test) callInit(); 123456789101112131415161718extern &quot;C&quot; JNIEXPORT jobject JNICALLJava_com_kanxue_reflectiontest_MainActivity_callInit( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; &#x2F;&#x2F; public Test(String arg, int arg2) jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); jmethodID con_mid &#x3D; env-&gt;GetMethodID(TestJclass, &quot;&lt;init&gt;&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;I)V&quot;); jstring arg0 &#x3D; env-&gt;NewStringUTF(&quot;i am from callInit&quot;); jobject obj &#x3D; env-&gt;NewObject(TestJclass, con_mid, arg0, 100); jmethodID privatetest_mid &#x3D; env-&gt;GetMethodID(TestJclass, &quot;privatetest&quot;, &quot;(ILjava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;); jstring arg2 &#x3D; env-&gt;NewStringUTF(&quot;i am from jni-CallObjectMethodA&quot;); return obj;&#125; 静态函数123456789101112131415161718192021222324252627282930313233343536373839extern &quot;C&quot; JNIEXPORT void JNICALLJava_com_kanxue_reflectiontest_MainActivity_callStaticFunc( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; &#x2F;&#x2F;public static void publicStaticFunc() jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); jmethodID publicStaticFunc_mid &#x3D; env-&gt;GetStaticMethodID(TestJclass, &quot;publicStaticFunc&quot;, &quot;()V&quot;); env-&gt;CallStaticVoidMethod(TestJclass, publicStaticFunc_mid); &#x2F;&#x2F;private static void privateStaticFunc() jmethodID privateStaticFunc_mid &#x3D; env-&gt;GetStaticMethodID(TestJclass, &quot;privateStaticFunc&quot;, &quot;()V&quot;); env-&gt;CallStaticVoidMethod(TestJclass, privateStaticFunc_mid);&#x2F;* public static int publicStaticFunc_int(int a) &#123; Log.i(&quot;kanxue&quot;, &quot;i am from publicStaticFunc_int&quot;); return 100+a; &#125;*&#x2F; jmethodID publicStaticFunc_int_mid &#x3D; env-&gt;GetStaticMethodID(TestJclass, &quot;publicStaticFunc_int&quot;, &quot;(I)I&quot;); jint result_int &#x3D; env-&gt;CallStaticIntMethod(TestJclass, publicStaticFunc_int_mid, 200); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;publicStaticFunc_int-&gt;%d&quot;, result_int); &#x2F;*public static String publicStaticFunc_string(String arg) &#123; Log.i(&quot;kanxue&quot;, &quot;i am from publicStaticFunc_int&quot;); return &quot;publicStaticFunc_string-&gt;&quot;+arg; &#125;*&#x2F; jmethodID publicStaticFunc_string_mid &#x3D; env-&gt;GetStaticMethodID(TestJclass, &quot;publicStaticFunc_string&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;); jstring arg_string &#x3D; env-&gt;NewStringUTF(&quot;i am from jni&quot;); jstring result_string &#x3D; static_cast&lt;jstring&gt;(env-&gt;CallStaticObjectMethod(TestJclass, publicStaticFunc_string_mid, arg_string)); const char *content &#x3D; env-&gt;GetStringUTFChars(result_string, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;publicStaticFunc_string-&gt;%s&quot;, content);&#125; 非静态域123456789101112131415161718192021222324252627282930313233343536373839404142434445extern &quot;C&quot; JNIEXPORT void JNICALLJava_com_kanxue_reflectiontest_MainActivity_getNonStaticField( JNIEnv *env, jclass obj, jobject testobj) &#123; &#x2F;&#x2F; private String privateField &#x3D; &quot;i am a privateField&quot;; jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); jfieldID privateField_fid &#x3D; env-&gt;GetFieldID(TestJclass, &quot;privateField&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); &#x2F;&#x2F; jobject GetObjectField(jobject obj, jfieldID fieldID) jstring privateField_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetObjectField(testobj, privateField_fid)); jstring newString &#x3D; env-&gt;NewStringUTF(&quot;Modified by jni&quot;); env-&gt;SetObjectField(testobj, privateField_fid, newString); privateField_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetObjectField(testobj, privateField_fid)); const char *privateField_obj_content &#x3D; env-&gt;GetStringUTFChars(privateField_obj, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;privateField_obj-&gt;%s&quot;, privateField_obj_content); jfieldID privateField_int_fid &#x3D; env-&gt;GetFieldID(TestJclass, &quot;privateField_int&quot;, &quot;I&quot;); env-&gt;SetIntField(testobj, privateField_int_fid, 300); jint privateField_int_value &#x3D; env-&gt;GetIntField(testobj, privateField_int_fid); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;privateField_int_value-&gt;%d&quot;, privateField_int_value); &#x2F;&#x2F; public int[] intarray &#x3D; null; jfieldID intarray_fid &#x3D; env-&gt;GetFieldID(TestJclass, &quot;intarray&quot;, &quot;[I&quot;); jintArray intarray_obj &#x3D; static_cast&lt;jintArray&gt;(env-&gt;GetObjectField(testobj, intarray_fid)); int arraylength &#x3D; env-&gt;GetArrayLength(intarray_obj); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;arraylength-&gt;%d&quot;, arraylength); jint jni_array[arraylength]; for (int j &#x3D; 0; j &lt; arraylength; j++) &#123; jni_array[j] &#x3D; 10 - j; &#125; const jint *ptr &#x3D; jni_array; env-&gt;SetIntArrayRegion(intarray_obj, 0, arraylength, ptr); int *array &#x3D; env-&gt;GetIntArrayElements(intarray_obj, nullptr); for (int i &#x3D; 0; i &lt; arraylength; i++) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;array[%d]-&gt;%d&quot;, i, array[i]); &#125;&#125; 非静态函数1234567891011121314151617181920212223242526272829303132333435extern &quot;C&quot; JNIEXPORT void JNICALLJava_com_kanxue_reflectiontest_MainActivity_callNonStaticFunc( JNIEnv *env, jobject obj&#x2F;* this *&#x2F;) &#123; jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); jmethodID con_mid &#x3D; env-&gt;GetMethodID(TestJclass, &quot;&lt;init&gt;&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;I)V&quot;); jstring arg0 &#x3D; env-&gt;NewStringUTF(&quot;i am from callInit&quot;); &#x2F;&#x2F; public void publicFunc() jobject testobj &#x3D; env-&gt;NewObject(TestJclass, con_mid, arg0, 100); jmethodID publicFunc_mid &#x3D; env-&gt;GetMethodID(TestJclass, &quot;publicFunc&quot;, &quot;()V&quot;); env-&gt;CallVoidMethod(testobj, publicFunc_mid); jmethodID privatetest &#x3D; env-&gt;GetMethodID(TestJclass, &quot;privatetest&quot;, &quot;(ILjava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;); jstring arg1 &#x3D; env-&gt;NewStringUTF(&quot;i am from jni&quot;); jvalue args[2]; args[0].i &#x3D; 200; args[1].l &#x3D; arg1; jstring result_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;CallObjectMethodA(testobj, privatetest, args)); const char *result_ptr &#x3D; env-&gt;GetStringUTFChars(result_obj, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;privatetest-&gt;%s&quot;, result_ptr); jmethodID privateFunc_array_mid &#x3D; env-&gt;GetMethodID(TestJclass, &quot;privateFunc_array&quot;, &quot;(I)[I&quot;); jintArray array_obj &#x3D; static_cast&lt;jintArray&gt;(env-&gt;CallObjectMethod(testobj, privateFunc_array_mid, 100)); jint *array_ptr &#x3D; env-&gt;GetIntArrayElements(array_obj, nullptr); for (int i &#x3D; 0; i &lt; env-&gt;GetArrayLength(array_obj); i++) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;array[%d]-&gt;%d&quot;, i, array_ptr[i]); &#125;&#125; onCreate1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&#x2F;&#x2F;protected native void onCreate(Bundle savedInstanceState);extern &quot;C&quot; JNIEXPORT void JNICALLJava_com_kanxue_reflectiontest_MainActivity_onCreate( JNIEnv *env, jobject thiz, jobject bundle) &#123;&#x2F;* super.onCreate(savedInstanceState); Log.i(&quot;kanxue&quot;,&quot;onCreate is Called!&quot;); setContentView(R.layout.activity_main); TextView tv &#x3D; findViewById(R.id.sample_text); Test testobj &#x3D; (Test) callInit(); Log.i(&quot;kanxue&quot;, testobj.flag);*&#x2F; jclass AppCompatActivity_jclass1 &#x3D; env-&gt;FindClass(&quot;androidx&#x2F;appcompat&#x2F;app&#x2F;AppCompatActivity&quot;); jclass MainActivity_jclass1 &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;MainActivity&quot;); jclass MainActivity_jclass2 &#x3D; env-&gt;GetObjectClass(thiz); jclass AppCompatActivity_jclass2 &#x3D; env-&gt;GetSuperclass(MainActivity_jclass2); &#x2F;&#x2F; protected void onCreate(Bundle savedInstanceState) jmethodID superClassOnCreate_mid &#x3D; env-&gt;GetMethodID(AppCompatActivity_jclass2, &quot;onCreate&quot;, &quot;(Landroid&#x2F;os&#x2F;Bundle;)V&quot;); env-&gt;CallNonvirtualVoidMethod(thiz, AppCompatActivity_jclass2, superClassOnCreate_mid, bundle); jstring arg1 &#x3D; env-&gt;NewStringUTF(&quot;kanxue&quot;); &#x2F;&#x2F; Log.i(&quot;kanxue&quot;,&quot;onCreate is Called&quot;) jstring arg2 &#x3D; env-&gt;NewStringUTF(&quot;native onCreate is called!&quot;); jclass Logjclass &#x3D; env-&gt;FindClass(&quot;android&#x2F;util&#x2F;Log&quot;); &#x2F;&#x2F; public static int i(String tag,String msg) jmethodID Log_i_mid &#x3D; env-&gt;GetStaticMethodID(Logjclass, &quot;i&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)I&quot;); jint result0 &#x3D; env-&gt;CallStaticIntMethod(Logjclass, Log_i_mid, arg1, arg2); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jint result0&#x3D;env-&gt;CallStaticIntMethod(Logjclass,Log_i_mid,arg1,arg2);-&gt;%d&quot;, result0);&#125; &#x2F;*TextView tv &#x3D; findViewById(R.id.sample_text); Test testobj &#x3D; (Test) callInit(); Log.i(&quot;kanxue&quot;, testobj.flag);*&#x2F; jmethodID setContentView_mid &#x3D; env-&gt;GetMethodID(MainActivity_jclass2, &quot;setContentView&quot;, &quot;(I)V&quot;); jclass R_layoutjclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;R$layout&quot;); jfieldID activity_main_fieldid &#x3D; env-&gt;GetStaticFieldID(R_layoutjclass, &quot;activity_main&quot;, &quot;I&quot;); jint activity_main_value &#x3D; env-&gt;GetStaticIntField(R_layoutjclass, activity_main_fieldid); env-&gt;CallVoidMethod(thiz, setContentView_mid, activity_main_value); &#x2F;&#x2F; TextView tv &#x3D; findViewById(R.id.sample_text); jmethodID findViewById_mid &#x3D; env-&gt;GetMethodID(MainActivity_jclass2, &quot;findViewById&quot;, &quot;(I)Landroid&#x2F;view&#x2F;View;&quot;); jclass R_idjclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;R$id&quot;); jfieldID sample_text_fieldid &#x3D; env-&gt;GetStaticFieldID(R_idjclass, &quot;sample_text&quot;, &quot;I&quot;); jint sample_text_value &#x3D; env-&gt;GetStaticIntField(R_idjclass, sample_text_fieldid); jobject tvobj &#x3D; env-&gt;CallObjectMethod(thiz, findViewById_mid, sample_text_value); &#x2F;&#x2F; Test testobj&#x3D;(Test) callInit(); &#x2F;&#x2F; Log.i(&quot;kanxue&quot;,testobj.flag); jmethodID callInit_mid &#x3D; env-&gt;GetMethodID(MainActivity_jclass2, &quot;callInit&quot;, &quot;()Ljava&#x2F;lang&#x2F;Object;&quot;); jobject testobj &#x3D; env-&gt;CallObjectMethod(thiz, callInit_mid); jclass testjclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); jfieldID flagjfield &#x3D; env-&gt;GetFieldID(testjclass, &quot;flag&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); jstring flagvalue &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetObjectField(testobj, flagjfield)); jint result1 &#x3D; env-&gt;CallStaticIntMethod(Logjclass, Log_i_mid, arg1, flagvalue); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot; jint result1&#x3D;env-&gt;CallStaticIntMethod(Logjclass,Log_i_mid,arg1,flagvalue);-&gt;%d&quot;, result1); env-&gt;DeleteGlobalRef(testjclass); 引用Java当中的内存管理:透明的当新建类的实例时，值需要在创建完这个类的实例之后，拿着这个引用访问它的所有数据成员(属性及方法)就可以了，Java来说有一儿垃圾回收线程即GC线程负责将一些不在使用的对象回收。 C/C++中的内存管理:需要编码人员自己进行内存管理，如在C++中new一个对象，使用完了还要做一次delete操作，malloc一次同样也要调用free来释放响应的内存，否则就会有内存泄漏。 局部引用通过NewLocalRef和各种JNI接口创建(FindClass,NewObject,GetObjectClass和NewCharArray等)，会阻止GC回收所引用的对象。局部引用只能在当前函数中使用，函数返回后局部引用所引用的对象会被JVM自动释放，或调用DeleteLocalRef手动释放，因此，局部引用不能跨函数使用，不能跨线程使用。 函数返回时自动释放 手动调用deletelocalref释放 使用jni提供的一系列函数来管理局部引用的生命周期，ensurelocalcapacity,newlocalref,pushlocalframe,poplocalframe,deletelocalref 如果需要创建更多的引用，可以通过调用ensurelocalcapacity函数，确保当前线程中创建指定数量的局部引用，如果创建成功则返回0否则创建失败，并抛出outofmemoryerror异常 123456789101112for (int i &#x3D; 0; i &lt; 2048; i++) &#123; jstring jstr &#x3D; env-&gt;NewStringUTF(&quot;12345&quot;); LOGI(&quot; local Reference is Num %d : &quot;, i );&#125;if (env-&gt;EnsureLocalCapacity(1024) &#x3D;&#x3D; 0) &#123; for (int i &#x3D; 0; i &lt; len; i++) &#123; jstring content &#x3D; env-&gt;NewStringUTF(&quot;test localreference&quot;); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;localreference number-&gt;%d&quot;, env-&gt;DeleteLocalRef(content); &#125;&#125; 全局引用调用NewGlobalRef基于局部引用创建阻GC回收所引用的对象。全局引用可以跨函数，跨线程使用。ART不会自动释放，必须调用DeleteGlobalRef手动释放，DeleteGlobalRef(g_cls_string),否则会出现内存泄漏。 jclass tmpjclass = env-&gt;FindClass(&quot;com/kanxue/reflectiontest/Test&quot;); testjclass = static_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(tmpjclass)); 弱全局引用调用NewWeakGlobalRef基于局部引用或全局引用创建不会阻止GC回收所引用的对象，可以跨方法，跨线程使用。但与全局引用很重要不同的一点是，弱引用不会组织GC回收它引用的对象，但是引用也不会自动释放，在ART认为应该回收它的时候(比如内存紧张的时候)，进行回收而被释放，或调用DeleteWeakGlobalRef手动释放。 Java层函数在调用本地jni代码的时候，会维护一个局部引用表（该引用表并不是无限的），一般jni函数调用结束后，ART会释放这个引用，如果是简单的函数就不需要注意这些问题，让他们自己释放，基本没什么问题，但是如果函数里面有注入大量的循环的操作的话，那么程序可能会因为局部引用太多而出现异常情况。 PushLocalFrame可以为当前函数中需要用到的局部引用创建一个引用堆栈，而PopLocalFrame负责销毁栈中所有的引用。因此push、poplocalframe函数对提供了对局部引用生命周期更方便的管理，而不需要时刻关注获取一个引用后，再调用deletelocalref来释放引用，在调用poplocalframe销毁当前frame中的所有引用前，如果第二个参数的result不为空，会有result生成一个新的局部引用，再把这个新生成的局部引用存储到上一个frame中。 1234567891011121314151617jint testPushAndPopLocalFrame(JNIEnv *env) &#123; jobject result &#x3D; nullptr; if (env-&gt;PushLocalFrame(20) &#x3D;&#x3D; 0) &#123; for (int i &#x3D; 0; i &lt; 18; i++) &#123; jstring tmp &#x3D; env-&gt;NewStringUTF(&quot;kanxue&quot;); &#125; jstring tmp1 &#x3D; env-&gt;NewStringUTF(&quot;result1&quot;); jstring tmp2 &#x3D; env-&gt;NewStringUTF(&quot;result2&quot;); result &#x3D; env-&gt;PopLocalFrame(NULL); &#125; else &#123; &#x2F;&#x2F;error &#125; return 100;&#125; 动态注册extern “C” JNIEXPORT 静态注册时，IDA可直接反编译函数，且函数名很长。对于任意一个jni函数来说，在该函数被调用前，必须要完成java函数与so中地址的绑定，这个绑定过程是被动的，即由Dalvik、Art虚拟机在调用前查找并完成地址的绑定，所以静态函数名JAVA+包名+类名+方法名，简单明了单不够安全，名字过长，很容易被反编译软件直接定位地址。也可以是主动的，即由app自己完成地址的动态绑定。 动态注册通过RedisterNatives方法手动完成native方法和so中方法的绑定，虚拟机通过函数映射关系直接找到响应方法。通常我们在JNI_Onload方法中完成动态注册，事实上只需要在jni函数被调用前的任意时机完成注册即可，甚至多次注册到不同地址都可以。 RegisterNatives函数返回值成功则返回JNI_OK(0)，失败则返回一个负值，需要三个参数：注册jni函数所属的jclass，JNINativeMethod数组指针，注册的jni函数个数。 MainActivity 12Test testobj&#x3D;new Test();getNonStaticField(testobj); 重复绑定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448extern &quot;C&quot; void _init(void) &#123; __android_log_print(4, &quot;jni&quot;, &quot;%s&quot;, &quot;enter _init&quot;);&#125;__attribute__ ((constructor(4), visibility (&quot;hidden&quot;))) void initarray_1(void) &#123; __android_log_print(4, &quot;jni&quot;, &quot;%s&quot;, &quot;enter initarray_1&quot;);&#125;__attribute__ ((constructor(3), visibility (&quot;hidden&quot;))) void initarray_2(void) &#123; __android_log_print(4, &quot;jni&quot;, &quot;%s&quot;, &quot;enter initarray_2&quot;);&#125;__attribute__ ((constructor(2), visibility (&quot;hidden&quot;))) void initarray_3(void) &#123; __android_log_print(4, &quot;jni&quot;, &quot;%s&quot;, &quot;enter initarray_3&quot;);&#125;__attribute__ ((constructor(1), visibility (&quot;hidden&quot;))) void initarray_4(void) &#123; __android_log_print(4, &quot;jni&quot;, &quot;%s&quot;, &quot;enter initarray_4&quot;);&#125;&#x2F;&#x2F;protected native void onCreate(Bundle savedInstanceState);__attribute__ ((visibility (&quot;hidden&quot;))) void onCreate( JNIEnv *env, jobject thiz, jobject bundle) &#123;&#x2F;* super.onCreate(savedInstanceState); Log.i(&quot;kanxue&quot;,&quot;onCreate is Called!&quot;); setContentView(R.layout.activity_main); TextView tv &#x3D; findViewById(R.id.sample_text); Test testobj &#x3D; (Test) callInit(); Log.i(&quot;kanxue&quot;, testobj.flag);*&#x2F; jclass AppCompatActivity_jclass1 &#x3D; env-&gt;FindClass(&quot;androidx&#x2F;appcompat&#x2F;app&#x2F;AppCompatActivity&quot;); jclass MainActivity_jclass1 &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;MainActivity&quot;); jclass MainActivity_jclass2 &#x3D; env-&gt;GetObjectClass(thiz); jclass AppCompatActivity_jclass2 &#x3D; env-&gt;GetSuperclass(MainActivity_jclass2); jmethodID superClassOnCreate_mid &#x3D; env-&gt;GetMethodID(AppCompatActivity_jclass2, &quot;onCreate&quot;, &quot;(Landroid&#x2F;os&#x2F;Bundle;)V&quot;); env-&gt;CallNonvirtualVoidMethod(thiz, AppCompatActivity_jclass2, superClassOnCreate_mid, bundle); jstring arg1 &#x3D; env-&gt;NewStringUTF(&quot;kanxue&quot;); jstring arg2 &#x3D; env-&gt;NewStringUTF(&quot;native onCreate is called!&quot;); jclass Logjclass &#x3D; env-&gt;FindClass(&quot;android&#x2F;util&#x2F;Log&quot;); jmethodID Log_i_mid &#x3D; env-&gt;GetStaticMethodID(Logjclass, &quot;i&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)I&quot;); jint result0 &#x3D; env-&gt;CallStaticIntMethod(Logjclass, Log_i_mid, arg1, arg2); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jint result0&#x3D;env-&gt;CallStaticIntMethod(Logjclass,Log_i_mid,arg1,arg2);-&gt;%d&quot;, result0); jmethodID setContentView_mid &#x3D; env-&gt;GetMethodID(MainActivity_jclass2, &quot;setContentView&quot;, &quot;(I)V&quot;); jclass R_layoutjclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;R$layout&quot;); jfieldID activity_main_fieldid &#x3D; env-&gt;GetStaticFieldID(R_layoutjclass, &quot;activity_main&quot;, &quot;I&quot;); jint activity_main_value &#x3D; env-&gt;GetStaticIntField(R_layoutjclass, activity_main_fieldid); env-&gt;CallVoidMethod(thiz, setContentView_mid, activity_main_value); jmethodID findViewById_mid &#x3D; env-&gt;GetMethodID(MainActivity_jclass2, &quot;findViewById&quot;, &quot;(I)Landroid&#x2F;view&#x2F;View;&quot;); jclass R_idjclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;R$id&quot;); jfieldID sample_text_fieldid &#x3D; env-&gt;GetStaticFieldID(R_idjclass, &quot;sample_text&quot;, &quot;I&quot;); jint sample_text_value &#x3D; env-&gt;GetStaticIntField(R_idjclass, sample_text_fieldid); jobject tvobj &#x3D; env-&gt;CallObjectMethod(thiz, findViewById_mid, sample_text_value); jmethodID callInit_mid &#x3D; env-&gt;GetMethodID(MainActivity_jclass2, &quot;callInit&quot;, &quot;()Ljava&#x2F;lang&#x2F;Object;&quot;); jobject testobj &#x3D; env-&gt;CallObjectMethod(thiz, callInit_mid); jfieldID flagjfield &#x3D; env-&gt;GetFieldID(testjclass, &quot;flag&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); jstring flagvalue &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetObjectField(testobj, flagjfield)); jint result1 &#x3D; env-&gt;CallStaticIntMethod(Logjclass, Log_i_mid, arg1, flagvalue); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot; jint result1&#x3D;env-&gt;CallStaticIntMethod(Logjclass,Log_i_mid,arg1,flagvalue);-&gt;%d&quot;, result1); env-&gt;DeleteWeakGlobalRef(testjclass);&#125;extern &quot;C&quot; JNIEXPORT void JNICALLJava_com_kanxue_reflectiontest_MainActivity_callNonStaticFunc( JNIEnv *env, jobject obj&#x2F;* this *&#x2F;) &#123; jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); jmethodID con_mid &#x3D; env-&gt;GetMethodID(TestJclass, &quot;&lt;init&gt;&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;I)V&quot;); jstring arg0 &#x3D; env-&gt;NewStringUTF(&quot;i am from callInit&quot;); jobject testobj &#x3D; env-&gt;NewObject(TestJclass, con_mid, arg0, 100); jmethodID publicFunc_mid &#x3D; env-&gt;GetMethodID(TestJclass, &quot;publicFunc&quot;, &quot;()V&quot;); env-&gt;CallVoidMethod(testobj, publicFunc_mid); jmethodID privatetest &#x3D; env-&gt;GetMethodID(TestJclass, &quot;privatetest&quot;, &quot;(ILjava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;); jstring arg1 &#x3D; env-&gt;NewStringUTF(&quot;i am from jni&quot;); jvalue args[2]; args[0].i &#x3D; 200; args[1].l &#x3D; arg1; jstring result_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;CallObjectMethodA(testobj, privatetest, args)); const char *result_ptr &#x3D; env-&gt;GetStringUTFChars(result_obj, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;privatetest-&gt;%s&quot;, result_ptr); jmethodID privateFunc_array_mid &#x3D; env-&gt;GetMethodID(TestJclass, &quot;privateFunc_array&quot;, &quot;(I)[I&quot;); jintArray array_obj &#x3D; static_cast&lt;jintArray&gt;(env-&gt;CallObjectMethod(testobj, privateFunc_array_mid, 100)); jint *array_ptr &#x3D; env-&gt;GetIntArrayElements(array_obj, nullptr); for (int i &#x3D; 0; i &lt; env-&gt;GetArrayLength(array_obj); i++) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;array[%d]-&gt;%d&quot;, i, array_ptr[i]); &#125;&#125;extern &quot;C&quot; JNIEXPORT void JNICALLJava_com_kanxue_reflectiontest_MainActivity_callStaticFunc( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; &#x2F;&#x2F;public static void publicStaticFunc() jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); jmethodID publicStaticFunc_mid &#x3D; env-&gt;GetStaticMethodID(TestJclass, &quot;publicStaticFunc&quot;, &quot;()V&quot;); env-&gt;CallStaticVoidMethod(TestJclass, publicStaticFunc_mid); &#x2F;&#x2F;private static void privateStaticFunc() jmethodID privateStaticFunc_mid &#x3D; env-&gt;GetStaticMethodID(TestJclass, &quot;privateStaticFunc&quot;, &quot;()V&quot;); env-&gt;CallStaticVoidMethod(TestJclass, privateStaticFunc_mid);&#x2F;* public static int publicStaticFunc_int(int a) &#123; Log.i(&quot;kanxue&quot;, &quot;i am from publicStaticFunc_int&quot;); return 100+a; &#125;*&#x2F; jmethodID publicStaticFunc_int_mid &#x3D; env-&gt;GetStaticMethodID(TestJclass, &quot;publicStaticFunc_int&quot;, &quot;(I)I&quot;); jint result_int &#x3D; env-&gt;CallStaticIntMethod(TestJclass, publicStaticFunc_int_mid, 200); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;publicStaticFunc_int-&gt;%d&quot;, result_int); &#x2F;*public static String publicStaticFunc_string(String arg) &#123; Log.i(&quot;kanxue&quot;, &quot;i am from publicStaticFunc_int&quot;); return &quot;publicStaticFunc_string-&gt;&quot;+arg; &#125;*&#x2F; jmethodID publicStaticFunc_string_mid &#x3D; env-&gt;GetStaticMethodID(TestJclass, &quot;publicStaticFunc_string&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;); jstring arg_string &#x3D; env-&gt;NewStringUTF(&quot;i am from jni&quot;); jstring result_string &#x3D; static_cast&lt;jstring&gt;(env-&gt;CallStaticObjectMethod(TestJclass, publicStaticFunc_string_mid, arg_string)); const char *content &#x3D; env-&gt;GetStringUTFChars(result_string, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;publicStaticFunc_string-&gt;%s&quot;, content);&#125;extern &quot;C&quot; JNIEXPORT jobject JNICALLJava_com_kanxue_reflectiontest_MainActivity_callInit( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); jmethodID con_mid &#x3D; env-&gt;GetMethodID(TestJclass, &quot;&lt;init&gt;&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;I)V&quot;); jstring arg0 &#x3D; env-&gt;NewStringUTF(&quot;i am from callInit&quot;); jobject obj &#x3D; env-&gt;NewObject(TestJclass, con_mid, arg0, 100); jmethodID privatetest_mid &#x3D; env-&gt;GetMethodID(TestJclass, &quot;privatetest&quot;, &quot;(ILjava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;); jstring arg2 &#x3D; env-&gt;NewStringUTF(&quot;i am from jni-CallObjectMethodA&quot;); return obj;&#125;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_kanxue_reflectiontest_MainActivity_stringFromJNI( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; JavaVM *thisvm &#x3D; nullptr; env-&gt;GetJavaVM(&amp;thisvm); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;env-&gt;GetJavaVM(&amp;thisvm)-&gt;%p&quot;, thisvm); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;Java_com_kanxue_reflectiontest_MainActivity_stringFromJNI-&gt;%p&quot;, env); std::string hello &#x3D; &quot;Hello from C++&quot;; jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); jfieldID publicStaticField_jfieldID &#x3D; env-&gt;GetStaticFieldID(TestJclass, &quot;publicStaticField&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); jstring publicStaticField_content &#x3D; (jstring) env-&gt;GetStaticObjectField(TestJclass, publicStaticField_jfieldID); const char *content_ptr &#x3D; env-&gt;GetStringUTFChars(publicStaticField_content, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, content_ptr); return env-&gt;NewStringUTF(hello.c_str());&#125;void newObject(JNIEnv *env, jobject obj) &#123;&#125;extern &quot;C&quot; JNIEXPORT void JNICALLJava_com_kanxue_reflectiontest_MainActivity_newObject( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; &#x2F;&#x2F;NewObject jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); jmethodID con_mid &#x3D; env-&gt;GetMethodID(TestJclass, &quot;&lt;init&gt;&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;)V&quot;); jstring arg &#x3D; env-&gt;NewStringUTF(&quot;I am From Jni&quot;); jobject testobj &#x3D; env-&gt;NewObject(TestJclass, con_mid, arg); if (testobj !&#x3D; nullptr) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, &quot;NewObject success!&quot;); &#125; &#x2F;&#x2F;AllocObject jobject testobj2 &#x3D; env-&gt;AllocObject(TestJclass); jstring arg1 &#x3D; env-&gt;NewStringUTF(&quot;I am From Jni-&gt;AllocObject&quot;); env-&gt;CallNonvirtualVoidMethod(testobj2, TestJclass, con_mid, arg1); if (testobj2 !&#x3D; nullptr) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, &quot;AllocObject success!&quot;); &#125; jmethodID privatetest_mid &#x3D; env-&gt;GetMethodID(TestJclass, &quot;privatetest&quot;, &quot;(ILjava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;); jstring arg2 &#x3D; env-&gt;NewStringUTF(&quot;i am from jni&quot;); jobject result &#x3D; env-&gt;CallObjectMethod(testobj2, privatetest_mid, 100, arg2);&#125;extern &quot;C&quot; JNIEXPORT void JNICALLJava_com_kanxue_reflectiontest_MainActivity_getStaticField( JNIEnv *env, jobject &#x2F;* this *&#x2F;) &#123; &#x2F;&#x2F;private static jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); &#x2F;&#x2F; public static String publicStaticField &#x3D; &quot;i am a publicStaticField&quot;; &#x2F;&#x2F; jfieldID GetStaticFieldID(jclass clazz, const char* name, const char* sig) jfieldID publicStaticField_fid &#x3D; env-&gt;GetStaticFieldID(TestJclass, &quot;publicStaticField&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); &#x2F;*jstring publicStaticField_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetStaticObjectField(TestJclass, publicStaticField_fid)); const char *publicStaticField_content &#x3D; env-&gt;GetStringUTFChars(publicStaticField_obj, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;publicStaticField_obj-&gt;%s&quot;, publicStaticField_content);*&#x2F; jstring setjstring &#x3D; env-&gt;NewStringUTF(&quot;modified by jni&quot;); &#x2F;&#x2F; void SetStaticObjectField(jclass clazz, jfieldID fieldID, jobject value) env-&gt;SetStaticObjectField(TestJclass, publicStaticField_fid, setjstring); jstring publicStaticField_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetStaticObjectField(TestJclass, publicStaticField_fid)); const char *publicStaticField_content &#x3D; env-&gt;GetStringUTFChars(publicStaticField_obj, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;publicStaticField_obj-&gt;%s&quot;, publicStaticField_content);&#x2F;&#x2F;private static String privateStaticField &#x3D; &quot;i am a privateStaticField&quot;; jfieldID privateStaticField_fid &#x3D; env-&gt;GetStaticFieldID(TestJclass, &quot;privateStaticField&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); jstring privateStaticField_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetStaticObjectField(TestJclass, privateStaticField_fid)); const char *privateStaticField_content &#x3D; env-&gt;GetStringUTFChars(privateStaticField_obj, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;privateStaticField_obj-&gt;%s&quot;, privateStaticField_content); &#x2F;&#x2F; public static int publicStaticField_int &#x3D; 100; jfieldID publicStaticField_int_fid &#x3D; env-&gt;GetStaticFieldID(TestJclass, &quot;publicStaticField_int&quot;, &quot;I&quot;); env-&gt;SetStaticIntField(TestJclass, publicStaticField_int_fid, 200); jint publicStaticField_int_value &#x3D; env-&gt;GetStaticIntField(TestJclass, publicStaticField_int_fid); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;publicStaticField_int_value-&gt;%d&quot;, publicStaticField_int_value);&#125;__attribute__ ((visibility (&quot;hidden&quot;))) void cccc( JNIEnv *env, jclass obj, jobject testobj) &#123; &#x2F;&#x2F; private String privateField &#x3D; &quot;i am a privateField&quot;; jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); jfieldID privateField_fid &#x3D; env-&gt;GetFieldID(TestJclass, &quot;privateField&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); &#x2F;&#x2F; jobject GetObjectField(jobject obj, jfieldID fieldID) jstring privateField_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetObjectField(testobj, privateField_fid)); jstring newString &#x3D; env-&gt;NewStringUTF(&quot;Modified by jni&quot;); env-&gt;SetObjectField(testobj, privateField_fid, newString); privateField_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetObjectField(testobj, privateField_fid)); const char *privateField_obj_content &#x3D; env-&gt;GetStringUTFChars(privateField_obj, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;privateField_obj-&gt;%s&quot;, privateField_obj_content); jfieldID privateField_int_fid &#x3D; env-&gt;GetFieldID(TestJclass, &quot;privateField_int&quot;, &quot;I&quot;); env-&gt;SetIntField(testobj, privateField_int_fid, 300); jint privateField_int_value &#x3D; env-&gt;GetIntField(testobj, privateField_int_fid); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;privateField_int_value-&gt;%d&quot;, privateField_int_value); &#x2F;&#x2F; public int[] intarray &#x3D; null; jfieldID intarray_fid &#x3D; env-&gt;GetFieldID(TestJclass, &quot;intarray&quot;, &quot;[I&quot;); jintArray intarray_obj &#x3D; static_cast&lt;jintArray&gt;(env-&gt;GetObjectField(testobj, intarray_fid)); int arraylength &#x3D; env-&gt;GetArrayLength(intarray_obj); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;arraylength-&gt;%d&quot;, arraylength); jint jni_array[arraylength]; for (int j &#x3D; 0; j &lt; arraylength; j++) &#123; jni_array[j] &#x3D; 10 - j; &#125; const jint *ptr &#x3D; jni_array; env-&gt;SetIntArrayRegion(intarray_obj, 0, arraylength, ptr); int *array &#x3D; env-&gt;GetIntArrayElements(intarray_obj, nullptr); for (int i &#x3D; 0; i &lt; arraylength; i++) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;array[%d]-&gt;%d&quot;, i, array[i]); &#125;&#125;__attribute__ ((visibility (&quot;hidden&quot;))) void dddd( JNIEnv *env, jclass obj, jobject testobj) &#123; &#x2F;&#x2F; private String privateField &#x3D; &quot;i am a privateField&quot;; jclass TestJclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); jfieldID privateField_fid &#x3D; env-&gt;GetFieldID(TestJclass, &quot;privateField&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); &#x2F;&#x2F; jobject GetObjectField(jobject obj, jfieldID fieldID) jstring privateField_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetObjectField(testobj, privateField_fid)); jstring newString &#x3D; env-&gt;NewStringUTF(&quot;Modified by jni&quot;); env-&gt;SetObjectField(testobj, privateField_fid, newString); privateField_obj &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetObjectField(testobj, privateField_fid)); const char *privateField_obj_content &#x3D; env-&gt;GetStringUTFChars(privateField_obj, nullptr); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;privateField_obj-&gt;%s&quot;, privateField_obj_content); jfieldID privateField_int_fid &#x3D; env-&gt;GetFieldID(TestJclass, &quot;privateField_int&quot;, &quot;I&quot;); env-&gt;SetIntField(testobj, privateField_int_fid, 300); jint privateField_int_value &#x3D; env-&gt;GetIntField(testobj, privateField_int_fid); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;privateField_int_value-&gt;%d&quot;, privateField_int_value); &#x2F;&#x2F; public int[] intarray &#x3D; null; jfieldID intarray_fid &#x3D; env-&gt;GetFieldID(TestJclass, &quot;intarray&quot;, &quot;[I&quot;); jintArray intarray_obj &#x3D; static_cast&lt;jintArray&gt;(env-&gt;GetObjectField(testobj, intarray_fid)); int arraylength &#x3D; env-&gt;GetArrayLength(intarray_obj); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;arraylength-&gt;%d&quot;, arraylength); jint jni_array[arraylength]; for (int j &#x3D; 0; j &lt; arraylength; j++) &#123; jni_array[j] &#x3D; 10 - j; &#125; const jint *ptr &#x3D; jni_array; env-&gt;SetIntArrayRegion(intarray_obj, 0, arraylength, ptr); int *array &#x3D; env-&gt;GetIntArrayElements(intarray_obj, nullptr); for (int i &#x3D; 0; i &lt; arraylength; i++) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;array[%d]-&gt;%d&quot;, i, array[i]); &#125;&#125;jint testPushAndPopLocalFrame(JNIEnv *env) &#123; jobject result &#x3D; nullptr; if (env-&gt;PushLocalFrame(20) &#x3D;&#x3D; 0) &#123; for (int i &#x3D; 0; i &lt; 18; i++) &#123; jstring tmp &#x3D; env-&gt;NewStringUTF(&quot;kanxue&quot;); &#125; jstring tmp1 &#x3D; env-&gt;NewStringUTF(&quot;result1&quot;); jstring tmp2 &#x3D; env-&gt;NewStringUTF(&quot;result2&quot;); result &#x3D; env-&gt;PopLocalFrame(NULL); &#125; else &#123; &#x2F;&#x2F;error &#125; return 100;&#125;&#x2F;&#x2F; 重复绑定JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) &#123; globalVM &#x3D; vm; int result &#x3D; 0; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;JNI_OnLoad(JavaVM *vm, void *reserved)-&gt;%p&quot;, vm); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, &quot;JNI_OnLoad is called&quot;); JNIEnv *env &#x3D; nullptr; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) &#x3D;&#x3D; JNI_OK) &#123; __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;jni-&gt;%s&quot;, &quot;vm-&gt;GetEnv((void**)&amp;env,JNI_VERSION_1_6) success&quot;); &#125; JNINativeMethod jniNativeMethod[] &#x3D; &#123;&#123;&quot;onCreate&quot;, &quot;(Landroid&#x2F;os&#x2F;Bundle;)V&quot;, (void *) onCreate&#125;, &#123;&quot;getNonStaticField&quot;, &quot;(Ljava&#x2F;lang&#x2F;Object;)V&quot;, (void *) cccc&#125; &#125;; jclass MainActivityjclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;MainActivity&quot;); env-&gt;RegisterNatives(MainActivityjclass, jniNativeMethod, sizeof(jniNativeMethod) &#x2F; sizeof(JNINativeMethod)); JNINativeMethod jniNativeMethod2[] &#x3D; &#123;&#123;&quot;onCreate&quot;, &quot;(Landroid&#x2F;os&#x2F;Bundle;)V&quot;, (void *) onCreate&#125;, &#123;&quot;getNonStaticField&quot;, &quot;(Ljava&#x2F;lang&#x2F;Object;)V&quot;, (void *) dddd&#125; &#125;; env-&gt;RegisterNatives(MainActivityjclass, jniNativeMethod2, sizeof(jniNativeMethod2) &#x2F; sizeof(JNINativeMethod)); jclass tmpjclass &#x3D; env-&gt;FindClass(&quot;com&#x2F;kanxue&#x2F;reflectiontest&#x2F;Test&quot;); testjclass &#x3D; static_cast&lt;jclass&gt;(env-&gt;NewWeakGlobalRef(tmpjclass)); jint result_jint &#x3D; testPushAndPopLocalFrame(env); __android_log_print(4, &quot;kanxue-&gt;jni&quot;, &quot;testPushAndPopLocalFrame-&gt;%d&quot;, result_jint); result &#x3D; JNI_VERSION_1_6; return result;&#125; Dalvik123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102709static bool dvmRegisterJNIMethod(ClassObject* clazz, const char* methodName,710 const char* signature, void* fnPtr)711&#123;712 if (fnPtr &#x3D;&#x3D; NULL) &#123;713 return false;714 &#125;715716 &#x2F;&#x2F; If a signature starts with a &#39;!&#39;, we take that as a sign that the native code doesn&#39;t717 &#x2F;&#x2F; need the extra JNI arguments (the JNIEnv* and the jclass).718 bool fastJni &#x3D; false;719 if (*signature &#x3D;&#x3D; &#39;!&#39;) &#123;720 fastJni &#x3D; true;721 ++signature;722 ALOGV(&quot;fast JNI method %s.%s:%s detected&quot;, clazz-&gt;descriptor, methodName, signature);723 &#125;724725 Method* method &#x3D; dvmFindDirectMethodByDescriptor(clazz, methodName, signature);726 if (method &#x3D;&#x3D; NULL) &#123;727 method &#x3D; dvmFindVirtualMethodByDescriptor(clazz, methodName, signature);728 &#125;729 if (method &#x3D;&#x3D; NULL) &#123;730 dumpCandidateMethods(clazz, methodName, signature);731 throwNoSuchMethodError(clazz, methodName, signature, &quot;static or non-static&quot;);732 return false;733 &#125;734735 if (!dvmIsNativeMethod(method)) &#123;736 ALOGW(&quot;Unable to register: not native: %s.%s:%s&quot;, clazz-&gt;descriptor, methodName, signature);737 throwNoSuchMethodError(clazz, methodName, signature, &quot;native&quot;);738 return false;739 &#125;740741 if (fastJni) &#123;742 &#x2F;&#x2F; In this case, we have extra constraints to check...743 if (dvmIsSynchronizedMethod(method)) &#123;744 &#x2F;&#x2F; Synchronization is usually provided by the JNI bridge,745 &#x2F;&#x2F; but we won&#39;t have one.746 ALOGE(&quot;fast JNI method %s.%s:%s cannot be synchronized&quot;,747 clazz-&gt;descriptor, methodName, signature);748 return false;749 &#125;750 if (!dvmIsStaticMethod(method)) &#123;751 &#x2F;&#x2F; There&#39;s no real reason for this constraint, but since we won&#39;t752 &#x2F;&#x2F; be supplying a JNIEnv* or a jobject &#39;this&#39;, you&#39;re effectively753 &#x2F;&#x2F; static anyway, so it seems clearer to say so.754 ALOGE(&quot;fast JNI method %s.%s:%s cannot be non-static&quot;,755 clazz-&gt;descriptor, methodName, signature);756 return false;757 &#125;758 &#125;759760 if (method-&gt;nativeFunc !&#x3D; dvmResolveNativeMethod) &#123;761 &#x2F;* this is allowed, but unusual 一个JNI函数注册到不同的地址，即被注册了多次 *&#x2F;762 ALOGE(&quot;dvmRegisterJNIMethod: %s.%s:%s was already registered&quot;, clazz-&gt;descriptor, methodName, signature);763 &#125;764765 method-&gt;fastJni &#x3D; fastJni;766 dvmUseJNIBridge(method, fnPtr);767768 ALOGV(&quot;JNI-registered %s.%s:%s&quot;, clazz-&gt;descriptor, methodName, signature);769 return true;770&#125;806void dvmUseJNIBridge(Method* method, void* func) &#123;807 method-&gt;shouldTrace &#x3D; shouldTrace(method);808809 &#x2F;&#x2F; Does the method take any reference arguments?810 method-&gt;noRef &#x3D; true;811 const char* cp &#x3D; method-&gt;shorty;812 while (*++cp !&#x3D; &#39;\\0&#39;) &#123; &#x2F;&#x2F; Pre-increment to skip return type.813 if (*cp &#x3D;&#x3D; &#39;L&#39;) &#123;814 method-&gt;noRef &#x3D; false;815 break;816 &#125;817 &#125;818819 DalvikBridgeFunc bridge &#x3D; gDvmJni.useCheckJni ? dvmCheckCallJNIMethod : dvmCallJNIMethod;820 dvmSetNativeFunc(method, bridge, (const u2*) func);821&#125;4559void dvmSetNativeFunc(Method* method, DalvikBridgeFunc func,4560 const u2* insns)4561&#123;4562 ClassObject* clazz &#x3D; method-&gt;clazz;45634564 assert(func !&#x3D; NULL);45654566 &#x2F;* just open up both; easier that way *&#x2F;4567 dvmLinearReadWrite(clazz-&gt;classLoader, clazz-&gt;virtualMethods);4568 dvmLinearReadWrite(clazz-&gt;classLoader, clazz-&gt;directMethods);45694570 if (insns !&#x3D; NULL) &#123;4571 &#x2F;* update both, ensuring that &quot;insns&quot; is observed first *&#x2F;4572 method-&gt;insns &#x3D; insns;4573 android_atomic_release_store((int32_t) func,4574 (volatile int32_t*)(void*) &amp;method-&gt;nativeFunc);4575 &#125; else &#123;4576 &#x2F;* only update nativeFunc *&#x2F;4577 method-&gt;nativeFunc &#x3D; func;4578 &#125;45794580 dvmLinearReadOnly(clazz-&gt;classLoader, clazz-&gt;virtualMethods);4581 dvmLinearReadOnly(clazz-&gt;classLoader, clazz-&gt;directMethods);4582&#125; method-&gt;nativeFunc = func;动态注册就是为了完成java函数在Dalvik中的method结构体中nativeFunc指针的绑定。 接下来通过手动修改aosp源码添加log Jni.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768692459static jint RegisterNatives(JNIEnv* env, jclass jclazz,2460 const JNINativeMethod* methods, jint nMethods)2461&#123;2462 ScopedJniThreadState ts(env);24632464 ClassObject* clazz &#x3D; (ClassObject*) dvmDecodeIndirectRef(ts.self(), jclazz);24652466 if (gDvm.verboseJni) &#123;2467 ALOGI(&quot;[Registering JNI native methods for class %s]&quot;,2468 clazz-&gt;descriptor);2469 &#125;24702471 for (int i &#x3D; 0; i &lt; nMethods; i++) &#123; ALOGE(&quot;[Registering Class:%s,methodname:%s,sig:%s,addr:%p]&quot;,clazz-&gt;descriptor,methods[i].name,methods[i].signature, methods[i].fnPtr);2472 if (!dvmRegisterJNIMethod(clazz, methods[i].name,2473 methods[i].signature, methods[i].fnPtr))2474 &#123;2475 return JNI_ERR;2476 &#125;2477 &#125;2478 return JNI_OK;2479&#125;709static bool dvmRegisterJNIMethod(ClassObject* clazz, const char* methodName,710 const char* signature, void* fnPtr)711&#123;712 if (fnPtr &#x3D;&#x3D; NULL) &#123;713 return false;714 &#125; ALOGE(&quot;[dvmRegisterJNIMethod Class:%s,methodname:%s,sig:%s,addr:%p]&quot;,clazz-&gt;descriptor,methodName,signature, fnPtr);715716 &#x2F;&#x2F; If a signature starts with a &#39;!&#39;, we take that as a sign that the native code doesn&#39;t717 &#x2F;&#x2F; need the extra JNI arguments (the JNIEnv* and the jclass).718 bool fastJni &#x3D; false;719 if (*signature &#x3D;&#x3D; &#39;!&#39;) &#123;720 fastJni &#x3D; true;721 ++signature;722 ALOGV(&quot;fast JNI method %s.%s:%s detected&quot;, clazz-&gt;descriptor, methodName, signature);723 &#125; ...760 if (method-&gt;nativeFunc !&#x3D; dvmResolveNativeMethod) &#123;761 &#x2F;* this is allowed, but unusual *&#x2F;762 ALOGV(&quot;Note: %s.%s:%s was already registered&quot;, clazz-&gt;descriptor, methodName, signature);763 &#125; 765 method-&gt;fastJni &#x3D; fastJni;766 dvmUseJNIBridge(method, fnPtr);767768 ALOGV(&quot;JNI-registered %s.%s:%s&quot;, clazz-&gt;descriptor, methodName, signature);769 return true;770&#125;806void dvmUseJNIBridge(Method* method, void* func) &#123;807 method-&gt;shouldTrace &#x3D; shouldTrace(method); ALOGE(&quot;[dvmUseJNIBridge Class:%s,methodname:%s,addr:%p]&quot;,clazz-&gt;descriptor,method-&gt;name,func);808809 &#x2F;&#x2F; Does the method take any reference arguments?810 method-&gt;noRef &#x3D; true;811 const char* cp &#x3D; method-&gt;shorty;812 while (*++cp !&#x3D; &#39;\\0&#39;) &#123; &#x2F;&#x2F; Pre-increment to skip return type.813 if (*cp &#x3D;&#x3D; &#39;L&#39;) &#123;814 method-&gt;noRef &#x3D; false;815 break;816 &#125;817 &#125;819 DalvikBridgeFunc bridge &#x3D; gDvmJni.useCheckJni ? dvmCheckCallJNIMethod : dvmCallJNIMethod;820 dvmSetNativeFunc(method, bridge, (const u2*) func);821&#125; Class.cpp 1234567891011121314151617181920212223244559void dvmSetNativeFunc(Method* method, DalvikBridgeFunc func,4560 const u2* insns)4561&#123;4562 ClassObject* clazz &#x3D; method-&gt;clazz;45634564 assert(func !&#x3D; NULL);45654566 &#x2F;* just open up both; easier that way *&#x2F;4567 dvmLinearReadWrite(clazz-&gt;classLoader, clazz-&gt;virtualMethods);4568 dvmLinearReadWrite(clazz-&gt;classLoader, clazz-&gt;directMethods);4570 if (insns !&#x3D; NULL) &#123;4571 &#x2F;* update both, ensuring that &quot;insns&quot; is observed first *&#x2F;4572 method-&gt;insns &#x3D; insns;4573 android_atomic_release_store((int32_t) func,4574 (volatile int32_t*)(void*) &amp;method-&gt;nativeFunc);4575 &#125; else &#123;4576 &#x2F;* only update nativeFunc *&#x2F; ALOGE(&quot;[dvmSetNativeFunc Class:%s,methodname:%s,addr:%p]&quot;,method-&gt;clazz-&gt;descriptor,method-&gt;name,func);4577 method-&gt;nativeFunc &#x3D; func;4578 &#125;45794580 dvmLinearReadOnly(clazz-&gt;classLoader, clazz-&gt;virtualMethods);4581 dvmLinearReadOnly(clazz-&gt;classLoader, clazz-&gt;directMethods);4582&#125; 编译好后，重新刷system.img即可。加固app查看日志信息查看Dalvik主动注册原理。 12345source build&#x2F;envsetup.shlunch7 aosp_hammerhead-userdebugtime make -j4flashboot flash system system.img 启动到bootloader ARTjni_internal.cc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149148 static jint RegisterNatives(JNIEnv* env, jclass java_class, const JNINativeMethod* methods,2149 jint method_count) &#123;2150 return RegisterNativeMethods(env, java_class, methods, method_count, true);2151 &#125;3054 void RegisterNativeMethods(JNIEnv* env, const char* jni_class_name, const JNINativeMethod* methods,3055 jint method_count) &#123;3056 ScopedLocalRef&lt;jclass&gt; c(env, env-&gt;FindClass(jni_class_name));3057 if (c.get() &#x3D;&#x3D; nullptr) &#123;3058 LOG(FATAL) &lt;&lt; &quot;Couldn&#39;t find class: &quot; &lt;&lt; jni_class_name;3059 &#125;3060 JNI::RegisterNativeMethods(env, c.get(), methods, method_count, false);3061 &#125;2153 static jint RegisterNativeMethods(JNIEnv* env, jclass java_class, const JNINativeMethod* methods,2154 jint method_count, bool return_errors) &#123;2155 if (UNLIKELY(method_count &lt; 0)) &#123;2156 JavaVmExtFromEnv(env)-&gt;JniAbortF(&quot;RegisterNatives&quot;, &quot;negative method count: %d&quot;,2157 method_count);2158 return JNI_ERR; 2159 &#125;2160 CHECK_NON_NULL_ARGUMENT_FN_NAME(&quot;RegisterNatives&quot;, java_class, JNI_ERR);2161 ScopedObjectAccess soa(env);2162 StackHandleScope&lt;1&gt; hs(soa.Self());2163 Handle&lt;mirror::Class&gt; c &#x3D; hs.NewHandle(soa.Decode&lt;mirror::Class&gt;(java_class));2164 if (UNLIKELY(method_count &#x3D;&#x3D; 0)) &#123;2165 LOG(WARNING) &lt;&lt; &quot;JNI RegisterNativeMethods: attempt to register 0 native methods for &quot;2166 &lt;&lt; c-&gt;PrettyDescriptor();2167 return JNI_OK;2168 &#125;2169 CHECK_NON_NULL_ARGUMENT_FN_NAME(&quot;RegisterNatives&quot;, methods, JNI_ERR);2170 for (jint i &#x3D; 0; i &lt; method_count; ++i) &#123;2171 const char* name &#x3D; methods[i].name;2172 const char* sig &#x3D; methods[i].signature;2173 const void* fnPtr &#x3D; methods[i].fnPtr;2174 if (UNLIKELY(name &#x3D;&#x3D; nullptr)) &#123;2175 ReportInvalidJNINativeMethod(soa, c.Get(), &quot;method name&quot;, i, return_errors);2176 return JNI_ERR;2177 &#125; else if (UNLIKELY(sig &#x3D;&#x3D; nullptr)) &#123;2178 ReportInvalidJNINativeMethod(soa, c.Get(), &quot;method signature&quot;, i, return_errors);2179 return JNI_ERR;2180 &#125; else if (UNLIKELY(fnPtr &#x3D;&#x3D; nullptr)) &#123;2181 ReportInvalidJNINativeMethod(soa, c.Get(), &quot;native function&quot;, i, return_errors);2182 return JNI_ERR;2183 &#125;2184 bool is_fast &#x3D; false; ition from kRunnable to kNative at the2213 &#x2F;&#x2F; entry.2214 if (*sig &#x3D;&#x3D; &#39;!&#39;) &#123;2215 is_fast &#x3D; true;2216 ++sig;2217 &#125;2218 &#x2F;&#x2F; 遍历注册前先获取jni函数在内存中ArtMethod对象指针2222 ArtMethod* m &#x3D; nullptr;2223 bool warn_on_going_to_parent &#x3D; down_cast&lt;JNIEnvExt*&gt;(env)-&gt;vm-&gt;IsCheckJniEnabled();2224 for (ObjPtr&lt;mirror::Class&gt; current_class &#x3D; c.Get();2225 current_class !&#x3D; nullptr;2226 current_class &#x3D; current_class-&gt;GetSuperClass()) &#123; &#x2F;&#x2F; 通过jni函数名及签名找到当前函数在art虚拟机中的表现显示Arthod,任意一个类的函数在调用前都会被加载，为这个类准备内存变量属性函数等，由class_linker.cc中的LoadClassMembers，先遍历field准备ArtField,其次遍历函数，准备好每个函数中的ArtMethod对象才能够完成调用，不论是java还是jni函数。art_method.h中是具体包括了哪些属性包括偏移，索引等。2228 m &#x3D; FindMethod&lt;true&gt;(current_class.Ptr(), name, sig);2229 if (m !&#x3D; nullptr) &#123;2230 break;2231 &#125;2232 2234 m &#x3D; FindMethod&lt;false&gt;(current_class.Ptr(), name, sig);2235 if (m !&#x3D; nullptr) &#123;2236 break;2237 &#125;2238 2239 if (warn_on_going_to_parent) &#123;2240 LOG(WARNING) &lt;&lt; &quot;CheckJNI: method to register \\&quot;&quot; &lt;&lt; name &lt;&lt; &quot;\\&quot; not in the given class. &quot;2241 &lt;&lt; &quot;This is slow, consider changing your RegisterNatives calls.&quot;;2242 warn_on_going_to_parent &#x3D; false;2243 &#125;2244 &#125;2245 2246 if (m &#x3D;&#x3D; nullptr) &#123;2247 c-&gt;DumpClass(2248 LOG_STREAM(return_errors2249 ? ::android::base::ERROR2250 : ::android::base::FATAL_WITHOUT_ABORT),2251 mirror::Class::kDumpClassFullDetail);2252 LOG(return_errors ? ::android::base::ERROR : ::android::base::FATAL)2253 &lt;&lt; &quot;Failed to register native method &quot;2254 &lt;&lt; c-&gt;PrettyDescriptor() &lt;&lt; &quot;.&quot; &lt;&lt; name &lt;&lt; sig &lt;&lt; &quot; in &quot;2255 &lt;&lt; c-&gt;GetDexCache()-&gt;GetLocation()-&gt;ToModifiedUtf8();2256 ThrowNoSuchMethodError(soa, c.Get(), name, sig, &quot;static or non-static&quot;);2257 return JNI_ERR;2258 &#125; else if (!m-&gt;IsNative()) &#123;2259 LOG(return_errors ? ::android::base::ERROR : ::android::base::FATAL)2260 &lt;&lt; &quot;Failed to register non-native method &quot;2261 &lt;&lt; c-&gt;PrettyDescriptor() &lt;&lt; &quot;.&quot; &lt;&lt; name &lt;&lt; sig2262 &lt;&lt; &quot; as native&quot;;2263 ThrowNoSuchMethodError(soa, c.Get(), name, sig, &quot;native&quot;);2264 return JNI_ERR;2265 &#125;2266 2267 VLOG(jni) &lt;&lt; &quot;[Registering JNI native method &quot; &lt;&lt; m-&gt;PrettyMethod() &lt;&lt; &quot;]&quot;;2268 2269 if (UNLIKELY(is_fast)) &#123; 2276 LOG(WARNING) &lt;&lt; &quot;!bang JNI is deprecated. Switch to @FastNative for &quot; &lt;&lt; m-&gt;PrettyMethod();2277 is_fast &#x3D; false; 2279 &#125;2280 2281 const void* final_function_ptr &#x3D; m-&gt;RegisterNative(fnPtr, is_fast);2282 UNUSED(final_function_ptr);2283 &#125;2284 return JNI_OK;2285 &#125;379 const void* ArtMethod::RegisterNative(const void* native_method, bool is_fast) &#123;380 CHECK(IsNative()) &lt;&lt; PrettyMethod();381 CHECK(!IsFastNative()) &lt;&lt; PrettyMethod();382 CHECK(native_method !&#x3D; nullptr) &lt;&lt; PrettyMethod();383 if (is_fast) &#123;384 AddAccessFlags(kAccFastNative);385 &#125;386 void* new_native_method &#x3D; nullptr;387 Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;RegisterNativeMethod(this,388 native_method,389 &#x2F;*out*&#x2F;&amp;new_native_method);390 SetEntryPointFromJni(new_native_method);391 return new_native_method;392 &#125;495 void SetEntryPointFromJni(const void* entrypoint) &#123;496 DCHECK(IsNative());497 SetEntryPointFromJniPtrSize(entrypoint, kRuntimePointerSize);498 &#125;495 void SetEntryPointFromJni(const void* entrypoint) &#123;496 DCHECK(IsNative());497 SetEntryPointFromJniPtrSize(entrypoint, kRuntimePointerSize);498 &#125;500 ALWAYS_INLINE void SetEntryPointFromJniPtrSize(const void* entrypoint, PointerSize pointer_size) &#123;501 SetDataPtrSize(entrypoint, pointer_size);502 &#125;509 ALWAYS_INLINE void SetDataPtrSize(const void* data, PointerSize pointer_size) &#123;510 DCHECK(IsImagePointerSize(pointer_size));511 SetNativePointer(DataOffset(pointer_size), data, pointer_size);512 &#125;ALWAYS_INLINE void SetNativePointer(MemberOffset offset, T new_value, PointerSize pointer_size) &#x2F;&#x2F; new_value指针代表设置要绑定的so的函数地址 接下来通过手动修改aosp源码添加log 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869702148 static jint RegisterNatives(JNIEnv* env, jclass java_class, const JNINativeMethod* methods,2149 jint method_count) &#123; LOG(WARNING) &lt;&lt; &quot;[jni_internal.cc-&gt;RegisterNatives]&quot; &lt;&lt; method_count;2150 return RegisterNativeMethods(env, java_class, methods, method_count, true);2151 &#125;2153 static jint RegisterNativeMethods(JNIEnv* env, jclass java_class, const JNINativeMethod* methods,2154 jint method_count, bool return_errors) &#123;2155 if (UNLIKELY(method_count &lt; 0)) &#123;2156 JavaVmExtFromEnv(env)-&gt;JniAbortF(&quot;RegisterNatives&quot;, &quot;negative method count: %d&quot;,2157 method_count);2158 return JNI_ERR; &#x2F;&#x2F; Not reached except in unit tests.2159 &#125;2160 CHECK_NON_NULL_ARGUMENT_FN_NAME(&quot;RegisterNatives&quot;, java_class, JNI_ERR);2161 ScopedObjectAccess soa(env);2162 StackHandleScope&lt;1&gt; hs(soa.Self());2163 Handle&lt;mirror::Class&gt; c &#x3D; hs.NewHandle(soa.Decode&lt;mirror::Class&gt;(java_class));2164 if (UNLIKELY(method_count &#x3D;&#x3D; 0)) &#123;2165 LOG(WARNING) &lt;&lt; &quot;JNI RegisterNativeMethods: attempt to register 0 native methods for &quot;2166 &lt;&lt; c-&gt;PrettyDescriptor();2167 return JNI_OK;2168 &#125;2169 CHECK_NON_NULL_ARGUMENT_FN_NAME(&quot;RegisterNatives&quot;, methods, JNI_ERR);2170 for (jint i &#x3D; 0; i &lt; method_count; ++i) &#123;2171 const char* name &#x3D; methods[i].name;2172 const char* sig &#x3D; methods[i].signature;2173 const void* fnPtr &#x3D; methods[i].fnPtr; LOG(WARNING) &lt;&lt; &quot;[jni_internal.cc-&gt;RegisterNativeMethods]&quot; &lt;&lt; i &lt;&lt;&quot;:methodname:&quot;&lt;&lt; name&lt;&lt;&quot;,sig:&quot;&lt;&lt;sig&lt;&lt;&quot;,addr:&quot;&lt;&lt;fnPtr;2174 if (UNLIKELY(name &#x3D;&#x3D; nullptr)) &#123;2175 ReportInvalidJNINativeMethod(soa, c.Get(), &quot;method name&quot;, i, return_errors);2176 return JNI_ERR;2177 &#125; else if (UNLIKELY(sig &#x3D;&#x3D; nullptr)) &#123;2178 ReportInvalidJNINativeMethod(soa, c.Get(), &quot;method signature&quot;, i, return_errors);2179 return JNI_ERR;2180 &#125; else if (UNLIKELY(fnPtr &#x3D;&#x3D; nullptr)) &#123;2181 ReportInvalidJNINativeMethod(soa, c.Get(), &quot;native function&quot;, i, return_errors);2182 return JNI_ERR;2183 &#125;......2281 const void* final_function_ptr &#x3D; m-&gt;RegisterNative(fnPtr, is_fast);2282 UNUSED(final_function_ptr);2283 &#125;2284 return JNI_OK;2285 &#125;379 const void* ArtMethod::RegisterNative(const void* native_method, bool is_fast) &#123; &#x2F;&#x2F; PrettyMethod可以获取到当前的函数名380 CHECK(IsNative()) &lt;&lt; PrettyMethod();381 CHECK(!IsFastNative()) &lt;&lt; PrettyMethod();382 CHECK(native_method !&#x3D; nullptr) &lt;&lt; PrettyMethod();383 if (is_fast) &#123;384 AddAccessFlags(kAccFastNative);385 &#125;386 void* new_native_method &#x3D; nullptr;387 Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;RegisterNativeMethod(this,388 native_method,389 &#x2F;*out*&#x2F;&amp;new_native_method); LOG(WARNING) &lt;&lt; &quot;[art_method.cc-&gt;RegisterNative]methodname:&quot; &lt;&lt; PrettyMethod() &lt;&lt;&quot;:addr:&quot;&lt;&lt; native_method;390 SetEntryPointFromJni(new_native_method); &#x2F;&#x2F; 完成具体绑定的工作391 return new_native_method;392 &#125;495 void SetEntryPointFromJni(const void* entrypoint) &#123;496 DCHECK(IsNative()); LOG(WARNING) &lt;&lt; &quot;[art_method.h-&gt;ArtMethod::SetEntryPointFromJni]methodname:&quot; &lt;&lt; PrettyMethod() &lt;&lt;&quot;:addr:&quot;&lt;&lt; entrypoint;497 SetEntryPointFromJniPtrSize(entrypoint, kRuntimePointerSize); &#x2F;&#x2F; kRuntimePointerSize表示app运行在32位为4或64位为8模式下指针的大小498 &#125; 编译刷机 1234source build&#x2F;envsetup.shlunch23 aosp_sailfish-userdebugtime make -j4 很多加壳时机就是在init/initarray或JNI_Onload中实现。init&gt;initarray&gt;JNI_Onload顺序 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"NDK开发","slug":"安卓逆向/NDK开发","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/NDK%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"NDK","slug":"NDK","permalink":"http://onejane.github.io/tags/NDK/"}]},{"title":"业务开发记录","slug":"业务开发记录","date":"2021-07-19T01:56:22.000Z","updated":"2021-12-12T03:09:39.287Z","comments":true,"path":"2021/07/19/业务开发记录/","link":"","permalink":"http://onejane.github.io/2021/07/19/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 支付单号列表查询所有流水信息支付单信息表 123456789CREATE TABLE &#96;motor_payment_transfer_serials&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT, &#96;order_num&#96; varchar(50) NOT NULL COMMENT &#39;订单号&#39;, &#96;transfer_serials_no&#96; varchar(50) NOT NULL COMMENT &#39;流水号&#39;, &#96;third_type&#96; tinyint(4) NOT NULL COMMENT &#39;第三方平台，1:一麻袋，2:杰税帮&#39;, &#96;create_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, &#96;update_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;2936 DEFAULT CHARSET&#x3D;utf8mb4; 流水信息表 12345678910111213141516171819CREATE TABLE &#96;motor_payment_transfer&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT, &#96;mchid&#96; varchar(50) NOT NULL COMMENT &#39;商户号&#39;, &#96;partner_trade_no&#96; varchar(50) NOT NULL COMMENT &#39;商户订单号&#39;, &#96;amount&#96; decimal(10,2) NOT NULL COMMENT &#39;收款金额，单位元&#39;, &#96;enc_bank_no&#96; varchar(64) NOT NULL COMMENT &#39;收款方银行卡号&#39;, &#96;enc_true_name&#96; varchar(64) NOT NULL COMMENT &#39;收款方用户名&#39;, &#96;bank_code&#96; varchar(64) DEFAULT NULL COMMENT &#39;收款方开户行&#39;, &#96;remark&#96; varchar(255) DEFAULT NULL COMMENT &#39;备注&#39;, &#96;create_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, &#96;update_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, &#96;payment_no&#96; varchar(50) DEFAULT &#39;&#39; COMMENT &#39;微信企业付款单号，代付成功后，返回的内部业务单号&#39;, &#96;cmms_amt&#96; int(11) DEFAULT &#39;0&#39; COMMENT &#39;手续费金额，单位分&#39;, &#96;status&#96; tinyint(1) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;状态，0:待转账，1:已转账，2:转账出错，3：已申请&#39;, &#96;uid&#96; int(11) DEFAULT NULL COMMENT &#39;用户id&#39;, &#96;bill_no&#96; varchar(255) DEFAULT NULL COMMENT &#39;一麻袋平台流水号&#39;, PRIMARY KEY (&#96;id&#96;), UNIQUE KEY &#96;udx_partner_trade_no&#96; (&#96;partner_trade_no&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;2465 DEFAULT CHARSET&#x3D;utf8mb4 COMMENT&#x3D;&#39;企业转账记录&#39;; 两张表根据流水号进行关联，一个支付单号关联多个流水号。 首先根据实现根据支付单号查询流水，返回Map。其中key为流水号，value为订单号 123456789public Map&lt;String, String&gt; querySerialsEntByOrderNum(List&lt;String&gt; orderNum) &#123; QueryWrapper&lt;MotorPaymentTransferSerialsENT&gt; ew &#x3D; new QueryWrapper&lt;&gt;(); ew.in(&quot;order_num&quot;, orderNum); List&lt;MotorPaymentTransferSerialsENT&gt; serialsENTS &#x3D; MotorPaymentTransferSerialsMapper.selectList(ew); if(HelperUtil.collectionNotEmpty(serialsENTS)) &#123; return serialsENTS.stream().collect(Collectors.toMap(MotorPaymentTransferSerialsENT::getTransferSerialsNo, MotorPaymentTransferSerialsENT::getOrderNum)); &#125; return null;&#125; 根据订单号列表查询返回Map，其中key流水号，value订单号 根据所有的key转成list后查询所有流水信息返回list 遍历流水信息，根据流水中的流水号和之前返回的Map拿到订单号，定义一个新Map，key为订单号，value为流水信息列表，该Map利用computeIfAbsent将订单号作为key返回一个list，并将流水信息赋值到dto填入value中，完成根据单号列表查询返回所有流水信息，并以单号为key，流水列表为value的map返回结果。 1234567891011121314151617181920public Map&lt;String, List&lt;RpcTransferSerialsDTO&gt;&gt; queryTransferSerialsByOrderNum(List&lt;String&gt; orderNum) &#123; Map&lt;String, String&gt; serialsOrderNumMap &#x3D; paymentTransferSerialsService.querySerialsEntByOrderNum(orderNum); Set&lt;String&gt; serialsNumSet &#x3D; serialsOrderNumMap.keySet(); List&lt;MotorPaymentTransferENT&gt; paymentTransferENTS &#x3D; transferService.queryTransferEntByOrderNum(new ArrayList&lt;&gt;(serialsNumSet)); Map&lt;String, List&lt;RpcTransferSerialsDTO&gt;&gt; orderSerialdataMap &#x3D; new HashMap&lt;&gt;(); for (MotorPaymentTransferENT motorPaymentTransferENT : paymentTransferENTS) &#123; String ordertNum &#x3D; serialsOrderNumMap.get(motorPaymentTransferENT.getPartnerTradeNo()); List&lt;RpcTransferSerialsDTO&gt; paymentTransferENTList &#x3D; orderSerialdataMap.computeIfAbsent(ordertNum, t -&gt; new ArrayList&lt;RpcTransferSerialsDTO&gt;()); RpcTransferSerialsDTO serialsDTO &#x3D; new RpcTransferSerialsDTO() &#123;&#123; setTransferSerialsNo(motorPaymentTransferENT.getPartnerTradeNo()); setStatus(motorPaymentTransferENT.getStatus()); setExceptionCause(motorPaymentTransferENT.getRemark()); setCreateTime(motorPaymentTransferENT.getCreateTime()); setUpdateTime(motorPaymentTransferENT.getUpdateTime()); &#125;&#125;; paymentTransferENTList.add(serialsDTO); &#125; return orderSerialdataMap;&#125; var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://onejane.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://onejane.github.io/tags/mybatis/"}]},{"title":"SO逆向之动态调试入门","slug":"SO逆向之动态调试入门","date":"2021-07-07T09:35:40.000Z","updated":"2022-04-05T14:33:57.725Z","comments":true,"path":"2021/07/07/SO逆向之动态调试入门/","link":"","permalink":"http://onejane.github.io/2021/07/07/SO%E9%80%86%E5%90%91%E4%B9%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 基本环境as-create new project-Native C++,Language选择Java引入easyso1自动安装ndk frida启动hook native方法demo.js frida -U -f com.roysue.easyso1 -l demo.js --no-pause 12345678910111213setImmediate(function()&#123; Java.perform(function()&#123; Java.use(&quot;com.roysue.easyso1.MainActivity&quot;).onCreate.implementation &#x3D; function(x)&#123; console.log(&quot;Entering onCreate!&quot;); return this.onCreate(x); &#125; Java.use(&quot;com.roysue.easyso1.MainActivity&quot;).stringFromJNI.implementation &#x3D; function()&#123; var result &#x3D; this.stringFromJNI(); console.log(&quot;return value of stringFromJNI is &#x3D;&gt; &quot;,result); return result; &#125; &#125;)&#125;) ghidra jeb 反编译工具build.gradle中android.defaultConfig.ndk配置abiFilters的cpu为’arm64-v8a’,’x86_64’,’armeabi-v7a’ 多个版本时 12345objection -g com.android.settings explore 获取系统版本fridaplugin load &#x2F;root&#x2F;Desktop&#x2F;Wallbreakerplugin wallbreaker classdump plugin wallbreaker classdump android.os.Build adb install -r -t --abi arm-v7a app-debug.apk 强制指定安装测试版本 https://github.com/android/ndk-samples.git 打开hello-jni加上defaultConfig中添加ndk的abiFilters无效，被productFlavors中ndk的abiFilters覆盖成v8a md5编译md51234git clone https:&#x2F;&#x2F;github.com&#x2F;pod32g&#x2F;MD5.gitgcc -o md5 md5.c.&#x2F;md5 onejanefile md5 查看编译生成后的文件格式 搜索 ndk cross compile 安卓交叉编译,源码编译成机器码 1234/Android/Sdk/ndk/22.0.7026061/toolchains/llvm/prebuilt/linux-x86_64/bin/clang -target aarch64-linux-android21 md5.c 生成a.outfile a.out 是ELF 64-bit,arm aarch64 adb push a.out /data/local/tmp &amp;&amp; chmod 777./a.out onejane 整合md5ndk开发以32位为主 123ndk &#123; abiFilters &#39;armeabi-v7a&#39;&#125; build.gradle中引入的cmake为CMakeLists.txt 123456externalNativeBuild &#123; cmake &#123; path &quot;src&#x2F;main&#x2F;cpp&#x2F;CMakeLists.txt&quot; version &quot;3.10.2&quot; &#125;&#125; 修改CMakeLists.txt配置so库 123456789# 配置so库add_library( # Sets the name of the library. roysue # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). roysue.c ) 修改MainActivity 123static &#123; System.loadLibrary(&quot;roysue&quot;);&#125; 新建roysue.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;string.h&gt;#include &lt;jni.h&gt;#include &lt;android&#x2F;log.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;JNIEXPORT jstring JNICALLJava_com_roysue_easyso1_MainActivity_stringFromJNI( JNIEnv* env, jobject thiz )&#123;#if defined(__arm__) #if defined(__ARM_ARCH_7A__) #if defined(__ARM_NEON__) #if defined(__ARM_PCS_VFP) #define ABI &quot;armeabi-v7a&#x2F;NEON (hard-float)&quot; #else #define ABI &quot;armeabi-v7a&#x2F;NEON&quot; #endif #else #if defined(__ARM_PCS_VFP) #define ABI &quot;armeabi-v7a (hard-float)&quot; #else #define ABI &quot;armeabi-v7a&quot; #endif #endif #else #define ABI &quot;armeabi&quot; #endif#elif defined(__i386__)#define ABI &quot;x86&quot;#elif defined(__x86_64__)#define ABI &quot;x86_64&quot;#elif defined(__mips64) &#x2F;* mips64el-* toolchain defines __mips__ too *&#x2F;#define ABI &quot;mips64&quot;#elif defined(__mips__)#define ABI &quot;mips&quot;#elif defined(__aarch64__)#define ABI &quot;arm64-v8a&quot;#else#define ABI &quot;unknown&quot;#endif int i, sum&#x3D;0; i &#x3D; 1; &#x2F;&#x2F;语句① while(i&lt;&#x3D;10 &#x2F;*语句②*&#x2F; )&#123; sum+&#x3D;i; i++; &#x2F;&#x2F;语句③ __android_log_print(ANDROID_LOG_INFO, &quot;r0ysue&quot;, &quot;now sum is %d&quot;, sum); &#125;&#x2F;&#x2F; return (*env)-&gt;NewStringUTF(env, &quot;Hello from JNI&quot; ABI &quot;.&quot;); char* msg &#x3D; &quot;r0ysue&quot;; size_t len &#x3D; strlen(msg); uint8_t result[16];&#x2F;&#x2F;&#x2F;&#x2F; md5((uint8_t*)msg, len, result);&#x2F;&#x2F;&#x2F;&#x2F; char* tmp &#x3D; (char*)malloc(16);&#x2F;&#x2F; &#x2F;&#x2F;字符串置空&#x2F;&#x2F; memset(tmp,0x00,sizeof(char)*16);&#x2F;&#x2F;&#x2F;&#x2F; char* final &#x3D; (char*)malloc(16);&#x2F;&#x2F; &#x2F;&#x2F;字符串置空&#x2F;&#x2F; memset(final,0x00,sizeof(char)*16);&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;&#x2F; display result&#x2F;&#x2F; for (i &#x3D; 0; i &lt; 16; i++)&#123;&#x2F;&#x2F; sprintf(tmp,&quot;%2.2x&quot;, result[i]);&#x2F;&#x2F; __android_log_print(ANDROID_LOG_INFO, &quot;r0ysue&quot;, &quot;now tmp is %s&quot;, tmp);&#x2F;&#x2F; sprintf(final, &quot;%s%s&quot;, final, tmp);&#x2F;&#x2F; &#125;&#x2F;&#x2F; __android_log_print(ANDROID_LOG_INFO, &quot;r0ysue&quot;, &quot;now final is %s&quot;, final);&#x2F;&#x2F; return (*env)-&gt;NewStringUTF(env, final); char *r &#x3D; (char *) malloc(16); memset(r,0x00,sizeof(char)*16); char *final &#x3D; (char *) malloc(16); memset(final,0x00,sizeof(char)*16); md5((uint8_t*)msg,len,result); for (i &#x3D; 0; i &lt; 16; i++)&#123; sprintf(r, &quot;%2.2x&quot;, result[i]); __android_log_print(ANDROID_LOG_INFO, &quot;r0ysue&quot;, &quot;Hi,now i is %s\\n&quot;,r); sprintf(final, &quot;%s%s&quot;, final, r); &#125; jstring jresult &#x3D; (*env)-&gt;NewStringUTF(env,final); return jresult;&#125; lldb调试第三方app有一下两种方案 app以debug模式启动，apk保重debuggable==true（重打包或xposed/frida去hook） aosp系统编译成userdebug模式（n5x/sailfish） 具体见Android调试利器之LLDB 12345678910111213141516cd ~&#x2F;Android&#x2F;Sdk&#x2F;ndk&#x2F;22.0.7026061tree -NCfhl | grep -i lldb-servercp toolchains&#x2F;llvm&#x2F;prebuilt&#x2F;linux-x86_64&#x2F;lib64&#x2F;clang&#x2F;11.0.5&#x2F;lib&#x2F;linux&#x2F;aarch64&#x2F;lldb-server ~&#x2F;Desktop&#x2F;ls64cp toolchains&#x2F;llvm&#x2F;prebuilt&#x2F;linux-x86_64&#x2F;lib64&#x2F;clang&#x2F;11.0.5&#x2F;lib&#x2F;linux&#x2F;arm&#x2F;lldb-server ~&#x2F;Desktop&#x2F;lsadb push ls* &#x2F;data&#x2F;local&#x2F;tmp.&#x2F;ls64 platform --listen &quot;0.0.0.0:10086&quot; --server将&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;ndk&#x2F;22.0.7026061&#x2F;toolchains&#x2F;llvm&#x2F;prebuilt&#x2F;linux-x96_64&#x2F;bin加入path,并source ~&#x2F;.zshrclldb platform select remote-androidplatform connect connect:&#x2F;&#x2F;192.168.0.183:10086adb shellps -e|grep easy 拿到进程后attach -p 23171 机器码llvm反汇编成16进制thread list 当前线程dis 当前执行函数register read x0 as调试模式Debug时也可以看到LLDB反汇编的结果 12apt install neofetchneofetch Capstone/Keystone跨平台反汇编器，硬编码直接修改so frida调试native通过dwarf 123git clone https:&#x2F;&#x2F;github.com&#x2F;iGio90&#x2F;Dwarf.gitpip install -r requirements.txtpython dwarf.py 启动frida和dwarf,debug启动easyso fridaobjection -g com.roysue.easyso1 explore 12memory list modules 找到libroysue.somemory list exports libroysue.so 1234567891011function dis(address, number) &#123; for (var i &#x3D; 0; i &lt; number; i++) &#123; var ins &#x3D; Instruction.parse(address); console.log(&quot;address:&quot; + address + &quot;--dis:&quot; + ins.toString()); address &#x3D; ins.next; &#125;&#125;setImmediate(function()&#123; var stringFromJniaddr &#x3D; Module.findExportByName(&quot;libroysue.so&quot;,&quot;Java_com_roysue_easyso1_MainActivity_stringFromJNI&quot;) dis(stringFromJniaddr,10);&#125;) frida -UF -l Intruction.js 打印地址 12345678910111213arm-linux-androidabi-objdump -i libroysue.soobjdump -t libroysue.so 反汇编目标文件显示基本信息，如果显示 no symbols说明符号被抽掉了objdump -tT libroysue.so 查看导出表arm-linux-androidabi-objdump -tT libroysue.so 查看动态导出表arm-linux-androidabi-objdump --all-headers libroysue.so 显示所有可用头信息包括符号表，重定位入口arm-linux-androidabi-objdump -D libroysue.so 反汇编sectionarm-linux-androidabi-objdump -D libroysue.so | grep -100 0c44 arm-linux-androidabi-objdump -g libroysue.sostrings libroysue.so 打印符号表nm -D libroysue.soreadelf -s libroysue.so 查看符号表readelf -A libroysue.so 查看支持的CPU和ABI架构信息size libroysue.so 具体工具查看GNU Binutils patch so010Editor安装插件，Templates-Template Repository-ELF.bt，修改so中的值保存， 1234adb push libroysue.so &#x2F;sdcard&#x2F;Downloadps -e|grep -i easysocat &#x2F;proc&#x2F;17518&#x2F;maps | grep -i libroysue 找到so存储位置并进入后cp &#x2F;sdcard&#x2F;Download&#x2F;libroysue.so .&#x2F; 调整权限后再次运行app，启动后打印logcat | grep -i roysue确实由now改为ooo 反汇编器ghidrarm -rf ~/.cache/vmware 123456apt search openjdk|grep openjdkapt --fix-broken installapt install openjdk-14-jdkupdate-alternatives --config java 查看本机java版本并选择主版本cd ghidra_9.2.1_PUBLIC.&#x2F;ghidraRun 将roysue.so加入分析 jebJEB Decompiler PRO 3.19.1，./jeb_linux.sh，首次输入密码pwd_ilbtcdnwiuypbzeo_，License data使用python2 jebKeygen.py激活 打开roysue idabinary ninja radare2CutterC算法WjCryptLib12345678git clone https:&#x2F;&#x2F;github.com&#x2F;WaterJuice&#x2F;WjCryptLibapt install cmakecmake .&#x2F;makecd projects&#x2F;Md5String.&#x2F;Md5String r0ysue 本身是8e2b0b38f557578f578ef21b33e4df0d，得到0x8e,0x2b,0x0b,0x38,...cd projects&#x2F;Sha256String.&#x2F;Sha256String r0ysue AntiFrida通过Frida内存特征对maps中elf文件进行扫描匹配特征，支持frida-gadget和frida-server easyso1cyberchef加解密，Android Inline Hook中的指令修复详解，Android APP逆向分析基础，Android NDK AES 加解密，**aesTool实现aes加解密** CMakeLists.txt 12345678910111213141516add_library( # Sets the name of the library. roysue # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). aes.h aes.c hex_utils.h hex_utils.c tools.h tools.cpp aes_utils.h aes_utils.c roysue.c) 首先，我们要创建一个 Android 工程，还有一个 MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class MainActivity extends AppCompatActivity &#123; &#x2F;&#x2F; Used to load the &#39;native-lib&#39; library on application startup. static &#123; System.loadLibrary(&quot;roysue&quot;); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#x2F;&#x2F; Example of a call to a native method TextView tv &#x3D; findViewById(R.id.sample_text); tv.setText(method02( method01(&quot;r0ysue&quot;)));&#x2F;&#x2F; Runnable mRunnable &#x3D; new Runnable() &#123;&#x2F;&#x2F; @Override&#x2F;&#x2F; public void run() &#123;&#x2F;&#x2F; while (true) &#123;&#x2F;&#x2F; try &#123;&#x2F;&#x2F; Thread.sleep(2000);&#x2F;&#x2F; &#125; catch (InterruptedException e)&#123;&#x2F;&#x2F; e.printStackTrace();&#x2F;&#x2F; &#125;&#x2F;&#x2F; Log.i(&quot;roysue&quot;,method01(&quot;roysue&quot;));&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;;&#x2F;&#x2F; mRunnable.run(); new Thread()&#123; @Override public void run() &#123; &#x2F;&#x2F;需要在子线程中处理的逻辑 while(true)&#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(&quot;roysueeasyso1&quot;,method01(&quot;r0syue&quot;)); &#125; &#125; &#125;.start(); &#125; &#x2F;** * A native method that is implemented by the &#39;native-lib&#39; native library, * which is packaged with this application. *&#x2F; public native String stringFromJNI(); &#x2F;** * AES加密, CBC, PKCS5Padding *&#x2F; public static native String method01(String str); &#x2F;** * AES解密, CBC, PKCS5Padding *&#x2F; public static native String method02(String str);&#125; 对应的 c 文件 roysue.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274#include &lt;string.h&gt;#include &lt;jni.h&gt;#include &lt;android&#x2F;log.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &quot;aes_utils.h&quot;#include &quot;tools.h&quot;#include &quot;junk.h&quot;#define NELEM(x) ((int) (sizeof(x) &#x2F; sizeof((x)[0])))&#x2F;* This is a trivial JNI example where we use a native method * to return a new VM String. See the corresponding Java source * file located at: * * hello-jni&#x2F;app&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;hellojni&#x2F;HelloJni.java *&#x2F;&#x2F;&#x2F; Constants are the integer part of the sines of integers (in radians) * 2^32.const uint32_t k[64] &#x3D; &#123; 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee , 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501 , 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be , 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821 , 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa , 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8 , 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed , 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a , 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c , 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70 , 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05 , 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665 , 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039 , 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1 , 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1 , 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 &#125;;&#x2F;&#x2F; r specifies the per-round shift amountsconst uint32_t r[] &#x3D; &#123;7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21&#125;;&#x2F;&#x2F; leftrotate function definition#define LEFTROTATE(x, c) (((x) &lt;&lt; (c)) | ((x) &gt;&gt; (32 - (c))))void to_bytes(uint32_t val, uint8_t *bytes)&#123; bytes[0] &#x3D; (uint8_t) val; bytes[1] &#x3D; (uint8_t) (val &gt;&gt; 8); bytes[2] &#x3D; (uint8_t) (val &gt;&gt; 16); bytes[3] &#x3D; (uint8_t) (val &gt;&gt; 24);&#125;uint32_t to_int32(const uint8_t *bytes)&#123; return (uint32_t) bytes[0] | ((uint32_t) bytes[1] &lt;&lt; 8) | ((uint32_t) bytes[2] &lt;&lt; 16) | ((uint32_t) bytes[3] &lt;&lt; 24);&#125;void md5(const uint8_t *initial_msg, size_t initial_len, uint8_t *digest) &#123; &#x2F;&#x2F; These vars will contain the hash uint32_t h0, h1, h2, h3; &#x2F;&#x2F; Message (to prepare) uint8_t *msg &#x3D; NULL; size_t new_len, offset; uint32_t w[16]; uint32_t a, b, c, d, i, f, g, temp; &#x2F;&#x2F; Initialize variables - simple count in nibbles: h0 &#x3D; 0x67452301; h1 &#x3D; 0xefcdab89; h2 &#x3D; 0x98badcfe; h3 &#x3D; 0x10325476; &#x2F;&#x2F;Pre-processing: &#x2F;&#x2F;append &quot;1&quot; bit to message &#x2F;&#x2F;append &quot;0&quot; bits until message length in bits ≡ 448 (mod 512) &#x2F;&#x2F;append length mod (2^64) to message for (new_len &#x3D; initial_len + 1; new_len % (512&#x2F;8) !&#x3D; 448&#x2F;8; new_len++) ; msg &#x3D; (uint8_t*)malloc(new_len + 8); memcpy(msg, initial_msg, initial_len); msg[initial_len] &#x3D; 0x80; &#x2F;&#x2F; append the &quot;1&quot; bit; most significant bit is &quot;first&quot; for (offset &#x3D; initial_len + 1; offset &lt; new_len; offset++) msg[offset] &#x3D; 0; &#x2F;&#x2F; append &quot;0&quot; bits &#x2F;&#x2F; append the len in bits at the end of the buffer. to_bytes(initial_len*8, msg + new_len); &#x2F;&#x2F; initial_len&gt;&gt;29 &#x3D;&#x3D; initial_len*8&gt;&gt;32, but avoids overflow. to_bytes(initial_len&gt;&gt;29, msg + new_len + 4); &#x2F;&#x2F; Process the message in successive 512-bit chunks: &#x2F;&#x2F;for each 512-bit chunk of message: for(offset&#x3D;0; offset&lt;new_len; offset +&#x3D; (512&#x2F;8)) &#123; &#x2F;&#x2F; break chunk into sixteen 32-bit words w[j], 0 ≤ j ≤ 15 for (i &#x3D; 0; i &lt; 16; i++) w[i] &#x3D; to_int32(msg + offset + i*4); &#x2F;&#x2F; Initialize hash value for this chunk: a &#x3D; h0; b &#x3D; h1; c &#x3D; h2; d &#x3D; h3; &#x2F;&#x2F; Main loop: for(i &#x3D; 0; i&lt;64; i++) &#123; if (i &lt; 16) &#123; f &#x3D; (b &amp; c) | ((~b) &amp; d); g &#x3D; i; &#125; else if (i &lt; 32) &#123; f &#x3D; (d &amp; b) | ((~d) &amp; c); g &#x3D; (5*i + 1) % 16; &#125; else if (i &lt; 48) &#123; f &#x3D; b ^ c ^ d; g &#x3D; (3*i + 5) % 16; &#125; else &#123; f &#x3D; c ^ (b | (~d)); g &#x3D; (7*i) % 16; &#125; temp &#x3D; d; d &#x3D; c; c &#x3D; b; b &#x3D; b + LEFTROTATE((a + f + k[i] + w[g]), r[i]); a &#x3D; temp; &#125; &#x2F;&#x2F; Add this chunk&#39;s hash to result so far: h0 +&#x3D; a; h1 +&#x3D; b; h2 +&#x3D; c; h3 +&#x3D; d; &#125; &#x2F;&#x2F; cleanup free(msg); &#x2F;&#x2F;var char digest[16] :&#x3D; h0 append h1 append h2 append h3 &#x2F;&#x2F;(Output is in little-endian) to_bytes(h0, digest); to_bytes(h1, digest + 4); to_bytes(h2, digest + 8); to_bytes(h3, digest + 12);&#125;JNIEXPORT jstring JNICALLJava_com_roysue_easyso1_MainActivity_stringFromJNI( JNIEnv* env, jobject thiz )&#123;#if defined(__arm__) #if defined(__ARM_ARCH_7A__) #if defined(__ARM_NEON__) #if defined(__ARM_PCS_VFP) #define ABI &quot;armeabi-v7a&#x2F;NEON (hard-float)&quot; #else #define ABI &quot;armeabi-v7a&#x2F;NEON&quot; #endif #else #if defined(__ARM_PCS_VFP) #define ABI &quot;armeabi-v7a (hard-float)&quot; #else #define ABI &quot;armeabi-v7a&quot; #endif #endif #else #define ABI &quot;armeabi&quot; #endif#elif defined(__i386__)#define ABI &quot;x86&quot;#elif defined(__x86_64__)#define ABI &quot;x86_64&quot;#elif defined(__mips64) &#x2F;* mips64el-* toolchain defines __mips__ too *&#x2F;#define ABI &quot;mips64&quot;#elif defined(__mips__)#define ABI &quot;mips&quot;#elif defined(__aarch64__)#define ABI &quot;arm64-v8a&quot;#else#define ABI &quot;unknown&quot;#endif int i, sum&#x3D;0; i &#x3D; 1; &#x2F;&#x2F;语句① while(i&lt;&#x3D;10 &#x2F;*语句②*&#x2F; )&#123; sum+&#x3D;i; i++; &#x2F;&#x2F;语句③ __android_log_print(ANDROID_LOG_INFO, &quot;r0ysue&quot;, &quot;now sum is %d&quot;, sum); &#125; char* msg &#x3D; &quot;r0ysue&quot;; size_t len &#x3D; strlen(msg); uint8_t result[16];&#x2F;&#x2F;&#x2F;&#x2F; md5((uint8_t*)msg, len, result);&#x2F;&#x2F;&#x2F;&#x2F; char* tmp &#x3D; (char*)malloc(16);&#x2F;&#x2F; memset(tmp,0x00,sizeof(char)*16);&#x2F;&#x2F;&#x2F;&#x2F; char* final &#x3D; (char*)malloc(16);&#x2F;&#x2F; memset(final,0x00,sizeof(char)*16);&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;&#x2F; display result&#x2F;&#x2F; for (i &#x3D; 0; i &lt; 16; i++)&#123;&#x2F;&#x2F; sprintf(tmp,&quot;%2.2x&quot;, result[i]);&#x2F;&#x2F; __android_log_print(ANDROID_LOG_INFO, &quot;r0ysue&quot;, &quot;now tmp is %s&quot;, tmp);&#x2F;&#x2F; sprintf(final, &quot;%s%s&quot;, final, tmp);&#x2F;&#x2F; &#125;&#x2F;&#x2F; __android_log_print(ANDROID_LOG_INFO, &quot;r0ysue&quot;, &quot;now final is %s&quot;, final);&#x2F;&#x2F;&#x2F;&#x2F; puts(&quot;&quot;);&#x2F;&#x2F; return (*env)-&gt;NewStringUTF(env, final); char *r &#x3D; (char *) malloc(16); memset(r,0x00,sizeof(char)*16); char *final &#x3D; (char *) malloc(16); memset(final,0x00,sizeof(char)*16); md5((uint8_t*)msg,len,result); for (i &#x3D; 0; i &lt; 16; i++)&#123; sprintf(r, &quot;%2.2x&quot;, result[i]); __android_log_print(ANDROID_LOG_INFO, &quot;r0ysue&quot;, &quot;Hi,now i is %s\\n&quot;,r); sprintf(final, &quot;%s%s&quot;, final, r); &#125; jstring jresult &#x3D; (*env)-&gt;NewStringUTF(env,final); return jresult;&#125;JNIEXPORT jstring JNICALLJava_com_roysue_easyso1_MainActivity_method01(JNIEnv *env, jclass clazz, jstring str_) &#123; &#x2F;&#x2F; TODO: implement method01() const char *str &#x3D; (*env)-&gt;GetStringUTFChars(env,str_, JNI_FALSE); char *result &#x3D; AES_128_CBC_PKCS5_Encrypt(str); (*env)-&gt;ReleaseStringUTFChars(env,str_, str); jstring jResult &#x3D; getJString(env, result); free(result); return jResult;&#125;JNIEXPORT jstring JNICALLJava_com_roysue_easyso1_MainActivity_method02(JNIEnv *env, jclass clazz, jstring str_) &#123; &#x2F;&#x2F; TODO: implement method02() const char *str &#x3D; (*env)-&gt;GetStringUTFChars(env,str_, JNI_FALSE); char *result &#x3D; AES_128_CBC_PKCS5_Decrypt(str); (*env)-&gt;ReleaseStringUTFChars(env,str_, str); jstring jResult &#x3D; getJString(env, result); free(result); return jResult;&#125; 编译好后使用ghidra分析，New project后新建文件夹 127z x ghidra_9.2.1_PUBLIC_20201215.zip.&#x2F;ghidraRun 将编译后的解包拿到libroysue.so拖入ghidra 右侧反编译后的代码已经被混淆 frida根据方法名获取地址frida_hook_libart，** hook_ArtMethod_RegisterNative** 12345678910111213setImmediate(function () &#123; console.log(&quot;Invoking...&quot;) var method01_addr &#x3D; Module.findExportByName(&quot;libroysue.so&quot;, &quot;Java_com_roysue_easyso1_MainActivity_method02&quot;); console.log(&quot;method01 addr is &#x3D;&gt;&quot;, method01_addr) # Java_com_roysue_easyso1_MainActivity_method02(JNIEnv *env, jclass clazz, jstring str_) Java.perform(function () &#123; var jstring &#x3D; Java.vm.getEnv().newStringUtf(&quot;4e8de2f3c674d8157b4862e50954d81c&quot;) var method01 &#x3D; new NativeFunction(method01_addr, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]); var result &#x3D; method01(Java.vm.getEnv(), jstring, jstring) console.log(&quot;final result is &#x3D;&gt; &quot;, Java.vm.getEnv().getStringUtfChars(result, null).readCString()); &#125;)&#125;) frida -UF -l FridaInvokeNative.js invoke() ExAndroidNativeEmu1234git clone https:&#x2F;&#x2F;github.com&#x2F;maiyao1988&#x2F;ExAndroidNativeEmu.git 基于Unicorn的模拟器proxychains pyenv install 3.7.0pyenv local 3.7.0proxychains pip install -r requirements.txt easyso1.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import loggingimport posixpathimport sysimport osfrom unicorn import *from unicorn.arm_const import *from androidemu.emulator import Emulatorfrom androidemu.java.java_class_def import JavaClassDeffrom androidemu.java.java_method_def import java_method_defimport androidemu.utils.debug_utilsfrom androidemu.utils.chain_log import ChainLoggerfrom androidemu.java.classes.string import Stringimport capstoneimport tracebackg_cfd &#x3D; ChainLogger(sys.stdout, &quot;.&#x2F;ins-jni.txt&quot;)def hook_code(mu, address, size, user_data): try: emu &#x3D; user_data if (not emu.memory.check_addr(address, UC_PROT_EXEC)): logger.error(&quot;addr 0x%08X out of range&quot;%(address,)) sys.exit(-1) androidemu.utils.debug_utils.dump_code(emu, address, size, g_cfd) except Exception as e: logger.exception(&quot;exception in hook_code&quot;) sys.exit(-1)def hook_mem_read(uc, access, address, size, value, user_data): pc &#x3D; uc.reg_read(UC_ARM_REG_PC) if (address &#x3D;&#x3D; 0xCBC80640): logger.debug(&quot;read mutex&quot;) data &#x3D; uc.mem_read(address, size) v &#x3D; int.from_bytes(data, byteorder&#x3D;&#39;little&#39;, signed&#x3D;False) logger.debug(&quot;&gt;&gt;&gt; Memory READ at 0x%08X, data size &#x3D; %u, data value &#x3D; 0x%08X, pc: 0x%08X,&quot; % (address, size, v, pc))def hook_mem_write(uc, access, address, size, value, user_data): pc &#x3D; uc.reg_read(UC_ARM_REG_PC) if (address &#x3D;&#x3D; 0xCBC80640): logger.debug(&quot;write mutex&quot;) logger.debug(&quot;&gt;&gt;&gt; Memory WRITE at 0x%08X, data size &#x3D; %u, data value &#x3D; 0x%08X, pc: 0x%08X&quot; % (address, size, value, pc))class MainActivity(metaclass&#x3D;JavaClassDef, jvm_name&#x3D;&#39;local&#x2F;myapp&#x2F;testnativeapp&#x2F;MainActivity&#39;): def __init__(self): pass @java_method_def(name&#x3D;&#39;stringFromJNI&#39;, signature&#x3D;&#39;()Ljava&#x2F;lang&#x2F;String;&#39;, native&#x3D;True) def string_from_jni(self, mu): pass def test(self): passlogger &#x3D; logging.getLogger(__name__) emulator &#x3D; Emulator( vfs_root&#x3D;posixpath.join(posixpath.dirname(__file__), &quot;vfs&quot;))# Register Java class.emulator.java_classloader.add_class(MainActivity)# emulator.mu.hook_add(UC_HOOK_CODE, hook_code, emulator)# emulator.mu.hook_add(UC_HOOK_MEM_WRITE, hook_mem_write)# emulator.mu.hook_add(UC_HOOK_MEM_READ, hook_mem_read)# Load all libraries.lib_module &#x3D; emulator.load_library(&quot;tests&#x2F;bin&#x2F;libroysue.so&quot;)logger.info(&quot;Loaded modules:&quot;)for module in emulator.modules: logger.info(&quot;&#x3D;&gt; 0x%08x - %s&quot; % (module.base, module.filename))try: logger.info(&quot;Response from JNI call: %s&quot; % emulator.call_symbol(lib_module,&quot;Java_com_roysue_easyso1_MainActivity_method01&quot;,emulator.java_vm.jni_env.address_ptr, 0x00, String(&#39;Hello&#39;))) logger.info(&quot;Response from JNI call: %s&quot; % emulator.call_symbol(lib_module,&quot;Java_com_roysue_easyso1_MainActivity_method02&quot;,emulator.java_vm.jni_env.address_ptr, 0x00, String(&#39;a8e98de3a13365e39030feefb6c508f7&#39;))) logger.info(&quot;Exited EMU.&quot;) logger.info(&quot;Native methods registered to MainActivity:&quot;)except UcError as e: print(&quot;Exit at %x&quot; % emulator.mu.reg_read(UC_ARM_REG_PC)) raise gdb调试 可调试内核 支持全平台 qemu内置 内核硬件断点，开启内存断点 建议使用aosp810自行编译的系统，将app编译成带调试符号的so 12345678910111213141516171819202122232425tree -NChfl | grep -i gdbfile aosp810r1&#x2F;prebuilts&#x2F;misc&#x2F;android-arm64&#x2F;gdbserver64 app端将misc文件夹中所有架构的gdb拷贝出来放到&#x2F;data&#x2F;local&#x2F;tmp&#x2F;gdbserveradb shell.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;gdbserver&#x2F;android-arm64&#x2F;gdbserver64 --help.&#x2F;fs1280arm64objection -g com.roysue.easyso1 explore frida 查看Process Architecture架构为arm架构，即32位ps -e|grep -i zgygote 查看孵化器进程id，如zgygote为3316，zgygote64位3317ps -e|grep -i 3316 查看32位的包chmod 777 android-arm&#x2F;gdbserveradb shell dumpsys activity top|grep com.roysue.easyso1 查看顶层app包名adb shell am start -D -n com.roysue.easyso1&#x2F;.MainActivity 调试模式运行ps -e|grep -i roysue 获取进程id为19175.&#x2F;gdbserver 0.0.0.0:23946 --attach 19175file aosp810r1&#x2F;prebuilts&#x2F;gcc&#x2F;linux-x86 在ip为192.168.0.129的kali中启动.&#x2F;linux-x86&#x2F;bin&#x2F;gdb(gdb) target remote 192.168.0.183:23946 app端ip为192.168.0.183(gdb) info shared 查看so的共享库(gdb) set disassemble-next on 指令回显(gdb) set step-mode on 打开单步调试(gdb) c.&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;tools&#x2F;jdb -connect com.sun.jdi.SocketAttach:hostname&#x3D;127.0.0.1,port&#x3D;8700 继续执行.&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;tools&#x2F;ln -s &#x2F;root&#x2F;Desktop&#x2F;android-studio&#x2F;jre&#x2F; &#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;tools&#x2F;lib&#x2F;monitor-x86_64&#x2F; 启动ddms，.&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;tools&#x2F;monitor 配置CMakeLists.txt 允许调试模块 123SET(CMAKE_BUILD_TYPE &quot;Debug&quot;)SET(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g2 -ggdb&quot;)SET(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;) 在build.gradle的android模块中加入 12345packagingOptions&#123; doNotStrip &quot;*&#x2F;armeabi&#x2F;*.so&quot; doNotStrip &quot;*&#x2F;armeabi-v7a&#x2F;*.so&quot; doNotStrip &quot;*&#x2F;x86&#x2F;*.so&quot;&#125; 编译好后解包拿到libroysue.so 123objdump -T libroysue.so 导出表objdump -t libroysue.so | more 符号表nm -s libroysue.so | grep method 查看符号表偏移 000033f5 HyperPwn调试https://github.com/bet4it/hyperpwn.git，[Kali安装Hyperpwn(基于gdb的调试利器)](https://bbs.pediy.com/thread-265856.htm)，[Hyperpwn:基于gdb的调试利器，让你的调试过程更轻松](https://bbs.pediy.com/thread-257344.html) apt –fix-broken install dpkg -i hyper_3.1.0-canary.4_amd64.deb 123456su kali 使用非root用户权限运行hyper versioncd &#x2F;opt&#x2F;Hypersudo chmod 4755 chrome-sandboxhyper -v 报错cannot open display: :0.0,将kali切换用户switch user,kali&#x2F;kali 登录后启动hyper 启动 安装插件需要代理，虽然proxychains可以代理，但是只能单个命令使用 1vim &#x2F;etc&#x2F;redsocks.conf 1redsocks 直接启动，ss -nltp|more 检查代理是否启动 sh iptables.sh 123456789101112131415#不重定向目的地址为服务器的包sudo iptables -t nat -A OUTPUT -d 192.168.179.1 -j RETURN #请用你的shadowsocks服务器的地址替换$SERVER_IP #不重定向私有地址的流量sudo iptables -t nat -A OUTPUT -d 10.0.0.0&#x2F;8 -j RETURNsudo iptables -t nat -A OUTPUT -d 172.16.0.0&#x2F;16 -j RETURNsudo iptables -t nat -A OUTPUT -d 192.168.0.0&#x2F;16 -j RETURN #不重定向保留地址的流量,这一步很重要sudo iptables -t nat -A OUTPUT -d 127.0.0.0&#x2F;8 -j RETURN #重定向所有不满足以上条件的流量到redsocks监听的12345端口sudo iptables -t nat -A OUTPUT -p tcp -j REDIRECT --to-ports 12345 #12345是你的redsocks运行的端口,请根据你的情况替换它curl ip.sb 查看全局科学的代理配置完成 安装插件 12hyper i hyperinatorhyper i hyperpwn 切换用户到kali 1hyper 更新插件报错error An unexpected error occurred: &quot;...getaddrinfo ENOENT raw.githubusercontent.com&quot;. 123vim &#x2F;etc&#x2F;hosts151.101.76.133 raw.githubusercontent.com重新Update,知道右上角出现Plugins Updated 切回用户root 123456adb push ~&#x2F;Android&#x2F;Sdk&#x2F;ndk&#x2F;22.0.7026061&#x2F;prebuild &#x2F;data&#x2F;local&#x2F;tmpapt search gdb-multiarchapt install gdb-multiarch gdbqcat &#x2F;proc&#x2F;13709&#x2F;status 查看TracerPid为0就是不可调试 切回kali插件安装 1234567git clone https:&#x2F;&#x2F;github.com&#x2F;pwndbg&#x2F;pwndbg.gitcd pwndbg.&#x2F;setup.shwget -O ~&#x2F;.gdbinit-gef.py -q http:&#x2F;&#x2F;gef.blah.cat&#x2F;pyecho source ~&#x2F;.gdbinit-gef.py &gt;&gt; ~&#x2F;.gdbinitgdb-multiarchhyper 1234567经常忘记：kali开sshd服务：# vim &#x2F;etc&#x2F;ssh&#x2F;sshd_configPermitRootLogin yes# &#x2F;etc&#x2F;init.d&#x2F;ssh start开机自启：update-rc.d ssh enable 开始attach，通过查看app架构为32位 123456ps -e|grep roysue 父进程id为3109，进程id为13709ps -e|grep zygote 进程也为3109ps -e|grep 3109chmod 777 &#x2F;data&#x2F;local&#x2F;tmp&#x2F;prebuilt&#x2F;android-arm&#x2F;gdbserver&#x2F;gdbserver.&#x2F;gdbserver 0.0.0.0:23946 --attach 13709cat &#x2F;proc&#x2F;13709&#x2F;maps | grep libroysue 查看带x权限的基地址 切换到kali账户 1234567891011hypertarget remote 192.168.0.183:23946set arch armset arm fallback-mode thumbc 运行到下个断点ctrl+c 停止执行info share 看所有加载sox&#x2F;20i 0x33f5+0xcfc2e000 查看b *(0x33f5+0xcfc2e000) 下断点 so基地址+函数偏移info b 查看断点c 运行到下个断点F8 进入函数F7 123objection -g com.roysue.easyso1 explorememory list modules 找到libroysue.so的基地址memory list exports libroysue.so 找出so的所有函数即地址 1234b *0xd3c31377b *0xd3c324ddcinvoke() arm汇编Android CPU 架构详解 12345678910111213141516171819202122232425file ~&#x2F;Android&#x2F;Sdk&#x2F;ndk&#x2F;22.0.7026061&#x2F;toolchains&#x2F;llvm&#x2F;prebuilt&#x2F;linux-x86_64&#x2F;bin&#x2F;*~&#x2F;Android&#x2F;Sdk&#x2F;ndk&#x2F;22.0.7026061&#x2F;toolchains&#x2F;llvm&#x2F;prebuilt&#x2F;linux-x86_64&#x2F;bin&#x2F;clang++ -target aarch64-linux-android21 md5.c 编译c文件.&#x2F;md5 r0ysueclang -target aarch64-linux-android21 md5.c -o md5arrch64 编译成64位adb push md5aarch64 &#x2F;data&#x2F;loca&#x2F;tmp.&#x2F;md5aarch64 r0ysue clang -target armv7a-linux-android21 md5.c -o md5v7a 编译成32位clang -target arm-linux-android21 md5.c -o md5armclang -target arm-linux-android21 -E md5.c -o md5arm.i 预处理,将依赖的库进行展开clang -target arm-linux-android21 -S md5arm2.i -o md5arm.s 编译clang -target arm-linux-android21 md5arm.o 汇编成二进制clang -target arm-linux-android21 md5arm.o -o md5Arm2 链接.&#x2F;md5Arm2 roysuellvm-readelf --sections md5Arm2llvm-nm md5Arm2man nmclang -target arm-linux-android21 md5.c -c -o md5.bc -emit-llvm 二进制文件不可读llvm-dis md5.bc -o md5.ll 生成字节码llvm-as md5.ll -o md52.bcapt install llvm-ll-toolsllc md52.bc -o md52.sclang -target arm-linux-android21 -c md52.s -o md52.o 打包成可执行程序但是没有链接符号clang -target arm-linux-android21 md52.o -o md52.&#x2F;md52 roysue ARM 反汇编基础，常用ARM指令 unicornhello.c 12345678910#include &lt;stdio.h&gt; int main()&#123; &#x2F;* 我的第一个 C 程序 *&#x2F; getchar(); printf(&quot;Hello, World! \\n&quot;); return 0;&#125; 编译 12345clang -target armv7a-linux-android21 -E hello.c -o hello.i 预编译clang -target arm-linux-android21 -S hello.i -o hello.s 编译成汇编clang -target arm-linux-android21 -mthumb -S hello.i -o helloTHUMB.s 开启thumb模式clang -target arm-linux-android21 hello.s -o hello.&#x2F;hello roysue 全局科学 123sh iptables.shredsockscurl ip.sb 调试 1234567891011121314151617181920.&#x2F;Hyper-3.1.0-canary.4.AppImage --no-sandboxvim ~&#x2F;.zshrcalias hyper2&#x3D;&#39;&#x2F;root&#x2F;Desktop&#x2F;Hyper-3.1.0-canary.4.AppImage --no-sandbox&#39;source ~&#x2F;.zshrchyper2npm install hyperinatornpm install hyperpwngit clone https:&#x2F;&#x2F;github.com&#x2F;pwndbg&#x2F;pwndbg.gitcd pwndbg.&#x2F;setup.shwget -O ~&#x2F;.gdbinit-gef.py -q http:&#x2F;&#x2F;gef.blah.cat&#x2F;pyecho source ~&#x2F;.gdbinit-gef.py &gt;&gt; ~&#x2F;.gdbinitvim ~&#x2F;.hyper.jsplugins: [&quot;hyperinator&quot;,&quot;hyperpwn&quot;]hyper2 左上角Plugins-updategdb-multiarchhyperadb shell.&#x2F;gdbserver 0.0.0.0:23946 hello 1234target remote 192.168.3.13:23946b main 下断点c 执行到下一个断点disassemble main 反编译main函数，等同于objdump -t hello ， 查看main函数的起始地址00001410 123adb shellps -e|grep -i hello 进程id为13120cat &#x2F;proc&#x2F;13120&#x2F;maps | grep hello hex(0xaae13000+0x1410)=0xaae14410 是main函数的起始地址，但是断点却下在了0xaae1441c，ARM三级流水线，pc值=当前指令内存地址+8。 123456b *0xaae14410 因为已经过了断点，重启gdbserver,在hyper中重打断点，但是每次启动地址可能不一样info registers 查看指令对应的值ni 汇编级别逐步调试，n是源码级别逐步调试 x&#x2F;4xw 0xab24043c 查看内存中的值hexdump 0xab23f370+0x8 打印地址值si 进入指令 结合frida 1234567clang -target arm-linux-android21 -mthumb hello.c -o hellogetchar.&#x2F;hellogetcharfrida -U -f &quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;hello&quot; --no-pauseProcess 进程id为14526Process.enumerateModules()Process.findModuleByName(&quot;hellogetchar&quot;) 获取base地址.&#x2F;gdbserver 0.0.0.0:23946 --attach 14526 hello.s 123456789101112131415 .text .syntax unified .fpu neon .file &quot;hello.c&quot; .globl main @ -- Begin function main .p2align 2 .type main,%function .code 32 @ @mainmain: push &#123;lr&#125; ldr r0,[r1,#8] bl printf mov r0,#0 pop &#123;lr&#125; bx lr 编译 12345678910111213clang -target armv7a-linux-android21 hello.s -o helloLASTadb push helloLAST &#x2F;data&#x2F;local&#x2F;tmp.&#x2F;helloLAST 1 123.&#x2F;gdbserver 0.0.0.0:23946 .&#x2F;helloLAST 1 abchyper2target remote 192.168.3.13:23946disassemble mainb *0xaae46400cinfo registersnihexdump *(0xfffefa14+0x8) objdump 123clang -target armv7a-linux-android21 -mthumb helloTHUMB.s -o helloTHUMBadb push helloTHUMB &#x2F;data&#x2F;local&#x2F;tmpobjdump -d helloTHUMB 报错can&#39;t disassemble for architecture UNKNOWN! 不能在x86机器反编译arm的汇编，kali nethunter上pkg install binutils安装objdump,在手机端调用反编译，或者将手机中的该文件拷贝出来使用，反编译拿到指令 主动执行汇编 1234567891011121314151617181920212223242526272829303132import unicorn import capstoneimport binascii# 142a: 4608 mov r0, r1# 141c: 4479 add r1, pcdef testthumb(): # CODE &#x3D; b&#39;\\x08\\x46\\x79\\x44&#39; CODE &#x3D; b&#39;\\x0a\\x46\\x03\\x46&#39; CP &#x3D; capstone.Cs(capstone.CS_ARCH_ARM,capstone.CS_MODE_THUMB) for i in CP.disasm(CODE,0,len(CODE)): print(&quot;[addr:%x]:%s %s\\n&quot;%(i.address,i.mnemonic,i.op_str)) mu&#x3D;unicorn.Uc(unicorn.UC_ARCH_ARM,unicorn.UC_MODE_THUMB) ADDRESS&#x3D;0x1000 SIZE&#x3D;1024 mu.mem_map(ADDRESS,SIZE) mu.mem_write(ADDRESS,CODE) bytes &#x3D; mu.mem_read(ADDRESS,10) print(&quot;ADDRESS:0x%x,contents:%s&quot;%(ADDRESS,binascii.b2a_hex (bytes))) mu.reg_write(unicorn.arm_const.UC_ARM_REG_R0,0x100) mu.reg_write(unicorn.arm_const.UC_ARM_REG_R1,0x200) mu.reg_write(unicorn.arm_const.UC_ARM_REG_R2,0x300) mu.reg_write(unicorn.arm_const.UC_ARM_REG_R3,0x400) mu.emu_start(ADDRESS+1,ADDRESS+4) print(&quot;result is 0x%x&quot;%(mu.reg_read(unicorn.arm_const.UC_ARM_REG_R2))) print(&quot;result is 0x%x&quot;%(mu.reg_read(unicorn.arm_const.UC_ARM_REG_R3)))if __name__&#x3D;&#x3D;&#39;__main__&#39;: testthumb() Unidbg 基于Unicorn(直接执行arm汇编)，配合libc.so,libart.so等so库对精简安卓系统的模拟实现。 1234567891011121314151617181920212223242526272829303132333435363738394041function stringToByte(str) &#123; var len, c; len &#x3D; str.length; var bytes &#x3D; []; for(var i &#x3D; 0; i &lt; len; i++) &#123; c &#x3D; str.charCodeAt(i); if(c &gt;&#x3D; 0x010000 &amp;&amp; c &lt;&#x3D; 0x10FFFF) &#123; bytes.push(((c &gt;&gt; 18) &amp; 0x07) | 0xF0); bytes.push(((c &gt;&gt; 12) &amp; 0x3F) | 0x80); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); &#125; else if(c &gt;&#x3D; 0x000800 &amp;&amp; c &lt;&#x3D; 0x00FFFF) &#123; bytes.push(((c &gt;&gt; 12) &amp; 0x0F) | 0xE0); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); &#125; else if(c &gt;&#x3D; 0x000080 &amp;&amp; c &lt;&#x3D; 0x0007FF) &#123; bytes.push(((c &gt;&gt; 6) &amp; 0x1F) | 0xC0); bytes.push((c &amp; 0x3F) | 0x80); &#125; else &#123; bytes.push(c &amp; 0xFF); &#125; &#125; return new Int8Array(bytes);&#125;var handle;function testdlopen()&#123; var dlopen_addr&#x3D;Module.findExportByName(&quot;libc.so&quot;,&quot;dlopen&quot;); var dlopen&#x3D;new NativeFunction(dlopen_addr,&quot;pointer&quot;,[&quot;pointer&quot;,&quot;int&quot;]); var soPath&#x3D;stringToByte(&quot;&#x2F;system&#x2F;lib&#x2F;libmobileServer.so&quot;); const pathAddr &#x3D; Memory.alloc(soPath.length); Memory.writeByteArray(pathAddr,soPath); handle&#x3D;dlopen(pathAddr,1);&#125;function testdlclose()&#123; var dlclose_addr&#x3D;Module.findExportByName(&quot;libc.so&quot;,&quot;dlclose&quot;); var dlclose&#x3D;new NativeFunction(dlclose_addr,&quot;int&quot;,[&quot;pointer&quot;]); var retVal&#x3D;dlclose(handle); console.log(&quot;retVal&quot;,retVal);&#125; cat /proc/10783/maps | grep system/lib64 简单粗暴的so加解密实现 从零打造简单的SODUMP工具 Android逆向中So模块自动化修复工具+实战一发 Android加固中So文件自动化修复工具GUI IDA看雪第三题对frida做了检测，输入账户密码后上frida闪退 IDA64bit打开libnative-lib.so，查看导出表，shift+F12查看so中的所有字符串，c++filt _ZN7_JNIEnv15RegisterNativesEP7_jclassPK15JNINativeMethodi,IDA会自动将这些字符串通过c++filt转为导出函数 进入init函数，F5反编译 123456789101112131415__int64 init()&#123; unsigned __int64 v0; &#x2F;&#x2F; x8 unsigned __int64 v1; &#x2F;&#x2F; ST00_8 __int64 result; &#x2F;&#x2F; x0 char v3; &#x2F;&#x2F; [xsp+20h] [xbp-10h] __int64 v4; &#x2F;&#x2F; [xsp+28h] [xbp-8h] v0 &#x3D; _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)); v4 &#x3D; *(_QWORD *)(v0 + 40); v1 &#x3D; v0; result &#x3D; pthread_create(&amp;v3, 0LL, detect_frida_loop, 0LL); *(_QWORD *)(v1 + 40); return result;&#125; 进入detect_frida_loop，可以尝试不要检测任意地址0.0.0.0,或者strcmp(&amp;v2, &quot;REJECT&quot;)不相等即可 1234567891011121314151617181920212223242526272829303132void __fastcall __noreturn detect_frida_loop(void *a1)&#123; ...... inet_aton(&quot;0.0.0.0&quot;, &amp;v8); while ( 1 ) &#123; for ( i &#x3D; 1; i &lt;&#x3D; 65533; ++i ) &#123; v5 &#x3D; socket(2LL, 1LL, 0LL); v7 &#x3D; bswap32((unsigned __int16)i) &gt;&gt; 16; if ( (unsigned int)connect(v5, &amp;v6, 16LL) !&#x3D; -1 ) &#123; ...... v3 &#x3D; recvfrom(v5, &amp;v2, 6LL, 64LL, 0LL, 0LL); if ( v3 !&#x3D; -1 ) &#123; if ( (unsigned int)strcmp(&amp;v2, &quot;REJECT&quot;) ) &#123; __android_log_print(4LL, &quot;pediy&quot;, &quot;not FOUND FRIDA SERVER&quot;); &#125; else &#123; v1 &#x3D; getpid(); kill(v1, 9LL); &#125; &#125; &#125; close(v5); &#125; &#125;&#125; 双击0.0.0.0，进入只读段的汇编代码 点中”0.0.0.0”，进入Hex View-1 C编码是ASCII码表，JAVA是UNICODE，尝试hex-to-ascii Swap后将2.2.2.2转为十六进制 F2修改So中的Hex，改完后再F2再应用 保存 回到Pseudocode-C重新F5反编译刷新 一般使用apk d 3.apk，再通过将so放到解开的文件夹中替换，apktool b 3 -o 3_mod.apk,但是没有签名无法安装，签名回编译uber-apk-signer,java -jar uber-apk-signer-1.1.0.jar -a 3_mod.apk --allowResign完成自动签名，重新安装即可。 回到Pseudocode-C页面，点中REJECT 双击进入IDA View-A，点中REJECT，进入Hex View-1 将REJECT改成“666666” 同样F2修改原字符串的十六进制，F2应用并保存 重新解析 完成过frida检测。 adb shell &amp;&amp; ls /system/lib64 查看所有so frida-ps -Ua 查看所有进程的包名 Frida尝试hook so层的函数 frida -U -f com.kanxue.pediy1 -l demo.js 启动后使用%resume重新加载 123456789101112131415161718192021function hookstrcmp()&#123; Java.perform(function() &#123; var addr_strcmp &#x3D; Module.findExportByName(&quot;libc.so&quot;,&quot;strcmp&quot;); Interceptor.attach(addr_strcmp, &#123; onEnter: function (args) &#123; if(ptr(args[1]).readCString().indexOf(&quot;REJECT&quot;)&gt;&#x3D;0)&#123; console.log(&quot;[*] strcmp (&quot; + ptr(args[0]).readCString() + &quot;,&quot; + ptr(args[1]).readCString()+&quot;)&quot;); this.isREJECT &#x3D; true; &#125; &#125;,onLeave:function(retval)&#123; if(this.isREJECT)&#123; retval.replace(0x1); console.log(&quot;the REJECT&#39;s result :&quot;,retval); &#125; &#125; &#125;); &#125;)&#125;setImmediate(hookstrcmp); 52第三题https://www.52pojie.cn/thread-1369661-1-1.html https://www.52pojie.cn/thread-1378761-1-1.htmlhttps://www.52pojie.cn/thread-1371527-1-1.htmlhttps://www.52pojie.cn/thread-1383999-1-1.html 1adb install 2021wuai.apk 直接ida打开libnative-lib.so，搜索check，或者查看shift+f12查看so中的字符串 查看Java_cn_pojie52_cm01_MainActivity_check，并F5查看源代码，修改类型 Frida开始hook frida-ps -Ua 查看所有包名 frida -U -n com.pojie52.cm01 -l 2021wuai.js 调用inline_hook() 123456789101112131415161718192021222324252627282930313233343536&#x2F;&#x2F; sub_B90((int)dest, v7, &quot;areyousure??????&quot;);function inline_hook() &#123; Java.perform(function() &#123; var addr_libnative &#x3D; Module.findBaseAddress(&quot;libnative-lib.so&quot;); if (addr_libnative) &#123; console.log(&quot;so基址: &quot;, addr_libnative); &#x2F;&#x2F; 尝试hook sub_B90((int)dest, v7, &quot;areyousure??????&quot;) 这行语句打印出入参 var sub_B90 &#x3D; addr_libnative.add(0xB90); &#x2F;&#x2F; so基址+物理地址（0xB90）&#x3D; 0x73bdd49000+8AC&#x3D;0x73bdd498AC Interceptor.attach(sub_B90, &#123; onEnter: function(args) &#123; this.arg0 &#x3D; args[0]; &#x2F;&#x2F; 传入明文字符串 this.arg1 &#x3D; args[1]; &#x2F;&#x2F; 明文字符串长度 this.arg2 &#x3D; args[2]; &#x2F;&#x2F; 固定字符串 console.log(&quot;\\n&quot;,hexdump(this.arg0)); console.log(&quot;\\n&quot;,this.arg1); console.log(&quot;\\n&quot;,hexdump(this.arg2)); &#125;, onLeave:function(retval)&#123; console.log(&quot;-------sub_B90 retval -------&quot;); console.log(&quot;\\n&quot;,hexdump(this.arg0)); console.log(&quot;\\n&quot;,this.arg1); console.log(&quot;\\n&quot;,hexdump(this.arg2)); &#125; &#125;); &#125; &#125;);&#125;setImmediate(inline_hook); 调试frida又想调试ida，需要先跑frida再挂IDA，F2加上断点方便对比，8AC 123adb push android_server64 &#x2F;data&#x2F;local&#x2F;tmpmv android_server64 as64chmod 777 as64 新起IDA 点击放行，由于so基地址通过frida拿到为0x73bdd49000+8AC=0x73bdd498AC，可以用python十进制转十六进制，hex(0x73bdd49000+0x8AC)G直接跳转，C转成字节码 对比静态分析 打上断点 点击屏幕删干掉验证按钮，F8单步调试，查看X0，就是我们输入的字符串值 以上是两种获取寄存器中值的方案。 hook方法sub_B90对输入内容加密和sub_D90是一个base64编码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 v29 &#x3D; *(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40); if ( (*a1)-&gt;GetStringUTFLength(a1, a3) !&#x3D; 30 ) return 0; v5 &#x3D; (*a1)-&gt;GetStringUTFChars(a1, a3, 0LL); v28 &#x3D; 0u; v27 &#x3D; 0u; v26 &#x3D; 0u; *dest &#x3D; 0u; v6 &#x3D; strlen(v5); strncpy(dest, v5, v6); (*a1)-&gt;ReleaseStringUTFChars(a1, a3, v5); v7 &#x3D; strlen(dest); sub_B90(dest, v7, &quot;areyousure??????&quot;); v8 &#x3D; strlen(dest); v9 &#x3D; sub_D90(dest, v8); *v19 &#x3D; unk_11A1; *&amp;v19[16] &#x3D; unk_11B1; *&amp;v19[25] &#x3D; unk_11BA; v10.n128_u64[0] &#x3D; 0xB2B2B2B2B2B2B2B2LL; v10.n128_u64[1] &#x3D; 0xB2B2B2B2B2B2B2B2LL; v11.n128_u64[0] &#x3D; 0xFEFEFEFEFEFEFEFELL; v11.n128_u64[1] &#x3D; 0xFEFEFEFEFEFEFEFELL; v19[0] &#x3D; 53; v12 &#x3D; veorq_s8(vaddq_s8(veorq_s8(vaddq_s8(*&amp;v19[1], v10), xmmword_1130), xmmword_1140), v11); v13.n128_u64[0] &#x3D; 0x101010101010101LL; v13.n128_u64[1] &#x3D; 0x101010101010101LL; v14.n128_u64[0] &#x3D; 0x3E3E3E3E3E3E3E3ELL; v14.n128_u64[1] &#x3D; 0x3E3E3E3E3E3E3E3ELL; *&amp;v19[1] &#x3D; vaddq_s8( veorq_s8(vsubq_s8(v13, vorrq_s8(vshrq_n_u8(v12, 7uLL), vshlq_n_s8(v12, 1uLL))), xmmword_1150), v14); v20 &#x3D; 1782990162; v15 &#x3D; veorq_s8(vaddq_s8(veorq_s8(vaddq_s8(*&amp;v19[17], v10), xmmword_1160), xmmword_1170), v11); v21 &#x3D; ((1 - ((2 * ((((unk_11C6 - 78) ^ 0xB2) - 117) ^ 0xFE)) | ((((((unk_11C6 - 78) ^ 0xB2) - 117) ^ 0xFE) &amp; 0x80) !&#x3D; 0))) ^ 0x25) + 62; v16 &#x3D; 0LL; v22 &#x3D; ((1 - ((2 * ((((unk_11C7 - 78) ^ 0xB1) - 118) ^ 0xFE)) | ((((((unk_11C7 - 78) ^ 0xB1) - 118) ^ 0xFE) &amp; 0x80) !&#x3D; 0))) ^ 0x26) + 62; *&amp;v19[17] &#x3D; vaddq_s8( veorq_s8(vsubq_s8(v13, vorrq_s8(vshrq_n_u8(v15, 7uLL), vshlq_n_s8(v15, 1uLL))), xmmword_1180), v14); v23 &#x3D; ((1 - ((2 * ((((unk_11C8 - 78) ^ 0xB0) - 119) ^ 0xFE)) | ((((((unk_11C8 - 78) ^ 0xB0) - 119) ^ 0xFE) &amp; 0x80) !&#x3D; 0))) ^ 0x27) + 62; v24 &#x3D; ((1 - ((2 * ((((unk_11C9 - 78) ^ 0xBF) - 120) ^ 0xFE)) | ((((((unk_11C9 - 78) ^ 0xBF) - 120) ^ 0xFE) &amp; 0x80) !&#x3D; 0))) ^ 0x28) + 62; while ( v9[v16] &#x3D;&#x3D; v19[v16] ) &#123; if ( v9[v16] ) &#123; if ( ++v16 !&#x3D; 41 ) continue; &#125; v17 &#x3D; 1; goto LABEL_9; &#125; v17 &#x3D; 0;LABEL_9: free(v9); return v17; 在sub_B90(dest, v7, &quot;areyousure??????&quot;);获得加密拿到新dest后，v8 = strlen(dest);是dest长度， v9 = sub_D90(dest, v8);是base64加密，后续在while ( v9[v16] == v19[v16] )中判断是否校验成功，和上面if ( (*a1)-&gt;GetStringUTFLength(a1, a3) != 30 )一样判断一旦没有30位直接校验失败，只有返回1才校验成功，即v9[v16] == v19[v16]。获取此时v19的地址0xB30，base64(密文)=v19 1234567891011var libnative &#x3D; Module.findBaseAddress(&quot;libnative-lib.so&quot;);console.log(&quot;libnative: &quot; + libnative);&#x2F;&#x2F;获取flag加密后的内容var LDRB &#x3D; libnative.add(0xB30);send(&quot;LDRB: &quot; + LDRB); &#x2F;&#x2F; ldrb从存储器中将一个8位的字节数据传送到目的寄存器,将存储器地址为X9＋X8的字节数据读入寄存器W11，并将W11的高24位清零Interceptor.attach(LDRB, &#123; onEnter: function(args)&#123; send(&quot;LDRB onEnter&quot;); console.log(Memory.readCString(this.context.x9)); &#125;&#125;); 打印5Gh2/y6Poq2/WIeLJfmh6yesnK7ndnJeWREFjRx8，IDA调试如下 sub_B90中我们传入的a1参数只有最后进行了异或操作并重新赋值得到密文。 明文 ^ 密钥 = 密文 明文 ^ 密文 = 密钥 上述方案可得我们根据明文及密文可以拿到密钥，三十个字符总共需要异或30次 依次类推拿到 十进制密钥=[209, 90, 6, 144, 68, 230, 199, 229, 222, 40, 247, 242, 102, 145, 200, 133, 66, 223, 249, 224, 130, 1, 43, 59, 56, 99, 55, 189, 46, 77] 十六进制密钥=[0xd1,0x5a,0x6,0x90,0x44,0xe6,0xc7,0xe5,0xde,0x28,0xf7,0xf2,0x66,0x91,0xc8,0x85,0x42,0xdf,0xf9,0xe0,0x82,0x1,0x2b,0x3b,0x38,0x63,0x37,0xbd,0x2e,0x4d] 或者通过hook寄存器方式拿到EOR地址为D58，需要的寄存器是x12 123456789101112131415161718var ishook &#x3D; true;var EOR &#x3D; libnative.add(0xD58);var eor &#x3D; [];var eorlen &#x3D; 0;send(&quot;EOR: &quot; + EOR);Interceptor.attach(EOR, &#123; onEnter: function(args)&#123; if (ishook)&#123; if (eorlen &lt; 30)&#123; eor.push(this.context.x12); eorlen +&#x3D; 1; &#125;else&#123; ishook &#x3D; false; console.log(eor); &#125; &#125; &#125;&#125;) python实现，返回52pojieHappyChineseNewYear2021就是明文，在sub_B90与密钥[0xd1,0x5a,0x6,0x90,0x44,0xe6,0xc7,0xe5,0xde,0x28,0xf7,0xf2,0x66,0x91,0xc8,0x85,0x42,0xdf,0xf9,0xe0,0x82,0x1,0x2b,0x3b,0x38,0x63,0x37,0xbd,0x2e,0x4d]异或返回dest，在sub_D90中加密得到密文5Gh2/y6Poq2/WIeLJfmh6yesnK7ndnJeWREFjRx8 12345import base64xordata &#x3D; [0xd1,0x5a,0x6,0x90,0x44,0xe6,0xc7,0xe5,0xde,0x28,0xf7,0xf2,0x66,0x91,0xc8,0x85,0x42,0xdf,0xf9,0xe0,0x82,0x1,0x2b,0x3b,0x38,0x63,0x37,0xbd,0x2e,0x4d]data &#x3D; base64.b64decode(&#39;5Gh2&#x2F;y6Poq2&#x2F;WIeLJfmh6yesnK7ndnJeWREFjRx8&#39;.encode())flag &#x3D; bytes([xordata[i] ^ data[i] for i in range(len(xordata))]).decode()print(flag) 将keypatch,**findcrypt-yara**放入IDA/plugin目录 1234pip install Keystonepip install keystone-enginepip install sixpip install yara-python F5刷新伪代码永远返回1 将改好的libnative-lib.so替换 12aoktool d 2021wuai.apk 解包并替换soapk b 2021wuai -o 2021wuai_mod.apk 重新打包 https://github.com/patrickfav/uber-apk-signer 1java -jar uber-apk-signer-1.2.1.jar -a 2021wuai_mod.apk --allowResign 重签名 JNIndk是安卓开发工具包，用于快速开发C/C++动态库，jni作为java原生接口交互c++规范，分为动静态注册 app\\build.gradle 1234567891011android &#123; compileSdkVersion 30 buildToolsVersion &quot;30.0.3&quot; defaultConfig &#123; ndk &#123; abiFilters &quot;arm64-v8a&quot;, &quot;armeabi-v7a&quot;, &quot;x86&quot;, &quot;x86_64&quot; &#125; &#125; &#125; 加固流程 init_array JNI_onLoad 反调试过得比较粗糙 自定义linker加载第二个so 手工修复elf_header 动态注册函数Interface11 native化java函数分发器分析 根据注册vmp方法时的描述信息执行分支 分析指令映射表 123objection -g com.roysue.easyso1 explorememory list modulesmemory list exports libroysue.so 查看所有动静态方法，c++filt 动态注册的方法，拿到该方法的签名 动态加载 IDA从导出表中JNIEnv::RegisterNatives引用，找到动态加载调用的地方，双击到IDA View-A中找到动态注册的函数。 12frida -U -f com.roysue.easyso1 -l hook_RegisterNatives.js --no-pausejnitrace -l libroysue.so com.roysue.easyso1 roysue.cpp源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172JNIEXPORT jstring JNICALL Java_com_roysue_easyso1_MainActivity_stringFromJNI( JNIEnv* env, jobject thiz ) &#123; return (*env)-&gt;NewStringUTF(env, &quot;Hello from JNI !&quot;);&#125;JNIEXPORT jstring JNICALL method02(JNIEnv *env, jclass jcls, jstring str_) &#123; if (str_ &#x3D;&#x3D; nullptr) return nullptr; const char *str &#x3D; env-&gt;GetStringUTFChars(str_, JNI_FALSE); char *result &#x3D; AES_128_CBC_PKCS5_Decrypt(str); env-&gt;ReleaseStringUTFChars(str_, str); jstring jResult &#x3D; getJString(env, result); free(result); return jResult;&#125;static JNINativeMethod method_table[] &#x3D; &#123; &#123;&quot;decrypt&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;, (void *) method02&#125;,&#x2F;&#x2F; (参数1类型标示；参数2类型标示；参数3类型标示...)返回值类型标示&#125;;static int registerMethods(JNIEnv *env, const char *className, JNINativeMethod *gMethods, int numMethods) &#123; jclass clazz &#x3D; env-&gt;FindClass(className); if (clazz &#x3D;&#x3D; nullptr) &#123; return JNI_FALSE; &#125; if (env-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) &#123; return JNI_FALSE; &#125; return JNI_TRUE;&#125;#ifdef __cplusplusextern &quot;C&quot; &#123;#endifJNIEXPORT jstring JNICALL Java_com_roysue_easyso1_MainActivity_method01(JNIEnv *env, jclass jcls, jstring str_) &#123; if (str_ &#x3D;&#x3D; nullptr) return nullptr; const char *str &#x3D; env-&gt;GetStringUTFChars(str_, JNI_FALSE); char *result &#x3D; AES_128_CBC_PKCS5_Encrypt(str); env-&gt;ReleaseStringUTFChars(str_, str); jstring jResult &#x3D; getJString(env, result); free(result); return jResult;&#125;JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) &#123; _JUNK_FUN_0 JNIEnv *env &#x3D; nullptr; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) !&#x3D; JNI_OK) &#123; return JNI_ERR; &#125; assert(env !&#x3D; nullptr);&#x2F;&#x2F; 注册native方法 if (!registerMethods(env, &quot;com&#x2F;roysue&#x2F;easyso1&#x2F;MainActivity&quot;, method_table, NELEM(method_table))) &#123; return JNI_ERR; &#125; return JNI_VERSION_1_6;&#125; MainActivity源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MainActivity extends AppCompatActivity &#123; static &#123; System.loadLibrary(&quot;roysue&quot;); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#x2F;&#x2F; Example of a call to a native method TextView tv &#x3D; findViewById(R.id.sample_text);&#x2F;&#x2F; tv.setText(method02( method01(&quot;r0ysue&quot;))); tv.setText(decrypt(&quot;82e8edd5b05654bf0fedcdfc1c9b4b0f&quot;)); new Thread()&#123; @Override public void run() &#123; &#x2F;&#x2F;需要在子线程中处理的逻辑 while(true)&#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(&quot;roysueeasyso1&quot;,method01(&quot;r0syue&quot;)); &#125; &#125; &#125;.start(); &#125; public native String stringFromJNI(); &#x2F;** * AES加密, CBC, PKCS5Padding *&#x2F; public static native String method01(String str); &#x2F;** * AES解密, CBC, PKCS5Padding *&#x2F; public static native String decrypt(String str);&#125; 动静态hook 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var is_hook_libart &#x3D; false;function hook_dlopen() &#123; Interceptor.attach(Module.findExportByName(null, &quot;dlopen&quot;), &#123; onEnter: function(args) &#123; var pathptr &#x3D; args[0]; if (pathptr !&#x3D;&#x3D; undefined &amp;&amp; pathptr !&#x3D; null) &#123; var path &#x3D; ptr(pathptr).readCString(); console.log(&quot;dlopen:&quot;, path); if (path.indexOf(&quot;libroysue.so&quot;) &gt;&#x3D; 0) &#123; this.can_hook_libart &#x3D; true; console.log(&quot;[dlopen:]&quot;, path); &#125; &#125; &#125;, onLeave: function(retval) &#123; if (this.can_hook_libart &amp;&amp; !is_hook_libart) &#123; is_hook_libart &#x3D; true; &#125; &#125; &#125;) Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123; onEnter: function(args) &#123; var pathptr &#x3D; args[0]; if (pathptr !&#x3D;&#x3D; undefined &amp;&amp; pathptr !&#x3D; null) &#123; var path &#x3D; ptr(pathptr).readCString(); console.log(&quot;android_dlopen_ext:&quot;, path); if (path.indexOf(&quot;libroysue.so&quot;) &gt;&#x3D; 0) &#123; this.can_hook_libart &#x3D; true; console.log(&quot;[android_dlopen_ext:]&quot;, path); &#125; &#125; &#125;, onLeave: function(retval) &#123; if (this.can_hook_libart &amp;&amp; !is_hook_libart) &#123; is_hook_libart &#x3D; true; var method01 &#x3D; Module.findExportByName(&quot;libroysue.so&quot;, &quot;Java_com_roysue_easyso1_MainActivity_method01&quot;) var method02 &#x3D; Module.findExportByName(&quot;libroysue.so&quot;, &quot;_Z8method02P7_JNIEnvP7_jclassP8_jstring&quot;) console.log(&quot;method01 address is &#x3D;&gt;&quot;,method01) console.log(&quot;method02 address is &#x3D;&gt;&quot;,method02) Interceptor.attach(method01,&#123; onEnter:function(args)&#123; console.log(&quot;arg[2&#x3D;&gt;&quot;,args[2]) &#125;,onLeave:function(retval)&#123; console.log(&quot;retval&#x3D;&gt;&quot;,retval) &#125; &#125;) Interceptor.attach(method02,&#123; onEnter:function(args)&#123; console.log(&quot;method02 arg[2&#x3D;&gt;&quot;,Java.vm.getEnv().getStringUtfChars(args[2], null).readCString()) &#125;,onLeave:function(retval)&#123; console.log(&quot;method02 retval&#x3D;&gt;&quot;,Java.vm.getEnv().getStringUtfChars(retval, null).readCString()) &#125; &#125;) &#125; &#125; &#125;);&#125; 主动调用并hook 123456789101112131415161718function hookJava()&#123; Java.perform(function()&#123; console.log(&quot;hooking java...&quot;) Java.use(&quot;com.roysue.easyso1.MainActivity&quot;).decrypt.implementation &#x3D; function(str)&#123; var result &#x3D; this.decrypt(str) console.log(&quot;str,result &#x3D;&gt; ,&quot;,str,result) return result; &#125; &#125;)&#125;function invokeJava()&#123; Java.perform(function()&#123; var result &#x3D; Java.use(&quot;com.roysue.easyso1.MainActivity&quot;).decrypt(&quot;82e8edd5b05654bf0fedcdfc1c9b4b0f&quot;) console.log(&quot;result &#x3D;&gt; ,&quot;,result) &#125;)&#125; Native层主动调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192function hook_RegisterNatives() &#123; var symbols &#x3D; Module.enumerateSymbolsSync(&quot;libart.so&quot;); var addrRegisterNatives &#x3D; null; for (var i &#x3D; 0; i &lt; symbols.length; i++) &#123; var symbol &#x3D; symbols[i]; &#x2F;&#x2F;_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi if (symbol.name.indexOf(&quot;art&quot;) &gt;&#x3D; 0 &amp;&amp; symbol.name.indexOf(&quot;JNI&quot;) &gt;&#x3D; 0 &amp;&amp; symbol.name.indexOf(&quot;NewStringUTF&quot;) &gt;&#x3D; 0 &amp;&amp; symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) &#123; addrNewStringUTF &#x3D; symbol.address; console.log(&quot;NewStringUTF is at &quot;, symbol.address, symbol.name); NewStringUTF &#x3D; new NativeFunction(addrNewStringUTF,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;pointer&#39;]) &#125; if (symbol.name.indexOf(&quot;art&quot;) &gt;&#x3D; 0 &amp;&amp; symbol.name.indexOf(&quot;JNI&quot;) &gt;&#x3D; 0 &amp;&amp; symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;&#x3D; 0 &amp;&amp; symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) &#123; addrRegisterNatives &#x3D; symbol.address; console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name); &#125; &#125; if (addrRegisterNatives !&#x3D; null) &#123; Interceptor.attach(addrRegisterNatives, &#123; onEnter: function (args) &#123; console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]); var env &#x3D; args[0]; ENV &#x3D; args[0]; var java_class &#x3D; args[1]; JCLZ &#x3D; args[1]; var class_name &#x3D; Java.vm.tryGetEnv().getClassName(java_class); &#x2F;&#x2F;console.log(class_name); var methods_ptr &#x3D; ptr(args[2]); var method_count &#x3D; parseInt(args[3]); for (var i &#x3D; 0; i &lt; method_count; i++) &#123; var name_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3)); var sig_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize)); var fnPtr_ptr &#x3D; Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2)); var name &#x3D; Memory.readCString(name_ptr); var sig &#x3D; Memory.readCString(sig_ptr); var find_module &#x3D; Process.findModuleByAddress(fnPtr_ptr); console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr, &quot;module_name:&quot;, find_module.name, &quot;module_base:&quot;, find_module.base, &quot;offset:&quot;, ptr(fnPtr_ptr).sub(find_module.base)); if(name.indexOf(&quot;method01&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; method01addr &#x3D; fnPtr_ptr; continue; &#125;else if (name.indexOf(&quot;decrypt&quot;)&gt;&#x3D;0)&#123; method02addr &#x3D; fnPtr_ptr; method02 &#x3D; new NativeFunction(method02addr,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;pointer&#39;,&#39;pointer&#39;]); method01addr &#x3D; Module.findExportByName(&quot;libroysue.so&quot;, &quot;Java_com_roysue_easyso1_MainActivity_method01&quot;) &#125;else&#123; continue; &#125; &#125; &#125; &#125;); &#125;&#125;function invokemethod01(contents)&#123; console.log(&quot;method01_addr is &#x3D;&gt;&quot;,method01addr) var method01 &#x3D; new NativeFunction(method01addr,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;pointer&#39;,&#39;pointer&#39;]); var NewStringUTF &#x3D; new NativeFunction(addrNewStringUTF,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;pointer&#39;]) var result &#x3D; null; Java.perform(function()&#123; console.log(&quot;Java.vm.getEnv()&quot;,Java.vm.getEnv()) var JSTRING &#x3D; NewStringUTF(Java.vm.getEnv(),Memory.allocUtf8String(contents)) result &#x3D; method01(Java.vm.getEnv(),JSTRING,JSTRING); console.log(&quot;result is &#x3D;&gt;&quot;,result) console.log(&quot;result is &quot;,Java.vm.getEnv().getStringUtfChars(result, null).readCString()) result &#x3D; Java.vm.getEnv().getStringUtfChars(result, null).readCString(); &#125;) return result;&#125;function invokemethod02(contents)&#123; var result &#x3D; null; Java.perform(function()&#123; var JSTRING &#x3D; NewStringUTF(Java.vm.getEnv(),Memory.allocUtf8String(contents)) result &#x3D; method02(Java.vm.getEnv(),JSTRING,JSTRING); result &#x3D; Java.vm.getEnv().getStringUtfChars(result, null).readCString(); &#125;) return result;&#125; git clone https://github.com/GravityBox/GravityBox.git 安装到xposed组件 Java与Native相互调用 1234XposedHelpers.getObjectField&#x3D;getDeclaredField+setAccessible+getAccessibleXposedHelpers.setObjectField&#x3D;getDeclaredField+setAccessible+setAccessibleXposedHelpers.callMethod(mTelephonyManager,&quot;setDataEnabled&quot;,enabled)&#x3D; Method m &#x3D; mPhoneWindowManagerClass.getDeclaredMethod(&quot;takeScreenshot&quot;,int.class)+m.setAccessible(true)+m.invoke(mPhoneWindowManager,1); plugin wallbreaker classdump android.os.Build 查看系统参数信息 简单风控roysue.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#define TAG &quot;roysuejni&quot; &#x2F;&#x2F; 这个是自定义的LOG的标识#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__) &#x2F;&#x2F; 定义LOGD类型#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG ,__VA_ARGS__) &#x2F;&#x2F; 定义LOGI类型#define LOGW(...) __android_log_print(ANDROID_LOG_WARN,TAG ,__VA_ARGS__) &#x2F;&#x2F; 定义LOGW类型#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG ,__VA_ARGS__) &#x2F;&#x2F; 定义LOGE类型#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL,TAG ,__VA_ARGS__) &#x2F;&#x2F; 定义LOGF类型#define NELEM(x) ((int) (sizeof(x) &#x2F; sizeof((x)[0])))JNIEXPORT jstring JNICALL method02(JNIEnv *env, jclass jcls, jstring str_) &#123; if (str_ &#x3D;&#x3D; nullptr) return nullptr; const char *str &#x3D; env-&gt;GetStringUTFChars(str_, JNI_FALSE); char *result &#x3D; AES_128_CBC_PKCS5_Decrypt(str); env-&gt;ReleaseStringUTFChars(str_, str); jstring jResult &#x3D; getJString(env, result); free(result); return jResult;&#125;bool function_check_tracerPID() &#123; bool b &#x3D; false ; int pid &#x3D; getpid(); std::string file_name &#x3D; &quot;&#x2F;proc&#x2F;pid&#x2F;status&quot;; std::string line; file_name.replace(file_name.find(&quot;pid&quot;), 3, std::to_string(pid)); LOGE(&quot;replace file name &#x3D;&gt; %s&quot;, file_name.c_str()); std::ifstream myfile(file_name, std::ios::in); if (myfile.is_open()) &#123; while (getline(myfile, line)) &#123; &#x2F;&#x2F; 获取父id， cat &#x2F;proc&#x2F;2345&#x2F;status size_t TracerPid_pos &#x3D; line.find(&quot;TracerPid&quot;); if (TracerPid_pos &#x3D;&#x3D; 0) &#123; line &#x3D; line.substr(line.find(&quot;:&quot;) + 1); LOGE(&quot;file line &#x3D;&gt; %s&quot;, line.c_str()); if (std::stoi(line.c_str()) !&#x3D; 0) &#123; LOGE(&quot;trace pid &#x3D;&gt; %s, i want to exit.&quot;, line.c_str()); b &#x3D; true ;&#x2F;&#x2F; kill(pid, 9); break; &#125; &#125; &#125; myfile.close(); &#125; return b ;&#125;bool system_getproperty_check() &#123; char man[256], mod[156]; &#x2F;* A length 0 value indicates that the property is not defined *&#x2F; int lman &#x3D; __system_property_get(&quot;ro.product.manufacturer&quot;, man); int lmod &#x3D; __system_property_get(&quot;ro.product.model&quot;, mod); int len &#x3D; lman + lmod; char *pname &#x3D; NULL; if (len &gt; 0) &#123; pname &#x3D; static_cast&lt;char *&gt;(malloc(len + 2)); snprintf(pname, len + 2, &quot;%s&#x2F;%s&quot;, lman &gt; 0 ? man : &quot;&quot;, lmod &gt; 0 ? mod : &quot;&quot;); &#125; bool b &#x3D; false; if(strstr(pname,&quot;Google&quot;))b&#x3D;true; LOGE(&quot;[roysue device]: [%s] result is &#x3D;&gt; %d\\n&quot;, pname ? pname : &quot;N&#x2F;A&quot;,b); return b;&#125;JNIEXPORT jstring JNICALL fuck(JNIEnv *env, jclass jcls, jstring str_) &#123; if (str_ &#x3D;&#x3D; nullptr) return nullptr; char *str &#x3D; const_cast&lt;char *&gt;(env-&gt;GetStringUTFChars(str_, JNI_FALSE)); char* sign &#x3D; &quot;REAL&quot;; jclass buildClazz &#x3D; env-&gt;FindClass(&quot;android&#x2F;os&#x2F;Build&quot;); jfieldID FINGERPRINT &#x3D; env-&gt;GetStaticFieldID(buildClazz,&quot;FINGERPRINT&quot;,&quot;Ljava&#x2F;lang&#x2F;String;&quot;); jstring fingerprint &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetStaticObjectField(buildClazz, FINGERPRINT)); if( function_check_tracerPID() || system_getproperty_check() || strstr( env-&gt;GetStringUTFChars(fingerprint, JNI_FALSE),&quot;aosp&quot;))&#123; sign &#x3D; &quot;FAKE&quot;; &#125;&#x2F;&#x2F; rightsign : 18d1fb4c2bac56c180f763e359d1d717500787ee90b32ed12f588e51f60e458d08303dcff7dd08a39b13c75e3f1ba9d9&#x2F;&#x2F;&#x2F;&#x2F; before entering aes &#x3D;&gt; requestUserInfoFAKE&#x2F;&#x2F; wrongsign:bc57f886b8822f0465fb87bedd58c4ba9bad4efc9e7556df925701f0427c72cb8b23a1c25ff9241f8199cb6db5437fe2 strcat(str,sign); jstring jstr &#x3D; getJString(env, str); LOGI(&quot;before entering aes &#x3D;&gt; %s&quot;,str); &#x2F;&#x2F;&#x2F;&#x2F; byte[] bytes &#x3D; MessageDigest.getInstance(&quot;MD5&quot;).digest(input.getBytes()); jclass MessageGigest &#x3D; env-&gt;FindClass(&quot;java&#x2F;security&#x2F;MessageDigest&quot;); jmethodID getInstance &#x3D; env-&gt;GetStaticMethodID(MessageGigest, &quot;getInstance&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;security&#x2F;MessageDigest;&quot;); jobject md5 &#x3D; env-&gt;CallStaticObjectMethod(MessageGigest, getInstance, getJString(env, &quot;MD5&quot;)); jmethodID digest &#x3D; env-&gt;GetMethodID(MessageGigest, &quot;digest&quot;, &quot;([B)[B&quot;); jclass stringClazz &#x3D; env-&gt;FindClass(&quot;java&#x2F;lang&#x2F;String&quot;); jmethodID getbytes &#x3D; env-&gt;GetMethodID(stringClazz, &quot;getBytes&quot;, &quot;()[B&quot;); jbyteArray jba &#x3D; static_cast&lt;jbyteArray&gt;(env-&gt;CallObjectMethod(jstr, getbytes)); jbyteArray md5result &#x3D; static_cast&lt;jbyteArray&gt;(env-&gt;CallObjectMethod(md5, digest, jba)); char *cmd5 &#x3D; reinterpret_cast&lt;char *&gt;(env-&gt;GetByteArrayElements(md5result, 0)); char md5string[33]; for(int i &#x3D; 0; i &lt; 16; ++i) sprintf(&amp;md5string[i*2], &quot;%02x&quot;, (unsigned int)cmd5[i]); char *result &#x3D; AES_128_CBC_PKCS5_Encrypt(str);&#x2F;&#x2F; strcat(result,&quot;XXXXXX&quot;); strcat(result,md5string); jstring finalResult &#x3D; getJString(env, result); env-&gt;ReleaseStringUTFChars(str_, str); free(result); return finalResult;&#125;static JNINativeMethod method_table[] &#x3D; &#123; &#123;&quot;decrypt&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;, (void *) method02&#125;, &#123;&quot;Sign&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;, (void *) fuck&#125;,&#x2F;&#x2F; (参数1类型标示；参数2类型标示；参数3类型标示...)返回值类型标示&#125;;static int registerMethods(JNIEnv *env, const char *className, JNINativeMethod *gMethods, int numMethods) &#123; jclass clazz &#x3D; env-&gt;FindClass(className); if (clazz &#x3D;&#x3D; nullptr) &#123; return JNI_FALSE; &#125; if (env-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) &#123; return JNI_FALSE; &#125; return JNI_TRUE;&#125;#ifdef __cplusplusextern &quot;C&quot; &#123;#endifJNIEXPORT jstring JNICALL Java_com_roysue_easyso1_MainActivity_method01(JNIEnv *env, jclass jcls, jstring str_) &#123; if (str_ &#x3D;&#x3D; nullptr) return nullptr; const char *str &#x3D; env-&gt;GetStringUTFChars(str_, JNI_FALSE); char *result &#x3D; AES_128_CBC_PKCS5_Encrypt(str); env-&gt;ReleaseStringUTFChars(str_, str); jstring jResult &#x3D; getJString(env, result); free(result); return jResult;&#125;JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) &#123; _JUNK_FUN_0 JNIEnv *env &#x3D; nullptr; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) !&#x3D; JNI_OK) &#123; return JNI_ERR; &#125; assert(env !&#x3D; nullptr);&#x2F;&#x2F; 注册native方法 if (!registerMethods(env, &quot;com&#x2F;roysue&#x2F;easyso1&#x2F;MainActivity&quot;, method_table, NELEM(method_table))) &#123; return JNI_ERR; &#125; return JNI_VERSION_1_6;&#125; unidbg 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MainActivity extends AbstractJni &#123; public static void main(String[] args) &#123; long start &#x3D; System.currentTimeMillis(); com.r0ysue.easyso.MainActivity mainActivity &#x3D; new com.r0ysue.easyso.MainActivity(); System.out.println(&quot;load offset&#x3D;&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;); mainActivity.crack(); &#125; private final AndroidEmulator emulator; private final VM vm; private final DvmClass dvmClass; private String className &#x3D; &quot;com&#x2F;roysue&#x2F;easyso1&#x2F;MainActivity&quot;; private final Module module; private MainActivity() &#123; emulator &#x3D; AndroidEmulatorBuilder .for32Bit()&#x2F;&#x2F; .addBackendFactory(new DynarmicFactory(true)) .build(); Memory memory &#x3D; emulator.getMemory(); LibraryResolver resolver &#x3D; new AndroidResolver(23); memory.setLibraryResolver(resolver); vm &#x3D; emulator.createDalvikVM(null); System.out.println(vm); vm.setVerbose(true); vm.setJni(this); DalvikModule dm &#x3D; vm.loadLibrary(new File(&quot;unidbg-android&#x2F;src&#x2F;test&#x2F;resources&#x2F;example_binaries&#x2F;armeabi-v7a&#x2F;libroysue.so&quot;), false); module &#x3D; dm.getModule(); Dobby dobby &#x3D; Dobby.getInstance(emulator); &#x2F;&#x2F; 2. 使用ida pro查看导出方法名，尝试hook dobby.replace(module.findSymbolByName(&quot;_Z24function_check_tracerPIDv&quot;), new ReplaceCallback() &#123; &#x2F;&#x2F; 使用Dobby inline hook导出函数 @Override &#x2F;&#x2F; 3. contextk可以拿到参数，originFunction是原方法的地址 public HookStatus onCall(Emulator&lt;?&gt; emulator, HookContext context, long originFunction) &#123;&#x2F;&#x2F; System.out.println(&quot;create_thread_check_traceid.onCall function address &#x3D;&gt; 0x&quot; + Long.toHexString(originFunction)); System.out.println(&quot;calling _Z14function_checkv ....&quot;);&#x2F;&#x2F; return HookStatus.RET(emulator, originFunction);&#x2F;&#x2F; return null; return HookStatus.LR(emulator, 0); &#125; @Override public void postCall(Emulator&lt;?&gt; emulator, HookContext context) &#123; System.out.println(&quot; calling _Z14function_checkv .... return false&quot;);&#x2F;&#x2F; context.getIntArg(0) ; &#125; &#125;, false); dm.callJNI_OnLoad(emulator); dvmClass &#x3D; vm.resolveClass(className); &#125; private void crack() &#123; DvmObject result &#x3D; dvmClass.callStaticJniMethodObject(emulator,&quot;Sign(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;,&quot;requestUserInfo&quot;);&#x2F;&#x2F; long start &#x3D; System.currentTimeMillis(); System.out.println(&quot;final result is &#x3D;&gt; &quot;+ result.getValue()); &#125;&#125; frida 12345678910111213141516171819202122232425262728293031323334353637setTimeout(function () &#123; Java.perform(function () &#123; &#x2F;&#x2F; Java.use(&quot;android.os.Build&quot;).FINGERPRINT.value &#x3D; &quot;12345&quot; console.log(&quot;found strcat address &#x3D;&gt; &quot;, Module.findExportByName(null, &quot;strcat&quot;)); var strcat &#x3D; new NativeFunction(Module.findExportByName(null, &quot;strcat&quot;), &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]) Interceptor.replace(Module.findExportByName(null, &quot;strcat&quot;), new NativeCallback(function (arg0, arg1) &#123; console.log(&quot;arg[0] is &#x3D;&gt; &quot;, arg0.readCString()); console.log(&quot;arg[1] is &#x3D;&gt; &quot;, arg1.readCString()); &#x2F;&#x2F; if(arg1.readCString().indexOf(&quot;FAKE&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; var REAL &#x3D; Memory.allocUtf8String(&quot;REAL&quot;); &#x2F;&#x2F; arg1 &#x3D; REAL ; &#x2F;&#x2F; console.log(&quot;change FAKE to REAL&quot;) &#x2F;&#x2F; &#125; var retval &#x3D; strcat(arg0, arg1); return retval; &#125;, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;])); &#125;) &#x2F;&#x2F; var strcat_addr &#x3D; Module.findExportByName(null,&quot;strcat&quot;) &#x2F;&#x2F; console.log(&quot;found address is &#x3D;&gt; &quot;,strcat_addr); &#x2F;&#x2F; var strcat &#x3D; new NativeFunction(strcat_addr,&quot;pointer&quot;,[&quot;pointer&quot;,&quot;pointer&quot;]); &#x2F;&#x2F; Interceptor.replace(strcat_addr, new NativeCallback(function(arg1, arg2)&#123; &#x2F;&#x2F; console.log(&quot;arg1 is &#x3D;&gt; &quot;,arg1); &#x2F;&#x2F; console.log(&quot;arg2 is &#x3D;&gt; &quot;,arg2); &#x2F;&#x2F; var result &#x3D; strcat(arg1,arg2); &#x2F;&#x2F; console.log(&quot;result is &#x3D;&gt; &quot;,result); &#x2F;&#x2F; &#125;, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]));&#125;, 0);function invoke() &#123; Java.perform(function () &#123; var result &#x3D; Java.use(&quot;com.roysue.easyso1.MainActivity&quot;).Sign(&quot;requestUserInfo&quot;); console.log(&quot;result is &#x3D;&gt; &quot;, result); &#125;)&#125; OnCreate的Native化看jni签名的方法，jadx的smali面板 MainActivity 1234static &#123; System.loadLibrary(&quot;roysue&quot;);&#125;protected native void onCreate(Bundle savedInstanceState); roysue.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#x2F;&#x2F; 动态注册不需要extern &quot;C&quot;&#x2F;&#x2F;extern &quot;C&quot;&#x2F;&#x2F;JNIEXPORT void JNICALL&#x2F;&#x2F;JAVA_com_roysue_easyso1_MainActivity_onCreate(JNIEnv *env,jobject thiz, jobject saved_instance_state)void ononon(JNIEnv *env, jobject thiz, jobject saved_instance_state) &#123; &#x2F;&#x2F; TODO: implement onCreate()&#x2F;&#x2F; super.onCreate(savedInstanceState); jclass AppCompatActivity_class1 &#x3D; env-&gt;FindClass(&quot;androidx&#x2F;appcompat&#x2F;app&#x2F;AppCompatActivity&quot;); jclass MainActivity_class1 &#x3D; env-&gt;FindClass(&quot;com&#x2F;roysue&#x2F;easyso1&#x2F;MainActivity&quot;); jclass MainActivity_class2 &#x3D; env-&gt;GetObjectClass(thiz); jclass AppCompatActivity_class2 &#x3D; env-&gt;GetSuperclass(MainActivity_class2); jmethodID onCreate &#x3D; env-&gt;GetMethodID(AppCompatActivity_class2, &quot;onCreate&quot;, &quot;(Landroid&#x2F;os&#x2F;Bundle;)V&quot;); env-&gt;CallNonvirtualVoidMethod(thiz, AppCompatActivity_class2, onCreate, saved_instance_state);&#x2F;&#x2F; setContentView(R.layout.activity_main); jmethodID setContentView &#x3D; env-&gt;GetMethodID(AppCompatActivity_class2, &quot;setContentView&quot;, &quot;(I)V&quot;); jclass Rlayout &#x3D; env-&gt;FindClass(&quot;com&#x2F;roysue&#x2F;easyso1&#x2F;R$layout&quot;); jfieldID activity_main &#x3D; env-&gt;GetStaticFieldID(Rlayout, &quot;activity_main&quot;, &quot;I&quot;); jint activity_main_value &#x3D; env-&gt;GetStaticIntField(Rlayout, activity_main); env-&gt;CallVoidMethod(thiz, setContentView, activity_main_value);&#x2F;&#x2F; TextView tv &#x3D; findViewById(R.id.sample_text); jmethodID findViewById &#x3D; env-&gt;GetMethodID(AppCompatActivity_class2, &quot;findViewById&quot;, &quot;(I)Landroid&#x2F;view&#x2F;View;&quot;); jclass Rid &#x3D; env-&gt;FindClass(&quot;com&#x2F;roysue&#x2F;easyso1&#x2F;R$id&quot;); jfieldID sample_text &#x3D; env-&gt;GetStaticFieldID(Rid, &quot;sample_text&quot;, &quot;I&quot;); jint sample_text_value &#x3D; env-&gt;GetStaticIntField(Rid, sample_text); jobject tv &#x3D; env-&gt;CallObjectMethod(thiz, findViewById, sample_text_value);&#x2F;&#x2F; tv.setText(&quot;r0ysue&quot;); jstring r0ysue &#x3D; env-&gt;NewStringUTF(&quot;r0ysue&quot;); jclass textView &#x3D; env-&gt;FindClass(&quot;android&#x2F;widget&#x2F;TextView&quot;); jmethodID setText &#x3D; env-&gt;GetMethodID(textView, &quot;setText&quot;, &quot;(Ljava&#x2F;lang&#x2F;CharSequence;)V&quot;); jstring r0ysueEn &#x3D; Java_com_roysue_easyso1_MainActivity_method01(env, MainActivity_class2, r0ysue); jmethodID Javamethod01 &#x3D; env-&gt;GetStaticMethodID(MainActivity_class2, &quot;method01&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;); jstring r0ysueEn2 &#x3D; static_cast&lt;jstring&gt;(env-&gt;CallStaticObjectMethod(MainActivity_class2, Javamethod01, r0ysue));&#x2F;&#x2F; env-&gt;CallVoidMethod(tv, setText, r0ysueEn); &#x2F;&#x2F; 反射 env-&gt;CallVoidMethod(tv, setText, r0ysueEn2); &#x2F;&#x2F; 超出局部引用表最大数量不及时释放将导致JNI局部引用表的溢出 for (int i &#x3D; 0; i &lt; 2048; i++) &#123; jstring jstr &#x3D; env-&gt;NewStringUTF(&quot;12345&quot;); LOGI(&quot; local Reference is Num %d : &quot;, i); &#125;&#125;static JNINativeMethod method_table[] &#x3D; &#123; &#123;&quot;decrypt&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;, (void *) method02&#125;, &#123;&quot;Sign&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;, (void *) fuck&#125;, &#123;&quot;onCreate&quot;, &quot;(Landroid&#x2F;os&#x2F;Bundle;)V&quot;, (void *) ononon&#125;,&#x2F;&#x2F; (参数1类型标示；参数2类型标示；参数3类型标示...)返回值类型标示&#125;; frida 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var ArtMethod_PrettyMethodfunction readStdString(str) &#123; if ((str.readU8() &amp; 1) &#x3D;&#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; size LSB (&#x3D;1) indicates if it&#39;s a long string return str.add(2 * Process.pointerSize).readPointer().readUtf8String(); &#125; return str.add(1).readUtf8String();&#125;function attach(addr) &#123; Interceptor.attach(addr, &#123; onEnter: function (args) &#123; this.arg0 &#x3D; args[0] &#125;, onLeave: function (retval) &#123; var modulemap &#x3D; new ModuleMap() var module &#x3D; modulemap.find(retval) if (module !&#x3D; null) &#123; var string &#x3D; Memory.alloc(0x100) ArtMethod_PrettyMethod(string, this.arg0, 1) console.log(&#39;method_name &#x3D;&gt;&#39;, readStdString(string), &#39;,offset&#x3D;&gt;&#39;, ptr(retval).sub(module.base), &#39;,module_name&#x3D;&gt;&#39;, module.name) if(readStdString(string).indexOf(&quot;method01&quot;)&gt;&#x3D;0)&#123; Interceptor.attach(ptr(retval),&#123; onEnter:function(args)&#123; console.log(&quot;entering method01&quot;,Java.vm.getEnv().getStringUtfChars(args[2], null).readCString()) &#125;,onLeave:function()&#123; console.log(&quot;leaving method01&quot;) &#125; &#125;) &#125;; &#125; &#125; &#125;);&#125;&#x2F;&#x2F; hook_RegisterNative显示所有动态注册方法，静态注册只能Java调用过才显示function hook_RegisterNative() &#123; var libart &#x3D; Process.findModuleByName(&#39;libart.so&#39;) var symbols &#x3D; libart.enumerateSymbols() for (var i &#x3D; 0; i &lt; symbols.length; i++) &#123; if (symbols[i].name.indexOf(&#39;PrettyMethod&#39;) &gt; -1 &amp;&amp; symbols[i].name.indexOf(&#39;ArtMethod&#39;) &gt; -1 &amp;&amp; symbols[i].name.indexOf(&quot;Eb&quot;) &gt;&#x3D; 0) &#123; ArtMethod_PrettyMethod &#x3D; new NativeFunction(symbols[i].address, &quot;void&quot;, [&#39;pointer&#39;, &quot;pointer&quot;, &quot;bool&quot;]) &#125; if (symbols[i].name.indexOf(&#39;RegisterNative&#39;) &gt; -1 &amp;&amp; symbols[i].name.indexOf(&#39;ArtMethod&#39;) &gt; -1 &amp;&amp; symbols[i].name.indexOf(&#39;RuntimeCallbacks&#39;) &lt; 0) &#123; attach(symbols[i].address) &#125; &#125;&#125;function main() &#123; hook_RegisterNative()&#125; Android JNI(一)——NDK与JNI基础讲述了局部引用和全局引用的概念 JNI局部引用、全局引用和弱全局引用 JNI动静态绑定和追踪一种通用超简单的Android Java Native方法Hook Dalvik&amp;Art_RegisterNativesTrace 目录下打印log 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111void ononon2(JNIEnv *env, jobject thiz, jobject saved_instance_state) &#123; &#x2F;&#x2F; TODO: implement onCreate()&#x2F;&#x2F; super.onCreate(savedInstanceState); jclass AppCompatActivity_class1 &#x3D; env-&gt;FindClass(&quot;androidx&#x2F;appcompat&#x2F;app&#x2F;AppCompatActivity&quot;); jclass MainActivity_class1 &#x3D; env-&gt;FindClass(&quot;com&#x2F;roysue&#x2F;easyso1&#x2F;MainActivity&quot;); jclass MainActivity_class2 &#x3D; env-&gt;GetObjectClass(thiz); jclass AppCompatActivity_class2 &#x3D; env-&gt;GetSuperclass(MainActivity_class2); jmethodID onCreate &#x3D; env-&gt;GetMethodID(AppCompatActivity_class2,&quot;onCreate&quot;,&quot;(Landroid&#x2F;os&#x2F;Bundle;)V&quot;); env-&gt;CallNonvirtualVoidMethod(thiz,AppCompatActivity_class2,onCreate,saved_instance_state);&#x2F;&#x2F; setContentView(R.layout.activity_main); jmethodID setContentView &#x3D; env-&gt;GetMethodID(AppCompatActivity_class2,&quot;setContentView&quot;,&quot;(I)V&quot;); jclass Rlayout &#x3D; env-&gt;FindClass(&quot;com&#x2F;roysue&#x2F;easyso1&#x2F;R$layout&quot;); jfieldID activity_main &#x3D; env-&gt;GetStaticFieldID(Rlayout,&quot;activity_main&quot;,&quot;I&quot;); jint activity_main_value &#x3D; env-&gt;GetStaticIntField(Rlayout,activity_main); env-&gt;CallVoidMethod(thiz,setContentView,activity_main_value);&#x2F;&#x2F; TextView tv &#x3D; findViewById(R.id.sample_text); jmethodID findViewById &#x3D; env-&gt;GetMethodID(AppCompatActivity_class2,&quot;findViewById&quot;, &quot;(I)Landroid&#x2F;view&#x2F;View;&quot;); jclass Rid &#x3D; env-&gt;FindClass(&quot;com&#x2F;roysue&#x2F;easyso1&#x2F;R$id&quot;); jfieldID sample_text &#x3D; env-&gt;GetStaticFieldID(Rid,&quot;sample_text&quot;,&quot;I&quot;); jint sample_text_value &#x3D; env-&gt;GetStaticIntField(Rid,sample_text); jobject tv &#x3D; env-&gt;CallObjectMethod(thiz,findViewById,sample_text_value);&#x2F;&#x2F; tv.setText(&quot;r0ysue&quot;); jstring r0ysue &#x3D; env-&gt;NewStringUTF(&quot;r0ysueONONON2&quot;); jclass textView &#x3D; env-&gt;FindClass(&quot;android&#x2F;widget&#x2F;TextView&quot;); jmethodID setText &#x3D; env-&gt;GetMethodID(textView,&quot;setText&quot;,&quot;(Ljava&#x2F;lang&#x2F;CharSequence;)V&quot;); jstring r0ysueEn &#x3D; Java_com_roysue_easyso1_MainActivity_method01(env,MainActivity_class2,r0ysue); jmethodID Javamethod01 &#x3D; env-&gt;GetStaticMethodID(MainActivity_class2,&quot;method01&quot;,&quot;(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;); jstring r0ysueEn2 &#x3D; static_cast&lt;jstring&gt;(env-&gt;CallStaticObjectMethod(MainActivity_class2, Javamethod01, r0ysue)); env-&gt;CallVoidMethod(tv,setText,r0ysueEn2);&#x2F;&#x2F; env-&gt;CallVoidMethod(tv,setText,r0ysue); jclass buildClazz &#x3D; env-&gt;FindClass(&quot;android&#x2F;os&#x2F;Build&quot;); jfieldID FINGERPRINT &#x3D; env-&gt;GetStaticFieldID(buildClazz,&quot;FINGERPRINT&quot;,&quot;Ljava&#x2F;lang&#x2F;String;&quot;); jstring fingerprint &#x3D; static_cast&lt;jstring&gt;(env-&gt;GetStaticObjectField(buildClazz, FINGERPRINT)); if( function_check_tracerPID() || system_getproperty_check() || strstr( env-&gt;GetStringUTFChars(fingerprint, JNI_FALSE),&quot;aosp&quot;))&#123; int a,b,c; a&#x3D;1; b&#x3D;0; c&#x3D;a&#x2F;b; LOGI(&quot;roysuey is %d&quot;,c); &#125; LOGI(&quot;roysuey is %d&quot;,100);&#x2F;&#x2F;&#x2F;&#x2F; for (int i &#x3D; 0; i &lt; 2048; i++) &#123;&#x2F;&#x2F; jstring jstr &#x3D; env-&gt;NewStringUTF(&quot;12345&quot;);&#x2F;&#x2F; LOGI(&quot; local Reference is Num %d : &quot;, i );&#x2F;&#x2F; &#125;&#125;static JNINativeMethod method_table[] &#x3D; &#123; &#123;&quot;decrypt&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;, (void *) method02&#125;, &#123;&quot;Sign&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;, (void *) fuck&#125;, &#123;&quot;onCreate&quot;, &quot;(Landroid&#x2F;os&#x2F;Bundle;)V&quot;, (void *) ononon&#125;, &#123;&quot;onCreate&quot;, &quot;(Landroid&#x2F;os&#x2F;Bundle;)V&quot;, (void *) ononon2&#125;,&#x2F;&#x2F; (参数1类型标示；参数2类型标示；参数3类型标示...)返回值类型标示&#125;;extern &quot;C&quot;JNIEXPORT void JNICALLJava_com_roysue_easyso1_MainActivity_onCreate(JNIEnv *env, jobject thiz, jobject saved_instance_state) &#123; &#x2F;&#x2F; TODO: implement onCreate()&#x2F;&#x2F; super.onCreate(savedInstanceState); jclass AppCompatActivity_class1 &#x3D; env-&gt;FindClass(&quot;androidx&#x2F;appcompat&#x2F;app&#x2F;AppCompatActivity&quot;); jclass MainActivity_class1 &#x3D; env-&gt;FindClass(&quot;com&#x2F;roysue&#x2F;easyso1&#x2F;MainActivity&quot;); jclass MainActivity_class2 &#x3D; env-&gt;GetObjectClass(thiz); jclass AppCompatActivity_class2 &#x3D; env-&gt;GetSuperclass(MainActivity_class2); jmethodID onCreate &#x3D; env-&gt;GetMethodID(AppCompatActivity_class2,&quot;onCreate&quot;,&quot;(Landroid&#x2F;os&#x2F;Bundle;)V&quot;); env-&gt;CallNonvirtualVoidMethod(thiz,AppCompatActivity_class2,onCreate,saved_instance_state);&#x2F;&#x2F; setContentView(R.layout.activity_main); jmethodID setContentView &#x3D; env-&gt;GetMethodID(AppCompatActivity_class2,&quot;setContentView&quot;,&quot;(I)V&quot;); jclass Rlayout &#x3D; env-&gt;FindClass(&quot;com&#x2F;roysue&#x2F;easyso1&#x2F;R$layout&quot;); jfieldID activity_main &#x3D; env-&gt;GetStaticFieldID(Rlayout,&quot;activity_main&quot;,&quot;I&quot;); jint activity_main_value &#x3D; env-&gt;GetStaticIntField(Rlayout,activity_main); env-&gt;CallVoidMethod(thiz,setContentView,activity_main_value);&#x2F;&#x2F; TextView tv &#x3D; findViewById(R.id.sample_text); jmethodID findViewById &#x3D; env-&gt;GetMethodID(AppCompatActivity_class2,&quot;findViewById&quot;, &quot;(I)Landroid&#x2F;view&#x2F;View;&quot;); jclass Rid &#x3D; env-&gt;FindClass(&quot;com&#x2F;roysue&#x2F;easyso1&#x2F;R$id&quot;); jfieldID sample_text &#x3D; env-&gt;GetStaticFieldID(Rid,&quot;sample_text&quot;,&quot;I&quot;); jint sample_text_value &#x3D; env-&gt;GetStaticIntField(Rid,sample_text); jobject tv &#x3D; env-&gt;CallObjectMethod(thiz,findViewById,sample_text_value);&#x2F;&#x2F; tv.setText(&quot;r0ysue&quot;); jstring r0ysue &#x3D; env-&gt;NewStringUTF(&quot;r0ysueSTATIC&quot;); jclass textView &#x3D; env-&gt;FindClass(&quot;android&#x2F;widget&#x2F;TextView&quot;); jmethodID setText &#x3D; env-&gt;GetMethodID(textView,&quot;setText&quot;,&quot;(Ljava&#x2F;lang&#x2F;CharSequence;)V&quot;);&#x2F;&#x2F; jstring r0ysueEn &#x3D; Java_com_roysue_easyso1_MainActivity_method01(env,MainActivity_class2,r0ysue);&#x2F;&#x2F; jmethodID Javamethod01 &#x3D; env-&gt;GetStaticMethodID(MainActivity_class2,&quot;method01&quot;,&quot;(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;);&#x2F;&#x2F; jstring r0ysueEn2 &#x3D; static_cast&lt;jstring&gt;(env-&gt;CallStaticObjectMethod(MainActivity_class2,&#x2F;&#x2F; Javamethod01, r0ysue));&#x2F;&#x2F; env-&gt;CallVoidMethod(tv,setText,r0ysueEn2); env-&gt;CallVoidMethod(tv,setText,r0ysue);&#x2F;&#x2F;&#x2F;&#x2F; for (int i &#x3D; 0; i &lt; 2048; i++) &#123;&#x2F;&#x2F; jstring jstr &#x3D; env-&gt;NewStringUTF(&quot;12345&quot;);&#x2F;&#x2F; LOGI(&quot; local Reference is Num %d : &quot;, i );&#x2F;&#x2F; &#125;&#125; var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"SO","slug":"SO","permalink":"http://onejane.github.io/tags/SO/"}]},{"title":"自制路由器抓包","slug":"自制路由器抓包","date":"2021-07-03T01:07:14.000Z","updated":"2021-12-12T03:09:39.337Z","comments":true,"path":"2021/07/03/自制路由器抓包/","link":"","permalink":"http://onejane.github.io/2021/07/03/%E8%87%AA%E5%88%B6%E8%B7%AF%E7%94%B1%E5%99%A8%E6%8A%93%E5%8C%85/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 京东搜索从实践中学习系列丛书 网络工具集：netwox 网络层：MAC/IP/ARP/DHCP 传输层：IP/TCP/UDP/ICMP(ping,traceroute) 应用层：DNS/Telnet/NC/FTP ARM设备武器化指南·破·Kali.Nethunter.2020a.上手实操 配合有线，无线网卡，手机wifi，4g该手机将会有4个ip地址。 网卡NDS Lookup 给指定网卡配置路由器给kali插入一块Ralink 802.11n网卡 nm-connection-editor 保存后ifconfig查看wlan0的ip，移动端就可以收到wifi信号了，jnettop结合wireshark抓包经过该网卡的全部流量。 123456789101112131415161718192021222324252627282930313233343536ifconfig wlan0 downifconfig wlan0 upssh root@192.168.0.107 连接kali nethunternethogs，jnettop 和 kali linux中抓的结果一致apt install netwox 创造任意tcp,udp数据报文，网络欺骗，自行发包netwox 55 -i 192.168.0.107 判断内网主机是否存活netwox 171 充当客户端请求dhcpnetwox 179 根据自己ip获取dhcp服务器信息netwox 3 -a www.163.comnetwox 3 -a 192.168.0.0&#x2F;24netwox 38 -l 192.168.0.8 -m 192.168.0.9netwox 34nentwox 74 -i &quot;192.168.0.107&quot; 洪水攻击netwox 94 -i 192.168.0.7 -p 8888 -c &quot;&#x2F;bin&#x2F;sh -c ifconfig&quot; 远程调用指令netwox 93 -P 8888netwox 87 -i 192.168.0.7 -p 80 发送消息netwox 89 -P 80 接受消息netwox 95 -i 192.168.0.7 -p 8888 &quot;nohup.out&quot; 获取目标机的文件netwox 95 --helpnetwox 93 -P 8888netwox 96 -i 192.168.0.7 -p 8888 -f get-pip.py -F get-pip.py 传输文件netwox 93 -P 8888netwox 51 -i 220.181.38.148netwox 67 -i 192.168.0.7 -p 1-100netwox 59 -i 192.168.0.7 洪水共计netwox 88 -i 192.168.0.7 -p 80 发送udp的包netwox 90 -P 80nc -l 8888 &gt; get-pip.py nc 118.126.66.192 8888 &lt; get-pip.py arp缓存表，路由表 树莓派刷安卓10 4G代理pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip 在kali nethunter下载shadowsocks-3.0.0 ssserver –version ssserver -k “123456” -m rc4-md5 pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip 在kali linux下载shadowsocks-3.0.0 sslocal –version ssserver –version sslocal -s 192.168.0.4 -p 8388 -k “123456” -m rc4-md5 vim /etc/proxychains4.conf socks5 127.0.0.1 1080 proxychains curl ip.sb =&gt; proxychains =&gt; sslocal =&gt; nps =&gt; 内网穿透 -&gt; npc -&gt; sserver -&gt; 4G 搭建NPS服务器 =&gt; 新增客户端 下载linux_arm64_client.tar.gz 执行新增客户端后生成的npc命令 建立隧道 sslocal -s 118.126.66.193 -p 58388 -k “123456” -m rc4-md5 112.65.48.132 是手机的ip，在手机端curl ip.sb pip install pysocks 1234567import requestsr &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;ip&#39;)print(r.text)proxy &#x3D; &#123;&quot;http&quot;:&quot;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;,&quot;https&quot;:&quot;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;&#125;r2 &#x3D;requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;ip&#39;,proxies &#x3D;proxy)print(r2.text) 美团点评移动网络优化实践 TCP协议详解 UDP协议的详细解析 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"加壳与脱壳之FART脱壳","slug":"加壳与脱壳之FART脱壳","date":"2021-06-03T05:25:02.000Z","updated":"2022-04-09T04:25:26.168Z","comments":true,"path":"2021/06/03/加壳与脱壳之FART脱壳/","link":"","permalink":"http://onejane.github.io/2021/06/03/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8BFART%E8%84%B1%E5%A3%B3/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 FART框架简介在对于整体保护来说，Dalvik和Art通用的解决方案都是寻找一个合适的时机点去dump内存中完整的dex。整体加固存在致命的弱点，就是在内存中是连续的。由此进入函数抽取的时代，即二代壳的开始，而FART的出现要解决的问题就是函数抽取的方案。FART是一个框架，不只是ART下的，事实上也可以在Dalvik下实现。 ART下脱壳原理InMemoryDexClassLoader源码分析 12345static jobjectCreateSingleDexFileCookie(JNIEnv* env,std::unique_ptr&lt;MemMap&gt;data)static constDexFile*CreateDexFile(JNIEnv*env,std::unique_ptr&lt;MemMap&gt;dex_mem_map)DexFile::Open(location,OpenCommon(map-&gt;Begin()DexFile::DexFile(constuint8_t*base, DexClassLoader源码分析 123OpenAndReadMagic(filename,&amp;magic, error_msg);DexFile::OpenCommon(constuint8_t* base,DexFile::DexFile(constuint8_t*base, dex2oat编译流程 123456789102965int main(int argc, char** argv) &#123;2966 int result &#x3D; static_cast&lt;int&gt;(art::Dex2oat(argc, argv));2967 &#x2F;&#x2F; Everything was done, do an explicit exit here to avoid running Runtime destructors that take2968 &#x2F;&#x2F; time (bug 10645725) unless we&#39;re a debug build or running on valgrind. Note: The Dex2Oat class2969 &#x2F;&#x2F; should not destruct the runtime in this case.2970 if (!art::kIsDebugBuild &amp;&amp; (RUNNING_ON_MEMORY_TOOL &#x3D;&#x3D; 0)) &#123;2971 _exit(result);2972 &#125;2973 return result;2974&#125; apk安装时进行的dex2oat的编译流程 dex2oat编译流程是最终通过CompileMethod按照函数粒度进行编译，并不是所有的函数都会被编译，比如类初始化函数&lt;clinit&gt;。因此对于当一个类被初始化时，该类的初始化函数始终运行在interpreter模式。对于类的初始化函数并不是dex2oat编译的对象，自然该函数被编译生成二进制代码，自然类的初始化函数始终运行在解释模式下。 ART下函数执行模式： interpreter模式：解释模式，最后进入art下的解释器完成取址，取出对应codeItem每一条smali指令，由art下的解释器解释执行，不同版本解释器实现不一样（对于所有的类的初始化函数不管有没有禁用掉dex2oat的编译流程，都是运行在解释模式下，最后必然进入art下的解释器中） android10 12345678910236 enum InterpreterImplKind &#123;237 kSwitchImplKind, &#x2F;&#x2F; Switch-based interpreter implementation.238 kMterpImplKind &#x2F;&#x2F; Assembly interpreter239 &#125;;240 241 #if ART_USE_CXX_INTERPRETER242 static constexpr InterpreterImplKind kInterpreterImplKind &#x3D; kSwitchImplKind;243 #else244 static constexpr InterpreterImplKind kInterpreterImplKind &#x3D; kMterpImplKind;245 #endif android 9 123456234 enum InterpreterImplKind &#123;235 kSwitchImplKind, &#x2F;&#x2F; Switch-based interpreter implementation.236 kMterpImplKind &#x2F;&#x2F; Assembly interpreter237 &#125;;238 239 static constexpr InterpreterImplKind kInterpreterImplKind &#x3D; kMterpImplKind; android 8 123456231 enum InterpreterImplKind &#123;232 kSwitchImplKind, &#x2F;&#x2F; Switch-based interpreter implementation.233 kMterpImplKind &#x2F;&#x2F; Assembly interpreter234 &#125;;235 236 static constexpr InterpreterImplKind kInterpreterImplKind &#x3D; kMterpImplKind; android 7 1234567891011121314229 enum InterpreterImplKind &#123;230 kSwitchImplKind, &#x2F;&#x2F; Switch-based interpreter implementation.231 kComputedGotoImplKind, &#x2F;&#x2F; Computed-goto-based interpreter implementation.232 kMterpImplKind &#x2F;&#x2F; Assembly interpreter233 &#125;;234 static std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const InterpreterImplKind&amp; rhs) &#123;235 os &lt;&lt; ((rhs &#x3D;&#x3D; kSwitchImplKind)236 ? &quot;Switch-based interpreter&quot;237 : (rhs &#x3D;&#x3D; kComputedGotoImplKind)238 ? &quot;Computed-goto-based interpreter&quot;239 : &quot;Asm interpreter&quot;);240 return os;241 &#125;243 static constexpr InterpreterImplKind kInterpreterImplKind &#x3D; kMterpImplKind; 说明在8.0以后google抛弃了基于kComputedGotoImplKind的实现，而使用汇编的方式实现。ArtMethod对象中的GetDexFile获取到ArtMethod所属的dex file，可以通过Begin和Size获取该dex的内存中起始地址和大小，实现内存中dex的dump操作。 12345671049 const uint8_t* Begin() const &#123;1050 return begin_;1051 &#125;10521053 size_t Size() const &#123;1054 return size_;1055 &#125; quick模式：直接运行dex2oat编译生成的arm模式，直接运行二进制代码 当一个壳使用dexclassloader加载一个dex文件时，如果没有禁用掉dex2oat类中初始化函数将也没有被编译，是运行在解释模式下。如果禁用掉dex2oat导致dex文件中所有的函数都运行在解释模式下。 FART脱壳点Execute脱壳点interpreter模式流程： 从ArtMethod类中EnterInterpreterFromInvoke开始分析Execute-&gt;ExecuteMterplmpl或者ExecuteSwitchImpl，可以看到对于任何一个运行在interpreter模式的java函数来说，最后都会进入art下的解释器中进行解释执行。 修改/art/runtime/interpreter/interpreter.cc添加static inline JValue Execute(的DCHECK(!shadow_frame.GetMethod()-&gt;IsAbstract());前面通过artmethod获取Dexfile对象从而dump下dex文件 ArtMethod* artmethod=shadow_frame.GetMethod(); // 判断是否是类初始化函数，降低调用次数，只在初始化时进行dump操作 if(strstr(artmethod-&gt;PrettyMethod().c_str(),&quot;&lt;clinit&gt;&quot;)) { // 很多函数抽取壳将dex2oat干掉，除了初始化函数所有的函数都进入解释模式 //inline const DexFile* ArtMethod::GetDexFile() const DexFile* dexfile=artmethod-&gt;GetDexFile(); /* const uint8_t* Begin() const { 1050 return begin_; 1051 } 1052 1053 size_t Size() const { 1054 return size_; 1055 }*/ // 获取dex文件的起始地址和大小 const uint8_t* begin=dexfile-&gt;Begin(); size_t size=dexfile-&gt;Size(); // 写入到sdcard中 char dexfilepath[100]={0}; sprintf(dexfilepath,&quot;/sdcard/%d_%d_Execute.dex&quot;,(int)size,getpid()); int fd=open(dexfilepath,O_CREAT|O_RDWR,0666); if(fd&gt;0) { int number=write(fd,begin,size); if(number&gt;0){ } close(fd); } } 重新编译,将out/target/product/sailfish下的system.img和system_other.img重新刷机 1234source build&#x2F;envsetup.shlunch选择23 aosp_sailfish-userdebugtime make -j4 开始刷机flash.bat 123456fastboot flash boot boot.imgfastboot flash vendor vendor.imgfastboot flash system_a system.imgfastboot flash system_b system_other.imgfastboot flash userdata userdata.imgfastboot reboot 打开加壳app后，在sdcard中查看Excute结尾的dex即为脱下来的原dex Execute和linkcode脱壳点源代码中找到出现DexFile的位置，添加相应代码，获取起始地址和大小dump下来。找到参数，返回值，函数执行过程中出现的dex对象都是潜在的脱壳点。或者通过artmethod对象获取到所属的dexFile对象，进入dex脱壳的流程。 FART：ART环境下基于主动调用的自动化脱壳方案 拨云见日：安卓APP脱壳的本质以及如何快速发现ART下的脱壳点 FART正餐前甜点：ART下几个通用简单高效的dump内存中dex方法 比如在dex2oat编译过程的DexFile的脱壳点，如果app的加壳厂商干掉了dex2oat流程，就不会进入到该脱壳点，自然无法在dex2oat的编译流程中dump内存中dex。故而dex2oat不是一个好的脱壳点。Execute为什么是一个好脱壳点，不管加固厂商有没有禁用dex2oat编译流程，对于dex文件类初始化都会进入到解释执行的流程当中。Execute是个内联函数，加固厂商很难通过hook修改Execute的逻辑。artmethod可以通过getDexFile获取到dexfile对象，以下都是合适的脱壳点。 进入LinkCode 将上文中artmethod获取Dexfile对象从而dump下dex文件的代码拷贝到LinkCode中 1234567891011121314151617181920212223242526272829303132ArtMethod* artmethod&#x3D;method;&#x2F;&#x2F; 判断是否是类初始化函数，降低调用次数，防止效率太低，只在初始化时进行dump操作if(strstr(artmethod-&gt;PrettyMethod().c_str(),&quot;&lt;clinit&gt;&quot;))&#123; &#x2F;&#x2F; 很多函数抽取壳将dex2oat干掉，除了初始化函数所有的函数都进入解释模式 &#x2F;&#x2F;inline const DexFile* ArtMethod::GetDexFile() const DexFile* dexfile&#x3D;artmethod-&gt;GetDexFile(); &#x2F;* const uint8_t* Begin() const &#123;1050 return begin_;1051 &#125;1052 1053 size_t Size() const &#123;1054 return size_;1055 &#125;*&#x2F; &#x2F;&#x2F; 获取dex文件的起始地址和大小 const uint8_t* begin&#x3D;dexfile-&gt;Begin(); size_t size&#x3D;dexfile-&gt;Size(); &#x2F;&#x2F; 写入到sdcard中 char dexfilepath[100]&#x3D;&#123;0&#125;; sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_LinkCode.dex&quot;,(int)size,getpid()); int fd&#x3D;open(dexfilepath,O_CREAT|O_RDWR,0666); if(fd&gt;0) &#123; int number&#x3D;write(fd,begin,size); if(number&gt;0)&#123; &#125; close(fd); &#125; &#125; 编译刷机，安装好加壳app后打开app存储权限，再打开app查看/sdcard/*_LinkCode.dex文件 1time make -j4 FART场景现在加固厂商对dex保护不仅仅局限在dex整体，已经进入到函数抽取中的函数粒度的保护，甚至进入到vmp和dex2c的每一条指令的保护，保护粒度越来越细化。很多工具无法应对函数粒度的加固保护方案，更别说vmp和dex2c的加固方案。dexhunter解决函数抽取通过遍历dex中全部的类进行主动加载初始化，fupk3首次使用主动调用概念，对每一个函数调用，一定程度上解决函数的抽取。但是fupk3基于Dalvik下的即Android4.4之前的，很多app已经不支持Dalvik了。 fart框架针对函数抽取，同时实现art，兼容4.4到10.0等，只要art没有被抛弃，fart都可以实现在这些系统上的脱壳。脱壳组件分离可以内存dex的整体dump加固基础的防护，主动调用组件对某一个函数或class中所有函数的指令部分，修复组件针对vmp保护的apk的修复。 CodeItem是运行过程中解密后的指令流部分，牵扯到dex的文件格式。 新建项目codeitemtest,在MainActivity中加入如下代码，并在onCreate中调用testWithoutTry();testWithTry(); 1234567891011121314public void testWithoutTry()&#123; Log.i(&quot;onejane&quot;,&quot;testWithoutTry&quot;);&#125;public void testWithTry()&#123; int i &#x3D; 0; int j &#x3D; 100; try &#123; Log.i(&quot;onejane&quot;,&quot;testWithtry&quot;); int result &#x3D; j&#x2F;i; &#125; catch (Exception e)&#123; Log.i(&quot;onejane&quot;,&quot;testWithTry-&gt;from catch&quot;); e.printStackTrace(); &#125;&#125; 使用010Editor打开编译后的dex，找到struct_method_id_list_dex_class_ids和struct_method_id_list_dex_method_ids右键Export CSV，搜索MainActivity找到index为1358 找到该MainActivity的位置，图中选中的0x11DAA0是该函数的代码偏移 前16字节是函数头部分，寄存器个数，参数等 在GDA中Show ByteCode定位相关的指令，05ae转成十进制为1454，通过struct_method_id_list_dex_method_ids查看1454找到对应函数。Show In Hex定位到地址 FART生成bin文件，即CodeItem的格式 5元组填充{name:函数名，method_idx:函数索引，offset:偏移，code_item_len:长度，ins:函数体CodeItem的base64字符串}，使用010Edito打开dex和bin文件对比索引，其中GDA中的地址复制到010Editor中使用Ctrl+g搜索找到dex索引位置，bin中的offset偏移转成十六进制后可以通过Ctrl+g在010Editor中找到对应代码位置， FART脱壳结束得到的文件列表有两类： Execute脱壳点得到dex和dex中的所有类列表 主动调用时dump得到的dex和此时dex中的所有类列表，以及该dex中所有函数的CodeItem即bin文件 FART脱下来的文件只需要函数体文件以及与函数体文件名开头的对应的大小的dex，而在execute脱壳点脱下来的dex只是作为参考 拷贝bin文件中ins的值base64编码到base64decode.py中写入checkSize.bin文件中，打开bin后将计算好的字节覆盖掉原dex中的代码，实现手动修复checkSize函数。GDA打开后找到MemoryCache的checkSize函数右键Show ByteCode查看字节码信息， 完美使用场景：整体加固壳就不说了 FART对dex的修复粒度在函数粒度，三组件结合可以完美解决基于函数抽取技术进行加固的app脱壳 案例adb install aipao.apk Settings—-Apps &amp; notifications—-App permissions—-添加该app的sd卡读写权限 打开app查看logcat信息，主动调用时出现ActivityThread的信息，/sdcard/fart中已经出现execute的dex文件，bin文件不断增大，等待fart主动调用结束出现fart run over 12grep -r &quot;MemoryCache&quot; .&#x2F;*.txt 找到MemoryCache类所在的txt中adb pull &#x2F;sdcard&#x2F;fart&#x2F;com.aipao.hanmoueschool 其中dexfile的dex文件是在主动调用每一个函数时顺带当前artmethod所属的dex文件dump下来，txt是类列表 当遇到函数被抽空时，可以使用dump下的codeItem函数体bin文件进行修复，使用python fart.py实现修复 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"FART","slug":"FART","permalink":"http://onejane.github.io/tags/FART/"}]},{"title":"克拉恋人会员制取证分析","slug":"克拉恋人会员制取证分析","date":"2021-05-30T16:21:13.000Z","updated":"2021-12-12T03:09:39.288Z","comments":true,"path":"2021/05/31/克拉恋人会员制取证分析/","link":"","permalink":"http://onejane.github.io/2021/05/31/%E5%85%8B%E6%8B%89%E6%81%8B%E4%BA%BA%E4%BC%9A%E5%91%98%E5%88%B6%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 绕过强制会员adb install com.caratlover.apk 安装后强制支付会员费才可进主页 脱壳jadx打开发现代码很少，目测被加固，脱个衣服先。 12345678910git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;FRIDA-DEXDump.git.&#x2F;fs1426arm64pyenv local 3.9.0python main.py app保持最前端,开始脱壳git clone https:&#x2F;&#x2F;github.com&#x2F;hanbinglengyue&#x2F;FART.gitadb push frida_fart&#x2F;lib&#x2F;fart* &#x2F;data&#x2F;local&#x2F;tmpadb shell &amp;&amp; cp fart* &#x2F;data&#x2F;app &amp;&amp; chmod 777frida -U -f com.caratlover -l frida_fart_hook.js --no-pause 使用安卓8和安卓8.1进行脱壳mv ..&#x2F;*.dex carat &amp;&amp; adb pull &#x2F;sdcard&#x2F;carat file * 查看文件格式是Dalvik dex file，但是脱完的部分dex文件用010 Editor打开时，报错，说明文件并不标准。 123objection -g com.caratlover exploreandroid hooking list activitiesandroid intent launch_activity com.chanson.business.MainActivity 直接绕过强制会员购买页面 使用jadx1.2.0中同时打开多个dex，查找com.chanson.business.MainActivity 用12.8.0的frida混淆的爹妈都不认识了，还是用14.2.16版本。 绕过强制会员页面后，编辑资料填写个人详细信息。 搭讪通过点击发送时，调用hookEvent.js查看触发的类frida -UF -l hookEvent.js 1[Pixel::克拉恋人]-&gt; [WatchEvent] onClick: com.tencent.qcloud.tim.uikit.modules.chat.layout.input.InputLayout 查看InputLayout该类的用例，该UI基本都在com.chanson.business.message.activity.ChatActivity中调用 其中com.chanson.business.message.activity.ChatActivity有一段代码，判断是否vip 12345678910111213141516171819202122232425262728293031private final void ja() &#123; BasicUserInfoBean col1; BasicUserInfoBean col12; if (Ib.f9521i.m()) &#123; MyInfoBean k &#x3D; Ib.f9521i.k(); if (k &#x3D;&#x3D; null || (col12 &#x3D; k.getCol1()) &#x3D;&#x3D; null || !col12.isVip()) &#123; CheckTalkBean checkTalkBean &#x3D; this.f10545d; if ((checkTalkBean !&#x3D; null ? checkTalkBean.getUnlockTime() : 0) &gt; 0) &#123; da(); &#125; else &#123; l(0); &#125; &#125; else &#123; da(); &#125; &#125; else &#123; MyInfoBean k2 &#x3D; Ib.f9521i.k(); if (k2 &#x3D;&#x3D; null || (col1 &#x3D; k2.getCol1()) &#x3D;&#x3D; null || !col1.isReal()) &#123; ConfirmDialogFragment.a aVar &#x3D; ConfirmDialogFragment.Companion; String string &#x3D; getString(R$string.you_can_chat_after_you_have_certified); i.a((Object) string, &quot;getString(R.string.you_c…after_you_have_certified)&quot;); String string2 &#x3D; getString(R$string.authentication_now_in_ten_seconds); i.a((Object) string2, &quot;getString(R.string.authe…ation_now_in_ten_seconds)&quot;); FragmentManager supportFragmentManager &#x3D; getSupportFragmentManager(); i.a((Object) supportFragmentManager, &quot;supportFragmentManager&quot;); ConfirmDialogFragment.a.a(aVar, &quot;&quot;, string, &quot;&quot;, string2, true, supportFragmentManager, true, (kotlin.jvm.a.a) null, false, (kotlin.jvm.a.b) null, (String) null, 0.0f, (kotlin.jvm.a.b) null, 8064, (Object) null).a(new I(this)); return; &#125; da(); &#125;&#125; 其中的isVip方法来自于com.chanson.business.model.BasicUserInfoBean,我们尝试trace下该类，并打印类的每个域的值。 tracefrida -UF -l trace.js -o traceVip.txt 对指定类的所有动静态方法及构造函数进行trace 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196function inspectObject(obj) &#123; Java.perform(function () &#123; const obj_class &#x3D; obj.class; &#x2F;&#x2F; var objClass &#x3D; Java.use(&quot;java.lang.Object&quot;).getClass.apply(object); &#x2F;&#x2F; obj_class &#x3D;Java.use(&quot;java.lang.Class&quot;).getName.apply(objClass); const fields &#x3D; obj_class.getDeclaredFields(); const methods &#x3D; obj_class.getMethods(); &#x2F;&#x2F; console.log(&quot;Inspecting &quot; + obj.getClass().toString()); &#x2F;&#x2F; console.log(&quot;Inspecting &quot; + obj.class.toString()); console.log(&quot;\\tFields:&quot;); for (var i in fields) &#123; console.log(&quot;\\t\\t&quot; + fields[i].toString()); var className &#x3D; obj_class.toString().trim().split(&quot; &quot;)[1]; &#x2F;&#x2F; console.log(&quot;className is &#x3D;&gt; &quot;,className); var fieldName &#x3D; fields[i].toString().split(className.concat(&quot;.&quot;)).pop(); console.log(fieldName + &quot; &#x3D;&gt; &quot;, obj[fieldName].value); &#125; &#x2F;&#x2F; console.log(&quot;\\tMethods:&quot;); &#x2F;&#x2F; for (var i in methods) &#x2F;&#x2F; console.log(&quot;\\t\\t&quot; + methods[i].toString()); &#125;)&#125;function uniqBy(array, key)&#123; var seen &#x3D; &#123;&#125;; return array.filter(function(item) &#123; var k &#x3D; key(item); return seen.hasOwnProperty(k) ? false : (seen[k] &#x3D; true); &#125;);&#125;&#x2F;&#x2F; trace a specific Java Methodfunction traceMethod(targetClassMethod)&#123; var delim &#x3D; targetClassMethod.lastIndexOf(&quot;.&quot;); if (delim &#x3D;&#x3D;&#x3D; -1) return; var targetClass &#x3D; targetClassMethod.slice(0, delim) var targetMethod &#x3D; targetClassMethod.slice(delim + 1, targetClassMethod.length) var hook &#x3D; Java.use(targetClass); var overloadCount &#x3D; hook[targetMethod].overloads.length; console.log(&quot;Tracing &quot; + targetClassMethod + &quot; [&quot; + overloadCount + &quot; overload(s)]&quot;); for (var i &#x3D; 0; i &lt; overloadCount; i++) &#123; hook[targetMethod].overloads[i].implementation &#x3D; function() &#123; inspectObject(this) console.warn(&quot;\\n*** entered &quot; + targetClassMethod); &#x2F;&#x2F; print backtrace &#x2F;&#x2F; Java.perform(function() &#123; &#x2F;&#x2F; var bt &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()); &#x2F;&#x2F; console.log(&quot;\\nBacktrace:\\n&quot; + bt); &#x2F;&#x2F; &#125;); &#x2F;&#x2F; print args if (arguments.length) console.log(); for (var j &#x3D; 0; j &lt; arguments.length; j++) &#123; console.log(&quot;arg[&quot; + j + &quot;]: &quot; + arguments[j]); &#125; &#x2F;&#x2F; print retval var retval &#x3D; this[targetMethod].apply(this, arguments); &#x2F;&#x2F; rare crash (Frida bug?) console.log(&quot;\\nretval: &quot; + retval); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.warn(&quot;\\n*** exiting &quot; + targetClassMethod); return retval; &#125; &#125; &#125;function traceClass(targetClass)&#123; &#x2F;&#x2F;Java.use是新建一个对象哈，大家还记得么？ var hook &#x3D; Java.use(targetClass); &#x2F;&#x2F;利用反射的方式，拿到当前类的所有方法 var methods &#x3D; hook.class.getDeclaredMethods(); &#x2F;&#x2F; var methods &#x3D; hook.class.getMethods(); console.log(&quot;methods &#x3D;&gt; &quot;,methods) &#x2F;&#x2F;建完对象之后记得将对象释放掉哈 hook.$dispose; &#x2F;&#x2F;将方法名保存到数组中 var parsedMethods &#x3D; []; methods.forEach(function(method) &#123; parsedMethods.push(method.toString().replace(targetClass + &quot;.&quot;, &quot;TOKEN&quot;).match(&#x2F;\\sTOKEN(.*)\\(&#x2F;)[1]); &#125;); &#x2F;&#x2F;去掉一些重复的值 var targets &#x3D; uniqBy(parsedMethods, JSON.stringify); &#x2F;&#x2F; 只hook构造函数 &#x2F;&#x2F;targets &#x3D; []; targets &#x3D; targets.concat(&quot;$init&quot;) console.log(&quot;targets&#x3D;&gt;&quot;,targets) &#x2F;&#x2F;对数组中所有的方法进行hook，traceMethod也就是第一小节的内容 targets.forEach(function(targetMethod) &#123; traceMethod(targetClass + &quot;.&quot; + targetMethod); &#125;);&#125;function hook() &#123; Java.perform(function () &#123; console.log(&quot;start&quot;) Java.enumerateClassLoaders(&#123; onMatch: function (loader) &#123; try &#123; if(loader.findClass(&quot;com.ceco.nougat.gravitybox.ModStatusbarColor$1&quot;))&#123; &#x2F;&#x2F; if(loader.findClass(&quot;de.robv.android.xposed.XC_MethodHook&quot;))&#123; &#x2F;&#x2F; if(loader.findClass(&quot;de.robv.android.xposed.XposedBridge&quot;))&#123; &#x2F;&#x2F;if(loader.findClass(&quot;com.android.internal.statusbar.StatusBarIcon&quot;))&#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); Java.classFactory.loader &#x3D; loader ; &#125; &#125; catch(error)&#123; console.log(&quot;find error:&quot; + error) &#125; &#125;, onComplete: function () &#123; console.log(&quot;end1&quot;) &#125; &#125;) &#x2F;&#x2F; Java.use(&quot;de.robv.android.xposed.XposedBridge&quot;).log.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (str) &#123; &#x2F;&#x2F; console.log(&quot;entering Xposedbridge.log &quot;,str.toString()) &#x2F;&#x2F; return true &#x2F;&#x2F; &#125; &#x2F;&#x2F;traceClass(&quot;com.ceco.nougat.gravitybox.ModStatusbarColor&quot;) &#x2F;&#x2F; Java.use(&quot;com.roysue.xposed1.HookTest$1&quot;).afterHookedMethod.implementation &#x3D; function (param)&#123; &#x2F;&#x2F; console.log(&quot;entering afterHookedMethod param is &#x3D;&gt; &quot;,param); &#x2F;&#x2F; return this.afterHookedMethod(param); &#x2F;&#x2F; &#125; &#x2F;&#x2F; traceClass(&quot;de.robv.android.xposed.XC_MethodHook&quot;) &#x2F;&#x2F; Java.use(&quot;de.robv.android.xposed.XC_MethodHook$MethodHookParam&quot;).setResult.implementation &#x3D; function(str)&#123; &#x2F;&#x2F; console.log(&quot;entersing de.robv.android.xposed.XC_MethodHook$MethodHookParam setResult &#x3D;&gt; &quot;,str) &#x2F;&#x2F; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); &#x2F;&#x2F; return this.setResult(str); &#x2F;&#x2F; &#125; Java.enumerateLoadedClasses (&#123; onMatch:function(className)&#123; if(className.toString().indexOf(&quot;gravitybox&quot;)&gt;0 &amp;&amp; className.toString().indexOf(&quot;$&quot;)&gt;0 )&#123; console.log(&quot;found &#x3D;&gt; &quot;,className) &#x2F;&#x2F; var interFaces &#x3D; Java.use(className).class.getInterfaces(); &#x2F;&#x2F; if(interFaces.length&gt;0)&#123; &#x2F;&#x2F; console.log(&quot;interface is &#x3D;&gt; &quot;); &#x2F;&#x2F; for(var i in interFaces)&#123; &#x2F;&#x2F; console.log(&quot;\\t&quot;,interFaces[i].toString()) &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; if(Java.use(className).class.getSuperclass())&#123; var superClass &#x3D; Java.use(className).class.getSuperclass().getName(); &#x2F;&#x2F; console.log(&quot;superClass is &#x3D;&gt; &quot;,superClass); if (superClass.indexOf(&quot;XC_MethodHook&quot;)&gt;0)&#123; console.log(&quot;found class is &#x3D;&gt; &quot;,className.toString()) traceClass(className); &#125; &#125; &#125; &#125;,onComplete:function()&#123; console.log(&quot;search completed!&quot;) &#125; &#125;) console.log(&quot;end2&quot;) &#125;)&#125;function main()&#123; &#x2F;&#x2F; hook() Java.perform(function()&#123; traceClass(&quot;com.chanson.business.model.BasicUserInfoBean&quot;) &#x2F;&#x2F; traceClass(&quot;com.chanson.business.model.MyInfoBean&quot;); &#125;)&#125;setImmediate(main) java.lang.Throwable at com.chanson.business.model.BasicUserInfoBean.isVip(Native Method) at com.chanson.business.message.activity.ChatActivity.na(SourceFile:2) at com.chanson.business.message.activity.ChatActivity.k(SourceFile:1) at com.chanson.business.message.activity.a.run(SourceFile:1) at android.os.Handler.handleCallback(Handler.java:790) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:164) at android.app.ActivityThread.main(ActivityThread.java:6494) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807) at de.robv.android.xposed.XposedBridge.main(XposedBridge.java:108) 优化对应关系 frida -UF -l trace.js -o traceVip.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function traceMethod(targetClassMethod) &#123; var delim &#x3D; targetClassMethod.lastIndexOf(&quot;.&quot;); if (delim &#x3D;&#x3D;&#x3D; -1) return; var targetClass &#x3D; targetClassMethod.slice(0, delim) var targetMethod &#x3D; targetClassMethod.slice(delim + 1, targetClassMethod.length) var hook &#x3D; Java.use(targetClass); var overloadCount &#x3D; hook[targetMethod].overloads.length; console.log(&quot;Tracing &quot; + targetClassMethod + &quot; [&quot; + overloadCount + &quot; overload(s)]&quot;); for (var i &#x3D; 0; i &lt; overloadCount; i++) &#123; hook[targetMethod].overloads[i].implementation &#x3D; function () &#123; var output &#x3D; &quot;&quot;; for(var line&#x3D;0;line&lt;100;line++)&#123; output &#x3D; output.concat(&quot;&#x3D;&quot;) &#125; output &#x3D; output.concat(&quot;\\r\\n&quot;) const Class &#x3D; Java.use(&quot;java.lang.Class&quot;); &#x2F;&#x2F; const obj_class &#x3D; Java.cast(this.getClass(), Class); const obj_class &#x3D; this.class; const fields &#x3D; obj_class.getDeclaredFields(); &#x2F;&#x2F; output &#x3D; output.concat(&quot;Inspecting &quot; + this.getClass().toString()); output &#x3D; output.concat(&quot;Inspecting &quot; + this.class); output &#x3D; output.concat(&quot;\\r\\n&quot;) output &#x3D; output.concat(&quot;\\tFields:&quot;); output &#x3D; output.concat(&quot;\\r\\n&quot;) for (var i in fields) &#123; &#x2F;&#x2F; console.log(&quot;\\t\\t&quot; + fields[i].toString()); var className &#x3D; obj_class.toString().trim().split(&quot; &quot;)[1]; &#x2F;&#x2F; console.log(&quot;className is &#x3D;&gt; &quot;,className); var fieldName &#x3D; fields[i].toString().split(className.concat(&quot;.&quot;)).pop(); var fieldValue &#x3D; undefined; if(!(this[fieldName]&#x3D;&#x3D;&#x3D;undefined))&#123; fieldValue &#x3D; this[fieldName].value ; &#125; output &#x3D; output.concat(fieldName + &quot; &#x3D;&gt; &quot;, fieldValue); output &#x3D; output.concat(&quot;\\r\\n&quot;) &#125; &#x2F;&#x2F; inspectObject(this); output &#x3D; output.concat(&quot;\\n*** entered &quot; + targetClassMethod); output &#x3D; output.concat(&quot;\\r\\n&quot;) &#x2F;&#x2F; print backtrace &#x2F;&#x2F; Java.perform(function() &#123; &#x2F;&#x2F; var bt &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()); &#x2F;&#x2F; console.log(&quot;\\nBacktrace:\\n&quot; + bt); &#x2F;&#x2F; &#125;); &#x2F;&#x2F; print args if (arguments.length) console.log(); for (var j &#x3D; 0; j &lt; arguments.length; j++) &#123; output &#x3D; output.concat(&quot;arg[&quot; + j + &quot;]: &quot; + arguments[j] + &quot; &#x3D;&gt; &quot; + JSON.stringify(arguments[j])); output &#x3D; output.concat(&quot;\\r\\n&quot;) &#125; output &#x3D; output.concat(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); output &#x3D; output.concat(&quot;\\r\\n&quot;); &#x2F;&#x2F; print retval var retval &#x3D; this[targetMethod].apply(this, arguments); &#x2F;&#x2F; rare crash (Frida bug?) output &#x3D; output.concat(&quot;\\nretval: &quot; + retval + &quot; &#x3D;&gt; &quot; + JSON.stringify(retval)); output &#x3D; output.concat(&quot;\\r\\n&quot;) output &#x3D; output.concat(&quot;\\n*** exiting &quot; + targetClassMethod); output &#x3D; output.concat(&quot;\\r\\n&quot;) console.log(output); return retval; &#125; &#125;&#125; vip旧版4.1.0frida -UF -l hookCaratVip.js 1234567891011121314function hookVIP()&#123; Java.perform(function()&#123; Java.use(&quot;com.chanson.business.model.BasicUserInfoBean&quot;).isVip.implementation &#x3D; function()&#123; console.log(&quot;Calling isVIP &quot;) return true; &#125; &#125;) &#125;function main()&#123; console.log(&quot;Start hook&quot;) hookVIP()&#125;setImmediate(main) 新版4.6.01android hooking watch class com.chanson.business.message.activity.ChatActivity --dump-args --dump-backtrace --dump-return 当我们无法判断什么时候判断vip时，hook整个类，查看调用链，点击发送消息时，弹窗付费 查看jadx中的com.chanson.business.message.activity.ChatActivity类，通过aa方法得知只有在被拉黑等情况，返回false则无法发送消息，我们在第一步让Z()返回false，直接进入return true 1234567891011121314151617181920212223242526272829303132333435363738394041private final boolean aa() &#123; if (!Z()) &#123; return true; &#125; if (this.f10873d &#x3D;&#x3D; null) &#123; Hb.a(Hb.f11628c, &quot;数据异常&quot;, 0, 2, (Object) null); return false; &#125; else if (ga()) &#123; return false; &#125; else &#123; CheckTalkBean checkTalkBean &#x3D; this.f10873d; if (checkTalkBean &#x3D;&#x3D; null) &#123; i.a(); throw null; &#125; else if (!checkTalkBean.getUnlock()) &#123; ChatLayout chatLayout &#x3D; (ChatLayout) k(R$id.chatLayout); i.a((Object) chatLayout, &quot;chatLayout&quot;); chatLayout.getInputLayout().hideSoftInput(); x.a(new RunnableC1179a(this), 100); return false; &#125; else if (checkTalkBean.getStatus() &#x3D;&#x3D; 3 || checkTalkBean.getStatus() &#x3D;&#x3D; 2) &#123; Hb.a(Hb.f11628c, &quot;你已将对方拉黑，无法发送消息&quot;, 0, 2, (Object) null); ChatLayout chatLayout2 &#x3D; (ChatLayout) k(R$id.chatLayout); i.a((Object) chatLayout2, &quot;chatLayout&quot;); InputLayout inputLayout &#x3D; chatLayout2.getInputLayout(); i.a((Object) inputLayout, &quot;chatLayout.inputLayout&quot;); inputLayout.getInputText().setText(&quot;&quot;); return false; &#125; else if (checkTalkBean.getStatus() !&#x3D; 1) &#123; return true; &#125; else &#123; Hb.a(Hb.f11628c, &quot;对方已将你拉黑，无法发送消息&quot;, 0, 2, (Object) null); ChatLayout chatLayout3 &#x3D; (ChatLayout) k(R$id.chatLayout); i.a((Object) chatLayout3, &quot;chatLayout&quot;); InputLayout inputLayout2 &#x3D; chatLayout3.getInputLayout(); i.a((Object) inputLayout2, &quot;chatLayout.inputLayout&quot;); inputLayout2.getInputText().setText(&quot;&quot;); return false; &#125; &#125;&#125; 通过objection判断ChatActivity源码实现 1234objection -g com.caratlover explore -P ~&#x2F;.objection&#x2F;pluginsandroid hooking search classes ChatActivityplugin wallbreaker classdump --fullname com.chanson.business.message.activity.ChatActivityandroid hooking watch class_method com.chanson.business.message.activity.ChatActivity.Z --dump-args --dump-backtrace --dump-return 每次Z()返回true自然进不了发送消息逻辑，主动调用Z()返回false，破解vip 1234567891011121314function hookVIP()&#123; Java.perform(function()&#123; Java.use(&quot;com.chanson.business.message.activity.ChatActivity&quot;).Z.implementation &#x3D; function()&#123; console.log(&quot;Calling isVIP &quot;) return false; &#125; &#125;) &#125;function main()&#123; console.log(&quot;Start hook&quot;) hookVIP()&#125;setImmediate(main) 抓包Postern配置代理，其中192.168.0.107是charles主机ip，8889是charles的socks 配置规则 遇到8668端口抓不到，报错SSL：Unsupported or unrecognized SSL message,修改charles的Proxy Settings 盲猜一波是base64加密 1python r0capture.py -U -f com.caratlover -v -w 2 &gt;&gt; capture.txt 抓包发现都被加密，类被混淆的非常厉害，虽然无法识别类的作用，我们可以有通过trace去跟踪调用返回值 找到登录包/auth/login-check,其调用栈中at com.chanson.common.a.j.intercept(SourceFile:45) 通过jadx查看com.chanson.common.a.j方法，其中com.chanson.common.utils.a.b将传入的jsonObject转成string后调用c方法。 12frida -U -f com.caratlover -l trace.js --no-pause -o traffic.txt 修改trace的classtraceClass(&quot;com.chanson.common.utils.a.b&quot;) Error: java.lang.ClassNotFoundException: Didn’t find class “com.chanson.common.utils.a.b” 报错是因为app启动还要时间，修改setTimeout(main, 2000); trace登录,先打开登录界面，输入密码后frida -U com.caratlover -l r0tracer.js --no-pause -o traffic.txt 大量的加密字段类似base64，尝试trace Base64。修改traceClass(&quot;android.util.Base64&quot;)，开启trace，frida -U com.caratlover -l r0tracer.js --no-pause -o base64.txt追查调用栈 通过jadx查看com.chanson.common.a.d,其中String a2 = a.a(string, &quot;f87210e0ed3079d8&quot;);的a方法跳转到实现发现是一个完整的标准aes加密。 全局搜索还有AESUtils，完全自己开发的非标准的AES加密，7z x com.caratlover.apk 查看lib/armeabi-v7a下存在alicomphonenumberauthsdk-log-online-standard-release_alijtca_plus.so strings查看该so中的字符串，traceClass(&quot;com.mobile.auth.gatewayauth.utils.security.CheckRoot&quot;) 对抗更新123adb connect 172.20.103.172 启动wifiadbadb install com.caratlover4.1.0.apkfrida -UF -l hookEvent.js 点击马上更新按钮，触发点击时间，打印点击类 打开jadx逐个查看脱完壳后的dex文件，新版本的jadx对加密后的dex反编译结果会rename 查看ConfirmDialogFragment类，其中有 1234public &#x2F;* synthetic *&#x2F; void onDestroyView() &#123; super.onDestroyView(); g();&#125; 主动调用去除弹窗frida -UF -l disableUPDATE.js 再destory 1234567891011121314151617181920function disableUPDATE()&#123; Java.perform(function()&#123; Java.choose(&quot;com.chanson.business.widget.ConfirmDialogFragment&quot;,&#123; onMatch:function(ins)&#123; &#x2F;&#x2F; 动态方法choose onMatch找到实例进行调用 console.log(&quot;found ins &#x3D;&gt; &quot;,ins); &#x2F;&#x2F; smali或objection看真实方法名 ins.onDestroyView() &#125;, onComplete:function()&#123; console.log(&quot;Search completed!&quot;) &#125; &#125;) &#125;)&#125;function main()&#123; console.log(&quot;Start hook&quot;) disableUPDATE()&#125;setImmediate(main) ![GIF 2021-6-3 16-37-29](克拉恋人会员制取证分析/GIF 2021-6-3 16-37-29.gif) 不过页面无法操作,尝试直接跳到MainActivity 12objection -g com.caratlover explore -P ~&#x2F;.objection&#x2F;pluginsandroid intent launch_activity com.chanson.business.MainActivity tracefrida -U -f com.caratlover -l r0trace.js --runtime=v8 --no-pause -o trace.txt 在traceClass中添加targets = []; 只hook构造函数，点击马上更新 12traceClass(&quot;com.chanson.business.widget.ConfirmDialogFragment&quot;)setTimeout(main, 1000); setImmediate是立即执行函数，setTimeout是等待毫秒后延迟执行函数二者在attach模式下没有区别在spawn模式下，hook系统API时如javax.crypto.Cipher建议使用setImmediate立即执行，不需要延时在spawn模式下，hook应用自己的函数或含壳时，建议使用setImmediate并给出适当的延时(500~5000) 找到com.chanson.business.login.presenter.PhoneLoginPresenter$a.a实现方法 找到a方法的调用处，在switch的baseResponse.getErrorCode()的判断时调用PhoneLoginPresenter.f10498a.a,其中renamed from: com.chanson.business.g.s正是我们trace得到的类 12traceClass(&quot;com.chanson.common.base.BaseResponse&quot;) setTimeout(main, 1000); 尝试tracecom.chanson.common.base.BaseResponse查看getErrorCode的结果，返回10002，正巧会调用PhoneLoginPresenter.f10498a.a((Update) rVar.a(rVar.a(baseResponse.getUpdate()), Update.class)); 使用新版本的apk启动时重新tracecom.chanson.common.base.BaseResponse查看正常情况下case返回的值为10001。 12345Java.use(&quot;com.chanson.common.base.BaseResponse&quot;).getErrorCode.implementation &#x3D; function()&#123; console.log(&quot;Calling getErrorCode &quot;) return 10001;&#125;setTimeout(main,2000) &#x2F;&#x2F; 壳的切换需要时间 frida -U -f com.caratlover -l disableUPDATE.js --no-pausehook getErrorCode直接返回10001，发现正常进入登录，登录时发现我们检测到你的账号存在异常数据，为确保你的账号安全，请重新登录,r0capture抓包发现对版本号进行了校验，接下来将SSLOutputStream的入参改成新版本 1234567891011121314151617181920212223Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (bytearry, int1, int2) &#123; for(var i &#x3D; 0; i &lt; bytearry.length; ++i)&#123; &#x2F;&#x2F; Memory.writeS8(ptr.add(i), array[i]); if(bytearry[i]&#x3D;&#x3D;&#39;0x34&#39;)&#123; console.log(&quot;found 4&quot;); if(bytearry.length - i &gt; 4)&#123; if(bytearry[i+1] &#x3D;&#x3D; &#39;0x2e&#39; &amp;&amp; bytearry[i+2] &#x3D;&#x3D; &#39;0x31&#39; &amp;&amp; bytearry[i+3] &#x3D;&#x3D; &#39;0x2e&#39; &amp;&amp; bytearry[i+4] &#x3D;&#x3D; &#39;0x30&#39; )&#123; bytearry[i+2] &#x3D; 50 console.log(&quot;finally change to 4.2.0!&quot;) &#125; &#125; &#x2F;&#x2F; 4.1.0 字符串转16进制转 0x34 0x2e 0x31 0x2e 0x30 &#125; &#125; var result &#x3D; this.write(bytearry, int1, int2); jhexdump(bytearry) &#x2F;&#x2F; var trafficstring &#x3D; StringClass.$new(bytearry).replace(StringClass.$new(&quot;4.1.0&quot;),StringClass.$new(&quot;4.2.0&quot;)) &#x2F;&#x2F; console.log(&quot;write &#x3D;&gt; &quot;,trafficstring) &#x2F;&#x2F; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()).toString(); &#x2F;&#x2F; var result &#x3D; this.write(trafficstring.getBytes(), int1, int2); return result;&#125; 批量撩妹jadx-gui查看新版本依旧加壳 1234567.&#x2F;fs14216arm64pyenv local 3.9.0git clone https:&#x2F;&#x2F;github.com&#x2F;hanbinglengyue&#x2F;FART.gitadb push frida_fart&#x2F;lib&#x2F;fart* &#x2F;data&#x2F;local&#x2F;tmpadb shell &amp;&amp; cp fart* &#x2F;data&#x2F;app &amp;&amp; chmod 777frida -U -f com.caratlover -l frida_fart_hook.js --no-pause 使用安卓8和安卓8.1进行脱壳mv ..&#x2F;*.dex carat &amp;&amp; adb pull &#x2F;sdcard&#x2F;carat 开启内存漫游 1234pyenv local 3.8.0.&#x2F;fs128arm64objection -g com.caratlover exploreandroid intent launch_activity com.chanson.business.MainActivity 直接绕过强制会员购买页面 将破解vip添加在r0trace的main中执行一次，实现trace某一个类时执行单次hook 123456789101112function main() &#123; Java.perform(function () &#123; console.warn(&quot;r0tracer begin ... !&quot;) Java.perform(function()&#123; Java.use(&quot;com.chanson.business.message.activity.ChatActivity&quot;).Z.implementation &#x3D; function()&#123; console.log(&quot;Calling isVIP &quot;) return false; &#125; &#125;) &#125;)&#125; frida -UF -l hookEvent.js 点击发送消息，触发com.tencent.qcloud.tim.uikit.modules.chat.layout.input.InputLayout`，并弹窗要求付费，我们尝试trace该类的同时并破解vip 12345678910111213function main() &#123; Java.perform(function () &#123; console.warn(&quot;r0tracer begin ... !&quot;) traceClass(&quot;com.tencent.qcloud.tim.uikit.modules.chat.layout.input.InputLayout&quot;); Java.perform(function()&#123; Java.use(&quot;com.chanson.business.message.activity.ChatActivity&quot;).Z.implementation &#x3D; function()&#123; console.log(&quot;Calling isVIP &quot;) return false; &#125; &#125;) &#125;)&#125; frida -UF -l r0tracer.js --no-pause &gt; chat.txt 开启trace,只有frida12 没有runtime=v8的选项，发送消息，查看调用栈 在jadx中找到InputLayout的onClick方法 尝试traceClass(&quot;com.tencent.qcloud.tim.uikit.modules.message.MessageInfoUtil&quot;) 1234567891011121314function main() &#123; Java.perform(function () &#123; console.warn(&quot;r0tracer begin ... !&quot;) traceClass(&quot;com.tencent.qcloud.tim.uikit.modules.message.MessageInfoUtil&quot;) Java.perform(function()&#123; Java.use(&quot;com.chanson.business.message.activity.ChatActivity&quot;).Z.implementation &#x3D; function()&#123; console.log(&quot;Calling isVIP &quot;) return false; &#125; &#125;) &#125;)&#125; frida -UF -l r0tracer.js --no-pause &gt; chat.txt 开启trace，再次发送消息,搜索我们发送的ccccdddd 通过jadx找到com.tencent.qcloud.tim.uikit.modules.message.MessageInfoUtil的buildTextMessage方法 想办法获取MessageInfo返回值的内容 1234567891011121314function main() &#123; Java.perform(function () &#123; console.warn(&quot;r0tracer begin ... !&quot;) traceClass(&quot;com.tencent.qcloud.tim.uikit.modules.message.MessageInfo&quot;) Java.perform(function()&#123; Java.use(&quot;com.chanson.business.message.activity.ChatActivity&quot;).Z.implementation &#x3D; function()&#123; console.log(&quot;Calling isVIP &quot;) return false; &#125; &#125;) &#125;)&#125; frida -UF -l r0tracer.js --no-pause &gt; chat.txt 开启trace，再次发送消息tttttttt,搜索tttttttt Inspecting Fields: =&gt; true =&gt; class com.tencent.qcloud.tim.uikit.modules.message.MessageInfocom.tencent.imsdk.TIMMessage TIMMessage =&gt; TIMMessage{ ConverstaionType:Invalid ConversationId: MsgId:2148258574 MsgSeq:32779 Rand:2148258574 time:1614087810 isSelf:true Status:Sending Sender:klover1_server_550179 elements:[ {Type:Text, Content:tttttttt} ]} =&gt; “&lt;instance: com.tencent.imsdk.TIMMessage&gt;”java.lang.String dataPath =&gt; null =&gt; nullandroid.net.Uri dataUri =&gt; null =&gt; nullcom.tencent.imsdk.TIMElem element =&gt; com.tencent.imsdk.TIMTextElem@7d67029 =&gt; “&lt;instance: com.tencent.imsdk.TIMElem, $className: com.tencent.imsdk.TIMTextElem&gt;”java.lang.Object extra =&gt; tttttttt =&gt; “&lt;instance: java.lang.Object, $className: java.lang.String&gt;”java.lang.String fromUser =&gt; klover1_server_550179 =&gt; “klover1_server_550179”boolean group =&gt; false =&gt; falsejava.lang.String groupNameCard =&gt; null =&gt; nulljava.lang.String id =&gt; 70b42de0-097a-4b9c-927d-13e660ce86a6 =&gt; “70b42de0-097a-4b9c-927d-13e660ce86a6”int imgHeight =&gt; 0 =&gt; 0int imgWidth =&gt; 0 =&gt; 0long msgTime =&gt; 1614087810 =&gt; “1614087810”int msgType =&gt; 0 =&gt; 0boolean peerRead =&gt; false =&gt; falseboolean read =&gt; true =&gt; trueboolean self =&gt; true =&gt; trueint status =&gt; 1 =&gt; 1long uniqueId =&gt; 0 =&gt; “0”int MSG_STATUS_DELETE =&gt; 274 =&gt; 274int MSG_STATUS_DOWNLOADED =&gt; 6 =&gt; 6int MSG_STATUS_DOWNLOADING =&gt; 4 =&gt; 4int MSG_STATUS_NORMAL =&gt; 0 =&gt; 0int MSG_STATUS_READ =&gt; 273 =&gt; 273int MSG_STATUS_REVOKE =&gt; 275 =&gt; 275int MSG_STATUS_SENDING =&gt; 1 =&gt; 1int MSG_STATUS_SEND_FAIL =&gt; 3 =&gt; 3int MSG_STATUS_SEND_SUCCESS =&gt; 2 =&gt; 2int MSG_STATUS_UN_DOWNLOAD =&gt; 5 =&gt; 5int MSG_TYPE_AUDIO =&gt; 48 =&gt; 48int MSG_TYPE_CUSTOM =&gt; 128 =&gt; 128int MSG_TYPE_CUSTOM_FACE =&gt; 112 =&gt; 112int MSG_TYPE_FILE =&gt; 80 =&gt; 80int MSG_TYPE_GROUP_CREATE =&gt; 257 =&gt; 257int MSG_TYPE_GROUP_DELETE =&gt; 258 =&gt; 258int MSG_TYPE_GROUP_JOIN =&gt; 259 =&gt; 259int MSG_TYPE_GROUP_KICK =&gt; 261 =&gt; 261int MSG_TYPE_GROUP_MODIFY_NAME =&gt; 262 =&gt; 262int MSG_TYPE_GROUP_MODIFY_NOTICE =&gt; 263 =&gt; 263int MSG_TYPE_GROUP_QUITE =&gt; 260 =&gt; 260int MSG_TYPE_IMAGE =&gt; 32 =&gt; 32int MSG_TYPE_LOCATION =&gt; 96 =&gt; 96int MSG_TYPE_MIME =&gt; 1 =&gt; 1int MSG_TYPE_TEXT =&gt; 0 =&gt; 0int MSG_TYPE_TIPS =&gt; 256 =&gt; 256int MSG_TYPE_VIDEO =&gt; 64 =&gt; 64[native function h() { [native code]} =&gt; undefined =&gt; undefined entered com.tencent.qcloud.tim.uikit.modules.message.MessageInfo.getTIMMessagejava.lang.Throwable at com.tencent.qcloud.tim.uikit.modules.message.MessageInfo.getTIMMessage(Native Method) at com.tencent.qcloud.tim.uikit.modules.chat.base.ChatManagerKit.sendMessage(SourceFile:11) 主要逻辑在this.mCurrentConversation.sendMessage，进入sendMessage方法 进入conversation.sendMessage方法 具体流程在native层，使用的是腾讯云sdk，很难抓到包，不过可以在com.tencent.qcloud.tim.uikit.modules.message.MessageInfoUtil.buildTextMessage构造消息体 123456android heap search instances com.tencent.imsdk.TIMManager android hooking list class_methods com.tencent.imsdk.TIMManagerandroid heap execute 227890024 getLoginUser 根据堆中的实例主动调用方法android heap execute 227890024 getVersionandroid hooking search classes TIMConversationandroid hooking list class_methods com.tencent.imsdk.TIMConversation trace单个函数在r0trace中添加 123if(targetMethod.toString().indexOf(&quot;getConversation&quot;) &lt; 0)&#123; return&#125; 查看腾讯云官方文档文档中心 &gt; 即时通信 IM &gt; SDK 文档 &gt; 旧版 API 教程 &gt; 消息收发 &gt; 消息收发（Android）,获取会话由 TIMManager 中的 getConversation 实现。 1234567891011121314151617function TIMManager() &#123; Java.perform(function () &#123; Java.choose(&quot;com.tencent.imsdk.TIMManager&quot;, &#123; onMatch: function (ins) &#123; console.log(&quot;found ins &#x3D;&gt; &quot;, ins) console.log(&quot;found ins.getNetworkStatus() &#x3D;&gt; &quot;, ins.getNetworkStatus()) console.log(&quot;found ins.getSdkConfig() &#x3D;&gt; &quot;, ins.getSdkConfig()) console.log(&quot;found ins.getUserConfig() &#x3D;&gt; &quot;, ins.getUserConfig()) &#x2F;&#x2F;看不到内容可以通过r0trace的inspectObject单独看 var output &#x3D; &quot;&quot;; output &#x3D; inspectObject(ins.getUserConfig(), output); console.log(output) &#125;, onComplete: function () &#123; console.log(&quot;search compeled&quot;) &#125; &#125;) &#125;)&#125; 尝试trace腾讯云sdk,frida -UF -l r0tracer.js --no-pause -o chat.txt,重新进入聊天界面获取log中的peer，即用户id 12345678910111213function main() &#123; Java.perform(function () &#123; console.warn(&quot;r0tracer begin ... !&quot;) traceClass(&quot;com.tencent.imsdk.TIMManager&quot;) Java.perform(function()&#123; Java.use(&quot;com.chanson.business.message.activity.ChatActivity&quot;).Z.implementation &#x3D; function()&#123; console.log(&quot;Calling isVIP &quot;) return false; &#125; &#125;) &#125;)&#125; 有了peer就可以调用TIMManager.getInstance().getConversation的sendMessage发送消息了 1234567891011121314151617181920212223242526272829303132333435363738394041function TIMManager() &#123; Java.perform(function () &#123; Java.choose(&quot;com.tencent.imsdk.TIMManager&quot;, &#123; onMatch: function (ins) &#123; console.log(&quot;found ins &#x3D;&gt; &quot;, ins) console.log(&quot;found ins.getNetworkStatus() &#x3D;&gt; &quot;, ins.getNetworkStatus()) console.log(&quot;found ins.getSdkConfig() &#x3D;&gt; &quot;, ins.getSdkConfig()) &#x2F;&#x2F; console.log(&quot;found ins.getUserConfig() &#x3D;&gt; &quot;, ins.getUserConfig()) 看不到内容可以通过r0trace的inspectObject单独看 &#x2F;&#x2F; var output &#x3D; &quot;&quot;; &#x2F;&#x2F; output &#x3D; inspectObject(ins.getUserConfig(), output); &#x2F;&#x2F; console.log(output) var peer &#x3D; Java.use(&#39;java.lang.String&#39;).$new(&quot;klover1_server_190249&quot;); &#x2F;&#x2F; 这就是peer用户id var conversation &#x3D; ins.getConversation(Java.use(&quot;com.tencent.imsdk.TIMConversationType&quot;).C2C.value, peer); var msg &#x3D; Java.use(&quot;com.tencent.imsdk.TIMMessage&quot;).$new(); &#x2F;&#x2F;添加文本内容 var elem &#x3D; Java.use(&quot;com.tencent.imsdk.TIMTextElem&quot;).$new(); elem.setText(Java.use(&quot;java.lang.String&quot;).$new(&quot;cpdd&quot;)); msg.addElement(elem) const callback &#x3D; Java.registerClass(&#123; &#x2F;&#x2F; new 一个接口 name: &#39;callback&#39;, implements: [Java.use(&quot;com.tencent.imsdk.TIMValueCallBack&quot;)], methods: &#123; onError(code, desc) &#123; console.log(&quot;send message failed. code: &quot; + code + &quot; errmsg: &quot; + desc); &#125;, onSuccess(msg) &#123;&#x2F;&#x2F;发送消息成功 console.log(&quot;SendMsg ok&quot; + msg); &#125;, &#125; &#125;); conversation.sendMessage(msg, callback.$new()) &#125;, onComplete: function () &#123; console.log(&quot;search compeled&quot;) &#125; &#125;) &#125;)&#125; 以上实现了sdk中完整的发送消息的流程 调用批量发送 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function TIMManager() &#123; Java.perform(function () &#123; Java.choose(&quot;com.tencent.imsdk.TIMManager&quot;, &#123; onMatch: function (ins) &#123; console.log(&quot;found ins &#x3D;&gt; &quot;, ins) console.log(&quot;found ins.getNetworkStatus() &#x3D;&gt; &quot;, ins.getNetworkStatus()) console.log(&quot;found ins.getSdkConfig() &#x3D;&gt; &quot;, ins.getSdkConfig()) &#x2F;&#x2F; console.log(&quot;found ins.getUserConfig() &#x3D;&gt; &quot;, ins.getUserConfig()) 看不到内容可以通过r0trace的inspectObject单独看 &#x2F;&#x2F; var output &#x3D; &quot;&quot;; &#x2F;&#x2F; output &#x3D; inspectObject(ins.getUserConfig(), output); &#x2F;&#x2F; console.log(output) console.log(&quot;found ins.getConversationList() &#x3D;&gt; &quot;, ins.getConversationList()) console.log(&quot;found ins.getConversationList() &#x3D;&gt; &quot;, ins.getConversationList().toString()) console.log(&quot;found ins.getConversationList() &#x3D;&gt; &quot;, JSON.stringify(ins.getConversationList())) var iter &#x3D; ins.getConversationList().listIterator(); while (iter.hasNext()) &#123; console.log(iter.next()); if (iter.next() !&#x3D; null) &#123; var TIMConversation &#x3D; Java.cast(iter.next(), Java.use(&quot;com.tencent.imsdk.TIMConversation&quot;)) console.log(TIMConversation.getPeer()); &#x2F;&#x2F; if (TIMConversation.getPeer().toString().indexOf(&quot;209509&quot;) &gt;&#x3D; 0) &#123; console.log(&quot;try send message...&quot;) &#x2F;&#x2F;构造一条消息 var msg &#x3D; Java.use(&quot;com.tencent.imsdk.TIMMessage&quot;).$new(); &#x2F;&#x2F;添加文本内容 var elem &#x3D; Java.use(&quot;com.tencent.imsdk.TIMTextElem&quot;).$new(); elem.setText(&quot;cpdd 你是唯一 问我是谁 codewj&quot;); &#x2F;&#x2F;将elem添加到消息 msg.addElement(elem) const callback &#x3D; Java.registerClass(&#123; name: &#39;com.tencent.imsdk.TIMValueCallBackCallback&#39;, implements: [Java.use(&quot;com.tencent.imsdk.TIMValueCallBack&quot;)], methods: &#123; onError(i, str) &#123; console.log(&quot;send message failed. code: &quot; + i + &quot; errmsg: &quot; + str) &#125;, onSuccess(msg) &#123; console.log(&quot;SendMsg ok&quot;, +msg) &#125; &#125; &#125;); &#x2F;&#x2F;发送消息 TIMConversation.sendMessage(msg, callback.$new()) &#125; &#125; &#125;, onComplete: function () &#123; console.log(&quot;search compeled&quot;) &#125; &#125;) &#125;)&#125; var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"haydream收费直播间的取证分析","slug":"haydream收费直播间的取证分析","date":"2021-05-29T03:49:08.000Z","updated":"2021-12-12T03:09:39.284Z","comments":true,"path":"2021/05/29/haydream收费直播间的取证分析/","link":"","permalink":"http://onejane.github.io/2021/05/29/haydream%E6%94%B6%E8%B4%B9%E7%9B%B4%E6%92%AD%E9%97%B4%E7%9A%84%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 脱壳 1234567git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;FRIDA-DEXDump.git.&#x2F;fs1280arm64pyenv local 3.8.0python main.py app保持最前端,开始脱壳python merge_dex.py .&#x2F;com.hay.dreamlover&#x2F; livedex 将脱壳后的dex反编译成java，推荐！！！git clone https:&#x2F;&#x2F;github.com&#x2F;Simp1er&#x2F;AndroidSec.git python dex2apk.py -a haydream.apk -i .&#x2F;com.hay.dreamlover -o output.apk 将脱壳后的dex重打包成apk 抓包charles-postern连接socks5启动vpn 发现任何一个页面只要连接代理或者vpn都无法访问请求 某抢票app逆向续篇之干掉vpn抓包检测 api有java.net.NetworkInterface.getName(),android.net.ConnectivityManager 1234567891011objection -g com.hay.dreamlover exploreandroid hooking search classes networkinterfaceandroid hooking watch class java.net.NetworkInterfaceandroid hooking search classes connectivitymanagerandroid hooking watch class android.net.ConnectivityManagerandroid hooking watch class android.net.IConnectivityManager 进入页面后果然触发了这些方法，说明确实做了vpn检测android hooking watch class_method android.net.ConnectivityManager.getActiveNetworkInfo --dump-args --dump-backtrace --dump-return 打印调用栈，通过jadx查看LiveNetChecker,尝试使用frida脚本过这段代码逻辑git clone https:&#x2F;&#x2F;github.com&#x2F;r0ysue&#x2F;r0capture.gitpython3 r0capture.py -U com.hay.dreamlover -v 先打开app后attach，log显示127.0.0.1和127.0.0.1通信，且所有内容都已经加密frida -U -f com.hay.dreamlover -l script.js -o out.txtpython3 r0capture.py -U com.hay.dreamlover -v -w 3 延迟3秒 使用带有kali nethunter底包的nexus 6p，开启ssh服务 12345ssh root@192.168.0.104 默认密码toorjnettop 点开直播间，可以看到直播间地址和ip手机自制路由器，电脑插上网卡连接到虚拟机，nm-connection-editor，新加一个Wi-Fi,设置SSID，Mode设置Hotspot,Band设置B&#x2F;G(2.4 GHZ),Device选择wlan0,配置IPv4 Settings的Address,手机即可收到新wifi热点lsusb 查看设备型号wireshark 抓包 收费直播间分析直播弹窗倒计时9s后强制退出 1234567objection -g com.hay.dreamlover exploreandroid hooking search classes Dialogandroid hooking search classes AlertDialogandroid hooking search classes PopupWindowandroid hooking watch class android.app.Dialog --dump-args --dump-backtrace --dump-returnandroid hooking watch class android.app.AlertDialog --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method android.app.Dialog.show --dump-args --dump-backtrace --dump-return (agent) [8z3ukmteu2y] Called android.app.Dialog.show()(agent) [8z3ukmteu2y] Backtrace: android.app.Dialog.show(Native Method) com.fanwe.lib.dialog.impl.SDDialogBase.show(SDDialogBase.java:337) com.fanwe.live.activity.room.LiveLayoutViewerExtendActivity.showScenePayJoinDialog(LiveLayoutViewerExtendActivity.java:618) com.fanwe.live.activity.room.LiveLayoutViewerExtendActivity.onScenePayViewerShowWhetherJoin(LiveLayoutViewerExtendActivity.java:516) com.fanwe.pay.LiveScenePayViewerBusiness.dealPayModelRoomInfoSuccess(LiveScenePayViewerBusiness.java:156) com.fanwe.live.activity.room.LiveLayoutViewerExtendActivity.onBsRequestRoomInfoSuccess(LiveLayoutViewerExtendActivity.java:111) com.fanwe.live.activity.room.LivePushViewerActivity.onBsRequestRoomInfoSuccess(LivePushViewerActivity.java:405) com.fanwe.live.business.LiveBusiness.onRequestRoomInfoSuccess(LiveBusiness.java:306) com.fanwe.live.business.LiveViewerBusiness.onRequestRoomInfoSuccess(LiveViewerBusiness.java:79) com.fanwe.live.business.LiveBusiness$2.onSuccess(LiveBusiness.java:257) com.fanwe.library.adapter.http.callback.SDRequestCallback.onSuccessInternal(SDRequestCallback.java:127) com.fanwe.library.adapter.http.callback.SDRequestCallback.notifySuccess(SDRequestCallback.java:175) com.fanwe.hybrid.http.AppHttpUtil$1.onSuccess(AppHttpUtil.java:105) com.fanwe.hybrid.http.AppHttpUtil$1.onSuccess(AppHttpUtil.java:74) org.xutils.http.HttpTask.onSuccess(HttpTask.java:447) org.xutils.common.task.TaskProxy$InternalHandler.handleMessage(TaskProxy.java:198) android.os.Handler.dispatchMessage(Handler.java:106) android.os.Looper.loop(Looper.java:164) android.app.ActivityThread.main(ActivityThread.java:6494) java.lang.reflect.Method.invoke(Native Method) com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438) com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807) (agent) [8z3ukmteu2y] Return Value: (none) frida -UF -l trace.js -o hay.txt 打印了多个android.app.Dialog.show 1traceClass(&quot;android.app.Dialog&quot;) 结合jadx分析弹窗堆栈，实现逻辑可以干掉弹窗或者干掉倒计时 1234android hooking search methods startCountDownandroid hooking watch class com.fanwe.pay.appview.PayLiveBlackBgView 进入直播间确实触发了该方法android hooking watch class_method com.fanwe.pay.appview.PayLiveBlackBgView.startCountDown --dump-args --dump-backtrace --dump-return android hooking list class_methods com.fanwe.lib.dialog.impl.SDDialogBase frida -UF -l hookVIP.js 破解收费直播间 1234567891011121314setImmediate(function()&#123; Java.perform(function()&#123; console.log(&quot;Entering hook&quot;) &#x2F;&#x2F; 干掉弹窗 Java.use(&quot;com.fanwe.lib.dialog.impl.SDDialogBase&quot;).show.implementation &#x3D; function()&#123; console.log(&quot;hook show &quot;) &#125; &#x2F;&#x2F; 设置倒计时 Java.use(&quot;com.fanwe.pay.appview.PayLiveBlackBgView&quot;).startCountDown.implementation &#x3D; function(x)&#123; console.log(&quot;Calling countdown &quot;) return this.startCountDown(1000*3600) &#125; &#125;)&#125;) 在 com.fanwe.live.business.LiveBusiness.onRequestRoomInfoSuccess类中大部分request都来自于CommonInterface类 123456android hooking watch class com.fanwe.live.common.CommonInterface 每进一个房间或下拉自动触发该类的方法android hooking watch class_method com.fanwe.live.common.CommonInterface.requestIndex --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method com.fanwe.live.common.CommonInterface.requestRoomInfo --dump-args --dump-backtrace --dump-return 进入直播间，log打印room_idplugin wallbreaker classdump --fullname com.fanwe.live.business.LiveBusiness$2android hooking search classes com.fanwe.live.business.LiveBusinessandroid hooking watch class com.fanwe.live.business.LiveBusiness (agent) [2xhzmmkxx1r] Called com.fanwe.live.common.CommonInterface.requestIndex(int, int, int, java.lang.String, com.fanwe.hybrid.http.AppRequestCallback) (agent) [2xhzmmkxx1r] Backtrace: com.fanwe.live.common.CommonInterface.requestIndex(Native Method) com.fanwe.live.appview.main.LiveTabHotView.requestData(LiveTabHotView.java:390) com.fanwe.live.appview.main.LiveTabHotView.onLoopRun(LiveTabHotView.java:382) com.fanwe.live.appview.main.LiveTabBaseView$1.run(LiveTabBaseView.java:116) com.fanwe.lib.looper.impl.SDSimpleLooper$1.handleMessage(SDSimpleLooper.java:54) android.os.Handler.dispatchMessage(Handler.java:106) android.os.Looper.loop(Looper.java:164) android.app.ActivityThread.main(ActivityThread.java:6494) java.lang.reflect.Method.invoke(Native Method) com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438) com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807) (agent) [2xhzmmkxx1r] Arguments com.fanwe.live.common.CommonInterface.requestIndex(1, (none), (none), 热门, com.fanwe.live.appview.main.LiveTabHotView$4@89cbef4)(agent) [2xhzmmkxx1r] Return Value: (none) 123android hooking search classes SDResponseplugin wallbreaker classdump --fullname com.fanwe.library.adapter.http.model.SDResponseandroid hooking watch class_method com.fanwe.library.adapter.http.model.SDResponse.getDecryptedResult --dump-args --dump-backtrace --dump-return frida -UF -l requestIndex.js 主动调用获取房间列表和详情 123456789101112131415161718192021222324252627282930313233343536373839404142434445function hook() &#123; Java.perform(function () &#123; var JSON &#x3D; Java.use(&quot;com.alibaba.fastjson.JSON&quot;) var Index_indexActModel &#x3D; Java.use(&quot;com.fanwe.live.model.Index_indexActModel&quot;); var gson &#x3D; Java.use(&quot;com.google.gson.Gson&quot;).$new(); var LiveRoomModel &#x3D; Java.use(&quot;com.fanwe.live.model.LiveRoomModel&quot;); Java.use(&quot;com.fanwe.live.appview.main.LiveTabHotView$4&quot;).onSuccess.implementation &#x3D; function (resp) &#123; console.log(&quot;Entering Room List Parser &#x3D;&gt; &quot;, resp) var result &#x3D; resp.getDecryptedResult(); &#x2F;&#x2F; 转成json对象 var resultModel &#x3D; JSON.parseObject(result, Index_indexActModel.class); &#x2F;&#x2F; json转成java对象，并调用getList方法 var roomList &#x3D; Java.cast(resultModel, Index_indexActModel).getList(); console.log(&quot;size : &quot;, roomList.size(), roomList.get(0)) for (var i &#x3D; 0; i &lt; roomList.size(); i++) &#123; var LiveRoomModelInfo &#x3D; Java.cast(roomList.get(i), LiveRoomModel); console.log(&quot;roominfo: &quot;, i, &quot; &quot;, gson.toJson(LiveRoomModelInfo)); &#125; return this.onSuccess(resp) &#125; &#125;)&#125;&#x2F;&#x2F; 主动调用function invoke()&#123; Java.perform(function()&#123; Java.choose(&quot;com.fanwe.live.appview.main.LiveTabHotView&quot;,&#123; onMatch:function(ins)&#123; console.log(&quot;found ins &#x3D;&gt; &quot;,ins) ins.requestData(); &#125;,onComplete:function()&#123; console.log(&quot;Search completed!&quot;) &#125; &#125;) &#125;)&#125;function main() &#123; hook() &#x2F;&#x2F; invoke()&#125;setImmediate(main) frida -UF -l requestRoomInfo.js 1234567891011121314151617181920212223242526272829303132333435363738394041&#x2F;&#x2F; 遍历类所有的域function inspectObject(obj) &#123; Java.perform(function () &#123; const Class &#x3D; Java.use(&quot;java.lang.Class&quot;); const obj_class &#x3D; Java.cast(obj.getClass(), Class); const fields &#x3D; obj_class.getDeclaredFields(); const methods &#x3D; obj_class.getMethods(); console.log(&quot;Inspecting &quot; + obj.getClass().toString()); console.log(&quot;\\tFields:&quot;); for (var i in fields)&#123; &#x2F;&#x2F; console.log(&quot;\\t\\t&quot; + fields[i].toString()); var className &#x3D; obj_class.toString().trim().split(&quot; &quot;)[1] ; &#x2F;&#x2F; console.log(&quot;className is &#x3D;&gt; &quot;,className); var fieldName &#x3D; fields[i].toString().split(className.concat(&quot;.&quot;)).pop() ; console.log(fieldName + &quot; &#x3D;&gt; &quot;,obj[fieldName].value); &#125; &#x2F;&#x2F; console.log(&quot;\\tMethods:&quot;); &#x2F;&#x2F; for (var i in methods) &#x2F;&#x2F; console.log(&quot;\\t\\t&quot; + methods[i].toString()); &#125;)&#125;&#x2F;&#x2F; 打印调用结果的域及信息，类似wallbreakerfunction hookROOMinfo() &#123; Java.perform(function () &#123; var JSON &#x3D; Java.use(&quot;com.alibaba.fastjson.JSON&quot;) var gson &#x3D; Java.use(&quot;com.google.gson.Gson&quot;).$new(); var App_get_videoActModel &#x3D; Java.use(&quot;com.fanwe.live.model.App_get_videoActModel&quot;); Java.use(&quot;com.fanwe.live.business.LiveBusiness$2&quot;).onSuccess.implementation &#x3D; function (resp) &#123; console.log(&quot;Enter LiveBusiness$2 ... &quot;, resp) var result &#x3D; resp.getDecryptedResult(); var resultVideoModel &#x3D; JSON.parseObject(result, App_get_videoActModel.class); var roomDetail &#x3D; Java.cast(resultVideoModel, App_get_videoActModel); console.log(&quot;room id is &#x3D;&gt; &quot;, roomDetail.getRoom_id()); inspectObject(roomDetail); return this.onSuccess(resp); &#125; &#125;)&#125; 当jadx找不到类的时候，说明脱壳没脱全，通过objection去内存即可搜刮wallbreak内存漫游。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&#x2F;&#x2F; 内存中捞不到类function invoke()&#123; Java.perform(function()&#123; Java.choose(&quot;com.fanwe.live.business.LiveBusiness&quot;,&#123; onMatch:function(ins)&#123; console.log(&quot;found ins &#x3D;&gt; &quot;,ins) &#x2F;&#x2F; ins.requestData(); &#125;,onComplete:function()&#123; console.log(&quot;Search completed!&quot;) &#125; &#125;) &#125;)&#125;&#x2F;&#x2F; 自行调用构造函数创建类function invoke2()&#123; Java.perform(function()&#123; &#x2F;&#x2F; com.fanwe.live.business.LiveBusiness(ILiveActivity); var ILiveActivity &#x3D; Java.use(&quot;com.fanwe.live.activity.room.ILiveActivity&quot;); &#x2F;&#x2F; 实现接口 const ILiveActivityImpl &#x3D; Java.registerClass(&#123; name: &#39;com.fanwe.live.activity.room.ILiveActivityImpl&#39;, implements: [ILiveActivity], methods: &#123; openSendMsg()&#123;&#125;, getCreaterId()&#123;&#125;, getGroupId()&#123;&#125;, getRoomId()&#123;&#125;, getRoomInfo()&#123;&#125;, getSdkType()&#123;&#125;, isAuctioning()&#123;&#125;, isCreater()&#123;&#125;, isPlayback()&#123;&#125;, isPrivate()&#123;&#125; &#125; &#125;); var result &#x3D; Java.use(&quot;com.fanwe.live.business.LiveBusiness&quot;).$new(ILiveActivityImpl.$new()); console.log(&quot;result is &#x3D;&gt; &quot;,result.requestRoomInfo(&quot;123454&quot;)) &#125;)&#125;var LiveBusiness &#x3D; null ;console.log(&quot;LiveBusiness is &#x3D;&gt; &quot;, LiveBusiness)function hook3()&#123; Java.perform(function()&#123; Java.use(&quot;com.fanwe.live.business.LiveBusiness&quot;).getLiveQualityData.implementation &#x3D; function()&#123; LiveBusiness &#x3D; this; console.log(&quot;now LiveBusiness is &#x3D;&gt; &quot;, LiveBusiness) LiveBusiness.requestRoomInfo(&quot;12343&quot;); var result &#x3D; this.getLiveQualityData() return result; &#125; &#125;)&#125;function invoke3()&#123; Java.perform(function()&#123; var result &#x3D; LiveBusiness.requestRoomInfo(&quot;12343&quot;); console.log(&quot;result is &#x3D;&gt; &quot;,result) &#125;)&#125;function invoke4()&#123; Java.perform(function()&#123; &#x2F;&#x2F; com.fanwe.live.business.LiveBusiness(ILiveActivity); var ILiveActivity &#x3D; Java.use(&quot;com.fanwe.live.activity.room.ILiveActivity&quot;); const ILiveActivityImpl &#x3D; Java.registerClass(&#123; name: &#39;com.fanwe.live.activity.room.ILiveActivityImpl&#39;, implements: [ILiveActivity], methods: &#123; openSendMsg()&#123;&#125;, getCreaterId()&#123;&#125;, getGroupId()&#123;&#125;, getRoomId()&#123;&#125;, getRoomInfo()&#123;&#125;, getSdkType()&#123;&#125;, isAuctioning()&#123;&#125;, isCreater()&#123;&#125;, isPlayback()&#123;&#125;, isPrivate()&#123;&#125; &#125; &#125;); var LB &#x3D; Java.use(&quot;com.fanwe.live.business.LiveBusiness&quot;).$new(ILiveActivityImpl.$new()); var LB2 &#x3D; Java.use(&quot;com.fanwe.live.business.LiveBusiness$2&quot;); var AppRequestCallback &#x3D; Java.use(&#39;com.fanwe.hybrid.http.AppRequestCallback&#39;); Java.use(&quot;com.fanwe.live.common.CommonInterface&quot;).requestRoomInfo(1377894,123,&quot;1234&quot;,Java.cast(LB2.$new(LB),AppRequestCallback)); &#125;)&#125;function main() &#123; hookROOMinfo(); hook3();&#125;setImmediate(main) 以上hook2时无法返回数据，是因为roomId为空，获取room_id时发现getRoomId来自于一个接口ILiveInfo，可以通过该接口找到实现类，或者通过jadx的smali查看是不是确实为getRoomId。 12android hooking search methods getRoomId 全局搜索方法android hooking watch class_method com.fanwe.live.activity.room.LiveActivity.getRoomId --dump-args --dump-backtrace --dump-return 123456789101112131415161718192021222324252627282930313233343536function hookROOMinfo() &#123; Java.perform(function () &#123; var JSON &#x3D; Java.use(&quot;com.alibaba.fastjson.JSON&quot;) var gson &#x3D; Java.use(&quot;com.google.gson.Gson&quot;).$new(); var App_get_videoActModel &#x3D; Java.use(&quot;com.fanwe.live.model.App_get_videoActModel&quot;); Java.use(&quot;com.fanwe.live.business.LiveBusiness$2&quot;).onSuccess.implementation &#x3D; function (resp) &#123; console.log(&quot;Enter LiveBusiness$2 ... &quot;, resp) var result &#x3D; resp.getDecryptedResult(); var resultVideoModel &#x3D; JSON.parseObject(result, App_get_videoActModel.class); var roomDetail &#x3D; Java.cast(resultVideoModel, App_get_videoActModel); console.log(&quot;room id is &#x3D;&gt; &quot;, roomDetail.getRoom_id()); inspectObject(roomDetail); return this.onSuccess(resp); &#125; &#x2F;&#x2F; 直接主动调用，设置房间号 &#x2F;&#x2F; Java.use(&quot;com.fanwe.live.common.CommonInterface&quot;).requestRoomInfo.implementation &#x3D; function (roomid, vod, key, ins) &#123; &#x2F;&#x2F; console.log(&quot;Calling common.CommonInterface.requestRoomInfo...&quot;) &#x2F;&#x2F; return this.requestRoomInfo(1379212, vod, key, ins); &#x2F;&#x2F; &#125; Java.use(&quot;com.fanwe.live.LiveInformation&quot;).getRoomId.implementation &#x3D; function()&#123; console.log(&quot;calling com.fanwe.live.activity.room.LiveActivity.getRoomId ...&quot;) return 1379212 ; &#125; &#x2F;&#x2F; com.fanwe.live.ILiveInfo.getRoomId &#x2F;&#x2F; com.fanwe.live.LiveInformation.getRoomId &#x2F;&#x2F; com.fanwe.live.activity.room.LiveActivity.getRoomId &#x2F;&#x2F; com.fanwe.live.appview.room.RoomSelectFriendsView.getRoomId &#x2F;&#x2F; com.fanwe.live.model.CreateLiveData.getRoomId &#x2F;&#x2F; com.fanwe.live.model.JoinLiveData.getRoomId &#x2F;&#x2F; com.fanwe.live.model.JoinPlayBackData.getRoomId &#125;)&#125; frida -UF -l rquestRoomInfo.js 再次调用invoke2()实现房间详情抓取 主动调用的原则：离数据越远，中间需要自己实现的细节就越多；哪个细节实现不对，APP就崩掉了。 针对单个类AppHttpUtil找不到，使用fart可以脱单个类 1234567android hooking search classes AppHttpUtilgit clone https:&#x2F;&#x2F;github.com&#x2F;hanbinglengyue&#x2F;FART.gitadb push lib&#x2F;fart* &#x2F;data&#x2F;local&#x2F;tmpadb shell -&gt;cp fart* &#x2F;data&#x2F;app &amp;&amp; chmod 777frida -UF -l frida_fart_reflection.jsdump(&quot;com.fanwe.hybrid.http.AppHttpUtil&quot;)adb pull &#x2F;sdcard&#x2F;6850924_22686.dex 通过jadx-gui打开看不到源码，file 6850924_22686.dex是data格式，而非Dalvik dex格式。通过010 Editor打开该dex发现文件魔术字全是00 00 00 00 00 00 00 00, 查看正常dex文件头为64 65 78 0a 30 33 35 00，再次打开即可找到AppHttpUtil，可以看到拼接参数时用的标准的加密库。 使用沙箱安装该apk后查看/data/data/com.hay.dreamlover的加密文件数据，找到Cipher文件中base64定位加解密的方法。 1android hooking watch class_method com.fanwe.library.utils.MD5Util.MD5 --dump-args --dump-backtrace --dump-return 通过vnc连接kali nethunter后启动wireshark抓包，保存为pcapng格式文件，使用电脑分析，找到最终发出去的包，发现通过本地端口转发出去，获取请求头参数后实现解密 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283## Time: 2020-7-31 19:41:11## com.hay.dreamlover import requests, os, time, sysfrom lxml import etreeimport reimport jsonimport threadingimport hashlibimport base64from urllib import parse# import click# import frida# import logging# import tracebackimport base64import refrom Crypto.Cipher import AES# https:&#x2F;&#x2F;blog.csdn.net&#x2F;wangziyang777&#x2F;article&#x2F;details&#x2F;104982823## aes 加密&#x2F;解密class AESECB: def __init__(self, key): self.key &#x3D; key self.mode &#x3D; AES.MODE_ECB self.bs &#x3D; 16 # block size self.PADDING &#x3D; lambda s: s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs) def encrypt(self, text): generator &#x3D; AES.new(self.key, self.mode) # ECB模式无需向量iv crypt &#x3D; generator.encrypt(self.PADDING(text)) crypted_str &#x3D; base64.b64encode(crypt) result &#x3D; crypted_str.decode() return result def decrypt(self, text): generator &#x3D; AES.new(self.key, self.mode) # ECB模式无需向量iv text +&#x3D; (len(text) % 4) * &#39;&#x3D;&#39; decrpyt_bytes &#x3D; base64.b64decode(text) meg &#x3D; generator.decrypt(decrpyt_bytes) # 去除解码后的非法字符 try: result &#x3D; re.compile(&#39;[\\\\x00-\\\\x08\\\\x0b-\\\\x0c\\\\x0e-\\\\x1f\\n\\r\\t]&#39;).sub(&#39;&#39;, meg.decode()) except Exception: result &#x3D; &#39;解码失败，请重试!&#39; return result#计算密码的md5值def get_md5(s): md &#x3D; hashlib.md5() md.update(s.encode(&#39;utf-8&#39;)) return md.hexdigest()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: aes &#x3D; AESECB(&#39;8648754518945235&#39;) ctl &#x3D; &quot;index&quot; act &#x3D; &quot;index&quot; signqt &#x3D; get_md5(&quot;528094&amp;*3564695()&quot; + ctl + &quot;+_&quot; + act + &quot;@!@###@&quot;); timeqt &#x3D; str(round(time.time() * 1000)); headers &#x3D; &#123;&quot;X-JSL-API-AUTH&quot;:&quot;sha1|1596358731|VOI1X6448Y4f4E|fd941812d5b875b021f92cf2b0044552462d8cd9&quot;&#125;; body &#x3D; &#123;&quot;screen_width&quot;:1080, &quot;screen_height&quot;:1794, &quot;sdk_type&quot;:&quot;android&quot;, &quot;sdk_version_name&quot;:&quot;1.3.0&quot;, &quot;sdk_version&quot;:2020031801, &quot;xpoint&quot;:120.107042, &quot;ypoint&quot;:30.302162, &quot;ctl&quot;:ctl, &quot;act&quot;:&quot;new_video&quot;, &quot;p&quot;:1, &quot;signqt&quot;:signqt, &quot;timeqt&quot;:timeqt&#125; requestData &#x3D; aes.encrypt(str(body)); url &#x3D; &quot;http:&#x2F;&#x2F;hhy2.hhyssing.com:37462&#x2F;mapi&#x2F;index.php?requestData&#x3D;&quot; + requestData + &quot;i_type&#x3D;1&amp;ctl&#x3D;&quot; + ctl + &quot;&amp;act&#x3D;&quot; + act; rsp &#x3D; requests.post(url, headers &#x3D; headers); result &#x3D; json.loads(rsp.text).get(&quot;output&quot;); decodeAes &#x3D; AESECB(&quot;7489148794156147&quot;); print(decodeAes.decrypt(result)); python r0capture.py -U com.hay.dreamlover -v -w 3 &gt;&gt; hay.txt 抓包进出直播间,查看请求 netstat -tuulp|grep hay 查看端口 adb forward tcp:37462 tcp:37462 将给本地发请求包转发到手机端的37462端口 nethunter 中wireshark抓lo包，本地对本地的包，因为app都是对本地请求，再转发到服务端(使用vnc viewer连接) 阿里游戏盾SDK的作用： 防止抓包 隐藏真实的服务器地址，流量包二次 抗D var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"ElasticSearch之搜索引擎结果分析","slug":"ElasticSearch之搜索引擎结果分析","date":"2021-05-25T09:09:09.000Z","updated":"2021-12-12T03:09:39.224Z","comments":true,"path":"2021/05/25/ElasticSearch之搜索引擎结果分析/","link":"","permalink":"http://onejane.github.io/2021/05/25/ElasticSearch%E4%B9%8B%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 _search解析1234567891011121314151617181920212223242526GET &#x2F;_search&#123; &quot;took&quot;: 6, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 6, &quot;successful&quot;: 6, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: 10, &quot;max_score&quot;: 1, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;.kibana&quot;, &quot;_type&quot;: &quot;config&quot;, &quot;_id&quot;: &quot;5.2.0&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;buildNum&quot;: 14695 &#125; &#125; ] &#125;&#125; took：整个搜索请求花费了多少毫秒 hits.total：本次搜索，返回了几条结果hits.max_score：本次搜索的所有结果中，最大的相关度分数是多少，每一条document对于search的相关度，越相关，_score分数越大，排位越靠前hits.hits：默认查询前10条数据，完整数据，_score降序排序 shards：shards fail的条件（primary和replica全部挂掉），不影响其他shard。默认情况下来说，一个搜索请求，会打到一个index的所有primary shard上去，当然了，每个primary shard都可能会有一个或多个replic shard，所以请求也可以到primary shard的其中一个replica shard上去。 timeout：默认无timeout，latency平衡completeness，手动指定timeout，timeout查询执行机制 timeout=10ms，timeout=1s，timeout=1mGET /_search?timeout=10m 搜索模式解析multi-index和multi-type搜索模式 12345678&#x2F;_search：所有索引，所有type下的所有数据都搜索出来&#x2F;index1&#x2F;_search：指定一个index，搜索其下所有type的数据&#x2F;index1,index2&#x2F;_search：同时搜索两个index下的数据&#x2F;*1,*2&#x2F;_search：按照通配符去匹配多个索引&#x2F;index1&#x2F;type1&#x2F;_search：搜索一个index下指定的type的数据&#x2F;index1&#x2F;type1,type2&#x2F;_search：可以搜索一个index下多个type的数据&#x2F;index1,index2&#x2F;type1,type2&#x2F;_search：搜索多个index下的多个type的数据&#x2F;_all&#x2F;type1,type2&#x2F;_search：_all可以代表搜索所有index下的指定type的数据 exact value 2017-01-01，exact value，搜索的时候，必须输入2017-01-01，才能搜索出来，如果你输入一个01，是搜索不出来的 full text（1）缩写 vs. 全程：cn vs. china（2）格式转化：like liked likes（3）大小写：Tom vs tom（4）同义词：like vs love 2017-01-01，2017 01 01，搜索2017，或者01，都可以搜索出来china，搜索cn，也可以将china搜索出来likes，搜索like，也可以将likes搜索出来Tom，搜索tom，也可以将Tom搜索出来like，搜索love，同义词，也可以将like搜索出来 就不是说单纯的只是匹配完整的一个值，而是可以对值进行拆分词语后（分词）进行匹配，也可以通过缩写、时态、大小写、同义词等进行匹配。 倒排索引doc1：I really liked my small dogs, and I think my mom also liked them.doc2：He never liked any dogs, so I hope that my mom will not expect me to liked him. mother like little dog，不可能有任何结果 normalization，建立倒排索引的时候，会执行一个操作，也就是说对拆分出的各个单词进行相应的处理，以提升后面搜索的时候能够搜索到相关联的文档的概率，包括时态的转换，单复数的转换，同义词的转换，大小写的转换。 word doc1 doc2 I * * really * like * * my * * little * dog * * and * think * mom * * also * them * He * never * any * so * hope * that * will * not * expect * me * to * him * 分词器切分词语，normalization（提升recall召回率），将句子拆分成一个一个的单个的单词，同时对每个单词进行normalization（时态转换，单复数转换），分词器。 recall召回率：搜索的时候，增加能够搜索到的结果的数量 123character filter：在一段文本进行分词之前，先进行预处理，比如说最常见的就是，过滤html标签（&lt;span&gt;hello&lt;span&gt; --&gt; hello），&amp; --&gt; and（I&amp;you --&gt; I and you）tokenizer：分词，hello you and me --&gt; hello, you, and, metoken filter：lowercase，stop word，synonymom，dogs --&gt; dog，liked --&gt; like，Tom --&gt; tom，a&#x2F;the&#x2F;an --&gt; 干掉，mother --&gt; mom，small --&gt; little 内置分词器Set the shape to semi-transparent by calling set_trans(5) 1234standard analyzer：set, the, shape, to, semi, transparent, by, calling, set_trans, 5（默认的是standard）simple analyzer：set, the, shape, to, semi, transparent, by, calling, set, transwhitespace analyzer：Set, the, shape, to, semi-transparent, by, calling, set_trans(5)language analyzer（特定的语言的分词器，比如说，english，英语分词器）：set, shape, semi, transpar, call, set_tran, 5 分页搜索es进行分页搜索size，from 1234567GET &#x2F;_search?size&#x3D;10GET &#x2F;_search?size&#x3D;10&amp;from&#x3D;0GET &#x2F;_search?size&#x3D;10&amp;from&#x3D;20GET &#x2F;test_index&#x2F;test_type&#x2F;_search 总共有9条GET &#x2F;test_index&#x2F;test_type&#x2F;_search?from&#x3D;0&amp;size&#x3D;3 将这9条数据分成3页，每一页是3条数据GET &#x2F;test_index&#x2F;test_type&#x2F;_search?from&#x3D;3&amp;size&#x3D;3 GET &#x2F;test_index&#x2F;test_type&#x2F;_search?from&#x3D;6&amp;size&#x3D;3 deep paging query string1234GET &#x2F;test_index&#x2F;test_type&#x2F;_search?q&#x3D;test_field:test 包含GET &#x2F;test_index&#x2F;test_type&#x2F;_search?q&#x3D;+test_field:test 包含GET &#x2F;test_index&#x2F;test_type&#x2F;_search?q&#x3D;-test_field:test 不包含GET &#x2F;test_index&#x2F;test_type&#x2F;_search?q&#x3D;test 直接可以搜索所有的field，任意一个field包含指定的关键字就可以搜索出来 es中的_all元数据，在建立索引的时候，我们插入一条document，它里面包含了多个field，此时，es会自动将多个field的值，全部用字符串的方式串联起来，变成一个长的字符串，作为_all field的值，同时建立索引，后面如果在搜索的时候，没有对某个field指定搜索，就默认搜索_all field，其中是包含了所有field的值的。 123456&#123; &quot;name&quot;: &quot;jack&quot;, &quot;age&quot;: 26, &quot;email&quot;: &quot;jack@sina.com&quot;, &quot;address&quot;: &quot;guamgzhou&quot;&#125; jack 26 jack@sina.com guangzhou，作为这一条document的_all field的值，同时进行分词后建立对应的倒排索引 mapping插入几条数据，让es自动为我们建立一个索引 12345678910111213141516171819202122232425262728PUT &#x2F;website&#x2F;article&#x2F;1&#123; &quot;post_date&quot;: &quot;2017-01-01&quot;, &quot;title&quot;: &quot;my first article&quot;, &quot;content&quot;: &quot;this is my first article in this website&quot;, &quot;author_id&quot;: 11400&#125;PUT &#x2F;website&#x2F;article&#x2F;2&#123; &quot;post_date&quot;: &quot;2017-01-02&quot;, &quot;title&quot;: &quot;my second article&quot;, &quot;content&quot;: &quot;this is my second article in this website&quot;, &quot;author_id&quot;: 11400&#125;PUT &#x2F;website&#x2F;article&#x2F;3&#123; &quot;post_date&quot;: &quot;2017-01-03&quot;, &quot;title&quot;: &quot;my third article&quot;, &quot;content&quot;: &quot;this is my third article in this website&quot;, &quot;author_id&quot;: 11400&#125;GET &#x2F;website&#x2F;article&#x2F;_search?q&#x3D;2017 3条结果 GET &#x2F;website&#x2F;article&#x2F;_search?q&#x3D;2017-01-01 3条结果GET &#x2F;website&#x2F;article&#x2F;_search?q&#x3D;post_date:2017-01-01 1条结果GET &#x2F;website&#x2F;article&#x2F;_search?q&#x3D;post_date:2017 1条结果 dynamic mapping，自动为我们建立index，创建type，以及type对应的mapping，mapping中包含了每个field对应的数据类型，以及如何分词等设置 123456789101112131415161718192021222324252627282930313233343536GET &#x2F;website&#x2F;_mapping&#x2F;article&#123; &quot;website&quot;: &#123; &quot;mappings&quot;: &#123; &quot;article&quot;: &#123; &quot;properties&quot;: &#123; &quot;author_id&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;post_date&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125;, &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 因为es自动建立mapping的时候，设置了不同的field不同的data type。不同的data type的分词、搜索等行为是不一样的。所以出现了_all field和post_date field的搜索表现完全不一样。 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://onejane.github.io/tags/elasticsearch/"}]},{"title":"打造完美逆向和沙箱编译环境","slug":"打造完美逆向和沙箱编译环境","date":"2021-05-22T01:38:12.000Z","updated":"2021-12-12T03:09:39.293Z","comments":true,"path":"2021/05/22/打造完美逆向和沙箱编译环境/","link":"","permalink":"http://onejane.github.io/2021/05/22/%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E9%80%86%E5%90%91%E5%92%8C%E6%B2%99%E7%AE%B1%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 md5校验：CertUtil -hashfile ide-eval-resetter-2.1.13.jar MD5 apt install neofetch 显示系统信息 echo $SHELL 查看终端 pyenv versions pyenv install –list htop jnettop iotop 010 Editor-Template Repository-Executable 选择指定文件格式解析 无限续期： 123先关闭软件：rm -rf ~&#x2F;.config&#x2F;SweetScape&#x2F;rm -rf ~&#x2F;.local&#x2F;share&#x2F;SweetScape&#x2F; 8.1.0_r1 对应代号 OPM1.171019.011 wget https://dl.google.com/dl/android/aosp/bullhead-opm1.171019.011-factory-3be6fd1c.zip ./flush-all.sh 如报错替换fastboot,which fastboot adb push n5x_nethunter /sdcard/ adb reboot bootloader fastboot flash recovery nex_nethunter/twrp-3.3.0-0-bullhead.img 刷入SR5-SuperSU和nethunter-2020.3-bullhead-oreo-kalifs-full.zip adb push /root/Android/Sdk/ndk/22.1.7171670/prebuilt/android-arm /data/local/tmp ./fs14248arm74 objection -g com.roysue.easyso1 explore memory list modules memory list exports libroysue.so 查看so的导出符号 ./gdbserver 0.0.0.0:23946 –attach pid hyper gdb-multiarch set arch armset arm fallback-mode thumb target remote192.168.0.10:23946 info shared libroysue.so b *0xcc7143f5 info break 打断点 c 执行下一个断点 nexti 汇编级别下一步F8 n 源码级别下一步 ctrl+shift+pageup 选寄存器状态 `ctrl+shift+pagedown 选寄存器状态 Nethunter 刷机 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"kali","slug":"kali","permalink":"http://onejane.github.io/tags/kali/"}]},{"title":"识货跳转淘宝时携带参数的实现","slug":"识货跳转淘宝时携带参数的实现","date":"2021-05-14T06:07:57.000Z","updated":"2021-12-12T03:09:39.337Z","comments":true,"path":"2021/05/14/识货跳转淘宝时携带参数的实现/","link":"","permalink":"http://onejane.github.io/2021/05/14/%E8%AF%86%E8%B4%A7%E8%B7%B3%E8%BD%AC%E6%B7%98%E5%AE%9D%E6%97%B6%E6%90%BA%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 需求最近在电商业务的设计中要求像识货app一样实现选好型号尺寸之类的商品属性后，跳转到淘宝时携带这些参数帮助用户自行选中，如下图所示： 分析 启动frida-server； 123adb shellsu.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64 使用PKiD判断是否加壳； 安装好识货app，由于没有加固，直接从AndroidMainfest.xml中拿到包名。jadx-gui *.apk 查看，package=&quot;com.hupu.shihuo&quot;找到包名； hook点击事件获取触发的类frida -UF -l hookEvent.js 12pyenv local 3.8.2 该环境的frida版本为12.8.0frida --version 点击尺寸型号时，选择配色尺码触发事件 1[Google Pixel XL::识货]-&gt; [WatchEvent] onClick: cn.shihuo.modulelib.views.widget.easyrecyclerview.adapter.RecyclerArrayAdapter$3 选好型号后，点击立即购买触发事件 1[Google Pixel XL::识货]-&gt; [WatchEvent] onClick: com.module.shoes.view.DetailOfShoesBFragment$ab 点击担保购买，查看触发事件 1[Google Pixel XL::识货]-&gt; [WatchEvent] onClick: com.module.shoes.view.adapter.ChannelOfShoesAdapter$ViewHolder$a 内存漫游属性点击1android hooking watch class cn.shihuo.modulelib.views.widget.easyrecyclerview.adapter.RecyclerArrayAdapter$3 --dump-args --dump-backtrace --dump-return 对整个RecyclerArrayAdapter类进行hook第三个匿名内部类 12jobs listjobs kill o0jgr3f2i6j 拿到需要hook的方法后取消hook 123plugin wallbreaker objectsearch cn.shihuo.modulelib.views.widget.easyrecyclerview.adapter.RecyclerArrayAdapter$3 内存中搜索该匿名内部类plugin wallbreaker objectdump --fullname 0x10117a 打印该内部类plugin wallbreaker objectdump --fullname 0x10108a 查看该类中可能的实力对象ShoeStylesAdapter 以上的类中没有任何线索涉及到参数的传递或者请求的跳转。 立即购买12android hooking search classes DetailOfShoesBFragment$ab 内存中搜索DetailOfShoesBFragment内部类ab及涉及的方法android hooking list class_methods com.module.shoes.view.DetailOfShoesBFragment$ab 获取该类方法及参数类型 123android heap search instances com.module.shoes.view.DetailOfShoesBFragment$ab 获取内存实例plugin wallbreaker objectdump --fullname 0x10e5b6 将该实例dump出来plugin wallbreaker objectdump --fullname 0xe566 该实例中还有一个DetailOfShoesBFragment实例 在DetailOfShoesBFragment实例中，ShoeDetailSecondModel极有可能有关键性线索实现参数携带跳转。 可是当我整个字符串拷贝下来时，发现连个taobao的毛都没看到，再次dump该实例，也没有什么重要线索。 担保购买12android heap search instances com.module.shoes.view.adapter.ChannelOfShoesAdapter$ViewHolder$a 直接内存搜刮plugin wallbreaker objectdump --fullname 0x20e57e 找到SupplierInfoModel类在jadx看源码是有一些关键性字段的，如price,href等。 1plugin wallbreaker objectdump --fullname 0x20e512 将这段href拷贝下来，解码后如下： 1shihuo:&#x2F;&#x2F;www.shihuo.cn?route&#x3D;go&amp;goods_product_id&#x3D;12331971&amp;tpExtra&#x3D;&#123;&quot;dgReqId&quot;:&quot;TTfc4jvaelao00&quot;,&quot;fReqId&quot;:&quot;93E867875BE612E72CAF39F223AF0C08&quot;,&quot;fTp&quot;:&quot;list:list:1&quot;,&quot;fTpName&quot;:&quot;&quot;,&quot;ffTp&quot;:&quot;home:feed_list:1&quot;,&quot;ffTpName&quot;:&quot;推荐&quot;,&quot;layer&quot;:&quot;2&quot;,&quot;sc&quot;:&quot;HOME_FEED_RECOMMEND_RANK&quot;,&quot;si&quot;:&quot;1001&quot;,&quot;skc&quot;:&quot;1683465&quot;,&quot;sourceTp&quot;:&quot;home:feed_list:1&quot;,&quot;sourceTpName&quot;:&quot;推荐&quot;,&quot;style_id&quot;:&quot;6459093&quot;,&quot;supplier_id&quot;:&quot;8234343&quot;&#125;&amp;url&#x3D;https:&#x2F;&#x2F;item.taobao.com&#x2F;item.htm?id&#x3D;643291979969&amp;skuId&#x3D;4798775291256&amp;dspm&#x3D;46e625b0904faa9c&amp;fromShType&#x3D;1&amp;goodsType&#x3D;4&amp;openType&#x3D;1&amp;shopId&#x3D;cn.taobao.62301187&amp;category_type&#x3D;1&amp;goods_id&#x3D;13#&#123;&quot;from&quot;:&quot;shihuo:&#x2F;&#x2F;www.shihuo.cn?route&#x3D;goodsDetail&quot;,&quot;block&quot;:&quot;Supplier&quot;,&quot;tp&quot;:&quot;Supplier&quot;,&quot;sku_id&quot;:88366767,&quot;extra&quot;:&quot;2&quot;,&quot;dspm&quot;:&quot;46e625b0904faa9c&quot;,&quot;pos_type&quot;:2,&quot;goods_id&quot;:&quot;13&quot;,&quot;supplier_id&quot;:&quot;8234343&quot;,&quot;style_id&quot;:&quot;6459093&quot;,&quot;size&quot;:&quot;41&quot;,&quot;price&quot;:&quot;1002&quot;,&quot;sort&quot;:&quot;2&quot;,&quot;filter&quot;:&quot;0000000&quot;,&quot;is_recommend&quot;:0,&quot;goods_sku_id&quot;:12331971&#125; 很明显这段是识货自行封装的协议，后面参数url=应该就是跳转到淘宝的链接。 将https://item.taobao.com/item.htm?id=643291979969&amp;skuId=4798775291256&amp;dspm=46e625b0904faa9c&amp;fromShType=1&amp;goodsType=4&amp;openType=1&amp;shopId=cn.taobao.62301187&amp;category_type=1&amp;goods_id=13#{&quot;from&quot;:&quot;shihuo://www.shihuo.cn?route=goodsDetail&quot;,&quot;block&quot;:&quot;Supplier&quot;,&quot;tp&quot;:&quot;Supplier&quot;,&quot;sku_id&quot;:88366767,&quot;extra&quot;:&quot;2&quot;,&quot;dspm&quot;:&quot;46e625b0904faa9c&quot;,&quot;pos_type&quot;:2,&quot;goods_id&quot;:&quot;13&quot;,&quot;supplier_id&quot;:&quot;8234343&quot;,&quot;style_id&quot;:&quot;6459093&quot;,&quot;size&quot;:&quot;41&quot;,&quot;price&quot;:&quot;1002&quot;,&quot;sort&quot;:&quot;2&quot;,&quot;filter&quot;:&quot;0000000&quot;,&quot;is_recommend&quot;:0,&quot;goods_sku_id&quot;:12331971}链接拷贝到手机浏览器中自动跳转到淘宝，点击选项时加上了选择条件。 逐步删除条件，最终得到https://item.taobao.com/item.htm?id=643291979969&amp;skuId=4798775291256&amp;fromShType=1&amp;goodsType=4&amp;openType=1&amp;shopId=cn.taobao.62301187&amp;category_type=1&amp;goods_id=13,一旦删除skuId将不能携带型号等属性自动选择。 真相淘宝的skuId就是将信息同步到淘宝，淘宝将自动选中用户在识货选中的条件。 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"}]},{"title":"ElasticSearch之分布式特性","slug":"ElasticSearch之分布式特性","date":"2021-05-13T03:12:37.000Z","updated":"2021-12-12T03:09:39.222Z","comments":true,"path":"2021/05/13/ElasticSearch之分布式特性/","link":"","permalink":"http://onejane.github.io/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 Elasticsearch是一套分布式的系统，分布式是为了应对大数据量，隐藏了复杂的分布式机制，实现了分片机制(数据插入分配不同的shard中)，集群发现机制(启动多个es进程自动发现集群并加入且接受部分数据当做副本)，shard负载均衡机制(增减节点时，多节点条件下es自动进行均匀分配，保持每个节点均衡读写负载请求)，shard副本机制(请求路由，集群扩容，shard重分配)。master节点实现创建或删除索引，增加或删除节点。节点对等，每个节点都能接收所有的请求，自动请求路由，响应收集。 ES就是一个分布式的文档数据存储系统。 文档数据：es可以存储和操作json文档类型的数据，而且这也是es的核心数据结构。 存储系统：es可以对json文档类型的数据进行存储，查询，创建，更新，删除，等等操作。其实ES满足了这些功能，就可以说已经是一个NoSQL的存储系统了。 场景： 数据量较大，es的分布式本质，可以帮助你快速进行扩容，承载大量数据 数据结构灵活多变，随时可能会变化，而且数据结构之间的关系，非常复杂，如果我们用传统数据库，那是不是很坑，因为要面临大量的表 对数据的相关操作，较为简单，比如就是一些简单的增删改查，用我们之前讲解的那些document操作就可以搞定 NoSQL数据库，适用的也是类似于上面的这种场景 shard&amp;replica机制 index包含多个shard 每个shard都是一个最小工作单元，承载部分数据，lucene实例，完整的建立索引和处理请求的能力 增减节点时，shard会自动在nodes中负载均衡,6个节点，7个shard，其中一个节点2个shard,进入新节点时，自动将shard负载均匀分配到所有节点。 primary shard和replica shard，每个document肯定只存在于某一个primary shard以及其对应的replica shard中，不可能存在于多个primary shard replica shard是primary shard的副本，负责容错，以及承担读请求负载 primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改 primary shard的默认数量是5，replica默认是1，默认有10个shard，5个primary shard，5个replica shard primary shard不能和自己的replica shard放在同一个节点上（否则节点宕机，primary shard和副本都丢失，起不到容错的作用），但是可以和其他primary shard的replica shard放在同一个节点上 单node创建index 单node环境下，创建一个index，有3个primary shard，3个replica shard 集群status是yellow 这个时候，只会将3个primary shard分配到仅有的一个node上去，另外3个replica shard是无法分配的 集群可以正常工作，但是一旦出现节点宕机，数据全部丢失，而且集群不可用，无法承接任何请求 1234567PUT &#x2F;test_index&#123; &quot;settings&quot; : &#123; &quot;number_of_shards&quot; : 3, &quot;number_of_replicas&quot; : 1 &#125;&#125; 双node分配shard replica shard分配：master(3个primary shard)，slave(3个replica shard)，新增1个node primary ---&gt; replica同步 读请求：primary/replica 横向扩容 primary&amp;replica自动负载均衡，6个shard，3 primary，3 replica 每个node有更少的shard，IO/CPU/Memory资源给每个shard分配更多，每个shard性能更好 扩容的极限，6个shard（3 primary，3 replica），最多扩容到6台机器，每个shard可以占用单台服务器的所有资源，性能最好 超出扩容极限，动态修改replica数量，9个shard（3primary，6 replica），扩容到9台机器，比3台机器时，拥有3倍的读吞吐量 3台机器下，9个shard（3 primary，6 replica），资源更少，但是容错性更好，最多容纳2台机器宕机，6个shard只能容纳0台机器宕机 容错机制 9 shard，3 node master node宕机，自动master选举，red replica容错：新master将replica提升为primary shard，yellow 重启宕机node，master copy replica到该node，使用原有的shard并同步宕机后的修改，green 元数据123456789101112131415PUT &#x2F;test_indx&#x2F;test_type&#x2F;1&#123; &quot;test_content&quot;: &quot;test test&quot;&#125;GET &#x2F;test_indx&#x2F;test_type&#x2F;1&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;test_content&quot;: &quot;test test&quot; &#125;&#125; _index元数据 （1）代表一个document存放在哪个index中（2）类似的数据放在一个索引，非类似的数据放不同索引：product index（包含了所有的商品），sales index（包含了所有的商品销售数据），inventory index（包含了所有库存相关的数据）。如果你把比如product，sales，human resource（employee），全都放在一个大的index里面，比如说company index，不合适的。（3）index中包含了很多类似的document：类似是什么意思，其实指的就是说，这些document的fields很大一部分是相同的，你说你放了3个document，每个document的fields都完全不一样，这就不是类似了，就不太适合放到一个index里面去了。（4）索引名称必须是小写的，不能用下划线开头，不能包含逗号：product，website，blog _type元数据 （1）代表document属于index中的哪个类别（type）（2）一个索引通常会划分为多个type，逻辑上对index中有些许不同的几类数据进行分类：因为一批相同的数据，可能有很多相同的fields，但是还是可能会有一些轻微的不同，可能会有少数fields是不一样的，举个例子，就比如说，商品，可能划分为电子商品，生鲜商品，日化商品，等等。（3）type名称可以是大写或者小写，但是同时不能用下划线开头，不能包含逗号 _id元数据 （1）代表document的唯一标识，与index和type一起，可以唯一标识和定位一个document（2）我们可以手动指定document的id（put /index/type/id），也可以不指定，由es自动为我们创建一个id document_id 手动指定document id 一般来说，是从某些其他的系统中，导入一些数据到es时，会采取这种方式，就是使用系统中已有数据的唯一标识，作为es中document的id。举个例子，比如说，我们现在在开发一个电商网站，做搜索功能，或者是OA系统，做员工检索功能。这个时候，数据首先会在网站系统或者IT系统内部的数据库中，会先有一份，此时就肯定会有一个数据库的primary key（自增长，UUID，或者是业务编号）。如果将数据导入到es中，此时就比较适合采用数据在数据库中已有的primary key。 如果说，我们是在做一个系统，这个系统主要的数据存储就是es一种，也就是说，数据产生出来以后，可能就没有id，直接就放es一个存储，那么这个时候，可能就不太适合说手动指定document id的形式了，因为你也不知道id应该是什么，此时可以采取下面要讲解的让es自动生成id的方式。 1234PUT &#x2F;test_index&#x2F;test_type&#x2F;2&#123; &quot;test_content&quot;: &quot;my test&quot;&#125; 自动生成document id （1）post /index/type 123456789101112131415161718POST &#x2F;test_index&#x2F;test_type&#123; &quot;test_content&quot;: &quot;my test&quot;&#125;&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;AVp4RN0bhjxldOOnBxaE&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;, &quot;created&quot;: true&#125; （2）自动生成的id，长度为20个字符，URL安全，base64编码，GUID，分布式系统并行生成时不可能会发生冲突 _source_source元数据：就是说，我们在创建一个document的时候，使用的那个放在request body中的json串，默认情况下，在get的时候，会原封不动的给我们返回回来。 12345678910111213141516171819put &#x2F;test_index&#x2F;test_type&#x2F;1&#123; &quot;test_field1&quot;: &quot;test field1&quot;, &quot;test_field2&quot;: &quot;test field2&quot;&#125;get &#x2F;test_index&#x2F;test_type&#x2F;1&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 2, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;test_field1&quot;: &quot;test field1&quot;, &quot;test_field2&quot;: &quot;test field2&quot; &#125;&#125; 定制返回的结果，指定_source中，返回哪些field,GET /test_index/test_type/1?_source=test_field1,test_field2 批量查询就是一条一条的查询，比如说要查询100条数据，那么就要发送100次网络请求，这个开销还是很大的如果进行批量查询的话，查询100条数据，就只要发送1次网络请求，网络请求的性能开销缩减100倍 12345678910111213141516171819202122232425262728293031323334GET &#x2F;test_index&#x2F;test_type&#x2F;1GET &#x2F;test_index&#x2F;test_type&#x2F;2GET &#x2F;_mget mget批量查询&#123; &quot;docs&quot; : [ &#123; &quot;_index&quot; : &quot;test_index&quot;, &quot;_type&quot; : &quot;test_type&quot;, &quot;_id&quot; : 1 &#125;, &#123; &quot;_index&quot; : &quot;test_index&quot;, &quot;_type&quot; : &quot;test_type&quot;, &quot;_id&quot; : 2 &#125; ]&#125;GET &#x2F;test_index&#x2F;_mget 查询的document是一个index下的不同type&#123; &quot;docs&quot; : [ &#123; &quot;_type&quot; : &quot;test_type&quot;, &quot;_id&quot; : 1 &#125;, &#123; &quot;_type&quot; : &quot;test_type&quot;, &quot;_id&quot; : 2 &#125; ]&#125;GET &#x2F;test_index&#x2F;test_type&#x2F;_mget 查询的数据都在同一个index下的同一个type&#123; &quot;ids&quot;: [1, 2]&#125; 可以说mget是很重要的，一般来说，在进行查询的时候，如果一次性要查询多条数据的话，那么一定要用batch批量操作的api，尽可能减少网络开销次数，可能可以将性能提升数倍，甚至数十倍。 bulk批量增删改bulk api对json的语法，有严格的要求，每个json串不能换行，只能放一行，同时一个json串和一个json串之间，必须有一个换行 delete：删除一个文档，只要1个json串就可以了 create：PUT /index/type/id/_create，强制创建 index：普通的put操作，可以是创建文档，也可以是全量替换文档 update：执行的partial update操作 12345678POST &#x2F;_bulk&#123; &quot;delete&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;3&quot; &#125;&#125; &#123; &quot;create&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;12&quot; &#125;&#125;&#123; &quot;test_field&quot;: &quot;test12&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;2&quot; &#125;&#125;&#123; &quot;test_field&quot;: &quot;replaced test2&quot; &#125;&#123; &quot;update&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_retry_on_conflict&quot; : 3&#125; &#125;&#123; &quot;doc&quot; : &#123;&quot;test_field2&quot; : &quot;bulk test1&quot;&#125; &#125; bulk操作中，任意一个操作失败，是不会影响其他的操作的，但是在返回结果里，会告诉你异常日志 123456789101112131415161718192021POST &#x2F;test_index&#x2F;_bulk&#123; &quot;delete&quot;: &#123; &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;3&quot; &#125;&#125; &#123; &quot;create&quot;: &#123; &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;12&quot; &#125;&#125;&#123; &quot;test_field&quot;: &quot;test12&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_type&quot;: &quot;test_type&quot; &#125;&#125;&#123; &quot;test_field&quot;: &quot;auto-generate id test&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;2&quot; &#125;&#125;&#123; &quot;test_field&quot;: &quot;replaced test2&quot; &#125;&#123; &quot;update&quot;: &#123; &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_retry_on_conflict&quot; : 3&#125; &#125;&#123; &quot;doc&quot; : &#123;&quot;test_field2&quot; : &quot;bulk test1&quot;&#125; &#125;POST &#x2F;test_index&#x2F;test_type&#x2F;_bulk&#123; &quot;delete&quot;: &#123; &quot;_id&quot;: &quot;3&quot; &#125;&#125; &#123; &quot;create&quot;: &#123; &quot;_id&quot;: &quot;12&quot; &#125;&#125;&#123; &quot;test_field&quot;: &quot;test12&quot; &#125;&#123; &quot;index&quot;: &#123; &#125;&#125;&#123; &quot;test_field&quot;: &quot;auto-generate id test&quot; &#125;&#123; &quot;index&quot;: &#123; &quot;_id&quot;: &quot;2&quot; &#125;&#125;&#123; &quot;test_field&quot;: &quot;replaced test2&quot; &#125;&#123; &quot;update&quot;: &#123; &quot;_id&quot;: &quot;1&quot;, &quot;_retry_on_conflict&quot; : 3&#125; &#125;&#123; &quot;doc&quot; : &#123;&quot;test_field2&quot; : &quot;bulk test1&quot;&#125; &#125; bulk request会加载到内存里，如果太大的话，性能反而会下降，因此需要反复尝试一个最佳的bulk size。一般从1000~5000条数据开始，尝试逐渐增加。另外，如果看大小的话，最好是在5~15MB之间。 bulk api奇特的json格式1234&#123;&quot;action&quot;: &#123;&quot;meta&quot;&#125;&#125;\\n&#123;&quot;data&quot;&#125;\\n&#123;&quot;action&quot;: &#123;&quot;meta&quot;&#125;&#125;\\n&#123;&quot;data&quot;&#125;\\n 不用将其转换为json对象，不会出现内存中的相同数据的拷贝，直接按照换行符切割json 对每两个一组的json，读取meta，进行document路由 直接将对应的json发送到node上去 最大的优势在于，不需要将json数组解析为一个JSONArray对象，形成一份大数据的拷贝，浪费内存空间，尽可能地保证性能 如果采用比较良好的json数组格式,允许任意的换行，整个可读性非常棒，读起来很爽，es拿到那种标准格式的json串以后，要按照下述流程去进行处理 将json数组解析为JSONArray对象，这个时候，整个数据，就会在内存中出现一份一模一样的拷贝，一份数据是json文本，一份数据是JSONArray对象 解析json数组里的每个json，对每个请求中的document进行路由 为路由到同一个shard上的多个请求，创建一个请求数组 将这个请求数组序列化 将序列化后的请求数组发送到对应的节点上去 耗费更多内存，更多的jvm gc开销，我们之前提到过bulk size最佳大小的那个问题，一般建议说在几千条那样，然后大小在10MB左右，所以说，可怕的事情来了。假设说现在100个bulk请求发送到了一个节点上去，然后每个请求是10MB，100个请求，就是1000MB = 1GB，然后每个请求的json都copy一份为jsonarray对象，此时内存中的占用就会翻倍，就会占用2GB的内存，甚至还不止。因为弄成jsonarray之后，还可能会多搞一些其他的数据结构，2GB+的内存占用。占用更多的内存可能就会积压其他请求的内存使用量，比如说最重要的搜索请求，分析请求，等等，此时就可能会导致其他请求的性能急速下降。占用内存更多，就会导致java虚拟机的垃圾回收次数更多，跟频繁，每次要回收的垃圾对象更多，耗费的时间更多，导致es的java虚拟机停止工作线程的时间更多 更新全量替换 语法与创建文档是一样的，如果document id不存在，那么就是创建；如果document id已经存在，那么就是全量替换操作，替换document的json串内容，更新_version的值 document是不可变的，如果要修改document的内容，第一种方式就是全量替换，直接对document重新建立索引，替换里面所有的内容 es会将老的document标记为deleted，然后新增我们给定的一个document，当我们创建越来越多的document的时候，es会在适当的时机在后台自动删除标记为deleted的document 局部更新PUT /index/type/id，创建文档&amp;替换文档，就是一样的语法 应用程序先发起一个get请求，获取到document，展示到前台界面，供用户查看和修改 用户在前台界面修改数据，发送到后台 后台代码，会将用户修改的数据在内存中进行执行，然后封装好修改后的全量数据 然后发送PUT请求，到es中，进行全量替换 es将老的document标记为deleted，然后重新创建一个新的document 123456post &#x2F;index&#x2F;type&#x2F;id&#x2F;_update &#123; &quot;doc&quot;: &#123; &quot;要修改的少数几个field即可，不需要全量的数据&quot; &#125;&#125; 原理 实战partial update123456789101112PUT &#x2F;test_index&#x2F;test_type&#x2F;10&#123; &quot;test_field1&quot;: &quot;test1&quot;, &quot;test_field2&quot;: &quot;test2&quot;&#125;POST &#x2F;test_index&#x2F;test_type&#x2F;10&#x2F;_update&#123; &quot;doc&quot;: &#123; &quot;test_field2&quot;: &quot;updated test2&quot; &#125;&#125; groovy实现partial updatees，其实是有个内置的脚本支持的，可以基于groovy脚本实现各种各样的复杂操作 准备数据 12345PUT &#x2F;test_index&#x2F;test_type&#x2F;11&#123; &quot;num&quot;: 0, &quot;tags&quot;: []&#125; 更新数据 1234POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update&#123; &quot;script&quot; : &quot;ctx._source.num+&#x3D;1&quot;&#125; 外部脚本 vim elasticsearch-5.2.0\\config\\scripts\\test-add-tags.groovyctx._source.tags+=new_tag 为tags字段添加tag1,test-add-tags.groovy 12345678910POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update&#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;groovy&quot;, &quot;file&quot;: &quot;test-add-tags&quot;, &quot;params&quot;: &#123; &quot;new_tag&quot;: &quot;tag1&quot; &#125; &#125;&#125; ctx.op = ctx._source.num == count ? &#39;delete&#39; : &#39;none&#39; 删除文档test-delete-document.groovy 12345678910POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update&#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;groovy&quot;, &quot;file&quot;: &quot;test-delete-document&quot;, &quot;params&quot;: &#123; &quot;count&quot;: 1 &#125; &#125;&#125; upsert操作 123456POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update&#123; &quot;doc&quot;: &#123; &quot;num&quot;: 1 &#125;&#125; 原始_update会直接报错404. 如果指定的document不存在，就执行upsert中的初始化操作；如果指定的document存在，就执行doc或者script指定的partial update操作 12345678POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update&#123; &quot;script&quot; : &quot;ctx._source.num+&#x3D;1&quot;, &quot;upsert&quot;: &#123; &quot;num&quot;: 0, &quot;tags&quot;: [] &#125;&#125; 强制创建PUT /index/type/id?op_type=create，PUT /index/type/id/_create 删除DELETE /index/type/id 不会理解物理删除，只会将其标记为deleted，当数据越来越多的时候，在后台自动删除 并发冲突 悲观锁与乐观锁方案 第一次创建一个document的时候，它的_version内部版本号就是1；以后，每次对这个document执行修改或者删除操作，都会对这个_version版本号自动加1；哪怕是删除，也会对这条数据的版本号加1。 在删除一个document之后，可以从一个侧面证明，它不是立即物理删除掉的，因为它的一些版本号等信息还是保留着的。先删除一条document，再重新创建这条document，其实会在delete version基础之上，再把version号加1 _version乐观锁实战 构造一条数据1234PUT &#x2F;test_index&#x2F;test_type&#x2F;7&#123; &quot;test_field&quot;: &quot;test test&quot;&#125; 模拟两个客户端，都获取到了同一条数据1234567891011GET test_index&#x2F;test_type&#x2F;7&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;7&quot;, &quot;_version&quot;: 1, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;test_field&quot;: &quot;test test&quot; &#125;&#125; 其中一个客户端，先更新了一下这个数据，同时带上数据的版本号，确保说，es中的数据的版本号，跟客户端中的数据的版本号是相同的，才能修改1234567891011121314151617PUT &#x2F;test_index&#x2F;test_type&#x2F;7?version&#x3D;1 &#123; &quot;test_field&quot;: &quot;test client 1&quot;&#125;&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;7&quot;, &quot;_version&quot;: 2, &quot;result&quot;: &quot;updated&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;, &quot;created&quot;: false&#125; 另外一个客户端，尝试基于version=1的数据去进行修改，同样带上version版本号，进行乐观锁的并发控制1234567891011121314151617181920212223PUT &#x2F;test_index&#x2F;test_type&#x2F;7?version&#x3D;1 &#123; &quot;test_field&quot;: &quot;test client 2&quot;&#125;&#123; &quot;error&quot;: &#123; &quot;root_cause&quot;: [ &#123; &quot;type&quot;: &quot;version_conflict_engine_exception&quot;, &quot;reason&quot;: &quot;[test_type][7]: version conflict, current version [2] is different than the one provided [1]&quot;, &quot;index_uuid&quot;: &quot;6m0G7yx7R1KECWWGnfH1sw&quot;, &quot;shard&quot;: &quot;3&quot;, &quot;index&quot;: &quot;test_index&quot; &#125; ], &quot;type&quot;: &quot;version_conflict_engine_exception&quot;, &quot;reason&quot;: &quot;[test_type][7]: version conflict, current version [2] is different than the one provided [1]&quot;, &quot;index_uuid&quot;: &quot;6m0G7yx7R1KECWWGnfH1sw&quot;, &quot;shard&quot;: &quot;3&quot;, &quot;index&quot;: &quot;test_index&quot; &#125;, &quot;status&quot;: 409&#125; 在乐观锁成功阻止并发问题之后，尝试正确的完成更新 1234567891011GET &#x2F;test_index&#x2F;test_type&#x2F;7&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;7&quot;, &quot;_version&quot;: 2, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;test_field&quot;: &quot;test client 1&quot; &#125;&#125; 基于最新的数据和版本号，去进行修改，修改后，带上最新的版本号，可能这个步骤会需要反复执行好几次，才能成功，特别是在多线程并发更新同一条数据很频繁的情况下1234PUT &#x2F;test_index&#x2F;test_type&#x2F;7?version&#x3D;2 &#123; &quot;test_field&quot;: &quot;test client 2&quot;&#125; external version乐观锁实战es提供了一个feature，就是说，你可以不用它提供的内部_version版本号来进行并发控制，可以基于你自己维护的一个版本号来进行并发控制。比如，加入你的数据在mysql里也有一份，然后你的应用系统本身就维护了一个版本号，无论是什么自己生成的，程序控制的。这个时候，你进行乐观锁并发控制的时候，可能并不是想要用es内部的_version来进行控制，而是用你自己维护的那个version来进行控制。 _version=1，?version=1，才能更新成功_version=1，?version&gt;1&amp;version_type=external，才能成功，比如说?version=2&amp;version_type=external version_type=external，唯一的区别在于，_version，只有当你提供的version与es中的_version一模一样的时候，才可以进行修改，只要不一样，就报错；当version_type=external的时候，只有当你提供的version比es中的_version大的时候，才能完成修改。 先构造一条数据 123456789101112131415161718PUT &#x2F;test_index&#x2F;test_type&#x2F;8&#123; &quot;test_field&quot;: &quot;test&quot;&#125;&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;8&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;, &quot;created&quot;: true&#125; 模拟两个客户端同时查询到这条数据 123456789101112GET &#x2F;test_index&#x2F;test_type&#x2F;8&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;8&quot;, &quot;_version&quot;: 1, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;test_field&quot;: &quot;test&quot; &#125;&#125; 第一个客户端先进行修改，此时客户端程序是在自己的数据库中获取到了这条数据的最新版本号，比如说是2 123456789101112131415161718PUT &#x2F;test_index&#x2F;test_type&#x2F;8?version&#x3D;2&amp;version_type&#x3D;external&#123; &quot;test_field&quot;: &quot;test client 1&quot;&#125;&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;8&quot;, &quot;_version&quot;: 2, &quot;result&quot;: &quot;updated&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;, &quot;created&quot;: false&#125; 模拟第二个客户端，同时拿到了自己数据库中维护的那个版本号，也是2，同时基于version=2发起了修改 123456789101112131415161718192021222324PUT &#x2F;test_index&#x2F;test_type&#x2F;8?version&#x3D;2&amp;version_type&#x3D;external&#123; &quot;test_field&quot;: &quot;test client 2&quot;&#125;&#123; &quot;error&quot;: &#123; &quot;root_cause&quot;: [ &#123; &quot;type&quot;: &quot;version_conflict_engine_exception&quot;, &quot;reason&quot;: &quot;[test_type][8]: version conflict, current version [2] is higher or equal to the one provided [2]&quot;, &quot;index_uuid&quot;: &quot;6m0G7yx7R1KECWWGnfH1sw&quot;, &quot;shard&quot;: &quot;1&quot;, &quot;index&quot;: &quot;test_index&quot; &#125; ], &quot;type&quot;: &quot;version_conflict_engine_exception&quot;, &quot;reason&quot;: &quot;[test_type][8]: version conflict, current version [2] is higher or equal to the one provided [2]&quot;, &quot;index_uuid&quot;: &quot;6m0G7yx7R1KECWWGnfH1sw&quot;, &quot;shard&quot;: &quot;1&quot;, &quot;index&quot;: &quot;test_index&quot; &#125;, &quot;status&quot;: 409&#125; 在并发控制成功后，重新基于最新的版本号发起更新12345678910111213141516171819202122232425262728293031GET &#x2F;test_index&#x2F;test_type&#x2F;8&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;8&quot;, &quot;_version&quot;: 2, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;test_field&quot;: &quot;test client 1&quot; &#125;&#125;PUT &#x2F;test_index&#x2F;test_type&#x2F;8?version&#x3D;3&amp;version_type&#x3D;external&#123; &quot;test_field&quot;: &quot;test client 2&quot;&#125;&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;8&quot;, &quot;_version&quot;: 3, &quot;result&quot;: &quot;updated&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;, &quot;created&quot;: false&#125; partial update内置乐观锁并发控制 post /index/type/id/_update?retry_on_conflict=5&amp;version=6 document原理路由 document路由到shard上的路由算法：shard = hash(routing) % number_of_primary_shards 举个例子，一个index有3个primary shard，P0，P1，P2，每次增删改查一个document的时候，都会带过来一个routing number，默认就是这个document的_id（可能是手动指定，也可能是自动生成）,routing = _id，假设_id=1,会将这个routing值，传入一个hash函数中，产出一个routing值的hash值，hash(routing) = 21，然后将hash函数产出的值对这个index的primary shard的数量求余数，21 % 3 = 0，就决定了，这个document就放在P0上。 决定一个document在哪个shard上，最重要的一个值就是routing值，默认是_id，也可以手动指定，相同的routing值，每次过来，从hash函数中，产出的hash值一定是相同的。无论hash值是几，无论是什么数字，对number_of_primary_shards求余数，结果一定是在0~number_of_primary_shards-1之间这个范围内的。0,1,2。 默认的routing就是_id，也可以在发送请求的时候，手动指定一个routing value，比如说put /index/type/id?routing=user_id。手动指定routing value是很有用的，可以保证说，某一类document一定被路由到一个shard上去，那么在后续进行应用级别的负载均衡，以及提升批量读取的性能。 增删改 客户端选择一个node发送请求过去，这个node就是coordinating node（协调节点） coordinating node，对document进行路由，将请求转发给对应的node（有primary shard） 实际的node上的primary shard处理请求，然后将数据同步到replica node coordinating node，如果发现primary node和所有replica node都搞定之后，就返回响应结果给客户端 查 客户端发送请求到任意一个node，成为coordinate node coordinate node对document进行路由，将请求转发到对应的node，此时会使用round-robin随机轮询算法，在primary shard以及其所有replica中随机选择一个，让读请求负载均衡 接收请求的node返回document给coordinate node coordinate node返回document给客户端 特殊情况：document如果还在建立索引过程中，可能只有primary shard有，任何一个replica shard都没有，此时可能会导致无法读取到document，但是document完成索引建立之后，primary shard和replica shard就都有了 quorum我们在发送任何一个增删改操作的时候，比如说put /index/type/id，都可以带上一个consistency参数，指明我们想要的写一致性put /index/type/id?consistency=quorum one：要求我们这个写操作，只要有一个primary shard是active活跃可用的，就可以执行all：要求我们这个写操作，必须所有的primary shard和replica shard都是活跃的，才可以执行这个写操作quorum：默认的值，要求所有的shard中，必须是大部分的shard都是活跃的，可用的，才可以执行这个写操作 quorum机制，写之前必须确保大多数shard都可用，int( (primary + number_of_replicas) / 2 ) + 1，当number_of_replicas&gt;1时才生效 quroum = int( (primary + number_of_replicas) / 2 ) + 1举个例子，3个primary shard，number_of_replicas=1，总共有3 + 3 * 1 = 6个shardquorum = int( (3 + 1) / 2 ) + 1 = 3所以，要求6个shard中至少有3个shard是active状态的，才可以执行这个写操作 如果节点数少于quorum数量，可能导致quorum不齐全，进而导致无法执行任何写操作。3个primary shard，replica=1，要求至少3个shard是active，3个shard按照之前学习的shard&amp;replica机制，必须在不同的节点上，如果说只有2台机器的话，是不是有可能出现说，3个shard都没法分配齐全，此时就可能会出现写操作无法执行的情况。 1个primary shard，replica=3，quorum=((1 + 3) / 2) + 1 = 3，要求1个primary shard + 3个replica shard = 4个shard，其中必须有3个shard是要处于active状态的。如果这个时候只有2台机器的话，es提供了一种特殊的处理场景，就是说当number_of_replicas&gt;1时才生效，因为假如说，你就一个primary shard，replica=1，此时就2个shard，(1 + 1 / 2) + 1 = 2，要求必须有2个shard是活跃的，但是可能就1个node，此时就1个shard是活跃的，如果你不特殊处理的话，导致我们的单节点集群就无法工作 quorum不齐全时，wait，默认1分钟，timeout，100，30s，等待期间，期望活跃的shard数量可以增加，最后实在不行，就会timeout，我们其实可以在写操作的时候，加一个timeout参数，比如说put /index/type/id?timeout=30，这个就是说自己去设定quorum不齐全的时候，es的timeout时长，可以缩短，也可以增长 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://onejane.github.io/tags/elasticsearch/"}]},{"title":"ElasticSearch之基础介绍","slug":"ElasticSearch之基础介绍","date":"2021-05-10T07:10:32.000Z","updated":"2021-12-12T03:09:39.223Z","comments":true,"path":"2021/05/10/ElasticSearch之基础介绍/","link":"","permalink":"http://onejane.github.io/2021/05/10/ElasticSearch%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 介绍垂直搜索（站内搜索） 互联网的搜索：电商网站，招聘网站，新闻网站，各种appIT系统的搜索：OA软件，办公自动化软件，会议管理，日程管理，项目管理，员工管理，搜索“张三”，“张三儿”，“张小三”；有个电商网站，卖家，后台管理系统，搜索“牙膏”，订单，“牙膏相关的订单” 搜索，就是在任何场景下，找寻你想要的信息，这个时候，会输入一段你要搜索的关键字，然后就期望找到这个关键字相关的有些信息 Elasticsearch，分布式，高性能，高可用，可伸缩的搜索和分析系统 elasticsearch，基于lucene，隐藏复杂性，提供简单易用的restful api接口、java api接口（还有其他语言的api接口）,开箱即用，优秀的默认参数，不需要任何额外设置，完全开源 分布式的文档存储引擎 分布式的搜索引擎和分析引擎 分布式，支持PB级数据 lucene，最先进、功能最强大的搜索库，直接基于lucene开发，非常复杂，api复杂（实现一些简单的功能，写大量的java代码），需要深入理解原理（各种索引结构） 数据库的弊端全表扫描 比方说，每条记录的指定字段的文本，可能会很长，比如说“商品描述”字段的长度，有长达数千个，甚至数万个字符，这个时候，每次都要对每条记录的所有文本进行扫描，来判断说，你包不包含我指定的这个关键词（比如说“牙膏”） 还不能将搜索词拆分开来，尽可能去搜索更多的符合你的期望的结果，比如输入“生化机”，就搜索不出来“生化危机”，输入“牙膏”搜索不到“牙刷膏”。 1select * from products where product_name like &quot;%牙膏%&quot; 什么是倒排索引 全文检索，倒排索引 lucene，就是一个jar包，里面包含了封装好的各种建立倒排索引，以及进行搜索的代码，包括各种算法。我们就用java开发的时候，引入lucene jar，然后基于lucene的api进行去进行开发就可以了。用lucene，我们就可以去将已有的数据建立索引，lucene会在本地磁盘上面，给我们组织索引的数据结构。另外的话，我们也可以用lucene提供的一些功能和api来针对磁盘上数据进行搜索 ElasticSearch功能分布式的搜索引擎和数据分析引擎 分布式搜索：百度，网站的站内搜索，IT系统的检索数据分析：电商网站，最近7天牙膏这种商品销量排名前10的商家有哪些；新闻网站，最近1个月访问量排名前3的新闻版块是哪些 全文检索，结构化检索，数据分析 全文检索：我想搜索商品名称包含牙膏的商品，select * from products where product_name like “%牙膏%”结构化检索：我想搜索商品分类为日化用品的商品都有哪些，select * from products where category_id=”日化用品”==&gt;实现部分匹配、自动完成、搜索纠错、搜索推荐数据分析：我们分析每一个商品分类下有多少个商品，select category_id,count(*) from products group by category_id 对海量数据进行近实时的处理 分布式：ES自动可以将海量数据分散到多台服务器上去存储和检索海量数据的处理：分布式以后，就可以采用大量的服务器去存储和检索数据，自然而然就可以实现海量数据的处理了近实时：检索个数据要花费1小时（这就不要近实时，离线批处理，batch-processing）；在秒级别对数据进行搜索和分析 跟分布式/海量数据相反的：lucene，单机应用，只能在单台服务器上使用，最多只能处理单台服务器可以处理的数据量 ElasticSearch适用场景国外 维基百科，类似百度百科，牙膏，牙膏的维基百科，全文检索，高亮，搜索推荐 The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈（好，坏，热门，垃圾，鄙视，崇拜） Stack Overflow（国外的程序异常讨论论坛），IT问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案 GitHub（开源代码管理），搜索上千亿行代码 电商网站，检索商品 日志数据分析，logstash采集日志，ES进行复杂的数据分析（ELK技术，elasticsearch+logstash+kibana） 商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买 BI系统，商业智能，Business Intelligence。比如说有个大型商场集团，BI，分析一下某某区域最近3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表，**区，最近3年，每年消费金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘，Kibana进行数据可视化 国内 站内搜索（电商，招聘，门户，等等），IT系统搜索（OA，CRM，ERP，等等），数据分析（ES热门的一个使用场景） ElasticSearch特点 可以作为一个大型分布式集群（数百台服务器）技术，处理PB级数据，服务大公司；也可以运行在单机上，服务小公司 Elasticsearch不是什么新技术，主要是将全文检索、数据分析以及分布式技术，合并在了一起，才形成了独一无二的ES；lucene（全文检索），商用的数据分析软件（也是有的），分布式数据库（mycat） 对用户而言，是开箱即用的，非常简单，作为中小型的应用，直接3分钟部署一下ES，就可以作为生产环境的系统来使用了，数据量不大，操作不是太复杂 数据库的功能面对很多领域是不够用的（事务，还有各种联机事务型的操作）；特殊的功能，比如全文检索，同义词处理，相关度排名，复杂数据分析，海量数据的近实时处理；Elasticsearch作为传统数据库的一个补充，提供了数据库所不不能提供的很多功能 ES核心概念 Near Realtime（NRT）：近实时，两个意思，从写入数据到数据可以被搜索到有一个小延迟（大概1秒）；基于es执行搜索和分析可以达到秒级 Cluster：集群，包含多个节点，每个节点属于哪个集群是通过一个配置（集群名称，默认是elasticsearch）来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常 Node：节点，集群中的一个节点，节点也有一个名称（默认是随机分配的），节点名称很重要（在执行运维管理操作的时候），默认节点会去加入一个名称为“elasticsearch”的集群，如果直接启动一堆节点，那么它们会自动组成一个elasticsearch集群，当然一个节点也可以组成一个elasticsearch集群 Document&amp;field：文档，es中的最小数据单元，一个document可以是一条客户数据，一条商品分类数据，一条订单数据，通常用JSON数据结构表示，每个index下的type中，都可以去存储多个document。一个document里面有多个field，每个field就是一个数据字段。 12345678product document&#123; &quot;product_id&quot;: &quot;1&quot;, &quot;product_name&quot;: &quot;高露洁牙膏&quot;, &quot;product_desc&quot;: &quot;高效美白&quot;, &quot;category_id&quot;: &quot;2&quot;, &quot;category_name&quot;: &quot;日化用品&quot;&#125; Index：索引，包含一堆有相似结构的文档数据，比如可以有一个客户索引，商品分类索引，订单索引，索引有一个名称。一个index包含很多document，一个index就代表了一类类似的或者相同的document。比如说建立一个product index，商品索引，里面可能就存放了所有的商品数据，所有的商品document。 Type：类型，每个索引里都可以有一个或多个type，type是index中的一个逻辑数据分类，一个type下的document，都有相同的field，比如博客系统，有一个索引，可以定义用户数据type，博客数据type，评论数据type。 商品index，里面存放了所有的商品数据，商品document，但是商品分很多种类，每个种类的document的field可能不太一样，比如说电器商品，可能还包含一些诸如售后时间范围这样的特殊field；生鲜商品，还包含一些诸如生鲜保质期之类的特殊field，type，日化商品type，电器商品type，生鲜商品type 日化商品type：product_id，product_name，product_desc，category_id，category_name电器商品type：product_id，product_name，product_desc，category_id，category_name，service_period生鲜商品type：product_id，product_name，product_desc，category_id，category_name，eat_period 12345678910111213141516171819每一个type里面，都会包含一堆document&#123; &quot;product_id&quot;: &quot;2&quot;, &quot;product_name&quot;: &quot;长虹电视机&quot;, &quot;product_desc&quot;: &quot;4k高清&quot;, &quot;category_id&quot;: &quot;3&quot;, &quot;category_name&quot;: &quot;电器&quot;, &quot;service_period&quot;: &quot;1年&quot;&#125;&#123; &quot;product_id&quot;: &quot;3&quot;, &quot;product_name&quot;: &quot;基围虾&quot;, &quot;product_desc&quot;: &quot;纯天然，冰岛产&quot;, &quot;category_id&quot;: &quot;4&quot;, &quot;category_name&quot;: &quot;生鲜&quot;, &quot;eat_period&quot;: &quot;7天&quot;&#125; shard：单台机器无法存储大量数据，es可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。有了shard就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个shard都是一个lucene index。 replica：任何一个服务器随时可能故障或宕机，此时shard可能就会丢失，因此可以为每个shard创建多个replica副本。replica可以在shard故障时提供备用服务，保证数据不丢失，多个replica还可以提升搜索操作的吞吐量和性能。primary shard（建立索引时一次设置，不能修改，默认5个），replica shard（随时修改数量，默认1个），默认每个索引10个shard，5个primary shard，5个replica shard，最小的高可用配置，是2台服务器。 Document 行 Type 表 Index 库 安装 安装JDK，至少1.8.0_73以上版本，java -version 下载和解压缩elasticsearch-5.2.0.zip，目录结构 启动Elasticsearch：bin\\elasticsearch.bat，es本身特点之一就是开箱即用，如果是中小型应用，数据量少，操作不是很复杂，直接启动就可以用了 检查ES是否启动成功：http://localhost:9200/?pretty 123name: node名称cluster_name: 集群名称（默认的集群名称就是elasticsearch）version.number: 5.2.0，es版本号 修改集群名称：elasticsearch.yml 下载和解压缩Kibana安装包，使用里面的开发界面，去操作elasticsearch，作为我们操作es的一个主要的界面入口 启动Kibana：bin\\kibana.bat 进入Dev Tools界面 GET _cluster/health CRUD面向文档的搜索分析引擎 应用系统的数据结构都是面向对象的，复杂的 对象数据存储到数据库中，只能拆解开来，变为扁平的多张表，每次查询的时候还得还原回对象格式，相当麻烦 ES是面向文档的，文档中存储的数据结构，与面向对象的数据结构是一样的，基于这种文档数据结构，es可以提供复杂的索引，全文检索，分析聚合等功能 es的document用json数据格式来表达 12345678910111213141516public class Employee &#123; private String email; private String firstName; private String lastName; private EmployeeInfo info; private Date joinDate;&#125;private class EmployeeInfo &#123; private String bio; &#x2F;&#x2F; 性格 private Integer age; private String[] interests; &#x2F;&#x2F; 兴趣爱好&#125; 两张表：employee表，employee_info表，将employee对象的数据重新拆开来，变成Employee数据和EmployeeInfo数据employee表：email，first_name，last_name，join_date，4个字段employee_info表：bio，age，interests，3个字段；此外还有一个外键字段，比如employee_id，关联着employee表 1234567891011&#123; &quot;email&quot;: &quot;zhangsan@sina.com&quot;, &quot;first_name&quot;: &quot;san&quot;, &quot;last_name&quot;: &quot;zhang&quot;, &quot;info&quot;: &#123; &quot;bio&quot;: &quot;curious and modest&quot;, &quot;age&quot;: 30, &quot;interests&quot;: [ &quot;bike&quot;, &quot;climb&quot; ] &#125;, &quot;join_date&quot;: &quot;2021&#x2F;01&#x2F;01&quot;&#125; 集群管理GET /_cat/health?v 快速检查集群的健康状况 12345epoch timestamp cluster status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent1488006741 15:12:21 elasticsearch yellow 1 1 1 1 0 0 1 0 - 50.0%epoch timestamp cluster status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent1488007113 15:18:33 elasticsearch green 2 2 2 1 0 0 0 0 - 100.0% green: 每个索引的primary shard和replica shard都是active状态的yellow: 每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态red: 不是所有索引的primary shard都是active状态的，部分索引有数据丢失了 PUT /test_index?pretty 创建索引 123health status index uuid pri rep docs.count docs.deleted store.size pri.store.sizeyellow open test_index XmS9DTAtSkSZSwWhhGEKkQ 5 1 0 0 650b 650byellow open .kibana rUm9n9wMRQCCrRDEhqneBg 1 1 1 0 3.1kb 3.1kb DELETE /test_index?pretty 删除索引 12health status index uuid pri rep docs.count docs.deleted store.size pri.store.sizeyellow open .kibana rUm9n9wMRQCCrRDEhqneBg 1 1 1 0 3.1kb 3.1kb 新增商品12345678910111213141516171819202122232425PUT &#x2F;ecommerce&#x2F;product&#x2F;1&#123; &quot;name&quot; : &quot;gaolujie yagao&quot;, &quot;desc&quot; : &quot;gaoxiao meibai&quot;, &quot;price&quot; : 30, &quot;producer&quot; : &quot;gaolujie producer&quot;, &quot;tags&quot;: [ &quot;meibai&quot;, &quot;fangzhu&quot; ]&#125;PUT &#x2F;ecommerce&#x2F;product&#x2F;2&#123; &quot;name&quot; : &quot;jiajieshi yagao&quot;, &quot;desc&quot; : &quot;youxiao fangzhu&quot;, &quot;price&quot; : 25, &quot;producer&quot; : &quot;jiajieshi producer&quot;, &quot;tags&quot;: [ &quot;fangzhu&quot; ]&#125;PUT &#x2F;ecommerce&#x2F;product&#x2F;3&#123; &quot;name&quot; : &quot;zhonghua yagao&quot;, &quot;desc&quot; : &quot;caoben zhiwu&quot;, &quot;price&quot; : 40, &quot;producer&quot; : &quot;zhonghua producer&quot;, &quot;tags&quot;: [ &quot;qingxin&quot; ]&#125; es会自动建立index和type，不需要提前创建，而且es默认会对document每个field都建立倒排索引，让其可以被搜索 12345678910111213&#123; &quot;_index&quot;: &quot;ecommerce&quot;, &quot;_type&quot;: &quot;product&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, # 创建与更新计数 &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, # 只有一个节点 &quot;failed&quot;: 0 &#125;, &quot;created&quot;: true&#125; 查询商品GET /ecommerce/product/1 替换文档123456789101112PUT &#x2F;ecommerce&#x2F;product&#x2F;1&#123; &quot;name&quot; : &quot;jiaqiangban gaolujie yagao&quot;, &quot;desc&quot; : &quot;gaoxiao meibai&quot;, &quot;price&quot; : 30, &quot;producer&quot; : &quot;gaolujie producer&quot;, &quot;tags&quot;: [ &quot;meibai&quot;, &quot;fangzhu&quot; ]&#125;PUT &#x2F;ecommerce&#x2F;product&#x2F;1&#123; &quot;name&quot; : &quot;jiaqiangban gaolujie yagao&quot;&#125; 替换方式有一个不好，即使必须带上所有的field，才能去进行信息的修改 更新文档123456POST &#x2F;ecommerce&#x2F;product&#x2F;1&#x2F;_update&#123; &quot;doc&quot;: &#123; &quot;name&quot;: &quot;jiaqiangban gaolujie yagao&quot; &#125;&#125; 删除文档DELETE /ecommerce/product/1 搜索方式 query string search query DSL query filter full-text search phrase search highlight search agg search query string searchtook：耗费了几毫秒timed_out：是否超时，这里是没有_shards：数据拆成了5个分片，所以对于搜索请求，会打到所有的primary shard（或者是它的某个replica shard也可以）hits.total：查询结果的数量，3个documenthits.max_score：score的含义，就是document对于一个search的相关度的匹配分数，越相关，就越匹配，分数也高hits.hits：包含了匹配搜索的document的详细数据 GET /ecommerce/product/_search 搜索全部商品 GET /ecommerce/product/_search?q=name:yagao&amp;sort=price:desc 搜索商品名称中包含yagao的商品，按照售价降序排序 适用于临时的在命令行使用一些工具，比如curl，快速的发出请求，来检索想要的信息；但是如果查询请求很复杂，是很难去构建的，在生产环境中，几乎很少使用query string search query DSL查询所有商品 1234GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; 查询名称包含yagao的商品，同时按照价格降序排序 1234567891011GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;name&quot; : &quot;yagao&quot; &#125; &#125;, &quot;sort&quot;: [ &#123; &quot;price&quot;: &quot;desc&quot; &#125; ]&#125; 分页查询商品，总共3条商品，假设每页就显示1条商品，现在显示第2页，所以就查出来第2个商品 123456GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;from&quot;: 1, &quot;size&quot;: 1&#125; 指定要查询出来商品的名称和价格 12345GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;_source&quot;: [&quot;name&quot;, &quot;price&quot;]&#125; 更加适合生产环境的使用，可以构建复杂的查询 query filter搜索商品名称包含yagao，而且售价大于25元的商品 1234567891011121314151617GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot; : &#123; &quot;bool&quot; : &#123; &quot;must&quot; : &#123; &quot;match&quot; : &#123; &quot;name&quot; : &quot;yagao&quot; &#125; &#125;, &quot;filter&quot; : &#123; &quot;range&quot; : &#123; &quot;price&quot; : &#123; &quot;gt&quot; : 25 &#125; &#125; &#125; &#125; &#125;&#125; full-text search（全文检索）1234567891011121314151617PUT &#x2F;ecommerce&#x2F;product&#x2F;4&#123; &quot;name&quot; : &quot;special yagao&quot;, &quot;desc&quot; : &quot;special meibai&quot;, &quot;price&quot; : 50, &quot;producer&quot; : &quot;special yagao producer&quot;, &quot;tags&quot;: [ &quot;meibai&quot;, &quot;fangzhu&quot; ]&#125;GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;producer&quot; : &quot;yagao producer&quot; &#125; &#125;&#125; special 4yagao 4producer 1,2,3,4gaolujie 1zhognhua 3jiajieshi 2 yagao producer ---&gt; 拆成yagao和producer,搜索结果根据score排序 phrase search（短语搜索）跟全文检索相对应，相反，全文检索会将输入的搜索串拆解开来，去倒排索引里面去一一匹配，只要能匹配上任意一个拆解后的单词，就可以作为结果返回phrase search，要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配，才能作为结果返回 12345678GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot; : &#123; &quot;match_phrase&quot; : &#123; &quot;producer&quot; : &quot;yagao producer&quot; &#125; &#125;&#125; highlight search（高亮搜索结果）12345678910111213GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;producer&quot; : &quot;producer&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;fields&quot; : &#123; &quot;producer&quot; : &#123;&#125; &#125; &#125;&#125; agg（聚合搜索）计算每个tag下的商品数量 12345678GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;aggs&quot;: &#123; &quot;group_by_tags&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;tags&quot; &#125; &#125; &#125;&#125; 报错：Fielddata is disabled on text fields by default. Set fielddata=true on [tags] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. 将文本field的fielddata属性设置为true 123456789PUT &#x2F;ecommerce&#x2F;_mapping&#x2F;product&#123; &quot;properties&quot;: &#123; &quot;tags&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fielddata&quot;: true &#125; &#125;&#125; GET /ecommerce/product/_search 12345678&#123; &quot;size&quot;: 0, # 不显示查询出来原始的doc &quot;aggs&quot;: &#123; &quot;all_tags&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;tags&quot; &#125; &#125; &#125;&#125; { “took”: 20, “timed_out”: false, “_shards”: { “total”: 5, “successful”: 5, “failed”: 0 }, “hits”: { “total”: 4, “max_score”: 0, “hits”: [] }, “aggregations”: { “group_by_tags”: { “doc_count_error_upper_bound”: 0, “sum_other_doc_count”: 0, “buckets”: [ { “key”: “fangzhu”, “doc_count”: 3 }, { “key”: “meibai”, “doc_count”: 2 }, { “key”: “qingxin”, “doc_count”: 1 } ] } }} 计算名称中包含yagao的商品，每个tag下的商品数量 GET /ecommerce/product/_search 1234567891011121314&#123; &quot;size&quot;: 0, &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;yagao&quot; &#125; &#125;, &quot;aggs&quot;: &#123; &quot;all_tags&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;tags&quot; &#125; &#125; &#125; 先分组，再算每组的平均值，计算每个tag下的商品的平均价格 GET /ecommerce/product/_search 12345678910111213&#123; &quot;size&quot;: 0, &quot;aggs&quot; : &#123; &quot;group_by_tags&quot; : &#123; &quot;terms&quot; : &#123; &quot;field&quot; : &quot;tags&quot; &#125;, &quot;aggs&quot; : &#123; &quot;avg_price&quot; : &#123; &quot;avg&quot; : &#123; &quot;field&quot; : &quot;price&quot; &#125; &#125; &#125; &#125; &#125;&#125; { “took”: 8, “timed_out”: false, “_shards”: { “total”: 5, “successful”: 5, “failed”: 0 }, “hits”: { “total”: 4, “max_score”: 0, “hits”: [] }, “aggregations”: { “group_by_tags”: { “doc_count_error_upper_bound”: 0, “sum_other_doc_count”: 0, “buckets”: [ { “key”: “fangzhu”, “doc_count”: 2, “avg_price”: { “value”: 27.5 } }, { “key”: “meibai”, “doc_count”: 2, “avg_price”: { “value”: 40 } }, { “key”: “qingxin”, “doc_count”: 1, “avg_price”: { “value”: 40 } } ] } }} 计算每个tag下的商品的平均价格，并且按照平均价格降序排序 GET /ecommerce/product/_search 12345678910111213&#123; &quot;size&quot;: 0, &quot;aggs&quot; : &#123; &quot;all_tags&quot; : &#123; &quot;terms&quot; : &#123; &quot;field&quot; : &quot;tags&quot;, &quot;order&quot;: &#123; &quot;avg_price&quot;: &quot;desc&quot; &#125; &#125;, &quot;aggs&quot; : &#123; &quot;avg_price&quot; : &#123; &quot;avg&quot; : &#123; &quot;field&quot; : &quot;price&quot; &#125; &#125; &#125; &#125; &#125;&#125; 按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格 123456789101112131415161718192021222324252627282930313233343536373839GET &#x2F;ecommerce&#x2F;product&#x2F;_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;group_by_price&quot;: &#123; &quot;range&quot;: &#123; &quot;field&quot;: &quot;price&quot;, &quot;ranges&quot;: [ &#123; &quot;from&quot;: 0, &quot;to&quot;: 20 &#125;, &#123; &quot;from&quot;: 20, &quot;to&quot;: 40 &#125;, &#123; &quot;from&quot;: 40, &quot;to&quot;: 50 &#125; ] &#125;, &quot;aggs&quot;: &#123; &quot;group_by_tags&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;tags&quot; &#125;, &quot;aggs&quot;: &#123; &quot;average_price&quot;: &#123; &quot;avg&quot;: &#123; &quot;field&quot;: &quot;price&quot; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://onejane.github.io/tags/elasticsearch/"}]},{"title":"Redis基本数据类型与应用场景","slug":"Redis基本数据类型与应用场景","date":"2021-05-09T09:05:24.000Z","updated":"2021-12-12T03:09:39.275Z","comments":true,"path":"2021/05/09/Redis基本数据类型与应用场景/","link":"","permalink":"http://onejane.github.io/2021/05/09/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 基本数据类型Redis作为内存中的数据结构存储系统,它可以用作数据库、缓存和消息中间件。它的 value支持多种类型的数据结构,基本数据结构包含:字符串( strings)、散列( hashes)、列表(ists)、集合(sets)、有序集合( sorted sets)五种。这五种数据结构在我们工作中经常使用到,面试过程中经常被问到,因此熟练掌握这5种基本数据结构的使用和应用场景是Redis知识最基础也是最重要的部分。 共同好友：set 用户积分排行榜：sorted set feed流：list … 字符串类型介绍字符串是 Redis最简单的储存类型,它存储的值可以是字符串、整数或者浮点数,对整个字符串或者字符串的其中一部分执行操作;对整数或者浮点数执行自增( increment)或者自减( decrement)操作。 Redis的字符串是一个由字节组成的序列,跟java里面的 ArrayList有点类似,采用预分配冗余空间的方式来减少内存的频繁分配,内部为当前字符串实际分配的空间 capacity一般要高于实际字符串长度len。当字符串长度小于1M时,扩容都是加倍现有的空间,如果超过1M,扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。 应用场景字符串类型在工作中使用广泛,主要用于不怎么更改但频繁查询的缓存数据,提高査询性能。比如存储登录用户信息、电商中存储商品信息、可以做计数器(想知道什么时候封锁一个IP地址(访问超过几次))等等。 123456789set username onejaneget usernamemset age 18 address suzhoumget username ageincr num decr numincrby num 2decrby num 2del num 散列散列相当于Java中的 HashMap,内部是无序字典。实现原理跟 HashMap一致。一个哈希表有多个节点,每个节点保存一个键值对。与Java中的 HashMap不同的是, rehash的方式不一样,因为Java的 HashMap在字典很大时, rehash是个耗时的操作,需要次性全部 rehash。 Redis为了高性能,不能堵塞服务,所以采用了渐进式 rehash策略。渐进式 rehash会在 rehash的同时,保留新旧两个hash结构,查询时会同时查询两个hash结构,然后在后续的定时任务中以及hash操作指令中,循序渐进地将旧hash的内容一点点迁移到新的hash结构中。当搬迁完成了,就会使用新的hash结。构取而代之当hash移除了最后一个元素之后,该数据结构自动被删除,内存被回收。 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://onejane.github.io/tags/redis/"}]},{"title":"Redis快速入门","slug":"Redis快速入门","date":"2021-05-08T18:26:01.000Z","updated":"2021-12-12T03:09:39.276Z","comments":true,"path":"2021/05/09/Redis快速入门/","link":"","permalink":"http://onejane.github.io/2021/05/09/Redis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 介绍优点高性能：底层C语言编写，内存数据库，通讯采用epoll非阻塞I/O多路复用机制 线程安全：单线程属于原子操作，高并发场景下保证数据安全。 redis 6.0多线程体现在网络协议解析。同步数据上，底层核心操作还是单线程的。 功能丰富： 数据结构：String,List,HashSet,SortedSet,GEO,BitMap,HyperLogLog 持久化：RDB持久化,AOF持久化,RDB-AOF混合持久化 主从：Master-Slave应对高并发场景，一般单机QPS都在几万左右，如果需要支撑高并发，我们可以将Redis做成主从架构来支持读写分离。 主从架构 -&gt; 读写分离 -&gt; 支撑10万+读QPS 并发10w以内：单节点读11w qps 写8.1w qps 10w-20w：读写分离 主从模式，为了主节点高可用，提供哨兵监控，为了降低各节点存储数据压力，提供集群模式 哨兵：主节点不能出现单点故障，哨兵机制Sentinel监控主节点，自动主从切换 集群：数据存储压力通过cluster分片存储，模块化实现自定义实现个性化需求 场景用户：注册，单点登录，签到 好友功能：关注，取消，互粉 排行榜：积分，热度排行榜 缓存：缓存餐厅数据 秒杀：预售，倒计时秒杀 订单：分布式锁 附近的人：地理位置搜索 Feed：添加，点赞，评论，列表 方案Springboot整合Redis SpringCloud搭建微服务 系统响应慢：连接池优化，用合适的数据类型缓存，慢日志查询，BigKey处理 缓存异常：分布式锁，LRU淘汰算法，通过限流等处理缓存雪崩，穿透。 数据丢失不安全：主从复制数据一致性，RDB-AOF混合持久化，全量/部分同步 主从复制故障：哨兵监控，主观/客观下线 存储不够用：集群分片存储，集群内部原理，故障自动转移 服务器宕机：集群动态收缩，moved/ask转向，故障演示与恢复方案 底层原理：网络底层，事务处理，持久化原理，主从复制原理，哨兵机制，分片存储原理 底层算法：Sorted Set底层，Bitmap、Geo算法，数据过期淘汰算法，Leader选举流程，槽位定位算法，备份迁移及其算法 性能提升方案：Key与Value设计规范，避免BigKey，避免耗时操作，Pipline管道操作，连接池性能优化，子进程的开销与优化 故障解决方案：数据延迟，数据脏读，数据抖动，数据一致性，热点数据存储，RDB文件损坏 版本说明 Redis2.6 键的过期时间支持毫秒 从节点支持只读功能 Redis2.8 可以用bind命令绑定多个IP地址 发布订阅添加了pub/sub Redis Sentienl第二版，相比于Redis2.6的RedisSentinel，已经变成生产可用 Redis3.0 添加Redis的分布式实现Redis Cluster Redis3.2 添加GEO相关功能 新List类型：quicklist Redis4.0 提供了模块系统,方便第三方开发者拓展 Redis的功能 提供了新的缓存剔除算法:LFU( Last Frequently Used),并对已有算法进行了优化。 提供了非阻塞del和 flushall/flushdb功能,有效解决删除了 bigKey可能造成的 Redis阻塞。 提供了RDB-AOF混合持久化格式,充分利用了AOF和RDB各自优势。 Redis5.0 新的 Stream数据类型。 客户经常连接和断开连接时性能更好。 Redis6.0 多线程IO，多线程部分只是用来处理网络数据的读写和协议解析,执行命令仍然是单线程。 支撑10w+qps特点 内存数据库,速度快,也支持数据的持久化 Redis不仅仅攴持简单的 key-value类型的数据,同时还提供 Lists、 Hashes、Sets、 Sorted Sets等多种数据结构的存储。 Redis支持数据的备份( master-slave)与集群(分片存储),以及拥有哨兵监控机制。 支持事务 优势 性能极高- Redis能读的速度是110000次/s,写的速度是81000次/s 丰富的数据类型- Redis支持 Strings、 Lists、 Hashes、Sets、 Sorted Sets等数据类型操作。 原子操作- Redis的所有操作都是原子性的,同时 Redis还支持对几个操作合并后的原子性执行(事务) 丰富的特性- Redis还支持 publish/subscribe,通知,key过期等特性 主节点一旦故障，无法写入数据，哨兵机制解决，奇数哨兵&gt;1/2重新选举主节点，避免网络波动误判 读写分离，每次写入都会复制，从节点也会拥有实际数据，每个节点都有大量重复数据，服务器压力大，集群分片解决 Redis、Memcached、Ehcache区别Ehcache不能很好实现分布式项目缓存的同步共享的问题 Memcached数据类型单一 这三个中间件都可以应用于缓存,但目前市面上使用 Redis的场景会更多,更广泛,其原因是: Redis性能高、原子操作、支持多种数据类型,主从复制与哨兵监控,持久化操作等 Redis的高并发官方的 bench-mark数据:测试完成了50个并发执行100000个请求,设置和获取的值是一个256字节字符串。结果:读的速度是110000次/s,写的速度是81000次/s,redis尽量少写多读,符合缓存的适用要求,单机 redis支撑万级,如果10万+可以采用主从复制的模式。 原理 Redis是纯内存数据库,没有磁盘IO，所以读取速度快。 Redis使用的是非阻塞I/O多路复用,减少了线程切换时上下文的切换和竞争。 Redis采用了单线程的模型,保证了每个操作的原子性,也减少了线程的上下文切换和竞争。 Redis存储结构多样化,不同的数据结构对数据存储进行了优化加快读取的速度。 Redis采用自己实现的事件分离器,效率比较高,内部采用非阻塞的执行方式,吞吐能力比较大 Redis的单线程原因 不需要各种锁的性能消耗 单线程多进程集群方案 CPU消耗 优劣单进程单线程优势 代码更清晰,处理逻辑更简单 不用去考虑各种锁的问题,不存在加锁释放锁操作,没有因为可能出现死锁而导致的性能消耗 不存在多进程或者多线程导致的切换而消耗CPU 单进程单线程弊端 无法发挥多核CPU性能,不过可以通过在单机开多个 Redis实例来完善 IO多路复用Redis采用网络IO多路复用技术来保证在多连接的时候系统高吞吐量，提高快速的写入和读取能力。 环境安装1234567891011121314151617181920212223242526272829303132wget -P &#x2F;usr&#x2F;local&#x2F;src&#x2F; https:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-6.0.9.tar.gz 下载redis-6.0.9tar zxvf redis-6.0.9.tar.gz 解压yum install -y gcc-c++ autoconf automake 安装redis-6.0.9必备依赖,升级gccyum install -y centos-release-scl scl-utils-buildyum install -y devtoolset-9-toolchainscl enable devtoolset-9 bashgcc -vcd redis-6.0.9&#x2F; &amp;&amp; make 编译mkdir -p &#x2F;usr&#x2F;local&#x2F;redismake PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis&#x2F; install 安装rediscd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;.&#x2F;redis-server 启动redis-servercp &#x2F;usr&#x2F;local&#x2F;src&#x2F;redis-6.0.9&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;vi redis.conf 打开守护进程daemonize yes.&#x2F;redis-server redis.conf 后台运行redisvi &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;redis.service[Unit]Description&#x3D;redis-serverAfter&#x3D;network.target[Service]Type&#x3D;forkingExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis.confPrivateTmp&#x3D;true[Install]WantedBy&#x3D;multi-user.targetsystemctl daemon-reloadsystemctl start redis.servicesystemctl stop redis.servicesystemctl enable redis.service 配置Redis支持很多的参数,但都有默认值。 daemonize默认情况下, redis不是在后台运行的,如果需要在后台运行,把该项的值更改为yes bind指定 Redis只接收来自于该IP地址的请求。 port监听端口,默认为6379。 databases设置数据库的个数,默认使用的数据库是0。 save设置 Redis进行数据库镜像的频率 filename镜像备份文件的文件名。 dir数据库镜像备份的文件放置的路径。 requirepass设置客户端连接后进行任何其他指定前需要使用的密码。 maxclients限制同时连接的客户数量。 maxmemory设置 redis能够使用的最大内存 客户端redis-cli1234567891011121314151617181920systemctl stop firewalldvi redis.confbind 0.0.0.0protected-mode norequirepass 123456systemctl restart redis.servicevim Vagrantfileconfig.vm.network &quot;private_network&quot;, type: &quot;dhcp&quot;vagrant reloadcd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;.&#x2F;redis-cli -h 172.28.128.3 -p 6379 -a 123456.&#x2F;redis-cli -a 123456select 2set username wjkeys *info CPUinfo clusterinfoflushall Redis Desktop Manager jedisRedis的Java客户端也有很多:https://redis.io/clients#java,其中比较受欢迎的是 Jedis和 Lettuce。 Jedis在实现上是直接连接的 redis server,如果在多线程环境下是非线程安全的,这个时候只有使用连接池,为毎个Jedis实例增加物理连接,官方推荐 Lettuce的连接是基于Netty的,连接实例( StatefulRedisConnection)可以在多个线程间并发访问,应为StatefulRedisConnection是线程安全的,所以一个连接实例( StatefulRedisconnection)就可以满足多线程环境下的并发访问,当然这个也是可伸缩的设计,一个连接实例不够的情况也可以按需增加连接实例。 在 Spring Boot Data Redis1.X之前默认使用的是 Jedis,但目前最新版的修改成了 Lettuce。 之前公司使用 Jedis居多, Lettuce近两年在逐步上升,总的来讲 Jedis的性能会优于 Lettuce(因为它是直接操作 Redis)。 pom引入依赖 1234567891011121314&lt;dependencies&gt; &lt;!--jedis客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt; &lt;version&gt;3.3.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.13&lt;&#x2F;version&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 测试 1234567891011121314151617181920212223242526272829303132333435public class JedisTest &#123; Jedis jedis &#x3D; null; @Before public void testInit()&#123; jedis &#x3D; new Jedis(&quot;172.28.128.3&quot;,6379);&#x2F;&#x2F; jedis.auth(&quot;123456&quot;); String pong &#x3D; jedis.ping(); System.out.println(pong); &#125; @Test public void testString()&#123; System.out.println(jedis.select(2)); System.out.println(jedis.set(&quot;username&quot;,&quot;onejane&quot;)); System.out.println(jedis.get(&quot;username&quot;)); jedis.set(&quot;user:name:1&quot;,&quot;j&quot;); System.out.println(jedis.get(&quot;user:name:1&quot;)); &#125; @Test public void testKeys()&#123; System.out.println(jedis.select(2)); System.out.println(jedis.keys(&quot;*&quot;)); System.out.println(jedis.flushAll()); &#125; @After public void close()&#123; if(null !&#x3D; jedis)&#123; jedis.close(); &#125; &#125;&#125; Jedis连接池优化 我们知道 Jedis是直接操作 Redis,当在并发量非常大的时候,那么 Jedis操作 Redis的连接数很有可能就会异常,因此为了提髙操作效率,引入连接池。 Jedis池化技术( JedisPool)在创建时初始化一些连接资源存储到连接池中,使用 Jadis连接资源时不需要创建,而是从连接池中获取一个资源进行 redis的操作,使用完毕后,不需要销毁该 jedis连接资源,而是将该资源归还给连接池,供其他请求使用。 1234567891011121314151617181920212223242526public class JedisPoolConnectRedis &#123; private static JedisPool jedisPool; static &#123; &#x2F;&#x2F; 创建连接池配置对象 JedisPoolConfig jedisPoolConfig &#x3D; new JedisPoolConfig(); &#x2F;&#x2F; 设置最大连接数 默认8 jedisPoolConfig.setMaxTotal(5); &#x2F;&#x2F; 设置最大空闲数量 默认8 jedisPoolConfig.setMaxIdle(5); &#x2F;&#x2F; 设置最少空闲数量 默认0 jedisPoolConfig.setMinIdle(0); &#x2F;&#x2F; 设置等待时间 ms jedisPoolConfig.setMaxWaitMillis(100); &#x2F;&#x2F; 初始化 JedisPool 对象 jedisPool &#x3D; new JedisPool(jedisPoolConfig,&quot;172.28.128.3&quot;,6379,100);&#x2F;&#x2F; jedisPool &#x3D; new JedisPool(jedisPoolConfig,&quot;172.28.128.3&quot;,6379,100,&quot;123456&quot;); &#125; &#x2F;** * 获取jedis对象 * @return *&#x2F; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; 修改测试生成jedis对象 12345678Jedis jedis &#x3D; null;@Beforepublic void testInit()&#123; jedis &#x3D; JedisPoolConnectRedis.getJedis(); &#x2F;&#x2F; jedis.auth(&quot;123456&quot;); String pong &#x3D; jedis.ping(); System.out.println(pong);&#125; spring-datapom添加依赖 12345678910111213141516171819202122232425262728293031323334 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3.10.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt; &lt;&#x2F;parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!--lettuce线程安全 打开commons-pool2依赖， spring.redis.jedis改成spring.redis.lettuce即可--&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;--&gt;&lt;!-- &lt;&#x2F;dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt; &lt;&#x2F;exclusion&gt; &lt;&#x2F;exclusions&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; application.yml添加配置 1234567891011121314151617181920spring: # redis配置 redis: host: 172.28.128.3 port: 6379 database: 5 # jedis连接池配置 jedis: pool: max-active: 8 max-idle: 8 min-idle: 0 max-wait: 1000# password: 123456# lettuce:# pool:# max-active: 8# max-idle: 8# min-idle: 0# max-wait: 1000 启动类添加Redis序列化方法 1234567891011121314151617181920@Beanpublic RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; redisTemplate &#x3D; new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(redisConnectionFactory); &#x2F;&#x2F; 使用Jackson2JsonRedisSerialize 替换默认序列化 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class); ObjectMapper objectMapper &#x3D; new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); &#x2F;&#x2F; 设置value的序列化规则和 key的序列化规则 redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); redisTemplate.afterPropertiesSet(); return redisTemplate;&#125; 测试 123456789101112131415161718@SpringBootTest&#x2F;&#x2F; 默认 (classes &#x3D; &#123;SpringdataDemoApplication.class&#125;)class SpringdataDemoApplicationTests &#123; @Autowired private RedisTemplate redisTemplate; @Test void testInit() &#123; System.out.println(redisTemplate.getConnectionFactory().getConnection().ping()); &#125; @Test public void testString()&#123; redisTemplate.opsForValue().set(&quot;username&quot;,&quot;onejane&quot;);; System.out.println(redisTemplate.opsForValue().get(&quot;username&quot;)); &#125;&#125; 微服务架构 food-social-contact-parent12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;properties&gt; &lt;spring-boot-version&gt;2.3.5.RELEASE&lt;&#x2F;spring-boot-version&gt; &lt;spring-cloud-version&gt;Hoxton.SR8&lt;&#x2F;spring-cloud-version&gt; &lt;lombok-version&gt;1.18.16&lt;&#x2F;lombok-version&gt; &lt;commons-lang-version&gt;3.11&lt;&#x2F;commons-lang-version&gt; &lt;mybatis-starter-version&gt;2.1.3&lt;&#x2F;mybatis-starter-version&gt; &lt;swagger-starter-version&gt;2.1.5-RELEASE&lt;&#x2F;swagger-starter-version&gt; &lt;hutool-version&gt;5.4.7&lt;&#x2F;hutool-version&gt; &lt;guava-version&gt;20.0&lt;&#x2F;guava-version&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;&lt;&#x2F;properties&gt;&lt;!-- 集中定义依赖，不引入 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- spring boot 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-boot-version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!-- spring cloud 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud-version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!-- lombok 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;lombok-version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- common-lang3 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;commons-lang-version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- mybatis 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mybatis-starter-version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- swagger 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.battcn&lt;&#x2F;groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;swagger-starter-version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- mysql 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!-- hutool 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt; &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;hutool-version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- guava 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt; &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;guava-version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt;&lt;!-- 集中定义项目所需插件 --&gt;&lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- spring boot maven 项目打包插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;pluginManagement&gt;&lt;&#x2F;build&gt; 注册中心ms-registry123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 配置 1234567891011121314server: port: 8080spring: application: name: ms-registry# 配置 Eureka Server 注册中心eureka: client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http:&#x2F;&#x2F;localhost:8080&#x2F;eureka&#x2F; 启动类添加注册中心注解@EnableEurekaServer 访问http://127.0.0.1:8080/ 查看注册到eureka的实例 网关ms-gateway12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 配置 123456789101112131415161718192021222324252627server: port: 80spring: application: name: ms-gateway cloud: gateway: discovery: locator: enabled: true # 开启配置注册中心进行路由功能 lower-case-service-id: true # 将服务名称转小写 routes: - id: ms-diners uri: lb:&#x2F;&#x2F;ms-diners predicates: - Path&#x3D;&#x2F;hello&#x2F;**# 配置 Eureka Server 注册中心eureka: instance: # 注册中心实例以ip显示 prefer-ip-address: true instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125; client: service-url: defaultZone: http:&#x2F;&#x2F;localhost:8080&#x2F;eureka&#x2F; 食客ms-diners12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 配置 123456789101112131415server: port: 8081spring: application: name: ms-diners# 配置 Eureka Server 注册中心eureka: instance: prefer-ip-address: true instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125; client: service-url: defaultZone: http:&#x2F;&#x2F;localhost:8080&#x2F;eureka&#x2F; Controller 12345678910@RestController@RequestMapping(&quot;hello&quot;)public class HelloController &#123; @GetMapping public String hello(String name) &#123; return &quot;hello &quot; + name; &#125;&#125; 直接访问 http://localhost:8081/hello?name=redis网关访问 http://localhost/hello?name=redis var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://onejane.github.io/tags/redis/"}]},{"title":"frida沙箱自吐实现","slug":"frida沙箱自吐实现","date":"2021-05-05T16:08:14.000Z","updated":"2021-12-12T03:09:39.283Z","comments":true,"path":"2021/05/06/frida沙箱自吐实现/","link":"","permalink":"http://onejane.github.io/2021/05/06/frida%E6%B2%99%E7%AE%B1%E8%87%AA%E5%90%90%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 沙箱沙箱：对于系统来说，单个APP是没有隐私的，不管是脱壳、还是收发包，都是由系统的API来执行的。HOOK系统的API，就能得到很多APP的关键信息。 APP想要对抗沙箱： 尽可能减少系统API的调用； 尽可能自己实现一定量的算法； 对自己实现的算法进行强混淆； 增加自身算法的复杂度吧：VMP 各大安全公司、杀毒软件公司基本上都会有自己的沙箱，只要病毒/木马在自己的沙箱跑一遍，直接得到执行流、病毒相似性分析，如绑绑安全的安全密钥白盒，对于APP也是一样的。 基于hook的沙箱Youpk Fart 都是沙箱,由于基于系统本身基本无法对抗。 appmonappmon wiki 123456789101112.&#x2F;fs128arm64 vim &#x2F;etc&#x2F;proxychains4.conf socks5 192.168.0.107 1080 # 电脑主机 ssr选项设置-开启来自局域网的连接PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pyenv install 3.8.2PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pip install frida&#x3D;&#x3D;12.8.0PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pip install frida-tools&#x3D;&#x3D;5.3.0PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pip install objection&#x3D;&#x3D;1.8.4proxychains wget https:&#x2F;&#x2F;github.com&#x2F;dpnishant&#x2F;appmon&#x2F;archive&#x2F;refs&#x2F;heads&#x2F;master.zip7z x master.zip cd appmon-master pip install argparse flask termcolor dataset --upgrade --ignore-installed sixpython appmon.py -a &quot;com.xiaojianbang.app&quot; -p android -s scripts&#x2F;Android 点击HookTestDemo.apk的算法加密按钮，触发生成./app_dumps/com.xiaojianbang.app.db 访问http://127.0.0.1:5000/ 选择com.xiaojianbang.app 由于显示内容都是[Object Object],修改源码打印hook内容。 12345data.value &#x3D; byteArraytoHexString(digest); 删除var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); 替换data.value &#x3D; ByteString.of(digest).hex()frida -UF -l Hash.js 基于源码的沙箱aosp810r1 解压驱动Vendor image 驱动GPS, Audio, Camera, Gestures, Graphics, DRM, Video, Sensors 解压驱动解压到aosp810r1中后./extrace-google_devices-sailfish.sh 和./extrace-qcom-sailfish.sh 123456789101112131415161718192021222324252627# apt update# git config --global user.email &quot;you@example.com&quot;# git config --global user.name &quot;Your Name&quot;# apt install bison tree# dpkg --add-architecture i386# apt update# apt install libc6:i386 libncurses5:i386 libstdc++6:i386# apt install libxml2-utilsdd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;swapfile bs&#x3D;1024 count&#x3D;10240000 使用dd创建swapfile作为swap分区空间mkswap swapfile mkswap创建交换文件Kali下手动安装openjdk-8-jdk：# wget http:&#x2F;&#x2F;http.kali.org&#x2F;pool&#x2F;main&#x2F;o&#x2F;openjdk-8&#x2F;openjdk-8-jdk-headless_8u212-b01-1_amd64.deb# dpkg -i openjdk-8-jdk-headless_8u212-b01-1_amd64.deb# wget http:&#x2F;&#x2F;http.kali.org&#x2F;pool&#x2F;main&#x2F;o&#x2F;openjdk-8&#x2F;openjdk-8-jdk_8u212-b01-1_amd64.deb# dpkg -i openjdk-8-jdk_8u212-b01-1_amd64.deb安装完成后再用：# update-alternatives --config java# update-alternatives --config javac选择2来切换jdk的版本：见图最后用version选项来确认版本：# java -version# javac -versionsource build&#x2F;envsetup.shlunch 选择24 aosp_sailfish-userdebugmake 编译完成的系统镜像位于当前目录的out&#x2F;target&#x2F;product&#x2F;sailfish&#x2F;下包括各个img 官方镜像 下载下来后解压将上面编译好的所有img替换到官方镜像解压后的image-sailfish-opm1.171019.011文件夹，并还原创建zip包 12adb reboot bootloader.&#x2F;flash-all.sh Android Studio 导入 AOSP 源码 development/tools/idegen/idegen.sh 会在根目录下生成android.iml 和 android.ipr 这两个文件，这两个文件是 Android Studio 的工程配置文件，这时候其实已经可以直接导入 Android Studio，但会导入所有的源码模块，会很慢，可以进行过滤，除了 frameworks 模块和 packages 模块，其他都给过滤掉，不导入 Android Studio，打开 android.iml 文件，搜下excludeFolder，在后面加入如下代码： 12345678910111213141516171819202122232425&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;art&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;bionic&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;bootable&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;build&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;cts&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;dalvik&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;developers&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;development&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;device&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;docs&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;external&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;hardware&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;kernel&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;libcore&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;libnativehelper&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;out&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;pdk&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;platform_testing&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;prebuilts&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;sdk&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;system&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;test&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;toolchain&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;tools&quot; &#x2F;&gt;&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;.repo&quot; &#x2F;&gt; 发现 Android Studio 不停 scanning files to index，我的强迫症又犯了，解决： invalidate and restart 不起作用； 右击项目 –&gt; Open module setting –&gt; Modules –&gt; 找到 gen 文件夹 –&gt; 右键选择 Resources，终于告别烦人的 scanning files to index。 修改MessageDigest.java crypto_filter_aosp基于android6.0.1 Nexus 6P ROM,系统底包 先刷官方原版底包，老版本使用fastboot6.0放到kali的/root/Android/Sdk/plateform-tools,flash-all.sh 手机先刷入fastbboot flash recovery twrp 下载rom解压，adb push ROM/ /sdcard/TWRP/BACKUPS 进入twrp，从备份中恢复Restore,重启手机,然后修改权限 chmod 777 /data/local/tmp/monitor_package 安装你需要监控的apk(系统自动把最后一次安装的apk添加进去监控的列表 /data/local/tmp/monitor_package),只能同时监控一个adb install HookTestDemo.apk /data/data/package_name/下面生成APK调用的算法,只有三种(数据均为JSON编码,字段为BASE64编码)/data/data/com.xiaojianbang.app 参考crypto_filter_aosp文件夹源码添加到aosp810r1的源码中，将MyUtil.java,ContextHolder.java,AndroidBase64.java,Cipher.java放到aosp810r1/libcore/ojluni/src/main/java/javax/crypto 将参考20200212/MessageDigest.java代码实现到aosp810r1的MessageDigest.java。同理，修改Mac.java openjdk_java_files.mk添加新增的需要编译的类 123ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;javax&#x2F;crypto&#x2F;Mac.java \\ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;javax&#x2F;crypto&#x2F;ContextHolder.java \\ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;javax&#x2F;crypto&#x2F;MyUtil.java \\ 123source build&#x2F;envsetup.shlunch aosp_sailfish-usermake 如报错make update-api 编译完成后将编译好的img压缩成image-sailfish-opm1.17019.011.zip放到官方系统底包，./flash-all.bat刷机 AOSP网络库自吐适用于沙箱的原则：我们要可以在安卓源码中找到其实现、彻底的修改其实现。 App开发实力越强，App自己实现的内容越多，对系统的依赖程度越低，沙箱的作用就越小。→ 沙箱只能帮助定位到关键的点，如何把内容解开还是分析自己实现的部分。 为了能抓到包，无数安全研究人员使出浑身解数，我们可以按照OSI七层模型或TCP/IP四层模型。 我们在谈论MAC地址/ARP的时候，我们聊的就是链路层； 我们在谈论IP地址/路由器的时候，我们聊的就是网络层； 我们在谈论连接某个端口的时候，我们聊的就是传输层； 我们在谈论发送数据的内容的时候，我们聊的就是应用层； 应用层/Application：基于中间人的HTTP(S)抓包 该方法继承于网页端的抓包，只不过对抗性全面强化；在设计网站时无法控制客户端，但是App确是可以被厂商全面控制的； 在客户端校验服务器证书的情况下，需要将抓包软件（推荐Charles）的证书置于手机根证书目录下，推荐Magisk插件Move Certificates； 在服务器验证客户端证书的情况下，还需要在App中dump出证书导入到Charles中，这就涉及到证书密码和证书的解密； App使用特定API，绕过WIFI代理进行通信→ 使用VPN将所有流量导入到Charles → App还会检测VPN，发现即断网 → 需要hook过VPN检测； 哪些是可以改的：（沙箱在辅助中间人抓包的过程中发挥的作用） Charles证书内置到系统根目录中去，某文件→某目录下（aosp810r1/system/ca-certificates/files） App的客户端证书的文件和密码，并不是所有的客户端证书都是必须以文件的形式、打开密码的要求存储的。可以是明文硬编码在代码里。(https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java，) 对抗部分：有没有使用No_ Proxy、VPN检测,某抢票app逆向续篇之干掉vpn抓包检测(System.getProperty(“http.proxyHost”); System.getProperty(“http.proxyPort”); java.net.NetworkInterface.getName(),android.net.ConnectivityManager.getNetworkCapabilities()) SSL pinning：从文件打开、哈希的计算处打调用栈 App使用SSL pinning，只信任自己的证书 → 从数十种框架中找到hook点并绕过 → App进行了代码混淆 → 反混淆并hook绕过，而反混淆总是让人倒吸一口凉气。。。 由于厂商可以全面控制客户端，因此可以使用小众协议，比如WebSocket、Protobuf，甚至自己写协议，比如腾讯的JceStruct，此时除了自己分析协议字段别无他法 传输层/Transport：App使用纯Socket通信 比如某应用的数据采用点对点纯Socket的tcp通信，此时只有dump其通信流量，分析其raw data，结合源码分析字段构成； 某厂商开创性地提出了自建代理长连通道的网络加速方案，App中绝大部分的请求通过CIP通道中的TCP子通道与长连服务器通信，长连服务器将收到的请求代理转发到业务服务器，对于业务来讲大大提高了效率，但是对于逆向来说却加大了抓包的难度。 也幸亏其SDK中包含了降级方案，可以hook某些关键函数实现降级到HTTP，给了安全研究员一口饭吃。更有大厂已经在通讯标准演进的路线上大步快跑，在目前HTTP/2都没有普及的情况下，受益于相比于网页端而言、App客户端全面可控的优势，提前迈入HTTP/3时代，在性能优化的KPI上一骑绝尘而去，从内核、算法、传输层网络库和服务端全部自研。 面对连抓包工具都没有提供支持的kQUIC，逆向分析者只能说欲哭无泪。同样还是幸亏SDK中包含了plan B降级方案，可以通过hook来进行降级，安全研究员续命一秒钟。 网络层/Network：一般而言鲜有App可以更改设备的IP地址 科学上网软件、VPN可以改手机的路由表，因此可以用来抓包； 可以自建路由器进行抓包，对手机完全无侵入、无感知，彻底搞定抓不到包！ 缺点是加密内容也无法还原，可以dump流量，却无法解密内容；在手机端连标准的SSL也解不开。也可以在手机上安装使用Kali Nethunter，在手机上直接跑Wireshark，接在4G流量卡上进行抓包，这种方式甚至可以抓到手机的流量卡的网卡包，应该是目前已知的唯一抓流量卡的方法。 应用层抓包通杀脚本 App在开发过程中，以App自己的权限，可以用代码实现到的最底层为传输层，也就用Socket接口，进行纯二进制的收发包，此处包括Java层和Native层。 除了少数开发实力雄厚甚至过剩的大厂，掌握着纯二进制收发包的传输层创新、或者自定义协议的技术之外，占绝对数量绝大多数的App厂商采用的还是传统的HTTP/SSL方案。 而且占绝对数量中绝大多数的App，其实现HTTP/SSL的方案也是非常的直白，那就是调用系统的API，或者调用更加易用的网络框架，比如访问网站的Okhttp框架，播放视频的Exoplayer，异步平滑图片滚动加载框架Glide，对于非网络库或协议等底层开发者来说，这些才应当是普罗大众安卓应用开发者的日常。 所以我们在对Java层Socket接口进行trace之后打调用栈，即可清晰地得出从肉眼可见的视频、到被封装成HTTP包、再到进入SSL进行加解密，再通过Socket与服务器进行通信的完整过程。 只要开发者使用了应用层框架，即无法避免的使用了系统的Socket进行了收发，如果是HTTP则直接走了Socket，没有加解密、直接是明文，将内容dump下来即可；如果走了HTTPS，那么HTTP包还要“裹上”一层SSL，通过SSL的接口进行收发，SSL则将加密后和解密前的数据走Socket与服务器进行通信，明文数据只有SSL库自己知道。 因此想要得到SSL加密前和解密后的HTTP数据的话，就要对SSL库有深入的研究，而像这种大型的、历史悠久的基础库，研究它的人是非常多的；比如谷歌就有研究员对OpenSSL的收发包接口进行了深入的研究，并对其收发包等接口使用frida进行hook，提取明文HTTP数据，最终的成品为ssl_logger项目；因为这种库一般作为互联网世界架构的基础设施，所以其应用非常广泛，这也是为何当其暴漏出“心脏滴血”漏洞时，几乎影响到所有互联网设备的原因，不管是Linux、Macos/iOS、还是安卓，使用的都是OpenSSL，刚刚我们trace到的SSLInputStream.read函数，充其量只是OpenSSL库在Java层的一个包装器罢了。 而又有来自阿里的巨佬，在使用的过程中，进一步优化了该项目的JS脚本，修复了在新版frida上的语法错误，并在原项目只支持Linux和macOS的基础上，增加了对iOS和Android的支持，最终的成品就是frida_ssl_logger项目。 该项目的完成度已经非常高，其核心原理就是对SSL_read和SSL_write进行hook，得到其收发包的明文数据。 12[Process.platform &#x3D;&#x3D; &quot;darwin&quot; ? &quot;*libboringssl*&quot; : &quot;*libssl*&quot;, [&quot;SSL_read&quot;, &quot;SSL_write&quot;, &quot;SSL_get_fd&quot;, &quot;SSL_get_session&quot;, &quot;SSL_SESSION_get_id&quot;]], &#x2F;&#x2F; for ios and Android[Process.platform &#x3D;&#x3D; &quot;darwin&quot; ? &quot;*libsystem*&quot; : &quot;*libc*&quot;, [&quot;getpeername&quot;, &quot;getsockname&quot;, &quot;ntohs&quot;, &quot;ntohl&quot;]] 并将明文数据使用RPC传输到电脑上，使用hexdump在python的控制台进行输出： 12345678910111213if verbose: src_addr &#x3D; socket.inet_ntop(socket.AF_INET, struct.pack(&quot;&gt;I&quot;, p[&quot;src_addr&quot;])) dst_addr &#x3D; socket.inet_ntop(socket.AF_INET, struct.pack(&quot;&gt;I&quot;, p[&quot;dst_addr&quot;])) print(&quot;SSL Session: &quot; + p[&quot;ssl_session_id&quot;]) print(&quot;[%s] %s:%d --&gt; %s:%d&quot; % ( p[&quot;function&quot;], src_addr, p[&quot;src_port&quot;], dst_addr, p[&quot;dst_port&quot;])) hexdump.hexdump(data) 或者保存至pcap文件，以供后续进一步分析。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def log_pcap(pcap_file, ssl_session_id, function, src_addr, src_port, dst_addr, dst_port, data): &quot;&quot;&quot;Writes the captured data to a pcap file. Args: pcap_file: The opened pcap file. ssl_session_id: The SSL session ID for the communication. function: The function that was intercepted (&quot;SSL_read&quot; or &quot;SSL_write&quot;). src_addr: The source address of the logged packet. src_port: The source port of the logged packet. dst_addr: The destination address of the logged packet. dst_port: The destination port of the logged packet. data: The decrypted packet data. &quot;&quot;&quot; t &#x3D; time.time() if ssl_session_id not in ssl_sessions: ssl_sessions[ssl_session_id] &#x3D; (random.randint(0, 0xFFFFFFFF), random.randint(0, 0xFFFFFFFF)) client_sent, server_sent &#x3D; ssl_sessions[ssl_session_id] if function &#x3D;&#x3D; &quot;SSL_read&quot;: seq, ack &#x3D; (server_sent, client_sent) else: seq, ack &#x3D; (client_sent, server_sent) for writes in ( # PCAP record (packet) header (&quot;&#x3D;I&quot;, int(t)), # Timestamp seconds (&quot;&#x3D;I&quot;, int((t * 1000000) % 1000000)), # Timestamp microseconds (&quot;&#x3D;I&quot;, 40 + len(data)), # Number of octets saved (&quot;&#x3D;i&quot;, 40 + len(data)), # Actual length of packet # IPv4 header (&quot;&gt;B&quot;, 0x45), # Version and Header Length (&quot;&gt;B&quot;, 0), # Type of Service (&quot;&gt;H&quot;, 40 + len(data)), # Total Length (&quot;&gt;H&quot;, 0), # Identification (&quot;&gt;H&quot;, 0x4000), # Flags and Fragment Offset (&quot;&gt;B&quot;, 0xFF), # Time to Live (&quot;&gt;B&quot;, 6), # Protocol (&quot;&gt;H&quot;, 0), # Header Checksum (&quot;&gt;I&quot;, src_addr), # Source Address (&quot;&gt;I&quot;, dst_addr), # Destination Address # TCP header (&quot;&gt;H&quot;, src_port), # Source Port (&quot;&gt;H&quot;, dst_port), # Destination Port (&quot;&gt;I&quot;, seq), # Sequence Number (&quot;&gt;I&quot;, ack), # Acknowledgment Number (&quot;&gt;H&quot;, 0x5018), # Header Length and Flags (&quot;&gt;H&quot;, 0xFFFF), # Window Size (&quot;&gt;H&quot;, 0), # Checksum (&quot;&gt;H&quot;, 0)): # Urgent Pointer pcap_file.write(struct.pack(writes[0], writes[1])) pcap_file.write(data) if function &#x3D;&#x3D; &quot;SSL_read&quot;: server_sent +&#x3D; len(data) else: client_sent +&#x3D; len(data) ssl_sessions[ssl_session_id] &#x3D; (client_sent, server_sent) 由于完成度已经相当高了，在构建安卓应用层抓包通杀脚本时，应当尽可能复用其已经实现好的“基础设施”，只要为其再补上明文数据即可，而这明文数据从哪里来？根据多轮trace可以得知，明文数据的收发包接口，正是由java.net.SocketOutputStream.socketWrite0和java.net.SocketInputStream.socketRead0这两个API负责的，当然其实二者还有很多上层调用的接口，在选择分析的接口时，应尽量选择离native层更近的、并且在更多安卓版本上适用的，比如这两个API在安卓7、8、9、10上是通用和不变的，以降低工作量。 最后的任务就是与SSL_read和SSL_write一样，根据收发的函数、找到收发的IP地址和端口，而正好两个API均有socket的实例域，提供了收发包的IP地址和端口信息。 最终就是取出这些信息，构造与SSL一样发给电脑即可，需要注意的是Java的[B需要手动转化成JavaScript的ByteArray还是略微复杂的。 123456789101112131415161718192021222324252627282930313233343536if (Java.available) &#123; Java.perform(function () &#123; Java.use(&quot;java.net.SocketOutputStream&quot;).socketWrite0.overload(&#39;java.io.FileDescriptor&#39;, &#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (fd, bytearry, offset, byteCount) &#123; var result &#x3D; this.socketWrite0(fd, bytearry, offset, byteCount); var message &#x3D; &#123;&#125;; message[&quot;function&quot;] &#x3D; &quot;HTTP_send&quot;; message[&quot;ssl_session_id&quot;] &#x3D; &quot;&quot;; message[&quot;src_addr&quot;] &#x3D; ntohl(ipToNumber((this.socket.value.getLocalAddress().toString().split(&quot;:&quot;)[0]).split(&quot;&#x2F;&quot;).pop())); message[&quot;src_port&quot;] &#x3D; parseInt(this.socket.value.getLocalPort().toString()); message[&quot;dst_addr&quot;] &#x3D; ntohl(ipToNumber((this.socket.value.getRemoteSocketAddress().toString().split(&quot;:&quot;)[0]).split(&quot;&#x2F;&quot;).pop())); message[&quot;dst_port&quot;] &#x3D; parseInt(this.socket.value.getRemoteSocketAddress().toString().split(&quot;:&quot;).pop()); var ptr &#x3D; Memory.alloc(byteCount); for (var i &#x3D; 0; i &lt; byteCount; ++i) Memory.writeS8(ptr.add(i), bytearry[offset + i]); send(message, Memory.readByteArray(ptr, byteCount)) return result; &#125; Java.use(&quot;java.net.SocketInputStream&quot;).socketRead0.overload(&#39;java.io.FileDescriptor&#39;, &#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (fd, bytearry, offset, byteCount, timeout) &#123; var result &#x3D; this.socketRead0(fd, bytearry, offset, byteCount, timeout); var message &#x3D; &#123;&#125;; message[&quot;function&quot;] &#x3D; &quot;HTTP_recv&quot;; message[&quot;ssl_session_id&quot;] &#x3D; &quot;&quot;; message[&quot;src_addr&quot;] &#x3D; ntohl(ipToNumber((this.socket.value.getRemoteSocketAddress().toString().split(&quot;:&quot;)[0]).split(&quot;&#x2F;&quot;).pop())); message[&quot;src_port&quot;] &#x3D; parseInt(this.socket.value.getRemoteSocketAddress().toString().split(&quot;:&quot;).pop()); message[&quot;dst_addr&quot;] &#x3D; ntohl(ipToNumber((this.socket.value.getLocalAddress().toString().split(&quot;:&quot;)[0]).split(&quot;&#x2F;&quot;).pop())); message[&quot;dst_port&quot;] &#x3D; parseInt(this.socket.value.getLocalPort()); if (result &gt; 0) &#123; var ptr &#x3D; Memory.alloc(result); for (var i &#x3D; 0; i &lt; result; ++i) Memory.writeS8(ptr.add(i), bytearry[offset + i]); send(message, Memory.readByteArray(ptr, result)) &#125; return result; &#125; &#125;)&#125; One more thing，虽然直接调用native层Socket的应用框架几乎没有；但是Javs层的Socket API是可以进一步下沉到C层的Socket，以支援so文件的socket抓包。以java.net.SocketOutputStream.socketWrite0举例，其native层的实现为JNIEXPORT void JNICALL 55SocketOutputStream_socketWrite0(JNIEnv *env, jobject this,jobject fdObj,jbyteArray data,jint off, jint len)（地址），其核心为一句话int n = NET_Send(fd, bufP + loff, llen, 0);，进一步追踪NET_Send可以在linux_close.cpp文件中找到其实现(地址)，本质上也是libc的send、sendto、recv、recvfrom这些，因此可以直接hook这些接口，捕获该进程的所有通信流量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int NET_Read(int s, void* buf, size_t len) &#123; BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );&#125; int NET_ReadV(int s, const struct iovec * vector, int count) &#123; BLOCKING_IO_RETURN_INT( s, readv(s, vector, count) );&#125; int NET_RecvFrom(int s, void *buf, int len, unsigned int flags, struct sockaddr *from, int *fromlen) &#123; socklen_t socklen &#x3D; *fromlen; BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, &amp;socklen) ); *fromlen &#x3D; socklen;&#125; int NET_Send(int s, void *msg, int len, unsigned int flags) &#123; BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );&#125; int NET_WriteV(int s, const struct iovec * vector, int count) &#123; BLOCKING_IO_RETURN_INT( s, writev(s, vector, count) );&#125; int NET_SendTo(int s, const void *msg, int len, unsigned int flags, const struct sockaddr *to, int tolen) &#123; BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );&#125; int NET_Accept(int s, struct sockaddr *addr, int *addrlen) &#123; socklen_t socklen &#x3D; *addrlen; BLOCKING_IO_RETURN_INT( s, accept(s, addr, &amp;socklen) ); *addrlen &#x3D; socklen;&#125; int NET_Connect(int s, struct sockaddr *addr, int addrlen) &#123; BLOCKING_IO_RETURN_INT( s, connect(s, addr, addrlen) );&#125; #ifndef USE_SELECTint NET_Poll(struct pollfd *ufds, unsigned int nfds, int timeout) &#123; BLOCKING_IO_RETURN_INT( ufds[0].fd, poll(ufds, nfds, timeout) );&#125;#elseint NET_Select(int s, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout) &#123; BLOCKING_IO_RETURN_INT( s-1, select(s, readfds, writefds, exceptfds, timeout) );&#125; 只是如果hook native层的这些接口的话，会混进openssl/boringssl的经过加密的流量，届时会比较难以区分，所以其实duck不必下降到native层，Java层的通信足以覆盖99%以上的场景（这个百分比是我估计的）。 最终也就是现在的效果：r0capture：安卓应用层抓包通杀脚本，地址：https://github.com/r0ysue/r0capture 仅限安卓平台，测试安卓7、8、9、10 可用 ； 无视所有证书校验或绑定，不用考虑任何证书的事情； 通杀TCP/IP四层模型中的应用层中的全部协议； 通杀协议包括：Http,WebSocket,Ftp,Xmpp,Imap,Smtp,Protobuf等等、以及它们的SSL版本； 通杀所有应用层框架，包括HttpUrlConnection、Okhttp1/3/4、Retrofit/Volley等等； 用法 Spawn 模式： 1$ python3 r0capture.py -U -f com.qiyi.video Attach 模式，抓包内容保存成pcap文件供后续分析： 1$ python3 r0capture.py -U com.qiyi.video -p iqiyi.pcap 建议使用Attach模式，从感兴趣的地方开始抓包，并且保存成pcap文件，供后续使用Wireshark进行分析。 PS：用来抓注册包，效果尤佳。 To-do： 此处还是有部分开发实力过强的大厂或框架，采用的是自身的SSL框架，比如WebView、小程序或Flutter，这部分目前暂未支持。当然这部分App也是少数。 暂不支持HTTP/2、或HTTP/3，该部分API在安卓系统上暂未普及或布署，为App自带，无法进行通用hook。 各种模拟器架构、实现、环境较为复杂，建议珍爱生命、使用真机。 暂未添加多进程支持，比如:service或:push等子进程，可以使用Frida的Child-gating来支持一下。 支持多进程之后要考虑pcap文件的写入锁问题，可以用frida-tool的Reactor线程锁来支持一下。 TCP/IP中可以实现的部分： 网络层：可以拿到所有的收发包。效果同Wireshark。如果是明文，其实效果跟传输层是一样的。非明文、跟传输层也是一样的。 传输层：可以拿到所有（应用层）的收发包，明文→明文；java.net.SocketInputStream.socketRead0、java.net.SocketOutputStream.socketWrite0都是native函数，意味着 应用层非明文→非明文：SSLInputStream.read 应用层2：com.android.okhttp.internal.http.HttpURLConnectionImpl SSL安装HttpSocket 123objection -g com.onejane.httpsocket exploreandroid hooking search ssl 将所有打印出的类放到sslandroid8.txt中，前面批量加上android hooking watch class objection -g com.onejane.httpsocket explore -c sslandroid8.txt 批量hook，报错ClassLoader就删除包括ClassLoader类 android hooking watch class com.android.org.conscrypt.OpenSSLBIOInputStreamandroid hooking watch class com.android.org.conscrypt.OpenSSLCipherandroid hooking watch class com.android.org.conscrypt.OpenSSLCipher$EVP_CIPHERandroid hooking watch class com.android.org.conscrypt.OpenSSLCipher​$EVP_CIPHER​$AESandroid hooking watch class com.android.org.conscrypt.OpenSSLCipher​$EVP_CIPHER​$AES​$CBCandroid hooking watch class com.android.org.conscrypt.OpenSSLCipher$EVP_CIPHER$AES$CBC$PKCS5Paddingandroid hooking watch class com.android.org.conscrypt.OpenSSLCipher$EVP_CIPHER$AES_BASEandroid hooking watch class com.android.org.conscrypt.OpenSSLContextImpl … 在安卓8上结果 (agent) [lrxbzy1b2ea] Called javax.net.ssl.HttpsURLConnection.getDefaultHostnameVerifier()(agent) [lrxbzy1b2ea] Called javax.net.ssl.HttpsURLConnection.getDefaultSSLSocketFactory()(agent) [lrxbzy1b2ea] Called javax.net.ssl.HttpsURLConnection.getDefaultSSLSocketFactory()(agent) [nrgnn66lv3e] Called com.android.org.conscrypt.OpenSSLSocketImpl.isClosed()(agent) [nrgnn66lv3e] Called com.android.org.conscrypt.OpenSSLSocketImpl.isInputShutdown()(agent) [nrgnn66lv3e] Called com.android.org.conscrypt.OpenSSLSocketImpl.isOutputShutdown()(agent) [42lol483nwl] Called com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write([B, int, int)(agent) [nrgnn66lv3e] Called com.android.org.conscrypt.OpenSSLSocketImpl.isClosed()(agent) [43hq04cbdn1] Called com.android.org.conscrypt.SslWrapper.write(java.io.FileDescriptor, [B, int, int, int)(agent) [yz4ikx9fcpb] Called com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read([B, int, int)(agent) [nrgnn66lv3e] Called com.android.org.conscrypt.OpenSSLSocketImpl.isClosed()(agent) [43hq04cbdn1] Called com.android.org.conscrypt.SslWrapper.read(java.io.FileDescriptor, [B, int, int, int) android hooking watch class_method com.android.org.conscrypt.ConscryptFileDescriptorSocket.$init 在安卓10上结果 (agent) [4816499695697] Called javax.net.ssl.HttpsURLConnection.getDefaultHostnameVerifier()com.roysue.httpsocket on (google: 10) [usb] #(agent) [4816499695697] Called javax.net.ssl.HttpsURLConnection.getDefaultSSLSocketFactory()(agent) [4816499695697] Called javax.net.ssl.HttpsURLConnection.getDefaultSSLSocketFactory()com.roysue.httpsocket on (google: 10) [usb] # (agent) [2575726777846] Called com.android.org.conscrypt.OpenSSLSocketImpl.isClosed()(agent) [2575726777846] Called com.android.org.conscrypt.OpenSSLSocketImpl.isInputShutdown()(agent) [2575726777846] Called com.android.org.conscrypt.OpenSSLSocketImpl.isOutputShutdown()(agent) [4979599214099] Called com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write([B, int, int)(agent) [2575726777846] Called com.android.org.conscrypt.OpenSSLSocketImpl.isClosed()(agent) [1105531481296] Called com.android.org.conscrypt.NativeSsl.write(java.io.FileDescriptor, [B, int, int, int)(agent) [1105531481296] Called com.android.org.conscrypt.NativeSsl.isClosed()(agent) [7367730933988] Called com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read([B, int, int)(agent) [2575726777846] Called com.android.org.conscrypt.OpenSSLSocketImpl.isClosed()(agent) [1105531481296] Called com.android.org.conscrypt.NativeSsl.read(java.io.FileDescriptor, [B, int, int, int)(agent) [1105531481296] Called com.android.org.conscrypt.NativeSsl.isClosed() frida -UF -l hookSocket.js 打印http抓包的结果 12plugin wallbreaker objectsearch com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStreamplugin wallbreaker objectdump --fullname 0x3486 1234567891011121314151617181920212223242526272829303132333435function hook_SSLsocketandroid8()&#123; Java.perform(function()&#123; console.log(&quot;hook_SSLsocket&quot;) Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); &#x2F;&#x2F; console.log(&quot;HTTPS write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) &#x2F;&#x2F; var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); &#x2F;&#x2F; console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) &#x2F;&#x2F;console.log(jhexdump(bytearry,int1,int2)); &#x2F;&#x2F; console.log(jhexdump(bytearry)); &#x2F;&#x2F; com.android.org.conscrypt.ConscryptFileDescriptorSocket this$0 console.log(this.this$0.value.sslSession.value.peerHost.value) console.log(this.this$0.value.sslSession.value.peerPort.value) console.log(this.this$0.value.sslSession.value.getProtocol()) console.log(this.this$0.value.sslSession.value.getRequestedServerName()) console.log(JSON.stringify( this.this$0.value.sslSession.value.getStatusResponses())) console.log(this.this$0.value.sslSession.value.getValueNames().toString()) return result; &#125; &#x2F;&#x2F; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; &#x2F;&#x2F; var result &#x3D; this.read(bytearry,int1,int2); &#x2F;&#x2F; console.log(&quot;HTTPS read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) &#x2F;&#x2F; var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); &#x2F;&#x2F; console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) &#x2F;&#x2F; &#x2F;&#x2F;console.log(jhexdump(bytearry,int1,int2)); &#x2F;&#x2F; &#x2F;&#x2F; console.log(jhexdump(bytearry)); &#x2F;&#x2F; return result; &#x2F;&#x2F; &#125; &#125;)&#125; frida 14 android hooking watch class_method com.android.org.conscrypt.ConscryptFileDescriptorSocket.$init objection -g com.onejane.httpsocket explore -s “android hooking watch class_method com.android.org.conscrypt.ConscryptFileDescriptorSocket.$init” Fileappmon中用到的API。12.8.0报错就切到14.*,frida -UF -l HTTP.js和frida -UF -l Storage.js和frida -UF -l SharedPreferences.js Mobile-Security-Framework-MobSF 123objection -g comoolapk.market explore -s &quot;android hooking watch class android.content.ContextWrapper&quot; 下载app查看agent用到的apiandroid hooking watch class_method android.content.ContextWrapper.getDataDir --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method android.content.ContextWrapper.getCacheDir --dump-args --dump-backtrace --dump-return 1234frida-ps -U|grep -i gravityobjection -g com.ceco.oreo.gravitybox exploreandroid hooking watch class android.app.SharedPreferencesImplandroid hooking watch class_method android.app.SharedPreferencesImpl.getString --dump-args --dump-backtrace --dump-return 通杀123456789objection -g comoolapk.market exploreandroid hooking search classes Fileandroid hooking watch class java.io.Fileandroid hooking watch class_method java.io.File.getPath --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method java.io.File.delete --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method java.io.File.exists --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method java.io.File.list --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method java.io.File.getName --dump-args --dump-backtrace --dump-returncat objection.log | grep Return java.io.Filejava.lang.String 1234567891011android hooking watch class java.lang.String android hooking watch class_method java.lang.String.toString --dump-args --dump-return 安卓8android hooking watch class_method java.lang.String.equals --dump-args --dump-return 安卓10android hooking watch class_method java.lang.StringBuilder.$init --dump-args --dump-returnandroid hooking watch class android.telephony.TelephonyManager 获取硬件信息plugin wallbreaker objectsearch android.telephony.TelephonyManagerplugin wallbreaker objectdump 0x4563plugin wallbreaker classdump android.os.Buildandroid hooking watch class_method android.telephony.TelephonyManager.getDeviceId --dump-args --dump-backtrace --dump-returnfrida -U -f com.coolapk.market -l File.js --no-pause -o file.txtfrida -UF -l File.js --no-pause -o file.txt 利用Frida修改Android设备的唯一标识符 修改Build.java 12345678910111213141516171819202122232425262728private static String getString(String property) &#123; String result &#x3D; SystemProperties.get(property, UNKNOWN) ; if(property.equals(&quot;ro.product.brand&quot;))&#123; result &#x3D; new String(&quot;r0ysueBRAND&quot;); &#125;else if(property.equals((&quot;ro.product.manufacturer&quot;)))&#123; result &#x3D; new String(&quot;r0ysueMANUFACTUERER&quot;); &#125;else if(property.equals(&quot;ro.product.board&quot;))&#123; result &#x3D; new String(&quot;r0ysueBOARD&quot;); &#125;else if(property.equals(&quot;no.such.thing&quot;))&#123; result &#x3D; new String(&quot;r0ysueAAAABBBBCCCCDDDD&quot;); &#125; Exception e &#x3D; new Exception(&quot;r0ysueFINGERPRINT&quot;); e.printStackTrace(); return result;&#125;@RequiresPermission(Manifest.permission.READ_PHONE_STATE)public static String getSerial() &#123; IDeviceIdentifiersPolicyService service &#x3D; IDeviceIdentifiersPolicyService.Stub .asInterface(ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE)); try &#123; String result &#x3D;service.getSerial(); return &quot;r0ysueserial1234&quot;; &#125; catch (RemoteException e) &#123; e.rethrowFromSystemServer(); &#125; return UNKNOWN;&#125; 修改TelephonyManager.java 123456789101112131415161718192021222324252627282930@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)public String getSimSerialNumber(int subId) &#123; try &#123; IPhoneSubInfo info &#x3D; getSubscriberInfo(); String resutlt &#x3D; info.getIccSerialNumberForSubscriber(subId, mContext.getOpPackageName()); if (info &#x3D;&#x3D; null) return null; return &quot;r0ysueSERIALAAAABBBB&quot;; &#125; catch (RemoteException ex) &#123; return null; &#125; catch (NullPointerException ex) &#123; &#x2F;&#x2F; This could happen before phone restarts due to crashing return null; &#125;&#125;@Deprecated@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)public String getDeviceId() &#123; try &#123; ITelephony telephony &#x3D; getITelephony(); String result &#x3D; telephony.getDeviceId(mContext.getOpPackageName()); if (telephony &#x3D;&#x3D; null) return null; return &quot;r0ysueIMEI&quot;; &#125; catch (RemoteException ex) &#123; return null; &#125; catch (NullPointerException ex) &#123; return null; &#125;&#125; . build/envsetup.sh lunch aosp_bullhead-user m 替换编译生成img到官方镜像包中，重新打包成image-bullhead-opm1.171019.011.zip ./flash-all.sh 指纹识别技术安全分析 对抗 不检测root，检测aosp，正常人不会用aosp，App可以通过判断java.net.NetworkInterface.getName()是否等于“tun0”或“ppp0”来判断是否存在VPN。Bypass也很简单，hook该api使其返回“rmnet_data1”，即可达到过vpn检测目的。 风险控制笔记 自制沙箱检测Android虚拟机的方法和代码实现 2020年安卓源码编译指南 Android 应用多开对抗实践 使用手机连接charles的代理，chsl.pro/ssl安装证书。 123456cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added 查看新安装的证书a27a90a2.0cp a27a90a2.0 &#x2F;sdcard&#x2F;Downloadcd Desktop&#x2F;asop810r1&#x2F;system&#x2F;ca-certificates&#x2F;filesadb pull &#x2F;sdcard&#x2F;Download&#x2F;a27a90a2.0. build&#x2F;envsetup.shlunch aosp_bullhead-user 编译，没有root，使用user-debug有root 修改KeyStore.java 123456789101112131415161718192021222324252627282930313233343536373839404142public final void load(InputStream stream, char[] password) throws IOException, NoSuchAlgorithmException, CertificateException &#123; if (password !&#x3D; null) &#123; String inputPASSWORD &#x3D; new String(password); Class logClass &#x3D; null; try &#123; logClass &#x3D; this.getClass().getClassLoader().loadClass(&quot;android.util.Log&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method loge &#x3D; null; try &#123; loge &#x3D; logClass.getMethod(&quot;e&quot;, String.class, String.class); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; try &#123; loge.invoke(null, &quot;r0ysueKeyStoreLoad&quot;, &quot;KeyStore load PASSWORD is &#x3D;&gt; &quot; + inputPASSWORD); Exception e &#x3D; new Exception(&quot;r0ysueKeyStoreLoad&quot;); e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; Date now &#x3D; new Date(); String currentTime &#x3D; String.valueOf(now.getTime()); FileOutputStream fos &#x3D; new FileOutputStream(&quot;&#x2F;sdcard&#x2F;Download&#x2F;&quot; + inputPASSWORD + currentTime); byte[] b &#x3D; new byte[1024]; int length; while ((length &#x3D; stream.read(b)) &gt; 0) &#123; fos.write(b, 0, length); &#125; fos.flush(); fos.close(); &#125; keyStoreSpi.engineLoad(stream, password); initialized &#x3D; true;&#125; 修改SocketOutputStream.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private void socketWrite(byte b[], int off, int len) throws IOException &#123; if (len &lt;&#x3D; 0 || off &lt; 0 || len &gt; b.length - off) &#123; if (len &#x3D;&#x3D; 0) &#123; return; &#125; throw new ArrayIndexOutOfBoundsException(&quot;len &#x3D;&#x3D; &quot; + len + &quot; off &#x3D;&#x3D; &quot; + off + &quot; buffer length &#x3D;&#x3D; &quot; + b.length); &#125; FileDescriptor fd &#x3D; impl.acquireFD(); try &#123; BlockGuard.getThreadPolicy().onNetwork(); socketWrite0(fd, b, off, len); if(len&gt;0)&#123; byte[] input &#x3D; new byte[len]; System.arraycopy(b,off,input,0,len); String inputString &#x3D; new String(input); Class logClass &#x3D; null; try &#123; logClass &#x3D; this.getClass().getClassLoader().loadClass(&quot;android.util.Log&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method loge &#x3D; null; try &#123; loge &#x3D; logClass.getMethod(&quot;e&quot;,String.class,String.class); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; try &#123; loge.invoke(null,&quot;r0ysueSOCKETrequest&quot;,&quot;Socket is &#x3D;&gt; &quot;+this.socket.toString()); loge.invoke(null,&quot;r0ysueSOCKETrequest&quot;,&quot;buffer is &#x3D;&gt; &quot;+inputString); Exception e &#x3D; new Exception(&quot;r0ysueSOCKETrequest&quot;); e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (SocketException se) &#123; if (se instanceof sun.net.ConnectionResetException) &#123; impl.setConnectionResetPending(); se &#x3D; new SocketException(&quot;Connection reset&quot;); &#125; if (impl.isClosedOrPending()) &#123; throw new SocketException(&quot;Socket closed&quot;); &#125; else &#123; throw se; &#125; &#125; finally &#123; impl.releaseFD(); &#125;&#125;SocketOutputStream 修改SocketInputStream.java 12345678910111213141516171819202122232425262728293031323334353637private int socketRead(FileDescriptor fd, byte b[], int off, int len, int timeout) throws IOException &#123; int result &#x3D; socketRead0(fd, b, off, len, timeout); if(result&gt;0)&#123; byte[] input &#x3D; new byte[result]; System.arraycopy(b,off,input,0,result); String inputString &#x3D; new String(input); Class logClass &#x3D; null; try &#123; logClass &#x3D; this.getClass().getClassLoader().loadClass(&quot;android.util.Log&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method loge &#x3D; null; try &#123; loge &#x3D; logClass.getMethod(&quot;e&quot;,String.class,String.class); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; try &#123; loge.invoke(null,&quot;r0ysueSOCKETresponse&quot;,&quot;Socket is &#x3D;&gt; &quot;+this.socket.toString()); loge.invoke(null,&quot;r0ysueSOCKETresponse&quot;,&quot;buffer is &#x3D;&gt; &quot;+inputString); Exception e &#x3D; new Exception(&quot;r0ysueSOCKETresponse&quot;); e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; return result;&#125; 修改SslWrapper.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869int read(FileDescriptor fd, byte[] buf, int offset, int len, int timeoutMillis) throws IOException &#123; int result &#x3D; NativeCrypto.SSL_read(ssl, fd, handshakeCallbacks, buf, offset, len, timeoutMillis) ; if(result&gt;0)&#123; byte[] input &#x3D; new byte[result]; System.arraycopy(buf,offset,input,0,result); String inputString &#x3D; new String(input); Class logClass &#x3D; null; try &#123; logClass &#x3D; this.getClass().getClassLoader().loadClass(&quot;android.util.Log&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method loge &#x3D; null; try &#123; loge &#x3D; logClass.getMethod(&quot;e&quot;,String.class,String.class); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; try &#123; loge.invoke(null,&quot;r0ysueSOCKETresponse&quot;,&quot;SSL is &#x3D;&gt;&quot;+this.handshakeCallbacks.toString()); loge.invoke(null,&quot;r0ysueSOCKETresponse&quot;,&quot;buffer is &#x3D;&gt; &quot;+inputString); Exception e &#x3D; new Exception(&quot;r0ysueSOCKETresponse&quot;); e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; return result; &#125; void write(FileDescriptor fd, byte[] buf, int offset, int len, int timeoutMillis) throws IOException &#123; if(len&gt;0)&#123; byte[] input &#x3D; new byte[len]; System.arraycopy(buf,offset,input,0,len); String inputString &#x3D; new String(input); Class logClass &#x3D; null; try &#123; logClass &#x3D; this.getClass().getClassLoader().loadClass(&quot;android.util.Log&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method loge &#x3D; null; try &#123; loge &#x3D; logClass.getMethod(&quot;e&quot;,String.class,String.class); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; try &#123; loge.invoke(null,&quot;r0ysueSSLrequest&quot;,&quot;SSL is &#x3D;&gt; &quot;+this.handshakeCallbacks.toString()); loge.invoke(null,&quot;r0ysueSSLrequest&quot;,&quot;buffer is &#x3D;&gt; &quot;+inputString); Exception e &#x3D; new Exception(&quot;r0ysueSSLrequest&quot;); e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; NativeCrypto.SSL_write(ssl, fd, handshakeCallbacks, buf, offset, len, timeoutMillis); &#125; 编译好后，刷机，安装soul使用chales抓包,查看logcat中Keystore加载的Password，下载下来的证书改名为soul.p12安装实现App客户端证书文件和密码自吐 12make update-api 由于修改了文件，更新apim 甲方风控实用FRIDA进阶：内存漫游、hook anywhere、抓包 r0capturegit clone https://github.com/r0ysue/r0capture.git 仅限安卓平台，测试安卓7、8、9、10、11 可用 ； 无视所有证书校验或绑定，不用考虑任何证书的事情； 通杀TCP/IP四层模型中的应用层中的全部协议； 通杀协议包括：Http,WebSocket,Ftp,Xmpp,Imap,Smtp,Protobuf等等、以及它们的SSL版本； 通杀所有应用层框架，包括HttpUrlConnection、Okhttp1/3/4、Retrofit/Volley等等； 无视加固，不管是整体壳还是二代壳或VMP，不用考虑加固的事情； python r0capture.py -U cn.soulapp.android -v python r0capture.py -U -f com.qiyi.video -v frida -UF -l hookSSLSocket.js frida -U -f cn.soulapp.android -l saveClientCet.js –no-pause 增加客户端证书dump功能 adb pull /sdcard/Download/ff93e99.p12 证书转换工具 支持bks to p12 把安卓转成Charles支持的p12 charles-Proxy-SSL Proxying Settings-Client Certificates-Create Secure Store-设置自定义密码，配置Host/Port为*对任何IP任何端口使用该证书，Import P12-填入SSL Certificate Password,即抓到的key密码 为沙箱增加调用栈dump证书 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function hook_KeyStore_load() &#123; Java.perform(function () &#123; var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); var myArray&#x3D;new Array(1024); var i &#x3D; 0 for (i &#x3D; 0; i &lt; myArray.length; i++) &#123; myArray[i]&#x3D; 0x0; &#125; var buffer &#x3D; Java.array(&#39;byte&#39;,myArray); var StringClass &#x3D; Java.use(&quot;java.lang.String&quot;); var KeyStore &#x3D; Java.use(&quot;java.security.KeyStore&quot;); KeyStore.load.overload(&#39;java.security.KeyStore$LoadStoreParameter&#39;).implementation &#x3D; function (arg0) &#123; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(&quot;KeyStore.load1:&quot;, arg0); this.load(arg0); &#125;; KeyStore.load.overload(&#39;java.io.InputStream&#39;, &#39;[C&#39;).implementation &#x3D; function (arg0, arg1) &#123; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(&quot;KeyStore.load2:&quot;, arg0, arg1 ? StringClass.$new(arg1) : null); if (arg0)&#123; var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(&quot;&#x2F;sdcard&#x2F;Download&#x2F;&quot;+ String(arg0)+&quot;.p12&quot;); var out &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); var r; while( (r &#x3D; arg0.read(buffer)) &gt; 0)&#123; out.write(buffer,0,r) &#125; console.log(&quot;save success!&quot;) out.close() &#125; this.load(arg0, arg1); &#125;; console.log(&quot;hook_KeyStore_load...&quot;);&#x2F;&#x2F; android.content.res.AssetManager$AssetInputStream@9b10ad6 bxMAFPL9gc@ntKTqmV@A&#x2F;&#x2F; android.content.res.AssetManager$AssetInputStream@41ce8f6 &#125;%2R+\\OSsjpP!w%X&#x2F;&#x2F; android.content.res.AssetManager$AssetInputStream@54858e6 cods.org.cn &#125;);&#125; 重新使用charles即可抓到soul包 1234567objection -g cn.soulapp.android explore android hooking search classes keystore 将打印的类放到文keystore.txt件中，批量hook,前面加上android hooking watch classobjection -g cn.soulapp.android explore -c keystore.txtplugin wallbreaker objectsearch java.security.KeyStore$PrivateKeyEntryplugin wallbreaker objectdump --fullname 0x0123uandroid hooking watch class_method java.security.KeyStore$PrivateKeyEntry.getCertificateChain --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method java.security.KeyStore$PrivateKeyEntry.getPrivateKey --dump-args --dump-backtrace --dump-return QtScrCpy 手机投屏 Linux版 12apt install libsdl2-2.0-0.&#x2F;run x 为沙箱增加客户端证书DUMP的功能 1234567frida -U -f cn.soulapp.android -l 2021trace.js --no-pause -o traceresult.txt 查看java.security.KeyStore$PrivateKeyEntry的调用栈objection -g cn.soulapp.android explore plugin load &#x2F;root&#x2F;Desktop&#x2F;Wallbreakerplugin wallbreaker objectsearch java.security.KeyStore$PrivateKeyEntryplugin wallbreaker objectdump --fullname 0x123f 查看KeyStore$PrivateKeyEntry类的privateKey和publicKeyandroid heap search instances java.security.KeyStore$PrivateKeyEntryandroid heap execute 0x2ce7 getPrivateKey() 主动调用 js实现,frida -U- f cn.soulapp.android -l savePrivateKey.js --no-pause 打开app后查看/data/local/tmp/soul下的证书文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960setImmediate(function () &#123; Java.perform(function () &#123; console.log(&quot;Entering&quot;) Java.use(&quot;java.security.KeyStore$PrivateKeyEntry&quot;).getPrivateKey.implementation &#x3D; function () &#123; console.log(&quot;Calling java.security.KeyStore$PrivateKeyEntry.getPrivateKey method &quot;) var result &#x3D; this.getPrivateKey() console.log(&quot;toString result is &#x3D;&gt; &quot;, result.toString()) storeP12(this.getPrivateKey(),this.getCertificate(),&#39;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;soul&#39;+uuid(10,16)+&#39;.p12&#39;,&#39;hello&#39;); return result; &#125; Java.use(&quot;java.security.KeyStore$PrivateKeyEntry&quot;).getCertificateChain.implementation &#x3D; function () &#123; console.log(&quot;Calling java.security.KeyStore$PrivateKeyEntry.getCertificateChain method &quot;) var result &#x3D; this.getCertificateChain() storeP12(this.getPrivateKey(),this.getCertificate(),&#39;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;soul&#39;+uuid(10,16)+&#39;.p12&#39;,&#39;hello&#39;); return result; &#125; &#125;)&#125;)function storeP12(pri, p7, p12Path, p12Password) &#123; var X509Certificate &#x3D; Java.use(&quot;java.security.cert.X509Certificate&quot;) var p7X509 &#x3D; Java.cast(p7, X509Certificate); var chain &#x3D; Java.array(&quot;java.security.cert.X509Certificate&quot;, [p7X509]) var ks &#x3D; Java.use(&quot;java.security.KeyStore&quot;).getInstance(&quot;PKCS12&quot;, &quot;BC&quot;); ks.load(null, null); ks.setKeyEntry(&quot;client&quot;, pri, Java.use(&#39;java.lang.String&#39;).$new(p12Password).toCharArray(), chain); try &#123; var out &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(p12Path); ks.store(out, Java.use(&#39;java.lang.String&#39;).$new(p12Password).toCharArray()) &#125; catch (exp) &#123; console.log(exp) &#125;&#125;function uuid(len, radix) &#123; var chars &#x3D; &#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#39;.split(&#39;&#39;); var uuid &#x3D; [], i; radix &#x3D; radix || chars.length; if (len) &#123; &#x2F;&#x2F; Compact form for (i &#x3D; 0; i &lt; len; i++) uuid[i] &#x3D; chars[0 | Math.random() * radix]; &#125; else &#123; &#x2F;&#x2F; rfc4122, version 4 form var r; &#x2F;&#x2F; rfc4122 requires these characters uuid[8] &#x3D; uuid[13] &#x3D; uuid[18] &#x3D; uuid[23] &#x3D; &#39;-&#39;; uuid[14] &#x3D; &#39;4&#39;; &#x2F;&#x2F; Fill in random data. At i&#x3D;&#x3D;19 set the high bits of clock sequence as &#x2F;&#x2F; per rfc4122, sec. 4.1.5 for (i &#x3D; 0; i &lt; 36; i++) &#123; if (!uuid[i]) &#123; r &#x3D; 0 | Math.random() * 16; uuid[i] &#x3D; chars[(i &#x3D;&#x3D; 19) ? (r &amp; 0x3) | 0x8 : r]; &#125; &#125; &#125; return uuid.join(&#39;&#39;);&#125; adb pull /data/local/tmp 使用KeyStore Explorer打开，密码是hello charles-手机连接代理-SSL Proxying Settings-Client Certificates-Add-Import P12-密码hello-Host和Port配置*，启动Postern,启动soul成功抓包 adb install dida.apk 通过top查看包名cn.ticktick.task 1objection -g cn.ticktick.task explore -s &quot;android hooking watch class_method java.io.File.\\$init --dump-args --dump-return --dump-backtrace&quot; frida -U -f cn.ticktick.task -l sslpinninghelper.js --no-pause 打印证书路径 123456789101112131415setImmediate(function()&#123; Java.perform(function()&#123; Java.use(&quot;java.io.File&quot;).$init.overload(&#39;java.io.File&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function(file,cert)&#123; var result &#x3D; this.$init(file,cert) var stack &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()); if(file.getPath().indexOf(&quot;cacert&quot;)&gt;0 &amp;&amp; stack.indexOf(&quot;X509TrustManagerExtensions.checkServerTrusted&quot;)&gt; 0)&#123; console.log(&quot;path,cart&quot;,file.getPath(), cert) console.log(stack); &#125; return result; &#125; &#125;)&#125;) SSL pinning helper 帮助定位证书绑定的关键代码，在服务器校验客户端的情形下，帮助dump客户端证书，并保存为p12的格式 pm -l | grep -i soul pm -l | grep -i ticktick pip install hexdump python r0capture.py -U -f cn.soulapp.android -v &gt;&gt;sout.txt 重新抓包，frida 14.0.8 python r0capture.py -U -f cn.ticktick.task -v &gt;&gt;tick.txt 框架层抓包沙箱SslWrapper.java 的修改等同于hook Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;)实现定位收发包函数的功能。 基于trace的内存漫游确认Java.use(&quot;java.security.KeyStore$PrivateKeyEntry&quot;).getCertificateChain客户端证书dump导出功能。 增加混淆后的SSLping代码定位功能stack.indexOf(&quot;X509TrustManagerExtensions.checkServerTrusted&quot;) 抓包沙箱植入根证书绕过客户端校验服务器，cd aosp810r1/system/ca-certificates/files 根证书目录，将charles的证书下载到该文件目录下，编译生成镜像，形成中间人 抓包沙箱导出客户端证书绕过服务器校验客户端，KeyStore.java有个内部方法PrivateKeyEntry KeyStore.java 去除上面自制沙箱时 public final void load(InputStream stream, char[] password)的修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public PrivateKey getPrivateKey() &#123; String p12Password &#x3D; &quot;r0ysue&quot;; Date now &#x3D; new Date(); String currentTime &#x3D; String.valueOf(now.getTime()); String p12Path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&quot; + currentTime + &quot;.p12&quot;; X509Certificate p7X509 &#x3D; (X509Certificate) chain[0]; Certificate[] mychain &#x3D; new Certificate[]&#123;p7X509&#125;; &#x2F;&#x2F; 生成一个空的p12证书 KeyStore myks &#x3D; null; try &#123; myks &#x3D; KeyStore.getInstance(&quot;PKCS12&quot;, &quot;BC&quot;); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (NoSuchProviderException e) &#123; e.printStackTrace(); &#125; try &#123; myks.load(null, null); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F; 将服务器返回的证书导入到p12中去 try &#123; myks.setKeyEntry(&quot;client&quot;, privKey, p12Password.toCharArray(), mychain); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F; 加密保存p12证书 FileOutputStream fOut &#x3D; null; try &#123; fOut &#x3D; new FileOutputStream(p12Path); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; try &#123; myks.store(fOut, p12Password.toCharArray()); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; return privKey; &#125; 抓包沙箱之定位(混淆后的)SSLpinning代码，修改File.java,去除上面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public File(File parent, String child) &#123; if (child &#x3D;&#x3D; null) &#123; throw new NullPointerException(); &#125; if (parent !&#x3D; null) &#123; if (parent.path.equals(&quot;&quot;)) &#123; this.path &#x3D; fs.resolve(fs.getDefaultParent(), fs.normalize(child)); &#125; else &#123; this.path &#x3D; fs.resolve(parent.path, fs.normalize(child)); &#125; &#125; else &#123; this.path &#x3D; fs.normalize(child); &#125; Class logClass &#x3D; null; try &#123; logClass &#x3D; this.getClass().getClassLoader().loadClass(&quot;android.util.Log&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method loge &#x3D; null; Method getStackTraceString &#x3D; null; try &#123;&#x2F;&#x2F; loge &#x3D; logClass.getMethod(&quot;e&quot;, String.class, String.class); getStackTraceString &#x3D; logClass.getMethod(&quot;getStackTraceString&quot;,Throwable.class); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; try &#123;&#x2F;&#x2F; loge.invoke(null, &quot;r0ysueKeyStoreLoad&quot;, &quot;KeyStore load PASSWORD is &#x3D;&gt; &quot; + inputPASSWORD); String stack &#x3D; (String)getStackTraceString.invoke(null,new Throwable()); if (parent.getPath().indexOf(&quot;cacert&quot;) &gt;&#x3D; 0 &amp;&amp; stack.indexOf(&quot;X509TrustManagerExtensions.checkServerTrusted&quot;) &gt;&#x3D; 0) &#123; Exception e &#x3D; new Exception(&quot;r0ysueFileSSLpinning&quot;); e.printStackTrace(); &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; this.prefixLength &#x3D; fs.prefixLength(this.path); &#125; 编译刷机 12lunch aosp_bullhead-userm 编译完更新system.img到官方镜像bullhead刷机 默认系统报错400 No required SSL certificate was sent,导入证书到SSLProxying Setting才能正确抓到soul包 绕过滴答 frida -U -f cn.ticktick.task -l bypassPinning.js --no-pause默认报错trust the Charles Root Certificate ,客户端收到charles的证书，计算公钥hash后比对结果决定发请求结果。 123456789setImmediate(function()&#123; Java.perform(function()&#123; console.log(&quot;Bypassing&quot;) Java.use(&quot;z1.g&quot;).a.implementation &#x3D; function()&#123; console.log(&quot;called here&quot;) return; &#125; &#125;)&#125;) HTTPS客户端证书多重证书绑定咪咕视频登录抓包，SSL handshake with client failed: An unknown issue occurred processing the certificate (certificate_unknown)从抓包发现证书 绑定,可能客户端只信任信任的公钥签名，不信任就不允许，停止客户端访问的证书绑定。客户端发了，我们已经绕过了校验，把自己公钥发给charles，charles用自己私钥解开客户端的公钥发现不正常的结果。 123456dumpsys activity top 查看包名 com.ophone.reader.uiobjection -g com.ophone.reader.ui exploreandroid sslpinning disable 需要在启动时运行objection -g com.ophone.reader.ui explore -s &quot;android sslpinning disable&quot; 在点我登录页面触发解绑定，如果崩溃objection -g com.ophone.reader.ui explore 在点我登录时开始漫游android sslpinning disable 解绑定后再获取验证码，再抓包 证书绑定的逻辑没有hook掉：”at com.bangcle.andjni.JniLib.cL(Native Method)” → 只有逆代码来过证书绑定 1python r0capture.py -U com.ophone.reader.ui -v -p migu.pcap 关闭postern抓包,获取验证码没有更新log，说明没有一些底层的框架 通过wireshark查看migu.pcap结果，发现也没有关键性信息，抓包也抓不到。 123456python r0capture.py -U -f com.ophone.reader.ui -v 尝试导出证书frida -U -f com.ophone.reader.ui -l script.js --no-pauseadb shell 查看sdcard&#x2F;Download下的证书adb pull &#x2F;sdcard&#x2F;Download&#x2F;ophone 下的证书导入到Charles的SSL Proxying Settings中，打开postern抓包objection -g com.ophone.reader.ui explore 在点我登录时开始漫游android sslpinning disable 解绑定后再获取验证码抓包即可获取passport.migu.cn:8443的包信息 SSL handshake with server failed - Remote host terminated the handshakeThe remote SSL server rejected the connection. The server may require a specific certificate or cipher not supported by Charles. 过客户端证书后发现更多证书绑定,Frida.Android.Practice 1objection -g com.ophone.reader.ui explore -s &quot;android sslpinning disable&quot; git clone https://github.com/WooyunDota/DroidSSLUnpinning.git 1frida -U -f com.ophone.reader.ui -l hooks.js --no-pause 抓发送验证码包依旧有请求失败 FRIDA 使用经验交流分享，git clone https://github.com/deathmemory/FridaContainer.git 1234cd utils&#x2F;androidfrida -U -f com.ophone.reader.ui -l multi_unpinning.js --no-pauseobjection -g com.ophone.reader.ui explore -s &quot;android hooking watch class_method java.io.File.\\$init --dump-args --dump-backtrace --dump-return&quot; 查看证书frida -U -f com.ophone.reader.ui -l trace.js --no-pause -o ophone.txt 修改trace.js中traceClass(&quot;java.io.File&quot;),在traceClass中修改targets&#x3D;[]只trace init方法,在traceMethod中打开调用栈android.util.log，发送验证码后查看文件,搜索cacert查看调用栈 北京银行1234python r0capture.py -U -f com.bankofbeijing.mobilebanking -v.&#x2F;hluda-server-14.2.1-android-arm64frida -U -f com.bankofbeijing.mobilebanking -l script.js --no-pause -o bjbank.txtfrida -U -f com.bankofbeijing.mobilebanking -l trace.js --no-pause -o bjbank2.txt 打开traceClass(&quot;java.security.KeyStore$PrivateKeyEntry&quot;) 加固厂商自定义开发的证书绑定对抗很难被攻克。 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"ssl","slug":"ssl","permalink":"http://onejane.github.io/tags/ssl/"},{"name":"aosp","slug":"aosp","permalink":"http://onejane.github.io/tags/aosp/"}]},{"title":"魔改系统源码编译","slug":"魔改系统源码编译","date":"2021-05-04T08:18:45.000Z","updated":"2021-12-12T03:09:39.339Z","comments":true,"path":"2021/05/04/魔改系统源码编译/","link":"","permalink":"http://onejane.github.io/2021/05/04/%E9%AD%94%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 环境frida pixel(salfish)+官方8.1.0_r1+twrp3.3.0+Magisk+Frida pixel(salfish)+twrp3.3.0+lineage16.0+addonsu16.0 xposed pixel(salfish)+官方7.1.2_r8+twrp3.2.1-0+SuperSU+XposedInstaller fart同aosp pixel(salfish)+最新fastboot+fart8.1.0 n6p(angler)+老fastboot+fart8.1.0 NetHunter n6p(angler)+原生8.1.0_r1+twrp3.3.1+SuoerSU 编译aosp刷机环境准备123456789# apt update# git config --global user.email &quot;you@example.com&quot;# git config --global user.name &quot;Your Name&quot;# apt install bison tree# dpkg --add-architecture i386# apt update# apt install libc6:i386 libncurses5:i386 libstdc++6:i386# apt install libxml2-utilsapt install nethogs 查看流量由哪个进程产生 android版本列表 同步清华 同步中科大 编译内存不足加swap 123456789101112131415161718192021222324252627282930313233343536dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;swapfile bs&#x3D;1024 count&#x3D;10240000 使用dd创建swapfile作为swap分区空间mkswap swapfile mkswap创建交换文件## 下载repo工具mkdir ~&#x2F;binPATH&#x3D;~&#x2F;bin:$PATHcurl https:&#x2F;&#x2F;storage.googleapis.com&#x2F;git-repo-downloads&#x2F;repo &gt; ~&#x2F;bin&#x2F;repo## 如果上述 URL 不可访问，可以用下面的：## curl -sSL &#39;https:&#x2F;&#x2F;gerrit-googlesource.proxy.ustclug.org&#x2F;git-repo&#x2F;+&#x2F;master&#x2F;repo?format&#x3D;TEXT&#39; |base64 -d &gt; ~&#x2F;bin&#x2F;repochmod a+x ~&#x2F;bin&#x2F;repomkdir COMPILEcd COMPILE## 初始化仓库：repo init -u git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;aosp&#x2F;platform&#x2F;manifest## 如果提示无法连接到 gerrit.googlesource.com，可以编辑 ~&#x2F;bin&#x2F;repo，把 REPO_URL 一行替换成下面的：## REPO_URL &#x3D; &#39;https:&#x2F;&#x2F;gerrit-googlesource.proxy.ustclug.org&#x2F;git-repo&#39;## 如果需要某个特定的 Android 版本：repo init -u git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;aosp&#x2F;platform&#x2F;manifest -b android-7.1.2_r8或者wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;aosp-monthly&#x2F;aosp-latest.tartar xf aosp-latest.tar## 同步源码树（以后只需执行这条命令来同步）：## 默认线程数4，可增加repo sync -j8# 下载java8 或者 apt install openjdk-8-jdkwget https:&#x2F;&#x2F;download.java.net&#x2F;openjdk&#x2F;jdk8u41&#x2F;ri&#x2F;openjdk-8u41-b04-linux-x64-14_jan_2020.tar.gz# 解压到&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;openjdk8&#x2F;#修改.zshrcnano ~&#x2F;.zshrc# 在zshrc中加入下面内容export JAVA_HOME&#x3D;&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;openjdk8&#x2F;java-se-8u41-riexport PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATHexport CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar 编译刷机7z x aosp712r8 7.62g 驱动下载 注意版本一致，在aosp712r8目录下解压安装 ./extrace-google_devices-sailfish.sh 和./extrace-qcom-sailfish.sh不装驱动，编译后没有vender 1234export LC_ALL&#x3D;C 编译前执行命令去除本地化设置cd COMPILE&#x2F;aosp712r8source build&#x2F;envsetup.sh 导入环境变量chsh -s &#x2F;bin&#x2F;bash 提示只支持bash，但kali2021默认是zsh，用zsh可能会导致编译版本不对，需要改成bash 重启-选择设备 1234lunch 选择版本18 aosp_sailfish_userdebug# j后面参数可以选则核心数*2make -j8 开始，编译完成的系统镜像位于当前目录的out&#x2F;target&#x2F;product&#x2F;sailfish&#x2F;下包括各个imgwhich fastboot 查看fastboot位置 关机+音量- 进入fastboot unzip sailfish-n2g47o-factory-f2bc8024.zip 将上面编译好的boot.img,ramdisk.img,ramdisk-recovery.img,system.img,system_other.img,userdata.img拷贝到解压后的image-sailfish-n2g47o.zip 删除所有镜像，保留android-info.txt，压缩image-sailfish-n2g47o下所有内容，压缩包名称与flash-all.sh里的内容匹配，压缩包内不要有文件夹zip -j image-sailfish-n2g47o.zip ./image-sailfish-n2g47o/* ./flush-all.sh 开始刷机 记一次安卓系统源码下载过程 记一次安卓系统源码编译刷机过程 记一次安卓内核源码编译刷机过程(修改反调试标志位) 编译原版Xposed刷机XPOSED魔改一：获取特征 123456mkdir XPOSEDgit clone https:&#x2F;&#x2F;github.com&#x2F;rovo89&#x2F;XposedInstaller.git xposed框架安装工具git clone https:&#x2F;&#x2F;github.com&#x2F;rovo89&#x2F;XposedBridge.git xposed框架java部分git clone https:&#x2F;&#x2F;github.com&#x2F;rovo89&#x2F;android_art.git android 5.0及以上用art虚拟机，对这部分的修改git clone https:&#x2F;&#x2F;github.com&#x2F;rovo89&#x2F;XposedTools.git 打包编译xposed框架git clone https:&#x2F;&#x2F;github.com&#x2F;rovo89&#x2F;Xposed.git xposed框架native部分 android-studio编译XposedInstaller 1234cd ~&#x2F;Android&#x2F;Sdk&#x2F;build-tools&#x2F;23.0.3.&#x2F;aaptapt-file search libz.so.1apt install lib32z1 下载的android_art复制到aosp712r8目录，用android_art替换原art重命名为art文件夹 1234export LC_ALL&#x3D;Csource build&#x2F;envsetup.shlunch 18make -j8 XposedBridge编译生成的apk改名为XposedBridge.jar放到/root/Desktop/COMPILE/aosp712r8/out/java/ XposedTools目录，cp build.conf.example ./build.conf修改配置文件build.conf 1234567891011121314151617181920212223242526272829[General]# 输出目录outdir &#x3D; &#x2F;root&#x2F;Desktop&#x2F;COMPILE&#x2F;aosp712r8&#x2F;out&#x2F;# xposedBridge.jar目录javadir &#x3D; &#x2F;root&#x2F;Desktop&#x2F;COMPILE&#x2F;aosp712r8&#x2F;out&#x2F;java&#x2F;[Build]# Please keep the base version number and add your custom suffix# 版本version &#x3D; 89 (custom build by xyz &#x2F; %s)# 编译时线程数makeflags &#x3D; -j8[GPG]sign &#x3D; releaseuser &#x3D; 852109AA!# Root directories of the AOSP source tree per SDK version[AospDir]# api版本和aosp源码目录25 &#x3D; &#x2F;root&#x2F;Desktop&#x2F;COMPILE&#x2F;aosp712r8&#x2F;# SDKs to be used for compiling BusyBox# Needs https:&#x2F;&#x2F;github.com&#x2F;rovo89&#x2F;android_external_busybox[BusyBox]# api版本一致arm &#x3D; 25x86 &#x3D; 25armv5 &#x3D; 25 下载Xposed复制到 aosp712r87/frameworks/base/cmds目录 安装perl包 12345678910111213141516apt-get install libauthen-ntlm-perlapt-get install libclass-load-perlapt-get install libcrypt-ssleay-perlapt-get install libdata-uniqid-perlapt-get install libdigest-hmac-perlapt-get install libdist-checkconflicts-perlapt-get install libfile-copy-recursive-perlapt-get install libfile-tail-perlapt-get install libconfig-inifiles-perlperl -MCPAN -e &#39;install Config::IniFiles&#39;perl -MCPAN -e &#39;install File::ReadBackwards&#39;perl -MCPAN -e &#39;install File::Tail&#39;cpaninstall Archive::Zipexit.&#x2F;build.pl -t arm64:25 hook远程url，修改xposed下载源 1234frida-ps -U | grep -i xposedobjection -g de.robv.android.xposed.installer exploreandroid hooking watch class de.robv.android.xposed.installer.util.DownloadsUtil --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method de.robv.android.xposed.installer.util.DownloadsUtil.getDownloadTargetForUrl --dump-args --dump-backtrace --dump-return 点击install触发打印调用栈 修改DownloadsUtil是setUrl方法中的mUrl的值为本地的zip地址，zip包目录：aosp712r8/out/sdk25/arm64/，apt install lighttpd Android.mk没找到ART.mk，路径问题，修改Android.mk最下面ART.mk路径改成绝对路径 魔改Xposed去特征定制Xposed框架 XposedBridge通过Gradle工具jarStubs和jarStubsSource编译生成的XposedBridge/app/build/api/api.jar替换xposed的项目的libs下的api.jar build.gradle compileOnly files(&#39;libs/api.jar&#39;) 修改XposedInstaller中的包名xposed为xppsed，所有的de.robv.android.xposed.installer改成de.robv.android.xppsed.installer，所有的/su/xposed/xposed.prop和/system/xposed.prop的xposed.prop改成xppsed.prop 修改XposedBridged的包名xposed改为xppsed，所有的de.robv.android.xposed改成所有的de.robv.android.xppsed，build好后的XposedBridge后包app-release-unsigned.apk的名字改成XppsedBridge.jar 进入aosp712r87/frameworks/base/cmds/xposed/ 修改libxposed_common.h 123#define CLASS_XPOSED_BRIDGE &quot;de&#x2F;robv&#x2F;android&#x2F;xppsed&#x2F;XposedBridge&quot;#define CLASS_ZYGOTE_SERVICE &quot;de&#x2F;robv&#x2F;android&#x2F;xppsed&#x2F;services&#x2F;ZygoteService&quot;#define CLASS_FILE_RESULT &quot;de&#x2F;robv&#x2F;android&#x2F;xppsed&#x2F;services&#x2F;FileResult&quot; 修改xposed.h 12345#define XPOSED_PROP_FILE &quot;&#x2F;system&#x2F;xppsed.prop&quot;#define XPOSED_LIB_ART XPOSED_LIB_DIR &quot;libxppsed_art.so&quot;#define XPOSED_JAR &quot;&#x2F;system&#x2F;framework&#x2F;XppsedBridge.jar&quot;#define XPOSED_CLASS_DOTS_ZYGOTE &quot;de.robv.android.xppsed.XposedBridge&quot;#define XPOSED_CLASS_DOTS_TOOLS &quot;de.robv.android.xppsed.XposedBridge$ToolEntryPoint&quot; 修改xposed_service.cpp 1IMPLEMENT_META_INTERFACE(XposedService, &quot;de.robv.android.xppsed.IXposedService&quot;); 修改xposed_shared.h 12#define XPOSED_DIR &quot;&#x2F;data&#x2F;user_de&#x2F;0&#x2F;de.robv.android.xppsed.installer&#x2F;&quot;#define XPOSED_DIR &quot;&#x2F;data&#x2F;data&#x2F;de.robv.android.xppsed.installer&#x2F;&quot; 修改libxposed_art.cpp名为libxppsed_art.cpp 修改ART.mk libxposed_art改成libxppsed_art 进入XposedTools 修改build.pl xposed.prop改成xppsed.prop XposedBridge.jar改成XppsedBridge.jar libxposed_art改成libxppsed_art grep -ril “xposedbridge.jar” * 找到所有包含的文件flash-script.sh等文件中的有上述xposed.prop，XposedBridge.jar，libxposed_art改掉即可。 1.&#x2F;build.pl -t arm64:25 重新编译生成路径aosp712r8&#x2F;out&#x2F;sdk25&#x2F;arm64下的zip包改成xposed-v89-sdk25-arm64.zip apt install lighttpd &amp;&amp; service lighttpd start cp xposed-v89-sdk25-arm64.zip /var/www/html/ 手机端访问192.168.0.102/xposed-v89-sdk25-arm64.zip (虚拟机) 可以直接下载 安装XposedInstaller(DownloadsUtil下的setUrl的mUrl改为虚拟机下载)进入Install界面进行安装xposed框架 adb install xposed_checker_app 过检测 开发新的xposed模块时，移除libs下的api.jar使用XposedBridge通过jarStubs生成的api.jar，更改代码中的de.robv.android.xppsed… var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"xposed","slug":"xposed","permalink":"http://onejane.github.io/tags/xposed/"}]},{"title":"Xposed主动调用开发","slug":"Xposed主动调用开发","date":"2021-05-01T07:39:54.000Z","updated":"2021-12-12T03:09:39.281Z","comments":true,"path":"2021/05/01/Xposed主动调用开发/","link":"","permalink":"http://onejane.github.io/2021/05/01/Xposed%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%BC%80%E5%8F%91/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 相比于Frida，Xposed在参数的构造上是更有优势的,因为它就是使用的Java进行的开发； hook(想通过hook的方式得到一个obj的话需要hook一个实例方法) constructor.newInstance xposed.newInstance 案例Qualification分析adb install Qualification-1.3-easy-release.apk 目标就是找到pin的真实值 jadx-gui Qualification-1.3-easy-release.apk 搜索not the 找不到可能的结果，弹窗可能存在于dialog_failure或者dialog_success 查看strings.xml中定义的变量，&lt;string name=&quot;dialog_failure&quot;&gt;Unfortunately, not the right PIN :(&lt;/string&gt; 通过hookEvent.js进行hook所有动作触发的组件，找到android.support.v7.app.AppCompatViewInflater$DeclaredOnClickListener jadx中搜索android.support.v7.app.AppCompatViewInflater.DeclaredOnClickListener,使用了系统框架，无法准确定位最近的方法。 1234objection -g org.teamsik.ahe17.qualification.easy explore -P ~&#x2F;.objection&#x2F;plugins AndroidManifest.xml拿到包名开始objectionandroid hooking search classes MainActivityandroid hooking list class_methods org.teamsik.ahe17.qualification.MainActivity android hooking watch class org.teamsik.ahe17.qualification.MainActivity 点击VERIFY PIN按钮触发事件 根据org.teamsik.ahe17.qualification.MainActivity.verifyPasswordClick触发hook verifyPasswordClick 1android hooking watch class_method org.teamsik.ahe17.qualification.MainActivity.verifyPasswordClick --dump-args --dump-backtrace --dump-return 12plugin wallbreaker objectsearch android.support.v7.app.AppCompatViewInflater$DeclaredOnClickListener plugin wallbreaker objectdump --fullname 0x227a 使用反射进行调用的框架 破解校验秘钥逻辑如下，通过调用逻辑改写verifyPassword实现解密。 1android hooking search classes Verifier 最好从内存中捞这个类，而非根据静态反编译，hook方法也最好从内存中获取，不要从静态编译结果中获取不准确 反射调用encodePasswordf (v[i] != p[i]) 1234567891011121314151617181920if (loadPackageParam.packageName.equals(&quot;org.teamsik.ahe17.qualification.easy&quot;)) &#123; &#x2F;&#x2F; 安装xposed1点击button触发反射调用 XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); Class clazz &#x3D; loadPackageParam.classLoader.loadClass(&quot;org.teamsik.ahe17.qualification.Verifier&quot;); Method encodePassword &#x3D; clazz.getDeclaredMethod(&quot;encodePassword&quot;, String.class); encodePassword.setAccessible(true); byte[] p &#x3D; &quot;09042ec2c2c08c4cbece042681caf1d13984f24a&quot;.getBytes(); &#x2F;&#x2F; XposedBridge.log(&quot;result i is &#x3D;&gt; &quot; + new String(p)); 打印字节数组 String pStr &#x3D; new String((p)); for (int i &#x3D; 999; i &lt; 10000; i++) &#123; byte[] v &#x3D; (byte[]) encodePassword.invoke(null, String.valueOf(i)); if (v.length !&#x3D; p.length) &#123; break; &#125; String vStr &#x3D; new String(v); if (vStr &#x3D;&#x3D; pStr) &#123; XposedBridge.log(&quot;Current i is &#x3D;&gt; &quot; + String.valueOf(i)); &#125; &#125;&#125; 反射调用verifyPasswordif (!Verifier.verifyPassword(this, this.txPassword.getText().toString())) 1234567891011121314if (loadPackageParam.packageName.equals(&quot;org.teamsik.ahe17.qualification.easy&quot;)) &#123; XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); Class clazz &#x3D; loadPackageParam.classLoader.loadClass(&quot;org.teamsik.ahe17.qualification.Verifier&quot;); &#x2F;&#x2F; public 方法不需要getDeclaredMethod和setAccessible，反射拿到verifyPassword Method verifyPassword &#x3D; clazz.getMethod(&quot;verifyPassword&quot;, Context.class, String.class); Context context &#x3D; AndroidAppHelper.currentApplication(); for (int i &#x3D; 999; i &lt; 10000; i++) &#123; if ((boolean) verifyPassword.invoke(null, context, String.valueOf(i))) &#123; XposedBridge.log(&quot;Current i is &#x3D;&gt; &quot; + String.valueOf(i)); &#125; &#125;&#125; callStaticMethod verifyPassword123456789101112if (loadPackageParam.packageName.equals(&quot;org.teamsik.ahe17.qualification.easy&quot;)) &#123; XposedBridge.log(&quot;inner&quot;+loadPackageParam.processName); Class clazz &#x3D; XposedHelpers.findClass(&quot;org.teamsik.ahe17.qualification.Verifier&quot;,loadPackageParam.classLoader); &#x2F;&#x2F; hook Verifier类，并直接调用静态方法verifyPassword Context context &#x3D; AndroidAppHelper.currentApplication(); for(int i &#x3D; 999;i&lt;10000;i++)&#123; if((boolean) XposedHelpers.callStaticMethod(clazz,&quot;verifyPassword&quot;,context,String.valueOf(i)))&#123; XposedBridge.log(&quot;Current i is &#x3D;&gt; &quot;+ String.valueOf(i)); &#125; &#125;&#125; findAndHookMethod encodePassword1234567891011121314151617if (loadPackageParam.packageName.equals(&quot;org.teamsik.ahe17.qualification.easy&quot;)) &#123; XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); Class clazz &#x3D; XposedHelpers.findClass(&quot;org.teamsik.ahe17.qualification.Verifier&quot;, loadPackageParam.classLoader); XposedHelpers.findAndHookMethod(clazz, &quot;encodePassword&quot;, String.class, new XC_MethodHook() &#123; &#x2F;&#x2F; hook encodePassword后拿到所在类，调用该类的verifyPassword protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; Context context &#x3D; AndroidAppHelper.currentApplication(); for (int i &#x3D; 999; i &lt; 10000; i++) &#123; if ((boolean) XposedHelpers.callMethod(param.thisObject, &quot;verifyPassword&quot;, context, String.valueOf(i))) &#123; XposedBridge.log(&quot;Current i is &#x3D;&gt; &quot; + String.valueOf(i)); &#125; &#125; Log.d(&quot;getResult is &#x3D;&gt; &quot;, (String) param.getResult()); &#125; &#125;);&#125; newInstance Verifier123456789101112131415if (loadPackageParam.packageName.equals(&quot;org.teamsik.ahe17.qualification.easy&quot;)) &#123; XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); Class clazz &#x3D; XposedHelpers.findClass(&quot;org.teamsik.ahe17.qualification.Verifier&quot;, loadPackageParam.classLoader); &#x2F;&#x2F; newInstance拿到Verifier类并调用verifyPassword Object Verifier &#x3D; XposedHelpers.newInstance(clazz); Context context &#x3D; AndroidAppHelper.currentApplication(); for (int i &#x3D; 999; i &lt; 10000; i++) &#123; if ((boolean) XposedHelpers.callMethod(Verifier, &quot;verifyPassword&quot;, context, String.valueOf(i))) &#123; XposedBridge.log(&quot;Current i is &#x3D;&gt; &quot; + String.valueOf(i)); &#125; &#125;&#125; findConstructorExact Verifier1234567891011121314if (loadPackageParam.packageName.equals(&quot;org.teamsik.ahe17.qualification.easy&quot;)) &#123; XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); &#x2F;&#x2F; Constructor获取构造器newInstance拿到Verifier并调用verifyPassword Constructor cons &#x3D; XposedHelpers.findConstructorExact(&quot;org.teamsik.ahe17.qualification.Verifier&quot;,loadPackageParam.classLoader); Object Verifier &#x3D; cons.newInstance(); Context context &#x3D; AndroidAppHelper.currentApplication(); for (int i &#x3D; 999; i &lt; 10000; i++) &#123; if ((boolean) XposedHelpers.callMethod(Verifier, &quot;verifyPassword&quot;, context, String.valueOf(i))) &#123; XposedBridge.log(&quot;Current i is &#x3D;&gt; &quot; + String.valueOf(i)); &#125; &#125;&#125; hookAllMethods onCreate12345678910111213141516if (loadPackageParam.packageName.equals(&quot;org.teamsik.ahe17.qualification.easy&quot;)) &#123; XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); Class clazz &#x3D; loadPackageParam.classLoader.loadClass(&quot;org.teamsik.ahe17.qualification.MainActivity&quot;); &#x2F;&#x2F; 直接调用verifyPassword成功后回调的方法showSuccessDialog XposedBridge.hookAllMethods(clazz, &quot;onCreate&quot;,new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); Object mMainAciticity &#x3D; param.thisObject; XposedHelpers.callMethod(mMainAciticity,&quot;showSuccessDialog&quot;); &#125; &#125;);&#125; 案例demoso11234567.&#x2F;fs1426arm64 pyenv local 3.9.0objection -g com.example.demoso1 explore android hooking search classes MainActivityandroid hooking list class_methods com.example.demoso1.MainActivity 查看该类中所有函数android hooking watch class com.example.demoso1.MainActivityandroid hooking watch class_method com.example.demoso1.MainActivity.$init 查看构造函数的参数 给android hooking list class_methods 加上构造函数 12345cd ~&#x2F;.pyenvtree -NCfhl|grep objectioncd .&#x2F;versions&#x2F;3.9.0&#x2F;lib&#x2F;python3.9&#x2F;site-packagestree -NCfhl |grep -i agent.jsvi .&#x2F;objection&#x2F;agent.js //android hooking list class_methods com.example.demoso1.MainActivity//protected void com.example.demoso1.MainActivity.onCreate(android.os.Bundle)//public native int com.example.demoso1.MainActivity.init()//public native int com.example.demoso1.MainActivity.myfirstjni()//public native java.lang.String com.example.demoso1.MainActivity.method02(java.lang.String)//public static native java.lang.String com.example.demoso1.MainActivity.method01(java.lang.String)//public static native java.lang.String com.example.demoso1.MainActivity.myfirstjniJNI(java.lang.String)//public static native java.lang.String com.example.demoso1.MainActivity.stringFromJNI()//public static native java.lang.String com.example.demoso1.MainActivity.stringFromJNI2()//public void com.example.demoso1.MainActivity.testField()//public void com.example.demoso1.MainActivity.testMethod()// Found 10 method(s) 1234567891011121314151617181920212223if (loadPackageParam.packageName.equals(&quot;com.example.demoso1&quot;)) &#123; XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); final Class clazz &#x3D; loadPackageParam.classLoader.loadClass(&quot;com.example.demoso1.MainActivity&quot;); &#x2F;&#x2F;得到对象：hook(想通过hook的方式得到一个obj的话得hook一个实例方法) onCreate 循环调用method01和method02，onCreate执行后再触发 XposedBridge.hookAllMethods(clazz, &quot;onCreate&quot;, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Object mMainAciticity &#x3D; param.thisObject; String cipherText &#x3D; (String) XposedHelpers.callMethod(mMainAciticity, &quot;method01&quot;, &quot;roysue&quot;); String clearText &#x3D; (String) XposedHelpers.callMethod(mMainAciticity, &quot;method02&quot;, &quot;47fcda3822cd10a8e2f667fa49da783f&quot;); XposedBridge.log(&quot;Cipher text is &#x3D;&gt; &quot; + cipherText); XposedBridge.log(&quot;Clear text is &#x3D;&gt; &quot; + clearText); &#125; &#125;); &#x2F;&#x2F;xposed.newInstance获取对象 毕竟在hook中，进行主动调用的话，触发条件需要将mMainActivity进行newInstance，包只要打开就会触发 Object newMainActivity &#x3D; XposedHelpers.newInstance(clazz); String cipherText &#x3D; (String) XposedHelpers.callMethod(newMainActivity, &quot;method01&quot;, &quot;roysue&quot;); String clearText &#x3D; (String) XposedHelpers.callMethod(newMainActivity, &quot;method02&quot;, &quot;47fcda3822cd10a8e2f667fa49da783f&quot;); XposedBridge.log(&quot;Cipher text 2 is &#x3D;&gt; &quot; + cipherText); XposedBridge.log(&quot;Clear text 2 is &#x3D;&gt; &quot; + clearText);&#125; Nanohttpd利用NanoHTTPD反射调用Android APP加密函数 build.gradle添加依赖implementation &#39;org.nanohttpd:nanohttpd:2.3.1&#39; AndroidManifest.xml添加网络权限声明&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384Object mMainActivity &#x3D; null;public void setActivity(Object obj) &#123; mMainActivity &#x3D; obj;&#125;public Object getActivity() &#123; return mMainActivity;&#125;if (loadPackageParam.packageName.equals(&quot;com.example.demoso1&quot;)) &#123; XposedBridge.log(&quot;inner&quot; + loadPackageParam.processName); final Class clazz &#x3D; loadPackageParam.classLoader.loadClass(&quot;com.example.demoso1.MainActivity&quot;); &#x2F;&#x2F;得到对象：hook(想通过hook的方式得到一个obj的话得hook一个实例方法) onCreate 循环调用method01和method02 XposedBridge.hookAllMethods(clazz, &quot;onCreate&quot;, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Object mMainAciticity &#x3D; param.thisObject; String cipherText &#x3D; (String) XposedHelpers.callMethod(mMainAciticity, &quot;method01&quot;, &quot;roysue&quot;); String clearText &#x3D; (String) XposedHelpers.callMethod(mMainAciticity, &quot;method02&quot;, &quot;47fcda3822cd10a8e2f667fa49da783f&quot;); XposedBridge.log(&quot;Cipher text is &#x3D;&gt; &quot; + cipherText); XposedBridge.log(&quot;Clear text is &#x3D;&gt; &quot; + clearText);&#x2F;&#x2F; setActivity(mMainAciticity); &#125; &#125;); &#x2F;&#x2F;xposed.newInstance获取对象 毕竟在hook中，进行主动调用的话，触发条件需要将mMainActivity进行newInstance Object newMainActivity &#x3D; XposedHelpers.newInstance(clazz); String cipherText &#x3D; (String) XposedHelpers.callMethod(newMainActivity, &quot;method01&quot;, &quot;roysue&quot;); String clearText &#x3D; (String) XposedHelpers.callMethod(newMainActivity, &quot;method02&quot;, &quot;47fcda3822cd10a8e2f667fa49da783f&quot;); XposedBridge.log(&quot;Cipher text 2 is &#x3D;&gt; &quot; + cipherText); XposedBridge.log(&quot;Clear text 2 is &#x3D;&gt; &quot; + clearText); setActivity(newMainActivity); class App extends NanoHTTPD &#123; public App() throws IOException &#123; super(8899); &#x2F;&#x2F; 内部新起线程实现http，无法直接调用当前类的变量，需要在上面定义setActivity拿到callMethod里的对象 start(NanoHTTPD.SOCKET_READ_TIMEOUT, true); XposedBridge.log(&quot;\\nRunning! Point your browsers to http:&#x2F;&#x2F;localhost:8899&#x2F; \\n&quot;); &#125; @Override public NanoHTTPD.Response serve(IHTTPSession session) &#123; Method method &#x3D; session.getMethod(); String uri &#x3D; session.getUri(); String RemoteIP &#x3D; session.getRemoteIpAddress(); String RemoteHostName &#x3D; session.getRemoteHostName(); Log.i(&quot;r0ysue nanohttpd &quot;,&quot;Method &#x3D;&gt; &quot;+method + &quot; ;Url &#x3D;&gt; &quot; + uri + &quot;&#39; &quot;); Log.i(&quot;r0ysue nanohttpd &quot;,&quot;Remote IP &#x3D;&gt; &quot;+RemoteIP + &quot; ;RemoteHostName &#x3D;&gt; &quot; + RemoteHostName + &quot;&#39; &quot;); String paramBody &#x3D; &quot;&quot;; Map&lt;String, String&gt; files &#x3D; new HashMap&lt;&gt;(); try &#123; session.parseBody(files); paramBody &#x3D; session.getQueryParameterString(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ResponseException e) &#123; e.printStackTrace(); &#125; Log.i(&quot;Nano_post_param &#x3D;&gt; &quot;, paramBody);&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; String msg &#x3D; &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello server&lt;&#x2F;h1&gt;\\n&quot;;&#x2F;&#x2F; Map&lt;String, String&gt; parms &#x3D; session.getParms();&#x2F;&#x2F; if (parms.get(&quot;username&quot;) &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; msg +&#x3D; &quot;&lt;form action&#x3D;&#39;?&#39; method&#x3D;&#39;get&#39;&gt;\\n &lt;p&gt;Your name: &lt;input type&#x3D;&#39;text&#39; name&#x3D;&#39;username&#39;&gt;&lt;&#x2F;p&gt;\\n&quot; + &quot;&lt;&#x2F;form&gt;\\n&quot;;&#x2F;&#x2F; &#125; else &#123;&#x2F;&#x2F; msg +&#x3D; &quot;&lt;p&gt;Hello, &quot; + parms.get(&quot;username&quot;) + &quot;!&lt;&#x2F;p&gt;&quot;;&#x2F;&#x2F; &#125; String result &#x3D; &quot;&quot;; result &#x3D; (String) XposedHelpers.callMethod(getActivity(), &quot;method01&quot;, &quot;r0ysue&quot;); return newFixedLengthResponse(Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, result); &#125; &#125; new App();&#125; curl -s -X POST “http://192.168.0.103:8899/&quot; -d ‘{“data”:onejane}’ python调用实现 12345678910111213import requestsdef encrypt(enParam): &#x2F;&#x2F; xposed1 app所在手机ip url &#x3D; &quot;http:&#x2F;&#x2F;192.168.0.103:8899&quot; param &#x3D; enParam headers &#x3D; &#123;&quot;Content-Type&quot;:&quot;application&#x2F;x-www-form-urlencoded&quot;&#125; r &#x3D; requests.post(url &#x3D; url ,data&#x3D;param,headers &#x3D; headers) print(r.content) return r.contentif __name__ &#x3D;&#x3D; &#39;__main__&#39; : encrypt(&quot;onejane&quot;) apt install siege https://www.jianshu.com/p/74c465ff136f 1siege -c5 -r10 &quot;http:&#x2F;&#x2F;192.168.0.103:8899 POST &lt;.&#x2F;iloveroysue.json &quot; 压测 iloveroysue.json { “data”:”iloveroysue” } adb forward tcp:8899 tcp:8899 将手机8899转发到电脑8899 siege -c5 -r10 “http://127.0.0.1:8899 POST &lt;./iloveroysue.json “ 1234567if(uri.contains(&quot;encrypt&quot;))&#123; result &#x3D; (String) XposedHelpers.callMethod(getActivity(), &quot;method01&quot;, paramBody);&#125;else if (uri.contains(&quot;decrypt&quot;))&#123; result &#x3D; (String) XposedHelpers.callMethod(getActivity(), &quot;method02&quot;, paramBody);&#125;else&#123; result &#x3D; paramBody;&#125; curl -s -X POST “http://192.168.0.103:8899/encrypt&quot; -d ‘{“data”:onejane}’ 123objection -g com.example.demoso1 explore -P ~&#x2F;.objection&#x2F;pluginsplugin wallbreaker classsearch Sessionandroid hooking watch class fi.iki.elonen.NanoHTTPD$IHTTPSession 该类不在目标进程中，在xposed的classloader中，可以hook但是objection没有切classloader的功能 暴露公网手机：npc file npc 查看该文件格式基本信息，执行客户端命令暴露一个公网ip出去，端口为58899 服务器：nps curl -s -X POST “http://118.126.66.193:58899/encrypt&quot; -d ‘{“data”:onejane}’ siege -c5 -r10 “http://118.126.66.193:8899 POST &lt;./iloveroysue.json “ 案例movetv1234567objection -g com.cz.babySister exploreandroid hooking search classes MainActivity android hooking list class_methods com.cz.babySister.activity.MainActivityandroid hooking watch class com.cz.babySister.activity.MainActivity 将所有MainActivity的方法进行hook，做任意操作打印调用方法android hooking search classes loadedapk 搜索类名包括loadedapk的类plugin wallbreaker objectsearch android.app.LoadedApk 内存漫游查找android.app.LoadedApkplugin wallbreaker objectdump 0x240a 可视化内存中类的信息 jadx-gui Desktop/movetv.apk 腾讯加固 123456789101112if (loadPackageParam.packageName.equals(&quot;com.cz.babySister&quot;)) &#123; Class clazz &#x3D; loadPackageParam.classLoader.loadClass(&quot;com.cz.babySister.activity.MainActivity&quot;); XposedHelpers.findAndHookMethod(clazz, &quot;getJiFen&quot;, float.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;float is &quot;+ String.valueOf( (float) param.args[0])); &#125; &#125;);&#125; 脱壳使用frida来hook加固的Android应用的java层，APP的启动过程，Android万能脱壳机，FART：ART环境下基于主动调用的自动化脱壳方案 1234plugin wallbreaker objectsearch android.app.ActivityThread plugin wallbreaker objectdump --fullname 0x2a6a 取mInitialApplication的内存地址plugin wallbreaker objectdump --fullname 0x10094eandroid hooking list class_methods java.lang.ClassLoader 有findClass方法 首先，对于获取Classloader的时机点的选择。在第一节的App启动流程以及第三节中APP加壳原理和执行流程的介绍中，可以看到，APP中的Application类中的attachBaseContext和onCreate函数是app中最先执行的方法。壳都是通过替换APP的Application类并自己实现这两个函数，并在这两个函数中实现dex的解密加载，hook系统中Class和method加载执行流程中的关键函数，最后通过反射完成关键变量如最终的Classloader，Application等的替换从而完成执行权的交付。因此，我们可以选在任意一个在Application的onCreate函数执行之后才开始被调用的任意一个函数中。众所周知，对于一个正常的应用来说，最终都要由一个个的Activity来展示应用的界面并和用户完成交互，那么我们就可以选择在ActivityThread中的performLaunchActivity函数作为时机，来获取最终的应用的Classloader。选择该函数还有一个好处在于该函数和应用的最终的application同在ActivityThread类中，可以很方便获取到该类的成员。 12345678910111213141516171819202122232425private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ...... Activity activity &#x3D; null; try &#123; java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();&#x2F;&#x2F;下面通过application的getClassLoader()获取最终的Classloader，并开启线程，在新线程中完成内存中的dex的dump以及主动调用过程，由于该过程相对耗时，为了防止应用出现ANR，从而开启新线程，在新线程中进行，主要的工作都在getDexFilesByClassLoader_23 &#x2F;&#x2F;addstart packagename&#x3D;r.packageInfo.getPackageName(); &#x2F;&#x2F;mInitialApplication &#x2F;&#x2F;final java.lang.ClassLoader finalcl&#x3D;cl if(mInitialApplication!&#x3D;null)&#123; final java.lang.ClassLoader finalcl&#x3D;mInitialApplication.getClassLoader(); new Thread(new Runnable() &#123; @Override public void run() &#123; getDexFilesByClassLoader_23(finalcl); &#125; &#125;).start(); &#125; &#x2F;&#x2F;addend &#125;&#125; wget https://github.com/hanbinglengyue/FART/blob/master/FART_6.0_sourcecode.zip 套用FART_6.0_sourcecod/frameworks/base/core/java/android/app/ActivityThread.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210if (loadPackageParam.packageName.equals(&quot;com.cz.babySister&quot;)) &#123; XposedBridge.log(&quot; has Hooked!&quot;); XposedBridge.log(&quot;inner &#x3D;&gt; &quot; + loadPackageParam.processName); Class ActivityThread &#x3D; XposedHelpers.findClass(&quot;android.app.ActivityThread&quot;,loadPackageParam.classLoader); XposedBridge.hookAllMethods(ActivityThread, &quot;performLaunchActivity&quot;, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); Object mInitialApplication &#x3D; (Application) XposedHelpers.getObjectField(param.thisObject,&quot;mInitialApplication&quot;); ClassLoader finalCL &#x3D; (ClassLoader) XposedHelpers.callMethod(mInitialApplication,&quot;getClassLoader&quot;); XposedBridge.log(&quot;found classload is &#x3D;&gt; &quot;+finalCL.toString()); Class BabyMain &#x3D; (Class)XposedHelpers.callMethod(finalCL,&quot;findClass&quot;,&quot;com.cz.babySister.activity.MainActivity&quot;); XposedBridge.log(&quot;found final class is &#x3D;&gt; &quot;+BabyMain.getName().toString()); fart(finalCL); &#125; &#125;);&#125;public static Object invokeStaticMethod(String class_name, String method_name, Class[] pareTyple, Object[] pareVaules) &#123; try &#123; Class obj_class &#x3D; Class.forName(class_name); Method method &#x3D; obj_class.getMethod(method_name, pareTyple); return method.invoke(null, pareVaules); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null;&#125;public static Object getFieldOjbect(String class_name, Object obj, String filedName) &#123; try &#123; Class obj_class &#x3D; Class.forName(class_name); Field field &#x3D; obj_class.getDeclaredField(filedName); field.setAccessible(true); return field.get(obj); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null;&#125;public static Field getClassField(ClassLoader classloader, String class_name, String filedName) &#123; try &#123; Class obj_class &#x3D; classloader.loadClass(class_name); Field field &#x3D; obj_class.getDeclaredField(filedName); field.setAccessible(true); return field; &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null;&#125;public static ClassLoader getClassloader() &#123; ClassLoader resultClassloader &#x3D; null; Object currentActivityThread &#x3D; invokeStaticMethod( &quot;android.app.ActivityThread&quot;, &quot;currentActivityThread&quot;, new Class[]&#123;&#125;, new Object[]&#123;&#125;); Object mBoundApplication &#x3D; getFieldOjbect( &quot;android.app.ActivityThread&quot;, currentActivityThread, &quot;mBoundApplication&quot;); Object loadedApkInfo &#x3D; getFieldOjbect( &quot;android.app.ActivityThread$AppBindData&quot;, mBoundApplication, &quot;info&quot;); Application mApplication &#x3D; (Application) getFieldOjbect(&quot;android.app.LoadedApk&quot;, loadedApkInfo, &quot;mApplication&quot;); resultClassloader &#x3D; mApplication.getClassLoader(); return resultClassloader;&#125;public static Object getClassFieldObject(ClassLoader classloader, String class_name, Object obj, String filedName) &#123; try &#123; Class obj_class &#x3D; classloader.loadClass(class_name); Field field &#x3D; obj_class.getDeclaredField(filedName); field.setAccessible(true); Object result &#x3D; null; result &#x3D; field.get(obj); return result; &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return null;&#125;public static void fart(ClassLoader clzloader) throws IOException &#123; ClassLoader appClassloader &#x3D; clzloader; List&lt;Object&gt; dexFilesArray &#x3D; new ArrayList&lt;Object&gt;(); Field pathList_Field &#x3D; (Field) getClassField(appClassloader, &quot;dalvik.system.BaseDexClassLoader&quot;, &quot;pathList&quot;); Object pathList_object &#x3D; getFieldOjbect(&quot;dalvik.system.BaseDexClassLoader&quot;, appClassloader, &quot;pathList&quot;); Object[] ElementsArray &#x3D; (Object[]) getFieldOjbect(&quot;dalvik.system.DexPathList&quot;, pathList_object, &quot;dexElements&quot;); Field dexFile_fileField &#x3D; null; try &#123; dexFile_fileField &#x3D; (Field) getClassField(appClassloader, &quot;dalvik.system.DexPathList$Element&quot;, &quot;dexFile&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Class DexFileClazz &#x3D; null; try &#123; DexFileClazz &#x3D; appClassloader.loadClass(&quot;dalvik.system.DexFile&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Method getClassNameList_method &#x3D; null; Method defineClass_method &#x3D; null; Method dumpDexFile_method &#x3D; null; Method dumpMethodCode_method &#x3D; null; for (Method field : DexFileClazz.getDeclaredMethods()) &#123; if (field.getName().equals(&quot;getClassNameList&quot;)) &#123; getClassNameList_method &#x3D; field; getClassNameList_method.setAccessible(true); &#125; if (field.getName().equals(&quot;defineClassNative&quot;)) &#123; defineClass_method &#x3D; field; defineClass_method.setAccessible(true); &#125; if (field.getName().equals(&quot;dumpMethodCode&quot;)) &#123; dumpMethodCode_method &#x3D; field; dumpMethodCode_method.setAccessible(true); &#125; &#125; Field mCookiefield &#x3D; getClassField(appClassloader, &quot;dalvik.system.DexFile&quot;, &quot;mCookie&quot;); for (int j &#x3D; 0; j &lt; ElementsArray.length; j++) &#123; Object element &#x3D; ElementsArray[j]; Object dexfile &#x3D; null; try &#123; dexfile &#x3D; (Object) dexFile_fileField.get(element); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if (dexfile &#x3D;&#x3D; null) &#123; continue; &#125; if (dexfile !&#x3D; null) &#123; dexFilesArray.add(dexfile); Object mcookie &#x3D; getClassFieldObject(appClassloader, &quot;dalvik.system.DexFile&quot;, dexfile, &quot;mCookie&quot;); if (mcookie &#x3D;&#x3D; null) &#123; continue; &#125; String[] classnames &#x3D; null; try &#123; classnames &#x3D; (String[]) getClassNameList_method.invoke(dexfile, mcookie); &#125; catch (Exception e) &#123; e.printStackTrace(); continue; &#125; catch (Error e) &#123; e.printStackTrace(); continue; &#125; if (classnames !&#x3D; null) &#123; File file &#x3D; new File(&quot;&#x2F;sdcard&#x2F;Download&#x2F;dumpClass1122.txt&quot;); if (!file.exists()) &#123; Log.d(&quot;TestFile&quot;, &quot;Create the file:&quot; ); file.createNewFile(); &#125; RandomAccessFile raf &#x3D; new RandomAccessFile(file, &quot;rw&quot;); raf.seek(file.length()); for (String eachclassname : classnames) &#123; String log &#x3D; &quot;ClassNameis::&quot; +eachclassname +&quot; :: &quot;+ dumpMethodCode_method +&quot;::&quot;+appClassloader.toString() +&quot;\\n&quot;; raf.write(log.getBytes()); Log.i(&quot;classes&#x3D;&gt;&quot;,log); &#125; raf.close(); &#125; &#125; &#125; return;&#125; cat dumpClass1122.txt |grep MainActivity 脱壳拿到类包括子类，完成trace到classloader所有类的功能 安卓逆向之基于Xposed-ZjDroid脱壳 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"xposed","slug":"xposed","permalink":"http://onejane.github.io/tags/xposed/"}]},{"title":"JS逆向之房天下pwd","slug":"JS逆向之房天下pwd","date":"2021-04-29T09:35:03.000Z","updated":"2021-12-12T03:09:39.272Z","comments":true,"path":"2021/04/29/JS逆向之房天下pwd/","link":"","permalink":"http://onejane.github.io/2021/04/29/JS%E9%80%86%E5%90%91%E4%B9%8B%E6%88%BF%E5%A4%A9%E4%B8%8Bpwd/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 https://passport.fang.com/?backurl=https%3A%2F%2Fsuzhou.fang.com%2F 目标POST https://passport.fang.com/login.api 1234uid: 15806204095@163.compwd: 3854d2ef8cc2455ed263a3a697414c6f59043010efba9b24da93c6596123fee5fded0d948bc9148beaa5f58756817725617bb3c09ade11e5586e6430392a27db28005ebcfc442d8cf64c0369d439b17011c88e89a57914d78f45a7bba9a7c9e95b75e9fcb4cccbc4c6d65b3e0d3257d183ff2ba35bf3eb70e6bf0b50d4ffdaa1Service: soufun-passport-webAutoLogin: 1 分析搜索login.api，并打上断点，重新登录时可以知道pwd是由key_to_encode和我们输入的密码123456经过encryptedString函数生成 搜索key_to_encode，通过RSAKeyPair构造函数返回key_to_encode 进入RSAKeyPair的构造函数中，正好encryptedString方法也在其中，我们将整个RSA.min.js:formatted拷贝下来命名fang.js，添加新方法getpwd，实现通过传入的123456加密生成pwd。 1234function getpwd(pwd) &#123; var key_to_encode &#x3D; new RSAKeyPair(&quot;010001&quot;, &quot;&quot;, &quot;978C0A92D2173439707498F0944AA476B1B62595877DD6FA87F6E2AC6DCB3D0BF0B82857439C99B5091192BC134889DFF60C562EC54EFBA4FF2F9D55ADBCCEA4A2FBA80CB398ED501280A007C83AF30C3D1A142D6133C63012B90AB26AC60C898FB66EDC3192C3EC4FF66925A64003B72496099F4F09A9FB72A2CF9E4D770C41&quot;); return encryptedString(key_to_encode, pwd)&#125; 爬虫实现拷贝参数到sublime中，使用ctrl+H正则替换功能将(.*?):\\s(.*?)\\n 改成&#39;$1&#39;:&#39;$2&#39;,\\n,或者通过请求头加参数.py修改格式。 1234uid: 15806204095@163.compwd: 3854d2ef8cc2455ed263a3a697414c6f59043010efba9b24da93c6596123fee5fded0d948bc9148beaa5f58756817725617bb3c09ade11e5586e6430392a27db28005ebcfc442d8cf64c0369d439b17011c88e89a57914d78f45a7bba9a7c9e95b75e9fcb4cccbc4c6d65b3e0d3257d183ff2ba35bf3eb70e6bf0b50d4ffdaa1Service: soufun-passport-webAutoLogin: 1 接下来再通过exec执行扣下的js并利用requests库实现post请求完成登录。 12345678910111213141516171819202122232425262728293031323334def get_pwd(): with open(&quot;fang.js&quot;, &quot;r&quot;) as f: js_code &#x3D; f.read() results &#x3D; execjs.compile(js_code).call(&quot;getpwd&quot;, password) return resultsdef login(): url &#x3D; &#39;https:&#x2F;&#x2F;passport.fang.com&#x2F;login.api&#39; pwd &#x3D; get_pwd() data &#x3D; &#123; &#39;uid&#39;: account, &#39;pwd&#39;: pwd, &#39;Service&#39;: &#39;soufun-passport-web&#39;, &#39;AutoLogin&#39;: &#39;1&#39;, &#125; headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.111 Safari&#x2F;537.36&#39;, &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;, &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&#39;, &#39;Host&#39;: &#39;passport.fang.com&#39;, &#39;Origin&#39;: &#39;https:&#x2F;&#x2F;passport.fang.com&#39;, &#39;Pragma&#39;: &#39;no-cache&#39;, &#39;Referer&#39;: &#39;https:&#x2F;&#x2F;passport.fang.com&#x2F;?backurl&#x3D;https%3A%2F%2Fsuzhou.fang.com%2F&#39;, &#39;Sec-Fetch-Dest&#39;: &#39;empty&#39;, &#39;Sec-Fetch-Mode&#39;: &#39;cors&#39;, &#39;Sec-Fetch-Site&#39;: &#39;same-origin&#39;, &#125; response &#x3D; requests.post(url, data, headers&#x3D;headers) print(response.text)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: login() 完整源码请关注微信公众号：ReverseCode，回复：JS逆向 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"爬虫基础篇之多途径抓取失信人名单","slug":"爬虫基础篇之多途径抓取失信人名单","date":"2021-04-27T12:14:07.000Z","updated":"2021-12-12T03:09:39.333Z","comments":true,"path":"2021/04/27/爬虫基础篇之多途径抓取失信人名单/","link":"","permalink":"http://onejane.github.io/2021/04/27/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%A4%9A%E9%80%94%E5%BE%84%E6%8A%93%E5%8F%96%E5%A4%B1%E4%BF%A1%E4%BA%BA%E5%90%8D%E5%8D%95/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 需求继爬虫基础篇之Scrapy抓取京东之后，我们对scrapy有了一定的掌握，接下来通过多渠道汇总对失信人信息抓取入库。 抓取百度失信人名单 抓取最高人民法院失信人名单 抓取国家企业信用公示系统失信人公告 把上面三个来源的失信人信息进行合并,去重 目标百度 搜索失信人名单 抓取数据: 失信人名称, 失信人号码,法人(企业), 年龄(企业的年龄为0), 区域,失信内容, 公布日期, 公布执行单位, 创建日期, 更新日期 企业信用信息公示系统 访问http://www.gsxt.gov.cn/corp-query-entprise-info-xxgg-100000.html 抓取: 失信人名称, 失信人号码, 年龄(企业的年龄为0), 区域, 失信内容, 公布日期, 公布单位, 类型(个人/企业), 创建日期, 更新日期 实现 把抓取的数据, 统一存储到同一个数据库的, 同一张表中. 如何去重? 对于个人: 根据失信人号码, 检查一下, 如果不存在才插入. 对于企业/组织: 失信人证件号, 有的是组织机构代码, 有的是信用号, 企业信用信息公示系统的失信人公告有的没有证件号, 所以无法进行准确判断. 区域 和 企业名称进行检查, 如果有就重复了, 没有才插入. 百度scrapy startproject dishonest 创建爬虫项目 数据模型定义数据模型继承自scrapy.Item的数据模型DishonestItem 12345678910111213141516171819202122class DishonestItem(scrapy.Item): # define the fields for your item here like: # 失信人名称 name &#x3D; scrapy.Field() # 失信人证件号 card_num &#x3D; scrapy.Field() # 失信人年龄, 企业年龄都是0 age &#x3D; scrapy.Field() # 区域 area &#x3D; scrapy.Field() # 法人(企业) business_entity &#x3D; scrapy.Field() # 失信内容 content &#x3D; scrapy.Field() # 公布日期 publish_date &#x3D; scrapy.Field() # 公布&#x2F;执行单位 publish_unit &#x3D; scrapy.Field() # 创建日期 create_date &#x3D; scrapy.Field() # 更新日期 update_date &#x3D; scrapy.Field() 分析通过翻页发起请求，在控制台的All请求下出现了https://sp0.baidu.com/8aQDcjqpAAV3otqbppnN2DJv/api.php?resource_id=6899&amp;query=失信人名单&amp;pn=0&amp;ie=utf-8&amp;oe=utf-8&amp;format=json的目标地址 参数: resource_id=6899: 资源id, 固定值 query=失信人名单: 查询内容, 固定值 pn=0: 数据起始号码 ie=utf-8&amp;oe=utf-8: 指定数据的编码方式, 固定值 format=json: 数据格式, 固定值 我们可以根据第一次请求, 获取到总的数据条数, 生成所有页面的URL. demo123456789url &#x3D; &#39;https:&#x2F;&#x2F;sp0.baidu.com&#x2F;8aQDcjqpAAV3otqbppnN2DJv&#x2F;api.php?resource_id&#x3D;6899&amp;query&#x3D;失信人&amp;pn&#x3D;10&amp;rn&#x3D;10&amp;ie&#x3D;utf-8&amp;oe&#x3D;utf-8&#39;headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;70.0.3538.110 Safari&#x2F;537.36&#39;, &#39;Referer&#39;: &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;s?ie&#x3D;UTF-8&amp;wd&#x3D;%E5%A4%B1%E4%BF%A1%E4%BA%BA&#39;&#125;response &#x3D; requests.get(url, headers&#x3D;headers)print(response.status_code)print(response.content.decode()) 爬虫实现 设置默认请求头, 在settings.py文件中 1234DEFAULT_REQUEST_HEADERS &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;70.0.3538.110 Safari&#x2F;537.36&#39;, &#39;Referer&#39;: &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;s?ie&#x3D;UTF-8&amp;wd&#x3D;%E5%A4%B1%E4%BF%A1%E4%BA%BA&#39;&#125; scrapy genspider baidu baidu.com 创建爬虫 分页实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class BaiduSpider(scrapy.Spider): name &#x3D; &#39;baidu&#39; allowed_domains &#x3D; [&#39;baidu.com&#39;] start_urls &#x3D; [&#39;https:&#x2F;&#x2F;sp0.baidu.com&#x2F;8aQDcjqpAAV3otqbppnN2DJv&#x2F;api.php?resource_id&#x3D;6899&amp;query&#x3D;失信人&amp;pn&#x3D;0&amp;rn&#x3D;10&amp;ie&#x3D;utf-8&amp;oe&#x3D;utf-8&#39;] def parse(self, response): # 构建所有页面请求 # 把响应内容的json字符串, 转为字典 results &#x3D; json.loads(response.text) # 取出总数据条数 disp_num &#x3D; jsonpath(results, &#39;$..dispNum&#39;)[0] # print(disp_num) # URL模板 url_pattern &#x3D; &#39;https:&#x2F;&#x2F;sp0.baidu.com&#x2F;8aQDcjqpAAV3otqbppnN2DJv&#x2F;api.php?resource_id&#x3D;6899&amp;query&#x3D;失信人&amp;pn&#x3D;&#123;&#125;&amp;rn&#x3D;10&amp;ie&#x3D;utf-8&amp;oe&#x3D;utf-8&#39; # 每隔10条数据, 构建一个请求 for pn in range(0, disp_num, 10): # 构建URL url &#x3D; url_pattern.format(pn) # 创建请求, 交给引擎 yield scrapy.Request(url, callback&#x3D;self.parse_data) def parse_data(self, response): &quot;&quot;&quot;解析数据&quot;&quot;&quot; # 响应数据 datas &#x3D; json.loads(response.text) results &#x3D; jsonpath(datas, &#39;$..result&#39;)[0] # 遍历结果列表 for result in results: item &#x3D; DishonestItem() # 失信人名称 item[&#39;name&#39;] &#x3D; result[&#39;iname&#39;] # 失信人号码 item[&#39;card_num&#39;] &#x3D; result[&#39;cardNum&#39;] # 失信人年龄 item[&#39;age&#39;] &#x3D; int(result[&#39;age&#39;]) # 区域 item[&#39;area&#39;] &#x3D; result[&#39;areaName&#39;] # 法人(企业) item[&#39;business_entity&#39;] &#x3D; result[&#39;businessEntity&#39;] # 失信内容 item[&#39;content&#39;] &#x3D; result[&#39;duty&#39;] # 公布日期 item[&#39;publish_date&#39;] &#x3D; result[&#39;publishDate&#39;] # 公布&#x2F;执行单位 item[&#39;publish_unit&#39;] &#x3D; result[&#39;courtName&#39;] # 创建日期 item[&#39;create_date&#39;] &#x3D; datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;) # 更新日期 item[&#39;update_date&#39;] &#x3D; datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;) # print(item) # 把数据交给引擎 yield item 数据存储 创建数据库表 12345678910111213141516171819 -- 创建数据库create database dishonest;-- 如果表存在就删除drop table if exists dishonest;-- 创建表create table dishonest(dishonest_id INT NOT NULL AUTO_INCREMENT, -- id主键age INT NOT NULL, -- 年龄, 自然人年龄都是&gt;0的, 企业的年龄等于0name VARCHAR(200) NOT NULL, -- 失信人名称card_num VARCHAR(50) , -- 失信人号码area VARCHAR(50) NOT NULL, -- 区域content VARCHAR(2000) NOT NULL, -- 失信内容business_entity VARCHAR(20), -- 企业法人publish_unit VARCHAR(200), -- 发布单位publish_date VARCHAR(20), -- 发布单位create_date DATETIME, -- 创建日期update_date DATETIME, -- 更新日期PRIMARY KEY (dishonest_id)); 在settings中配置数据库信息 1234567891011# 配置MYSQL# MYSQL的主机IP地址MYSQL_HOST &#x3D; &#39;127.0.0.1&#39;# MYSQL端口号MYSQL_PORT &#x3D; 3306# MYSQL用户名MYSQL_USER &#x3D; &#39;root&#39;# MYSQL密码MYSQL_PASSWORD &#x3D; &#39;&#39;# MYSQL数据库名MYSQL_DB &#x3D; &#39;dishonest&#39; 使用pipeline存储数据到mysql 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class DishonestListPipeline(object): def open_spider(self, spider): # 创建数据链接 self.connect &#x3D; pymysql.connect(host&#x3D;&quot;127.0.0.1&quot;,user&#x3D;&quot;root&quot;, password&#x3D;&quot;123&quot;, db&#x3D;&quot;dishonest&quot;,port&#x3D;3306) # 获取执行SQL的cursor self.cursor &#x3D; self.connect.cursor() def close_spider(self, spider): # 释放游标 self.cursor.close() # 释放链接 self.connect.close() def process_item(self, item, spider): if item[&#39;age&#39;] &#x3D;&#x3D; 0: # 如果年龄 &#x3D;&#x3D; 0 , 就是企业, 就根据公司名和区域进行查询 name &#x3D; item[&#39;name&#39;] area_name &#x3D; item[&#39;area&#39;] select_sql &#x3D; &quot;select count(1) from t_dishonest where name&#x3D;&#39;&#123;&#125;&#39; and area &#x3D; &#39;&#123;&#125;&#39;&quot;.format(name, area) else: # 如果是个人根据证件号, 数据条数 select_sql &#x3D; &quot;select count(1) from t_dishonest where card_num&#x3D;&#39;&#123;&#125;&#39;&quot;.format(item[&#39;card_num&#39;] ) # 根据证件号, 数据条数 select_sql &#x3D; &quot;select count(1) from dishonest where card_num&#x3D;&#39;&#123;&#125;&#39;&quot;.format(item[&#39;card_num&#39;]) # 执行查询SQL self.cursor.execute(select_sql) # 获取查询结果 count &#x3D; self.cursor.fetchone()[0] # 如果查询的数量为0, 说明该人不存在, 不存在就插入 if count &#x3D;&#x3D; 0: # 获取当前的时间, 为插入数据库的时间 item[&#39;create_date&#39;] &#x3D; datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;) item[&#39;update_date&#39;] &#x3D; datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;) # 把数据转换为键, 值的格式, 方便插入数据库 keys, values &#x3D; zip(*dict(item).items()) # 插入数据库SQL insert_sql &#x3D; &#39;insert into dishonest (&#123;&#125;) values(&#123;&#125;)&#39;.format( &#39;,&#39;.join(keys), &#39;,&#39;.join([&#39;%s&#39;] * len(values)) ) # 执行插入数据SQL self.cursor.execute(insert_sql, values) # 提交 self.connect.commit() else: spider.logger.info(&#39;&#123;&#125; 重复&#39;.format(item)) return item if __name__ &#x3D;&#x3D; &#39;__main__&#39;: pipeline &#x3D; DishonestListPipeline() pipeline.open_spider(&#39;xx&#39;) item &#x3D; &#123; &#39;card_num&#39;: &#39;12345&#39; &#125; pipeline.process_item(item, &#39;&#39;) 随机User-Agent反反爬 在settings.py中添加USER_AGENTS列表 123456789101112131415161718192021222324252627282930313233343536USER_AGENTS &#x3D; [ &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident&#x2F;4.0; WOW64; Trident&#x2F;4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit&#x2F;523.15 (KHTML, like Gecko, Safari&#x2F;419.3) Arora&#x2F;0.3 (Change: 287 c9dfb30)&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux; en-US) AppleWebKit&#x2F;527+ (KHTML, like Gecko, Safari&#x2F;419.3) Arora&#x2F;0.6&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko&#x2F;20070215 K-Ninja&#x2F;2.1.1&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko&#x2F;20080705 Firefox&#x2F;3.0 Kapiko&#x2F;3.0&quot;, &quot;Mozilla&#x2F;5.0 (X11; Linux i686; U;) Gecko&#x2F;20070322 Kazehakase&#x2F;0.4.5&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora&#x2F;1.9.0.8-1.fc10 Kazehakase&#x2F;0.5.6&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;535.11 (KHTML, like Gecko) Chrome&#x2F;17.0.963.56 Safari&#x2F;535.11&quot;, &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit&#x2F;535.20 (KHTML, like Gecko) Chrome&#x2F;19.0.1036.7 Safari&#x2F;535.20&quot;, &quot;Opera&#x2F;9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto&#x2F;2.9.168 Version&#x2F;11.52&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;536.11 (KHTML, like Gecko) Chrome&#x2F;20.0.1132.11 TaoBrowser&#x2F;2.0 Safari&#x2F;536.11&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.71 Safari&#x2F;537.1 LBBROWSER&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;535.11 (KHTML, like Gecko) Chrome&#x2F;17.0.963.84 Safari&#x2F;535.11 LBBROWSER&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser&#x2F;7.0.3698.400)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident&#x2F;4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 5.1) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.89 Safari&#x2F;537.1&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.89 Safari&#x2F;537.1&quot;, &quot;Mozilla&#x2F;5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit&#x2F;533.17.9 (KHTML, like Gecko) Version&#x2F;5.0.2 Mobile&#x2F;8C148 Safari&#x2F;6533.18.5&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko&#x2F;20110307 Firefox&#x2F;4.0b13pre&quot;, &quot;Mozilla&#x2F;5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko&#x2F;20100101 Firefox&#x2F;16.0&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.11 (KHTML, like Gecko) Chrome&#x2F;23.0.1271.64 Safari&#x2F;537.11&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko&#x2F;20100922 Ubuntu&#x2F;10.10 (maverick) Firefox&#x2F;3.6.10&quot;] 实现随机User-Agent下载器中间件 12345678910class RandomUserAgent(object): def process_request(self, request, spider): # 如果spider是公示系统爬虫, 就直接跳过 if isinstance(spider, GsxtSpider): return None # 3. 实现process_request方法, 设置随机的User-Agent request.headers[&#39;User-Agent&#39;] &#x3D; random.choice(USER_AGENTS) return None settings.py中开启中间件 1234# 开启下载器中间件DOWNLOADER_MIDDLEWARES &#x3D; &#123; &#39;dishonest.dishonest.middlewares.RandomUserAgent&#39;: 543,&#125; 代理IP反反爬实现代理IP下载器中间件，在settings.py中开启, 并配置重试次数，继爬虫基础篇之IP代理池实现的动态IP代理池启动用于本次失信人抓取。 123456789101112131415161718class ProxyMiddleware(object): def process_request(self, request, spider): # 实现process_request方法, 设置代理IP # 如果spider是公示系统爬虫, 就直接跳过 if isinstance(spider, GsxtSpider): return None # 1. 获取协议头 protocol &#x3D; request.url.split(&#39;:&#x2F;&#x2F;&#39;)[0] # 2. 构建代理IP请求的URL proxy_url &#x3D; &#39;http:&#x2F;&#x2F;localhost:16888&#x2F;random?protocol&#x3D;&#123;&#125;&#39;.format(protocol) # 3. 发送请求, 获取代理IP response &#x3D; requests.get(proxy_url) # 4. 把代理IP设置给request.meta[&#39;proxy&#39;] request.meta[&#39;proxy&#39;] &#x3D; response.content.decode() return None 配置代理池中间件及重试次数(毕竟免费ip不稳定) 1234567# 开启下载器中间件DOWNLOADER_MIDDLEWARES &#x3D; &#123; &#39;dishonest.dishonest.middlewares.ProxyMiddleware&#39;: 500, &#39;dishonest.dishonest.middlewares.RandomUserAgent&#39;: 543,&#125;# 配置重试次数, 当使用不稳定代理的时候,可能会导致请求失败RETRY_TIMES &#x3D; 6 ![百度爬虫](爬虫基础篇之多途径抓取失信人名单/GIF 2021-4-27 22-15-36.gif) 国家企业信用公示系统继JS逆向之国家企业信用信息公示系统Cookie传递完成了cookie的逆向分析，本文利用Cookie的实现逻辑，在scrapy中实现公示系统的爬虫入库。 scrapy genspider gsxt gsxt.gov.cn 创建爬虫 准备起始URL, 打印响应内容 1234567891011class GsxtSpider(scrapy.Spider): name &#x3D; &#39;gsxt&#39; allowed_domains &#x3D; [&#39;gsxt.gov.cn&#39;] # 准备起始 start_urls &#x3D; [&#39;http:&#x2F;&#x2F;www.gsxt.gov.cn&#x2F;corp-query-entprise-info-xxgg-100000.html&#39;] def parse(self, response): # 打印状态吗 print(response.status) # 内容 print(response.text) 修改原来的随机User-Agent, 和随机代理的下载器中间件类, 如果是公示系统爬虫直接跳过. 123456789101112131415161718# 随机User-Agent下载器中间件class RandomUserAgent(object): def process_request(self, request, spider): # 国家企业信用信息系统爬虫, 每次发送请求必须携带cookie信息 if isinstance(spider, GsxtSpider): return ...# 代理下载器中间件class ProxyMiddleware(object): def process_request(self, request, spider): # 发送请求获取代理IP # 如果是国家企业信用信息系统爬虫, 直接返回 if isinstance(spider, GsxtSpider): return 定制cookie为了实现代理IP, User-Agent, cookie信息生成, 绑定和重用，实现步骤如下： 步骤: 实现生成cookie的脚本 用于生成多套代理IP, User-Agent, Cookie信息, 放到Redis 实现公示系统中间件类, 实现process_request方法, 从Redis中随机取出Cookie来使用, 关闭页面重定向. 实现process_response方法, 如果响应码不是200 或 没有内容重试 在setting.py文件件中配置, 开启该下载器中间 实现生成cookie的脚本 创建gen_gsxt_cookies.py文件, 在其中创建GenGsxtCookie的类 实现一个方法, 用于把一套代理IP, User-Agent, Cookie绑定在一起的信息放到Redis的list中 随机获取一个User-Agent 随机获取一个代理IP 获取request的session对象 把User-Agent, 通过请求头, 设置给session对象 把代理IP, 通过proxies, 设置给session对象 使用session对象, 发送请求, 获取需要的cookie信息 把代理IP, User-Agent, Cookie放到字典中, 序列化后, 存储到Redis的list中 实现一个run方法, 用于开启多个异步来执行这个方法. 注: 为了和下载器中间件交互方便, 需要在settings.py中配置一些常量. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374def push_cookie_to_redis(self): while True: try: &quot;&quot;&quot; 2. 实现一个方法, 用于把一套代理IP, User-Agent, Cookie绑定在一起的信息放到Redis的list中 &quot;&quot;&quot; # 1. 随机获取一个User-Agent user_agent &#x3D; random.choice(USER_AGENTS) # 2. 随机获取一个代理IP # response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;localhost:16888&#x2F;random?protocol&#x3D;http&#39;) # proxy &#x3D; response.content.decode() # 3. 获取requests的session对象 session &#x3D; requests.session() # 4. 把User-Agent, 通过请求头, 设置给session对象 session.headers &#x3D; &#123; &#39;User-Agent&#39;: user_agent &#125; # 5. 把代理IP, 通过proxies, 设置给session对象 # session.proxies &#x3D; &#123; # &#39;http&#39;: proxy # &#125; # 6. 使用session对象, 发送请求, 获取需要的cookie信息 index_url &#x3D; &#39;http:&#x2F;&#x2F;www.gsxt.gov.cn&#x2F;corp-query-entprise-info-xxgg-100000.html&#39; # 获取request的session对象, 可以自动合并cookie信息 # ######################################################使用session发送index_url请求########################### response &#x3D; session.get(index_url) print(response.status_code) # 第一次请求521 服务器借助这个请求设置一个Set-Cookie: __jsluid_h&#x3D;8af7a39f7cdb1c46f8f624c972968c8f; max-age&#x3D;31536000; path&#x3D;&#x2F;; HttpOnly到本地，并返回一段js ########################################################拿到第一个cookie######################## # 1. 提取script标签中的js js1 &#x3D; re.findall(&#39;&lt;script&gt;(.+?)&lt;&#x2F;script&gt;&#39;, response.content.decode())[0].replace(&#39;document.cookie&#x3D;&#39;, &#39;&#39;).replace( &#39;location.href&#x3D;location.pathname+location.search&#39;, &#39;&#39;) context &#x3D; js2py.EvalJs() ###################################################根据第一个请求返回的js生成第二个cookie############################### context.execute(&#39;cookies2 &#x3D;&#39; + js1) cookies &#x3D; context.cookies2.split(&#39;;&#39;)[0].split(&#39;&#x3D;&#39;) session.cookies.set(cookies[0], cookies[1]) # 到此拿到第两个cookie ######################################################拿到第二个cookie############################ # 第二次请求携带Cookie: __jsluid_h&#x3D;6ed2648e0a734bc66e3011d648f6f1ab; __jsl_clearance&#x3D;1619152879.013|-1|aS3lFknWlGtD%2FADiygf7vxl4yqk%3D返回一段js # 添加jsdom实现浏览器上下文 js2 &#x3D; &#39;&#39;&#39;const jsdom &#x3D; require(&quot;jsdom&quot;);const &#123;JSDOM&#125; &#x3D; jsdom;const dom &#x3D; new JSDOM();window &#x3D; dom.window;document &#x3D; window.document;location &#x3D; new Array();&#39;&#39;&#39; + \\ re.findall(&#39;&lt;script&gt;(.+?)&lt;&#x2F;script&gt;&#39;, session.get(index_url).content.decode(&#39;utf-8&#39;))[0] # 正则获取document[&#39;cookie&#39;]，由于每次个数不一样我们取最后一个 cookies2_1 &#x3D; re.findall(r&quot;document\\[.*?\\]&#x3D;(.*?)location&quot;, js2, re.S)[-1] # 将document[&#39;cookie&#39;]内容返回给go函数 js3 &#x3D; re.sub(&quot;&#125;;go&quot;, &quot;return &quot; + cookies2_1 + &quot;&#125;;go&quot;, js2, 1) # 获取调用go函数时里面的参数 request &#x3D; re.findall(r&quot;go\\(&#123;(.*?)&#125;\\)&quot;, js3, re.S)[-1] # 通过python修改js生成一个request方法 final_js &#x3D; js3 + &quot;\\nfunction request() &#123;return go(&#123;&quot; + request + &quot;&#125;)&#125;&quot; # js调用request方法返回cookie并将新的__jsl_clearance塞给session中 cookies3 &#x3D; execjs.compile(final_js).call(&#39;request&#39;).split(&#39;;&#39;)[0].split(&#39;&#x3D;&#39;) session.cookies.set(cookies3[0], cookies3[1]) # 第三次请求 修改了__jsl_clearance后服务端向客户端设置新cookie的SECTOKEN session.get(index_url) cookies &#x3D; requests.utils.dict_from_cookiejar(session.cookies) # print(cookies) # 7. 把代理IP, User-Agent, Cookie放到字典中, 序列化后, 存储到Redis的list中 cookies_dict &#x3D; &#123; COOKIES_KEY:cookies, COOKIES_USER_AGENT_KEY:user_agent, # COOKIES_PROXY_KEY:proxy &#125; # 序列化后, 存储到Redis的list中 self.redis.lpush(REDIS_COOKIES_KEY, pickle.dumps(cookies_dict)) print(cookies_dict) break except Exception as ex: print(&quot;error&quot;,ex) settings.py中配置信息 123456# 定义cookie的键COOKIE_KEY &#x3D; &#39;COOKIE&#39; # 字典中Cookie键COOKIE_PROXY_KEY &#x3D; &#39;COOKIE_PROXY&#39; # 字典中代理IP的键COOKIE_USER_AGENT_KEY &#x3D; &#39;COOKIE_USER_AGENT&#39; # 字典中User-Agent的键REDIS_COOKIES_KEY &#x3D; &#39;REDIS_COOKIES&#39; # Redis的cookie列表的键REDIS_URL &#x3D; &#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;0&#39; # Redis数据库的链接 定制中间件 步骤 实现process_request方法, 从Redis中随机取出Cookie来使用, 关闭页面重定向. 实现process_response方法, 如果响应码不是200 或 没有内容重试 1234567891011121314151617181920212223242526272829303132333435class GsxtCookieMiddleware(object): def __init__(self): &quot;&quot;&quot;建立Redis数据库连接&quot;&quot;&quot; self.redis &#x3D; StrictRedis.from_url(REDIS_URL) def process_request(self, request, spider): &quot;&quot;&quot;从Redis中随机取出Cookie来使用, 关闭页面重定向.&quot;&quot;&quot; count &#x3D; self.redis.llen(REDIS_COOKIES_KEY) random_index &#x3D; random.randint(0, count-1) cookie_data &#x3D; self.redis.lindex(REDIS_COOKIES_KEY, random_index) # 反序列化, 把二进制转换为字典 cookie_dict &#x3D; pickle.loads(cookie_data) # 把cookie信息设置request request.headers[&#39;User-Agent&#39;] &#x3D; cookie_dict[COOKIES_USER_AGENT_KEY] # 设置请求代理IP request.meta[&#39;proxy&#39;] &#x3D; cookie_dict[COOKIES_PROXY_KEY] # 设置cookie信息 request.cookies &#x3D; cookie_dict[COOKIES_KEY] # 设置不要重定向 request.meta[&#39;dont_redirect&#39;] &#x3D; True def process_response(self, request, response, spider): &quot;&quot;&quot;如果响应码不是200 或 没有内容重试&quot;&quot;&quot; # print(response.status) if response.status !&#x3D; 200 or response.body &#x3D;&#x3D; b&#39;&#39;: # 备份请求 req &#x3D; request.copy() # 设置请求不过滤 req.dont_filter &#x3D; True # 把请求交给引擎 return req return response 在setting.py文件件中配置中间件 12345DOWNLOADER_MIDDLEWARES &#x3D; &#123; &#39;dishonest.dishonest.middlewares.GsxtCookieMiddleware&#39;: 10, &#39;dishonest.dishonest.middlewares.ProxyMiddleware&#39;: 500, &#39;dishonest.dishonest.middlewares.RandomUserAgent&#39;: 543,&#125; 完善爬虫 解析页面中的城市名称和id, 构建公告信息的URL 解析失信企业公告信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class GsxtSpider(scrapy.Spider): name &#x3D; &#39;gsxt&#39; allowed_domains &#x3D; [&#39;gsxt.gov.cn&#39;] # 准备起始 start_urls &#x3D; [&#39;http:&#x2F;&#x2F;www.gsxt.gov.cn&#x2F;corp-query-entprise-info-xxgg-100000.html&#39;] custom_settings &#x3D; &#123; &#39;DOWNLOAD_DELAY&#39; : 5 &#125; def parse(self, response): # 获取城市标签的div列表 divs &#x3D; response.xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;qysx&quot;]&#x2F;div[3]&#x2F;div&#39;) # 遍历divs, 获取城市id和名称 for div in divs: area_id &#x3D; div.xpath(&#39;.&#x2F;@id&#39;).extract_first() area_name &#x3D; div.xpath(&#39;.&#x2F;label&#x2F;text()&#39;).extract_first() # 准备请求的URL url &#x3D; &#39;http:&#x2F;&#x2F;www.gsxt.gov.cn&#x2F;affiche-query-area-info-paperall.html?&#39; \\ &#39;noticeType&#x3D;11&amp;areaid&#x3D;100000&amp;noticeTitle&#x3D;&amp;regOrg&#x3D;&#123;&#125;&#39;.format(area_id) # 一个城市最多能够获取50条数据. for i in range(0, 50, 10): data &#x3D; &#123; &#39;start&#39;: str(i) &#125; # 构建请求, 交给引擎 yield scrapy.FormRequest(url, formdata&#x3D;data, callback&#x3D;self.parse_data, meta&#x3D;&#123;&#39;area_name&#39;: area_name&#125;) def parse_data(self, response): # print(response.text) &quot;&quot;&quot;解析页面中的城市&quot;&quot;&quot; area_name &#x3D; response.meta[&#39;area_name&#39;] result &#x3D; json.loads(response.text) datas &#x3D; result[&#39;data&#39;] for data in datas: item &#x3D; DishonestItem() # 区域名称 item[&#39;area_name&#39;] &#x3D; area_name # 公告标题 notice_title &#x3D; data[&#39;noticeTitle&#39;] name &#x3D; re.findall(&#39;关?于?(.+?)的?列入.*&#39;, notice_title)[0] item[&#39;name&#39;] &#x3D; name # 由于抓取的是失信企业公告, 所以抓到都是企业; 年龄设置为0 item[&#39;age&#39;] &#x3D; 0 notice_content &#x3D; data[&#39;noticeContent&#39;] card_id &#x3D; re.findall(&#39;经查.+[（\\(]统一社会信用码&#x2F;注册号：(\\w+)[）\\)]&#39;, notice_content) item[&#39;card_num&#39;] &#x3D; card_id[0] if len(card_id) !&#x3D; 0 else &#39;&#39; item[&#39;content&#39;] &#x3D; notice_content # 公布单位 item[&#39;publish_unit&#39;] &#x3D; data[&#39;judAuth_CN&#39;] # 获取到的时间, 是1970年1月1日 0时0分0秒 到发布时间的毫秒数 publish_ms &#x3D; data[&#39;noticeDate&#39;] # 转换为日期类型 publish_date &#x3D; datetime.fromtimestamp(publish_ms &#x2F; 1000) item[&#39;publish_date&#39;] &#x3D; publish_date.strftime(&#39;%Y年%m月%d日&#39;) yield item var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"http://onejane.github.io/tags/scrapy/"}]},{"title":"JS逆向之国家企业信用信息公示系统Cookie传递","slug":"JS逆向之国家企业信用信息公示系统Cookie","date":"2021-04-26T13:21:52.000Z","updated":"2021-12-12T03:09:39.226Z","comments":true,"path":"2021/04/26/JS逆向之国家企业信用信息公示系统Cookie/","link":"","permalink":"http://onejane.github.io/2021/04/26/JS%E9%80%86%E5%90%91%E4%B9%8B%E5%9B%BD%E5%AE%B6%E4%BC%81%E4%B8%9A%E4%BF%A1%E7%94%A8%E4%BF%A1%E6%81%AF%E5%85%AC%E7%A4%BA%E7%B3%BB%E7%BB%9FCookie/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 目标http://www.gsxt.gov.cn/corp-query-entprise-info-xxgg-100000.html 分析POST http://www.gsxt.gov.cn/affiche-query-area-info-paperall.html?noticeType=21&amp;areaid=100000&amp;noticeTitle=&amp;regOrg=110000 参数: noticeType=21 通知类型, 失信企业固定21 areaid=100000 无论在哪个区域, 固定是100000 noticeTitle= 通知标题, 可以为空 regOrg= 通知的区域id, 可以从省份标签上获取 请求体数据: draw: 1 点击分页按钮的次数, 可以省略 start: 0 起始索引号 length: 10 长度, 固定是10, 设置多了也无效 直接访问该接口时，状态521，返回如下js混淆加密代码。 尝试给请求头中加上cookie__jsluid_h=f6db0fc02adff8425bebcd8ed1b5fffc; SECTOKEN=7445298838033400749; __jsl_clearance=1619443187.64|0|nGqWRKwajO%2BeHI6CP7Mt50EbdcU%3D;，正常返回如下结果。 __jsluid_h打开fiddler，刷新页面抓包http://www.gsxt.gov.cn/corp-query-entprise-info-xxgg-100000.html,一共访问了三次该页面，前两次521第三次正场返回请求页面。 第一次请求时服务端向服务器塞入第一个__jsluid_h关键cookie 1Set-Cookie: __jsluid_h&#x3D;01737b0139a221e260d1061c68b4232f; max-age&#x3D;31536000; path&#x3D;&#x2F;; HttpOnly 并向浏览器返回一段混淆过的js，内容如下，主要功能应该是设置cookie。 1&lt;script&gt;document.cookie&#x3D;(&#39;_&#39;)+(&#39;_&#39;)+(&#39;j&#39;)+(&#39;s&#39;)+(&#39;l&#39;)+(&#39;_&#39;)+(&#39;c&#39;)+(&#39;l&#39;)+(&#39;e&#39;)+(&#39;a&#39;)+(&#39;r&#39;)+(&#39;a&#39;)+(&#39;n&#39;)+(&#39;c&#39;)+(&#39;e&#39;)+(&#39;&#x3D;&#39;)+((+true)+&#39;&#39;)+((1+[2])&#x2F;[2]+&#39;&#39;)+(-~false+&#39;&#39;)+(3+6+&#39;&#39;)+(2+2+&#39;&#39;)+(-~[2]+&#39;&#39;)+(~~false+&#39;&#39;)+((2)*[4]+&#39;&#39;)+((1+[0])&#x2F;[2]+&#39;&#39;)+(9-1*2+&#39;&#39;)+(&#39;.&#39;)+((2)*[2]+&#39;&#39;)+(6+&#39;&#39;)+(1+6+&#39;&#39;)+(&#39;|&#39;)+(&#39;-&#39;)+(-~0+&#39;&#39;)+(&#39;|&#39;)+(&#39;w&#39;)+(&#39;Y&#39;)+(&#39;p&#39;)+(&#39;A&#39;)+(&#39;F&#39;)+(&#39;R&#39;)+(&#39;%&#39;)+(1+1+&#39;&#39;)+(&#39;B&#39;)+(-~(4)+&#39;&#39;)+(&#39;X&#39;)+(&#39;x&#39;)+(&#39;m&#39;)+(&#39;W&#39;)+(&#39;Y&#39;)+((1&lt;&lt;2)+&#39;&#39;)+(&#39;j&#39;)+(&#39;P&#39;)+(&#39;a&#39;)+(&#39;Q&#39;)+([3]*(3)+&#39;&#39;)+(&#39;t&#39;)+(&#39;Q&#39;)+(1+7+&#39;&#39;)+(&#39;T&#39;)+(&#39;P&#39;)+(&#39;Z&#39;)+(&#39;i&#39;)+(&#39;E&#39;)+(&#39;%&#39;)+(3+&#39;&#39;)+(&#39;D&#39;)+(&#39;;&#39;)+(&#39;m&#39;)+(&#39;a&#39;)+(&#39;x&#39;)+(&#39;-&#39;)+(&#39;a&#39;)+(&#39;g&#39;)+(&#39;e&#39;)+(&#39;&#x3D;&#39;)+(3+&#39;&#39;)+(3+3+&#39;&#39;)+(~~&#39;&#39;+&#39;&#39;)+(~~false+&#39;&#39;)+(&#39;;&#39;)+(&#39;p&#39;)+(&#39;a&#39;)+(&#39;t&#39;)+(&#39;h&#39;)+(&#39;&#x3D;&#39;)+(&#39;&#x2F;&#39;);location.href&#x3D;location.pathname+location.search&lt;&#x2F;script&gt; 我们将这段js放入浏览器中执行，如我们所料，正是返回第二个__jsl_clearance关键性cookie。 __jsl_clearance第二次请求http://www.gsxt.gov.cn/corp-query-entprise-info-xxgg-100000.html时，浏览器发送了__jsl_clearance和__jsluid_h两个关键cookie，服务端接收后并返回了一段混淆后的js，这次没有向浏览器塞入cookie。 1Cookie: __jsluid_h&#x3D;01737b0139a221e260d1061c68b4232f; __jsl_clearance&#x3D;1619430857.467|-1|wYpAFR%2B5XxmWY4jPaQ9tQ8TPZiE%3D SECTOKEN第三次请求http://www.gsxt.gov.cn/corp-query-entprise-info-xxgg-100000.html时，浏览器携带了两个关键性Cookie，不过这次__jsl_clearance和之前的值发生变化，怀疑是第二次请求返回的js做了手脚。 1Cookie: __jsluid_h&#x3D;01737b0139a221e260d1061c68b4232f; __jsl_clearance&#x3D;1619430857.529|0|WGn9gKxiPtYUHAGBZ1a%2B%2F3o9sJE%3D 这次请求不仅正常的返回了页面内容，而且还往请求头中塞入了第三个SECTOKEN关键性Cookie。 1Set-Cookie: SECTOKEN&#x3D;7448433543385710812; Expires&#x3D;Sat, 14-May-2089 13:03:34 GMT; Path&#x3D;&#x2F;; HttpOnly 请求数据在上面的三个cookie加持下，终于成功的返回了我们想要的数据，接下来就是分析这三个cookie在代码中如何拿到。 爬虫实现通过requests的session对象，自动合并cookie信息，并设置请求头。 12345headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;78.0.3904.70 Safari&#x2F;537.36&#39;,&#125;session &#x3D; requests.session()session.headers &#x3D; headers 第一次请求通过第一次请求，服务端往客户端返回__jsluid_h作为第一个关键cookie，根据返回的js通过正则表达式拿到script标签中的js逻辑，并去除后面无用jslocation.href... 12345678response &#x3D; session.get(index_url)js1 &#x3D; re.findall(&#39;&lt;script&gt;(.+?)&lt;&#x2F;script&gt;&#39;, response.content.decode())[0].replace(&#39;document.cookie&#x3D;&#39;, &#39;&#39;).replace( &#39;location.href&#x3D;location.pathname+location.search&#39;, &#39;&#39;)context &#x3D; js2py.EvalJs() context.execute(&#39;cookies2 &#x3D;&#39; + js1)cookies &#x3D; context.cookies2.split(&#39;;&#39;)[0].split(&#39;&#x3D;&#39;)session.cookies.set(cookies[0], cookies[1]) # 到此拿到第两个cookieprint(session.cookies) 第二次请求第二次请求携带了前面两个关键性cookie，并返回了一段js。这里我们的cookie都存在了session中，所以不用额外处理。通过正则取出第二次返回的js中script标签中的内容。 就算格式化后这段代码都难以阅读，我们通过ob混淆专解测试版V0.1进行反混淆，重新审视这段js。 逻辑就是通过调用go函数往document中塞入cookie，我们在function go(_0x2323c8)最后返回document[&#39;cookie&#39;],把setTimeout的时间设置久一点。 通过上面分析我们可以通过第二次请求返回的js进行修改后，python调用生成cookie传递后被修改的__jsl_clearance关键cookie。不过很多对象在python调用时不可用，如window，document，location等等，我们可以通过jsdom库npm install jsdom实现浏览器的上下文。 123456const jsdom &#x3D; require(&quot;jsdom&quot;);const &#123;JSDOM&#125; &#x3D; jsdom;const dom &#x3D; new JSDOM();window &#x3D; dom.window;document &#x3D; window.document;location &#x3D; new Array(); 就这段js存入文件后，python读取文件，使用execjs实现调用，返回第二个__jsl_clearance关键性cookie，为获取SECTOKEN埋下伏笔。 1234with open(r&#39;第二次请求.js&#39;, encoding&#x3D;&#39;utf-8&#39;, mode&#x3D;&#39;r&#39;) as f: JsData &#x3D; f.read()cookie &#x3D; execjs.compile(JsData).call(&#39;request&#39;)print(cookie) 在python中为了调用go函数，还需要在js中新创建一个request函数，让go函数的数据返回给python作为cookie存入session中。 123456789101112131415# 添加jsdom实现浏览器上下文js2 = '''const jsdom = require(\"jsdom\");const &#123;JSDOM&#125; = jsdom;const dom = new JSDOM();window = dom.window;document = window.document;location = new Array();''' + \\ re.findall('&lt;script&gt;(.+?)&lt;/script&gt;', session.get(index_url).content.decode('utf-8'))[0]# 正则获取document['cookie']，由于每次个数不一样我们取最后一个cookies2_1 = re.findall(r\"document\\[.*?\\]=(.*?)location\", js2, re.S)[-1]# 将document['cookie']内容返回给go函数js3 = re.sub(\"&#125;;go\", \"return \" + cookies2_1 + \"&#125;;go\", js2, 1)# 获取调用go函数时里面的参数request = re.findall(r\"go\\(&#123;(.*?)&#125;\\)\", js3, re.S)[-1]# 通过python修改js生成一个request方法final_js = js3+\"\\nfunction request() &#123;return go(&#123;\"+request+\"&#125;)&#125;\"# js调用request方法返回cookie并将新的__jsl_clearance塞给session中cookies3 = execjs.compile(final_js).call('request').split(';')[0].split('=')session.cookies.set(cookies3[0], cookies3[1])print(cookies3) 第三次请求利用新的__jsl_clearance和__jsluid_h发送第三次请求，服务端会向客户端返回新Cookie SECTOKEN，接下来我们打印出所有的cookie。 123session.get(index_url)cookies &#x3D; requests.utils.dict_from_cookiejar(session.cookies)print(cookies) 12345678&#123; &#39;__jsl_clearance&#39;: &#39;1619446283.778|0|DFaPnxb5OqsBcRBkaxTSCax2qLA%3D&#39;, &#39;HttpOnly&#39;: None, &#39;JSESSIONID&#39;: &#39;e80d7db0e1fe65e65ab6a29e8cc4&#39;, &#39;SECTOKEN&#39;: &#39;7448640433386424422&#39;, &#39;__jsluid_h&#39;: &#39;2c8e0b64535955d16c6db3072464d199&#39;, &#39;tlb_cookie&#39;: &#39;S172.16.12.67&#39;&#125; 数据抓取12345678910111213141516171819url &#x3D; &#39;http:&#x2F;&#x2F;www.gsxt.gov.cn&#x2F;affiche-query-area-info-paperall.html?noticeType&#x3D;21&amp;areaid&#x3D;100000&amp;noticeTitle&#x3D;&amp;regOrg&#x3D;110000&#39;data &#x3D; &#123; # &#39;draw&#39;: &#39;0&#39;, &#39;start&#39;: &#39;0&#39;, &#39;length&#39;: &#39;10&#39;&#125;# 准备请求头headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;78.0.3904.70 Safari&#x2F;537.36&#39;, # &#39;User-Agent&#39;: &#39;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&#39;, # &#39;Referer&#39;: &#39;http:&#x2F;&#x2F;www.gsxt.gov.cn&#x2F;corp-query-entprise-info-xxgg-100000.html&#39;, # &#39;Cookie&#39;: &#39;__jsluid&#x3D;fb0718dce34ccf53c4b94d15e9ab13d5; SECTOKEN&#x3D;7178252594204902863; __jsl_clearance&#x3D;1546475343.133|0|QZ7AOWMecndqD4CZG4hqoBAHtVw%3D;&#39;&#125;response &#x3D; requests.post(url, cookies&#x3D;cookies, data&#x3D;data, headers&#x3D;headers)print(response.status_code)print(response.content.decode()) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之淘宝h5视频sign破解","slug":"JS逆向之淘宝h5视频sign破解","date":"2021-04-25T09:54:37.000Z","updated":"2021-12-12T03:09:39.272Z","comments":true,"path":"2021/04/25/JS逆向之淘宝h5视频sign破解/","link":"","permalink":"http://onejane.github.io/2021/04/25/JS%E9%80%86%E5%90%91%E4%B9%8B%E6%B7%98%E5%AE%9Dh5%E8%A7%86%E9%A2%91sign%E7%A0%B4%E8%A7%A3/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 需求最近需要抓取一些淘宝商品的首图视频，比如https://item.taobao.com/item.htm?spm=a230r.1.14.31.7ebfcec2qmczgd&amp;id=641116554739&amp;ns=1&amp;abbucket=2#detail，该页面首图视频页面元素是blob协议加密，该协议返回大多是m3u8格式的视频，并被切分为多个ts格式的小段视频集合。 分析通过chrome抓包果然找到了m3u8视频请求，第一个请求返回ts文件列表，紧接着发起视频请求返回ts视频数据。 12345# EXTM3U：.m3u8文件的格式定义# EXT-X-KEY： 密钥的信息# METHOD： 加密的方法，这里采用的是AES-128的加密方式# URI： 密钥的地址，需要获取访问得到密钥的信息# IV： 偏移量，AES加密的方法，通过这个密钥就可以解密，获取正确的视频信息 数据来源找到了，那么紧跟着就是找到这些链接的组成字段，如首个链接https://tbm-auth.alicdn.com/e99361edd833010b/1Ptetzs7wLumqr8DVXj/IZAAx7ivPbWWLLDYpm0_275076925941___hd.m3u8?auth_key=1619353994-0-0-7eac2e2d00d26717d7aad9746575f99f中大部分url参数都是加密串，通过搜索其中的1Ptetzs7wLumqr8DVXj，找到了多条符合条件的请求。 第一条请求中返回的数据中有两个参数的video_url，分别是hlsResources和mp4Resources，返回了m3u8和mp4格式，好家伙，这样省去了合并m3u8个流程，直接拿mp4格式的视频即可。 逆向拿到返回video_url的请求的参数，通过逐条过滤参数发现，最终生效的参数只有四个，分别是appKey,t,sign,data，每次请求都有失效时间。 其中appKey固定为12574478，t为精确到毫秒的时间戳，sign是今天的逆向主角参数，data动态内容为&#39;{&quot;videoId&quot;: &quot;%s&quot;,&quot;from&quot;:&quot;detail&quot;}&#39; % &quot;301079547561&quot;,其中301079547561作为videoId在页面请求时直接返回在页面js中。 sign无痕浏览器清空页面缓存，搜索sign，从众多页面中找到可能出现的位置，sign就是j，而 j = h(d.token + &quot;&amp;&quot; + i + &quot;&amp;&quot; + g + &quot;&amp;&quot; + c.data),其中d.token是加密字符串，i为时间戳，g为固定值12574478，c.data为{“videoId”:”275076925941”,”from”:”detail”} 在控制台中调用h函数返回32位字符串，猜测是md5加密，就不扣h函数的js了。 接下来就是分析这些参数中唯一变的参数d.token的来源。 d.token第一次断点时d.token为undefined。 放开断点后搜索d.token的值0027f0b395e6356158d06d22da238855,第一次出现在了返回video_url的请求返回时set-cookie中，作为Response Cookie返回了两个cookie，一个是_m_h5_tk，一个是_m_h5_tk_enc，_分割的前面一段就是d.token的值。 第二次进入断点时d.token=0027f0b395e6356158d06d22da238855,放开断点后搜索0027f0b395e6356158d06d22da238855出现在了同一个请求的Request Cookie中。 逻辑梳理大概思路清晰了，对同一个请求多次访问，第一次返回cookie作为第二次请求的cookie，cookie中的_m_h5_tk_enc通过_分割的前半段字符串作为d.token，根据d.token + &quot;&amp;&quot; + i + &quot;&amp;&quot; + g + &quot;&amp;&quot; + c.data进行md5得到sign，请求时加上两个cookie，完成video_url的请求，从而实现淘宝商品首图的视频抓取。 爬虫12345678910111213141516171819202122232425262728APPKEY &#x3D; &#39;12574478&#39;DATA &#x3D; &#39;&#123;&quot;videoId&quot;: &quot;%s&quot;,&quot;from&quot;:&quot;detail&quot;&#125;&#39; % &quot;301079547561&quot;URL &#x3D; &#39;https:&#x2F;&#x2F;h5api.m.taobao.com&#x2F;h5&#x2F;mtop.taobao.cloudvideo.video.queryforh5&#x2F;1.0&#x2F;&#39;params &#x3D; &#123;&#39;jsv&#39;: &#39;2.4.11&#39;, &#39;appKey&#39;: APPKEY, &#39;t&#39;: int(time.time() * 1000), &#39;sign&#39;: &#39;FAKE_SIGN_WITH_ANYTHING&#39;, &#39;api&#39;: &#39;mtop.wdetail.getItemDescx&#39;, &#39;callback&#39;: &#39;mtopjsonp1&#39;,&#39;v&#39;: &#39;4.9&#39;, &#39;type&#39;: &#39;jsonp&#39;, &#39;dataType&#39;: &#39;jsonp&#39;, &#39;data&#39;: DATA&#125;headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (iPhone; CPU iPhone OS 9_3_4 like Mac OS X) AppleWebKit&#x2F;601.1.46 &#39; + \\ &#39;(KHTML, like Gecko) Version&#x2F;9.0 Mobile&#x2F;13G35 Safari&#x2F;601.1&#39;,&#125;images &#x3D; []# get token in first requestr1 &#x3D; requests.get(URL, params&#x3D;params, headers&#x3D;headers)token_with_time &#x3D; r1.cookies.get(&#39;_m_h5_tk&#39;)token &#x3D; token_with_time.split(&#39;_&#39;)[0]enc_token &#x3D; r1.cookies.get(&#39;_m_h5_tk_enc&#39;)# get results in second requestt2 &#x3D; str(int(time.time() * 1000))c &#x3D; &#39;&amp;&#39;.join([token, t2, APPKEY, DATA])m &#x3D; hashlib.md5()m.update(c.encode(&#39;utf-8&#39;))params.update(&#123;&#39;t&#39;: t2, &#39;sign&#39;: m.hexdigest()&#125;)cookies &#x3D; &#123;&#39;_m_h5_tk&#39;: token_with_time, &#39;_m_h5_tk_enc&#39;: enc_token&#125;r2 &#x3D; requests.get(URL, params&#x3D;params, headers&#x3D;headers, cookies&#x3D;cookies)results&#x3D;json.loads(re.match(r&#39; mtopjsonp1\\((.*?)\\)&#39;, r2.text).group(1))video_url &#x3D; jsonpath(results, &#39;$..video_url&#39;)[1]print(video_url) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"Xposed搭建开发","slug":"Xposed搭建开发","date":"2021-04-23T13:06:27.000Z","updated":"2022-10-15T10:00:21.878Z","comments":true,"path":"2021/04/23/Xposed搭建开发/","link":"","permalink":"http://onejane.github.io/2021/04/23/Xposed%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 pixel刷安卓7proxychains wget https://dl.google.com/dl/android/aosp/sailfish-n2g47o-factory-f2bc8024.zip proxychains wget https://forum.xda-developers.com/attachments/xposedinstaller_3-1-5-apk.4393082/ proxychains wget https://supersuroot.org/downloads/supersu-pro.apk proxychains wget https://dl.twrp.me/sailfish/twrp-3.3.0-0-sailfish.img 123456cd sailfish-opm4.171019.021.p1 &amp;&amp; adb reboot bootloader &amp;&amp; .&#x2F;flash-all.shadb push SR5-SuperSU-v2.82-SR5-20171001224502.zip &#x2F;data&#x2F;local&#x2F;tmpadb reboot bootloader &amp;&amp; fastboot boot twrp-3.3.0-0-sailfish.img 刷入twrp后安装supersuadb install XposedInstaller_3.1.5.apk 常见模块https:&#x2F;&#x2F;github.com&#x2F;WrBug&#x2F;GravityBox.gitadb push timeadjust.sh &#x2F;data&#x2F;local&#x2F;tmp &amp;&amp; sh timeadjust.sh 时间修改正确adb install com.ttxapps.wifiadb_2.1.3-810031745_minAPI15.apk pixel刷安卓101234567891011121314adb reboot bootloader 安卓10，marlin-qp1a.191005.007.a3解压缩拿到boot.imgflash-all.sh adb install magisk-25.2.apk 开发者模式开启后安装magiskadb push boot.img &#x2F;sdcard&#x2F;Download 在magisk安装选择一个修补文件，生成同目录magisk_patched-25200_5K3cq.img adb pull &#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Download&#x2F;magisk_patched-25200_5K3cq.img adb reboot bootloaderfastboot flash boot magisk_patched-25200_5K3cq.imgsettings put global captive_portal_http_url https:&#x2F;&#x2F;www.google.cn&#x2F;generate_204 去除wifi上的×settings put global captive_portal_https_url https:&#x2F;&#x2F;www.google.cn&#x2F;generate_204settings put global ntp_server 1.hk.pool.ntp.org 修改时区adb push Shamiko-v0.5.2-120-release.zip &#x2F;sdcard&#x2F;Downloadadb push LSPosed-v1.8.4-6609-zygisk-release.zip &#x2F;sdcard&#x2F;Downloadadb install com.ttxapps.wifiadb_2.1.3-810031745_minAPI15.apkadb push MagiskHidePropsConf-v5.3.4.zip &#x2F;sdcard&#x2F;Download 通过magisk安装后adb shell-props-413yy,getprop ro.debuggable 即可查看1,开启全局可调式 如何卸载Magisk：方法一：在Magisk首页点击“卸载Magisk”并按提示操作；方法二：下载官方Magisk.apk，复制并改名为uninstall.zip，再使用Recovery刷入；从Magisk v22.0开始，Magisk和Magisk Manager就合并为一个文件了，将文件名为Magisk.apk时它是Magisk应用程序，用于管理Magisk模块及功能；当文件名为Magisk.zip时它是刷入Magisk的卡刷包；当文件名为uninstall.zip时它是用于卸载Magisk的卡刷包。如果安装Magisk导致无法正常开机，可在Recovery中刷入uninstall.zip即可卸载Magisk。magisk在v24之后取消了magisk hide和在线仓库，可以通过Zygisk来实现root隐藏，刷入Shamiko模块，关闭遵守排除列表。 为什么要用Shamiko做root隐藏，而不是使用zygisk magisk自带的遵守排除列表？不适用Shamiko也是可以的，zygisk magisk自带排除列表功能，但是这种情况下排除列表中的应用是无法使用magisk和xposed模块的，如果我想对某个排除列表中的应用使用虚拟框架和模块，就需要使用到Shamiko模块 zygisk是什么？和riru有什么关系在Zygisk出现之前，Xposed是通过riru实现的，riru注入zygote以允许模块在应用程序中运行。在magisk v24+中，推出zygisk，可以理解成Zygisk = Zygote + Magisk，和riru的功能类似。使用了Zygisk后，就不需要安装riru模块了，同时依赖于riru的xposed框架也无法使用，但是可以使用支持zygisk的LSPosed。目前riru已经停止更新。 xposedxposed api demo过滤子进程：loadPackageParam.processName,可以通过hook参数、调用栈、返回值 ，打印和修改，Xposed的开发，本质上就是Java的开发。 创建安卓项目xposed1 build.gradle引入xposed api依赖 123456789101112131415161718192021222324252627apply plugin: &#39;com.android.application&#39;android &#123; compileSdkVersion 30 buildToolsVersion &quot;30.0.2&quot; defaultConfig &#123; applicationId &quot;com.roysue.xposed1&quot; minSdkVersion 16 targetSdkVersion 30 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; &#125;&#125;dependencies &#123; compileOnly &#39;de.robv.android.xposed:api:82&#39; compileOnly &#39;de.robv.android.xposed:api:82:sources&#39; implementation fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;]) implementation &#39;androidx.appcompat:appcompat:1.2.0&#39; implementation &#39;androidx.constraintlayout:constraintlayout:2.0.2&#39; testImplementation &#39;junit:junit:4.12&#39; androidTestImplementation &#39;androidx.test.ext:junit:1.1.2&#39; androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.3.0&#39;&#125; AndroidManifest.xml添加xposed项目基本配置 12345678910111213141516171819202122232425262728&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; package&#x3D;&quot;com.roysue.xposed1&quot;&gt; &lt;application android:allowBackup&#x3D;&quot;true&quot; android:icon&#x3D;&quot;@mipmap&#x2F;ic_launcher&quot; android:label&#x3D;&quot;@string&#x2F;app_name&quot; android:roundIcon&#x3D;&quot;@mipmap&#x2F;ic_launcher_round&quot; android:supportsRtl&#x3D;&quot;true&quot; android:theme&#x3D;&quot;@style&#x2F;AppTheme&quot;&gt; &lt;meta-data android:name&#x3D;&quot;xposedmodule&quot; android:value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;meta-data android:name&#x3D;&quot;xposeddescription&quot; android:value&#x3D;&quot;这是一个Xposed例程&quot; &#x2F;&gt; &lt;meta-data android:name&#x3D;&quot;xposedminversion&quot; android:value&#x3D;&quot;53&quot; &#x2F;&gt; &lt;activity android:name&#x3D;&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name&#x3D;&quot;android.intent.action.MAIN&quot; &#x2F;&gt; &lt;category android:name&#x3D;&quot;android.intent.category.LAUNCHER&quot; &#x2F;&gt; &lt;&#x2F;intent-filter&gt; &lt;&#x2F;activity&gt; &lt;&#x2F;application&gt;&lt;&#x2F;manifest&gt; activity_main.xml添加按钮组件 12345678910111213141516171819202122232425&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot; xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; tools:context&#x3D;&quot;.MainActivity&quot;&gt; &lt;TextView android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot; app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot; app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot; app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; &#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;button&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;Button&quot; tools:layout_editor_absoluteX&#x3D;&quot;158dp&quot; tools:layout_editor_absoluteY&#x3D;&quot;238dp&quot; &#x2F;&gt;&lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt; MainActivity调用Button组件，实现被hook方法toastMessage 1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity &#123; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button &#x3D; (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; public void onClick(View v) &#123; Toast.makeText(MainActivity.this, toastMessage(&quot;我未被劫持&quot;), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; public String toastMessage(String message) &#123; return message; &#125;&#125; 继承IXposedHookLoadPackage实现hook 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class HookTest implements IXposedHookLoadPackage &#123; &#x2F;&#x2F; 堆栈打印 public void PrintStack()&#123; XposedBridge.log(&quot;Dump Stack: &quot;+ &quot;---------------start----------------&quot;); Throwable ex &#x3D; new Throwable(); StackTraceElement[] stackElements &#x3D; ex.getStackTrace(); if (stackElements !&#x3D; null) &#123; for (int i &#x3D; 0; i &lt; stackElements.length; i++) &#123; XposedBridge.log(&quot;Dump Stack&quot;+i+&quot;: &quot;+ stackElements[i].getClassName() +&quot;----&quot;+stackElements[i].getFileName() +&quot;----&quot; + stackElements[i].getLineNumber() +&quot;----&quot; +stackElements[i].getMethodName()); &#125; &#125; XposedBridge.log(&quot;Dump Stack: &quot;+ &quot;---------------over----------------&quot;); RuntimeException e &#x3D; new RuntimeException(&quot;&lt;Start dump Stack !&gt;&quot;); e.fillInStackTrace(); Log.i(&quot;&lt;Dump Stack&gt;:&quot;, &quot;++++++++++++&quot;, e); &#125; public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; &#x2F;&#x2F;XposedBridge.log(loadPackageParam.processName); if (loadPackageParam.packageName.equals(&quot;com.roysue.xposed1&quot;)) &#123; XposedBridge.log(&quot; has Hooked!&quot;); XposedBridge.log(&quot;inner&quot;+loadPackageParam.processName); Class clazz &#x3D; loadPackageParam.classLoader.loadClass(&quot;com.roysue.xposed1.MainActivity&quot;); XposedHelpers.findAndHookMethod(clazz, &quot;toastMessage&quot;, String.class,new XC_MethodHook() &#123; protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; &#x2F;&#x2F; 原始参数 String oldText &#x3D; (String) param.args[0]; Log.d(&quot;din not hijacked&#x3D;&gt;&quot;, oldText); &#x2F;&#x2F;param.args[0] &#x3D; &quot;test&quot;; &#x2F;&#x2F; 修改新参数 param.args[0] &#x3D; &quot;你已被劫持&quot;; PrintStack(); &#x2F;&#x2F;super.beforeHookedMethod(param); &#x2F;&#x2F;XposedBridge.log(&quot; has Hooked!&quot;); &#125; protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; Log.d(&quot;getResult is &#x3D;&gt; &quot;,(String) param.getResult()); param.setResult(&quot;你已被劫持2&quot;); &#125; &#125;); &#125; &#125;&#125; xposed_init配置hook方法com.roysue.xposed1.HookTest 编译启动该app，注入Xposed 点击按钮查看log及调用栈 123objection -g com.roysue.xposed1 exploreandroid hooking search classes HookTest android hooking list class_methods com.roysue.xposed1.HookTest 找不到该类，原因是实现了接口IXposedHookLoadPackage，HookTest不在接口包中，需要在xposed_init里指定路径 hookHook HookTestobjection无法找到，通过frida进行hook拿到HookTest，frida -UF -l hookXposed.js 12345678910111213141516171819202122232425262728293031function hook() &#123; Java.perform(function () &#123; console.log(&quot;start&quot;) Java.enumerateClassLoaders(&#123; onMatch: function (loader) &#123; try &#123; if(loader.findClass(&quot;com.roysue.xposed1.HookTest&quot;))&#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); Java.classFactory.loader &#x3D; loader ; &#125; &#125; catch(error)&#123; console.log(&quot;find error:&quot; + error) &#125; &#125;, onComplete: function () &#123; console.log(&quot;end1&quot;) &#125; &#125;) &#125;) Java.use(&quot;com.roysue.xposed1.HookTest&quot;).PrintStack.implementation &#x3D; function (param)&#123; console.log(&quot;entering PrintStack&quot;); return true; &#125; console.log(&quot;end2&quot;) &#125;function main()&#123; hook()&#125;setImmediate(main) Hook XposedBridge1234567891011121314151617181920212223242526272829function hook() &#123; Java.perform(function () &#123; console.log(&quot;start&quot;) Java.enumerateClassLoaders(&#123; onMatch: function (loader) &#123; try &#123; &#x2F;&#x2F; if (loader.findClass(&quot;com.roysue.xposed1.HookTest&quot;)) &#123; if(loader.findClass(&quot;de.robv.android.xposed.XposedBridge&quot;))&#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); Java.classFactory.loader &#x3D; loader; &#125; &#125; catch (error) &#123; console.log(&quot;find error:&quot; + error) &#125; &#125;, onComplete: function () &#123; console.log(&quot;end1&quot;) &#125; &#125;) Java.use(&quot;de.robv.android.xposed.XposedBridge&quot;).log.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (str) &#123; console.log(&quot;entering XposedBridge.log&quot;,str.toString()); return true; &#125; console.log(&quot;end2&quot;) &#125;)&#125; Hook All Methods1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function uniqBy(array, key) &#123; var seen &#x3D; &#123;&#125;; return array.filter(function (item) &#123; var k &#x3D; key(item); return seen.hasOwnProperty(k) ? false : (seen[k] &#x3D; true); &#125;);&#125;&#x2F;&#x2F; trace a specific Java Methodfunction traceMethod(targetClassMethod) &#123; var delim &#x3D; targetClassMethod.lastIndexOf(&quot;.&quot;); if (delim &#x3D;&#x3D;&#x3D; -1) return; var targetClass &#x3D; targetClassMethod.slice(0, delim) var targetMethod &#x3D; targetClassMethod.slice(delim + 1, targetClassMethod.length) var hook &#x3D; Java.use(targetClass); var overloadCount &#x3D; hook[targetMethod].overloads.length; console.log(&quot;Tracing &quot; + targetClassMethod + &quot; [&quot; + overloadCount + &quot; overload(s)]&quot;); &#x2F;* &#x2F;&#x2F; hook all class_method for (var i &#x3D; 0; i &lt; overloadCount; i++) &#123; hook[targetMethod].overloads[i].implementation &#x3D; function () &#123; console.warn(&quot;\\n*** entered &quot; + targetClassMethod); &#x2F;&#x2F; print backtrace &#x2F;&#x2F; Java.perform(function() &#123; &#x2F;&#x2F; var bt &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()); &#x2F;&#x2F; console.log(&quot;\\nBacktrace:\\n&quot; + bt); &#x2F;&#x2F; &#125;); &#x2F;&#x2F; print args if (arguments.length) console.log(); for (var j &#x3D; 0; j &lt; arguments.length; j++) &#123; console.log(&quot;arg[&quot; + j + &quot;]: &quot; + arguments[j]); &#125; &#x2F;&#x2F; print retval var retval &#x3D; this[targetMethod].apply(this, arguments); &#x2F;&#x2F; rare crash (Frida bug?) console.log(&quot;\\nretval: &quot; + retval); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.warn(&quot;\\n*** exiting &quot; + targetClassMethod); return retval; &#125; &#125; *&#x2F;&#125;function traceClass(targetClass) &#123; &#x2F;&#x2F;Java.use是新建一个对象哈，大家还记得么？ var hook &#x3D; Java.use(targetClass); &#x2F;&#x2F;利用反射的方式，拿到当前类的所有方法 var methods &#x3D; hook.class.getDeclaredMethods(); &#x2F;&#x2F; var methods &#x3D; hook.class.getMethods(); &#x2F;&#x2F;建完对象之后记得将对象释放掉哈 hook.$dispose; &#x2F;&#x2F;将方法名保存到数组中 var parsedMethods &#x3D; []; methods.forEach(function (method) &#123; parsedMethods.push(method.toString().replace(targetClass + &quot;.&quot;, &quot;TOKEN&quot;).match(&#x2F;\\sTOKEN(.*)\\(&#x2F;)[1]); &#125;); &#x2F;&#x2F;去掉一些重复的值 var targets &#x3D; uniqBy(parsedMethods, JSON.stringify); &#x2F;&#x2F;对数组中所有的方法进行hook，traceMethod也就是第一小节的内容 targets.forEach(function (targetMethod) &#123; traceMethod(targetClass + &quot;.&quot; + targetMethod); &#125;);&#125; traceClass(“de.robv.android.xposed.XposedBridge”); 12if (loader.findClass(&quot;com.roysue.xposed1.HookTest$1&quot;)) &#123; traceClass(&quot;com.roysue.xposed1.HookTest$1&quot;); 说明com.roysue.xposed1.HookTest$1就是XposedHelpers.findAndHookMethod(clazz, &quot;toastMessage&quot;, String.class,new XC_MethodHook() {中的XC_MethodHook内部类 hook afterHookedMethod 1234567891011121314151617181920212223242526272829function hook() &#123; Java.perform(function () &#123; console.log(&quot;start&quot;) Java.enumerateClassLoaders(&#123; onMatch: function (loader) &#123; try &#123; &#x2F;&#x2F; if (loader.findClass(&quot;com.roysue.xposed1.HookTest&quot;)) &#123; if(loader.findClass(&quot;com.roysue.xposed1.HookTest$1&quot;))&#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); Java.classFactory.loader &#x3D; loader; &#125; &#125; catch (error) &#123; console.log(&quot;find error:&quot; + error) &#125; &#125;, onComplete: function () &#123; console.log(&quot;end1&quot;) &#125; &#125;) Java.use(&quot;com.roysue.xposed1.HookTest$1&quot;).afterHookedMethod.implementation &#x3D; function (param) &#123; console.log(&quot;entering afterHookedMethod param is &quot;,param); return this.afterHookedMethod(param); &#125; console.log(&quot;end2&quot;) &#125;)&#125; 通过traceClass(&quot;de.robv.android.xposed.XC_MethodHook$MethodHookParam&quot;)拿到所有的类方法，在classloader中而不是在app中 123456Java.use(&quot;de.robv.android.xposed.XC_MethodHook$MethodHookParam&quot;).setResult.implementation &#x3D; function (param) &#123; console.log(&quot;entering XC_MethodHook$MethodHookParam setResult param is &quot;,param); &#x2F;&#x2F; 打印调用栈 console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return this.setResult(param);&#125; XC_MethodHook是抽象类不能直接hook，需要hook实现。 traceClass(“com.roysue.xposed1.HookTest$1”) GravityBoxgit clone https://github.com/GravityBox/GravityBox.git 修改app/build.gradle 123456789compileSdkVersion 23targetSdkVersion 23 debug &#123; 避免打包需要秘钥&#x2F;&#x2F; versionNameSuffix &quot;-Dev&quot; &#x2F;&#x2F; if (signingConfigs.releaseConfig !&#x3D; null) &#123;&#x2F;&#x2F; signingConfig signingConfigs.releaseConfig&#x2F;&#x2F; &#125; &#125;compile &#39;com.android.support:appcompat-v7:26.0.2&#39; 指定版本 build.gradle 1234567891011121314151617buildscript &#123; repositories &#123; jcenter() google() 添加google镜像源 &#125; dependencies &#123; classpath &#39;com.android.tools.build:gradle:2.3.3&#39; &#125;&#125;allprojects &#123; repositories &#123; jcenter() google() maven &#123; url &#39;https:&#x2F;&#x2F;jitpack.io&#39; &#125; &#125;&#125; 源码分析src/assets/xposed_init 文件中提供了入口类com.wrbug.gravitybox.nougat.GravityBox 1public class GravityBox implements IXposedHookZygoteInit, IXposedHookInitPackageResources, IXposedHookLoadPackage 入口类中实现了三个接口IXposedHookInitPackageResources，IXposedHookLoadPackage，IXposedHookZygoteInit IXposedHookZygoteInit 所有的进程 Hook the initialization of ** (es), from which **all the apps are forked. Implement this interface in your module’s main class in order to be notified when Android is starting up. In IXposedHookZygoteInit, you can modify objects and place hooks that should be applied for every app. Only the Android framework/system classes are available at that point in time. Use null as class loader for XposedHelpers.findAndHookMethod(String, ClassLoader, String, Object...) and its variants. If you want to hook one/multiple specific apps, use IXposedHookLoadPackage instead. 说明initZygote只有在系统启动的时候执行一遍，只有系统框架库可以使用。 XposedBridge.log(“GB:Hardware: “ + Build.HARDWARE); 代码中调用了Build.HARDWARE 123frida-ps -U|grep gravityobjection -g com.ceco.nougat.gravitybox explore -P ~&#x2F;.objection&#x2F;pluginsplugin wallbreaker classdump --fullname android.os.Build **IXposedHookInitPackageResources ** 所有的资源 Get notified when the resources for an app are initialized. In handleInitPackageResources(XC_InitPackageResources.InitPackageResourcesParam), resource replacements can be created. This interface should be implemented by the module’s main class. Xposed will take care of registering it as a callback automatically. 说明handleInitPackageResources实现的回调在创建之后就会得到通知 **IXposedHookLoadPackage ** 所有的包 Get notified when an app (“Android package”) is loaded. This is especially useful to hook some app-specific methods. This interface should be implemented by the module’s main class. Xposed will take care of registering it as a callback automatically. xposed会将handleLoadPackage注册成为回调，app在加载时都会经过该回调，主要用来实现具体的hook逻辑。 在handleLoadPackage中调用了ModStatusbarColor.init 123if (lpparam.packageName.equals(ModStatusbarColor.PACKAGE_NAME)) &#123; ModStatusbarColor.init(prefs, lpparam.classLoader);&#125; 1234567891011121314151617181920212223242526272829303132public static final String PACKAGE_NAME &#x3D; &quot;com.android.systemui&quot;; private static final String CLASS_PHONE_STATUSBAR &#x3D; &quot;com.android.systemui.statusbar.phone.PhoneStatusBar&quot;; public static void init(final XSharedPreferences prefs, final ClassLoader classLoader) &#123; try &#123; &#x2F;&#x2F; findClass底层通过反射获取CLASS_PHONE_STATUSBAR类 final Class&lt;?&gt; phoneStatusbarClass &#x3D; XposedHelpers.findClass(CLASS_PHONE_STATUSBAR, classLoader); final Class&lt;?&gt; statusbarIconViewClass &#x3D; XposedHelpers.findClass(CLASS_STATUSBAR_ICON_VIEW, classLoader); final Class&lt;?&gt; sbTransitionsClass &#x3D; XposedHelpers.findClass(CLASS_SB_TRANSITIONS, classLoader); XposedHelpers.findAndHookMethod(phoneStatusbarClass, &#x2F;&#x2F; hook相同的类时XCallback.PRIORITY_LOWEST最低,优先级最高 &#x2F;&#x2F; https:&#x2F;&#x2F;api.xposed.info&#x2F;reference&#x2F;de&#x2F;robv&#x2F;android&#x2F;xposed&#x2F;XC_MethodHook.html &quot;makeStatusBarView&quot;, new XC_MethodHook(XCallback.PRIORITY_LOWEST) &#123; @Override protected void afterHookedMethod(final MethodHookParam param) throws Throwable &#123; mPhoneStatusBar &#x3D; param.thisObject; &#x2F;&#x2F; getObjectField获取对象的属性值 &#x2F;&#x2F; https:&#x2F;&#x2F;api.xposed.info&#x2F;reference&#x2F;de&#x2F;robv&#x2F;android&#x2F;xposed&#x2F;XposedHelpers.html Context context &#x3D; (Context) XposedHelpers.getObjectField(param.thisObject, &quot;mContext&quot;); if (SysUiManagers.IconManager !&#x3D; null) &#123; SysUiManagers.IconManager.registerListener(mIconManagerListener); &#125; Intent i &#x3D; new Intent(ACTION_PHONE_STATUSBAR_VIEW_MADE); context.sendBroadcast(i); &#125; &#125;); &#125; catch (Throwable t) &#123; GravityBox.log(TAG, t); &#125; &#125; 由于com.android.systemui和当前hook的包在不同进程中 123objection -g com.android.systemui exploreandroid hooking search classes com.android.systemui ~&#x2F;.objection&#x2F;pluginsplugin wallbreaker classdump --fullname com.android.systemui.statusbar.phone.PhoneStatusBar 静态域 https://api.xposed.info/reference/de/robv/android/xposed/XposedHelpers.html 12345BRIGHTNESS_ON &#x3D; XposedHelpers.getStaticIntField(powerManagerClass, &quot;BRIGHTNESS_ON&quot;);plugin wallbreaker classdump --fullname android.os.PowerManager 查看静态域(int[])XposedHelpers.getStaticObjectField(classAudioService, &quot;MAX_STREAM_VOLUME&quot;);XposedHelpers.getStaticLongField(param.thisObject.getClass(),&quot;SWIPE_TIMEOUT_MS&quot;)(boolean) XposedHelpers.getStaticBooleanField(mDisplayPowerController.getClass(), &quot;MTK_ULTRA_DIMMING_SUPPORT&quot;); 动态域 https://api.xposed.info/reference/de/robv/android/xposed/XposedHelpers.html 12345XposedHelpers.getObjectField(param.thisObject, &quot;mNotification&quot;) &#x3D;&#x3D; nullobjection -g com.ceco.nougat.gravitybox explore -P ~&#x2F;.objection&#x2F;pluginsandroid heap search instances com.android.systemui.statusbar.phone.PhoneStatusBar 内存搜索PhoneStatusBar类实例plugin wallbreaker objectsearch com.android.systemui.statusbar.phone.PhoneStatusBar 内存搜索对象plugin wallbreaker objectiondump --fullname 0x100e6e 查看类内容中的动态域mNotification 主动调用 https://api.xposed.info/reference/de/robv/android/xposed/XposedHelpers.html 123456(Float) XposedHelpers.callMethod(param.thisObject, &quot;getNonBatteryClockAlphaFor&quot;, (Integer) param.args[0]);XposedHelpers.callStaticMethod(mClsPhoneFactory, &quot;getPhone&quot;, mSimSlot);plugin wallbreaker objectsearch com.android.systemui.statusbar.phone.PhoneStatusBarTransitionsplugin wallbreaker objectdump --fullname 0x10141e 查找getNonBatteryClockAlphaFor方法int phoneId &#x3D; XposedHelpers.getIntField(param.thisObject, &quot;mPhoneId&quot;);Context context &#x3D; (Context) XposedHelpers.getObjectField(param.thisObject, &quot;mContext&quot;); 构造函数 123456789101112131415XposedHelpers.findAndHookConstructor(&quot;android.media.AudioManager&quot;, classLoader, Context.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; Object objService &#x3D; XposedHelpers.callMethod(param.thisObject, &quot;getService&quot;); Context mApplicationContext &#x3D; (Context) XposedHelpers.getObjectField(param.thisObject, &quot;mApplicationContext&quot;); if (objService !&#x3D; null &amp;&amp; mApplicationContext !&#x3D; null) &#123; XposedHelpers.callMethod(param.thisObject, &quot;disableSafeMediaVolume&quot;); &#125; &#125;&#125;);android hooking search classes android.media.AudioMangerplugin wallbreaker objectsearch android.media.AudioManagerplugin wallbreaker objectdump --fullname 0x186e 查看getService和disableSafeMediaVolume和mApplicationContext Not In Frida1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950setAdditionalInstanceField(param.thisObject, &quot;mVolumeUpLongPress&quot;, mVolumeUpLongPress); 给对象加静态域Object ls &#x3D; XposedHelpers.getSurroundingThis(mLight); 内部类对象返回给外部类Class[] params &#x3D; method.getParameterTypes(); 获取参数列表UserHandle uh &#x3D; (UserHandle) uhConst.newInstance(-2); 创建新实例对象Constructor&lt;?&gt; uhConst &#x3D; XposedHelpers.findConstructorExact(UserHandle.class, int.class); 查找一个构造函数让其可用XposedBridge.hookAllConstructors(XposedHelpers.findClass( hook所有构造函数 CLASS_TRUST_MANAGER_SERVICE, classLoader), new XC_MethodHook() &#123; @Override protected void afterHookedMethod(final MethodHookParam param) throws Throwable &#123; mTrustManager &#x3D; param.thisObject; Context context &#x3D; (Context) XposedHelpers.getObjectField(param.thisObject, &quot;mContext&quot;); mWifiManager &#x3D; new WifiManagerWrapper(context, null); mConnectivityManager &#x3D; (ConnectivityManager) context.getSystemService( Context.CONNECTIVITY_SERVICE); IntentFilter intentFilter &#x3D; new IntentFilter(); intentFilter.addAction(WifiPriorityActivity.ACTION_WIFI_TRUSTED_CHANGED); intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); context.registerReceiver(mBroadcastReceiver, intentFilter); if (DEBUG) log(&quot;Trust manager constructed&quot;); &#125;&#125;);XposedBridge.hookMethod(mtdHandlePlay, new XC_MethodHook() &#123; hook所有方法并创建回调 @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; qhPrefs.reload(); QuietHours qh &#x3D; new QuietHours(qhPrefs); if (qh.isSystemSoundMuted(QuietHours.SystemSound.RINGER)) &#123; param.setResult(null); &#125; &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; if (!mRingerConfig.enabled) return; mRingtone &#x3D; (Ringtone) XposedHelpers.getObjectField(mAsyncRinger, &quot;mRingtone&quot;); if (mRingtone &#x3D;&#x3D; null) &#123; if (DEBUG) log(&quot;handlePlay called but ringtone is null&quot;); return; &#125; setVolume(mRingerConfig.minVolume); mIncrementAmount &#x3D; (1f - mRingerConfig.minVolume) &#x2F; (float) mRingerConfig.rampUpDuration; mCurrentIncrementVolume &#x3D; mRingerConfig.minVolume; mHandler &#x3D; (Handler) XposedHelpers.getObjectField(mAsyncRinger, &quot;mHandler&quot;); mHandler.postDelayed(mRunnable, 1000); if (DEBUG) log(&quot;Starting increasing ring&quot;); &#125;&#125;); set(get)AdditionalInstanceField getMD5Sum getMethodDepth getParameterTypes getSurroundingThis hookMethod 系统级别的，过滤所有的进程 只要Xposed生效了，可以把Xposed理解为系统框架，作为系统的本身来考虑没有关系。 Not In Xposed Java.choose rpc 热重载/加载 单进程级别的，只能在hook的进程内生效 hook本项目中 xposed 系统级别的，过滤所有的进程，入口类中实现了三个接口，hook了所有的资源，进程，包。只会hook进程中的包等于ModStatusbarColor.PACKAGE_NAME即com.android.systemui时，才启动hook。所有逻辑不在GravityBox中，也不在xposed.jar中，而是在com.android.systemui if (lpparam.packageName.equals(ModStatusbarColor.PACKAGE_NAME)) { ModStatusbarColor.init(prefs, lpparam.classLoader); } frida-ps -U |grep com.android.systemui 在app逆向中遇到interface搜索其实现还是一顿乱搜，可以使用反射getInterfaces得到实现的接口数组，然后打印出来即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function hook() &#123; Java.perform(function () &#123; console.log(&quot;start&quot;) Java.enumerateClassLoaders(&#123; onMatch: function (loader) &#123; try &#123; if (loader.findClass(&quot;com.ceco.nougat.gravitybox.ModStatusbarColor$1&quot;)) &#123; &#x2F;&#x2F; if(loader.findClass(&quot;de.robv.android.xposed.XC_MethodHook&quot;))&#123; &#x2F;&#x2F; if(loader.findClass(&quot;com.roysue.xposed1.HookTest&quot;))&#123; &#x2F;&#x2F; if(loader.findClass(&quot;de.robv.android.xposed.XposedBridge&quot;))&#123; &#x2F;&#x2F;if(loader.findClass(&quot;com.android.internal.statusbar.StatusBarIcon&quot;))&#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); Java.classFactory.loader &#x3D; loader; &#125; &#125; catch (error) &#123; console.log(&quot;find error:&quot; + error) &#125; &#125;, onComplete: function () &#123; console.log(&quot;end1&quot;) &#125; &#125;) &#x2F;&#x2F; Java.use(&quot;de.robv.android.xposed.XposedBridge&quot;).log.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (str) &#123; &#x2F;&#x2F; console.log(&quot;entering Xposedbridge.log &quot;,str.toString()) &#x2F;&#x2F; return true &#x2F;&#x2F; &#125; &#x2F;&#x2F;traceClass(&quot;com.ceco.nougat.gravitybox.ModStatusbarColor&quot;) &#x2F;&#x2F; Java.use(&quot;com.roysue.xposed1.HookTest$1&quot;).afterHookedMethod.implementation &#x3D; function (param)&#123; &#x2F;&#x2F; console.log(&quot;entering afterHookedMethod param is &#x3D;&gt; &quot;,param); &#x2F;&#x2F; return this.afterHookedMethod(param); &#x2F;&#x2F; &#125; &#x2F;&#x2F; traceClass(&quot;de.robv.android.xposed.XC_MethodHook&quot;) &#x2F;&#x2F; Java.use(&quot;de.robv.android.xposed.XC_MethodHook$MethodHookParam&quot;).setResult.implementation &#x3D; function(str)&#123; &#x2F;&#x2F; console.log(&quot;entersing de.robv.android.xposed.XC_MethodHook$MethodHookParam setResult &#x3D;&gt; &quot;,str) &#x2F;&#x2F; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); &#x2F;&#x2F; return this.setResult(str); &#x2F;&#x2F; &#125; Java.enumerateLoadedClasses(&#123; onMatch: function (className) &#123; if (className.toString().indexOf(&quot;gravitybox&quot;) &gt; 0 &amp;&amp; className.toString().indexOf(&quot;$&quot;) &gt; 0 ) &#123; console.log(&quot;found &#x3D;&gt; &quot;, className) &#x2F;&#x2F; var interFaces &#x3D; Java.use(className).class.getInterfaces(); &#x2F;&#x2F; if(interFaces.length&gt;0)&#123; &#x2F;&#x2F; console.log(&quot;interface is &#x3D;&gt; &quot;); &#x2F;&#x2F; for(var i in interFaces)&#123; &#x2F;&#x2F; console.log(&quot;\\t&quot;,interFaces[i].toString()) &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; if (Java.use(className).class.getSuperclass()) &#123; var superClass &#x3D; Java.use(className).class.getSuperclass().getName(); &#x2F;&#x2F; console.log(&quot;superClass is &#x3D;&gt; &quot;,superClass); if (superClass.indexOf(&quot;XC_MethodHook&quot;) &gt; 0) &#123; console.log(&quot;found class is &#x3D;&gt; &quot;, className.toString()) traceClass(className); &#125; &#125; &#125; &#125;, onComplete: function () &#123; console.log(&quot;search completed!&quot;) &#125; &#125;) console.log(&quot;end2&quot;) &#125;)&#125; var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"xposed","slug":"xposed","permalink":"http://onejane.github.io/tags/xposed/"}]},{"title":"违法应用移动TV取证分析","slug":"违法应用移动TV取证分析","date":"2021-04-21T14:37:18.000Z","updated":"2021-12-12T03:09:39.338Z","comments":true,"path":"2021/04/21/违法应用移动TV取证分析/","link":"","permalink":"http://onejane.github.io/2021/04/21/%E8%BF%9D%E6%B3%95%E5%BA%94%E7%94%A8%E7%A7%BB%E5%8A%A8TV%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 抓包应用层抓包 传输层抓包charles开启Enable socks proxy wget https://www.charlesproxy.com/assets/release/4.6.1/charles-proxy-4.6.1_amd64.tar.gz?k=17bcbd3dc2 tar zxf charles-proxy-4.6.1_amd64.tar.gz &amp;&amp; ./charles 通过注册码注册或生成加权jar包破解 vim ~/.zshrc 并source ~/.zshrc 使得charles在任意路径可启动 1export PATH&#x3D;&quot;&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;ndk-bundle:&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;platform-tools:$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH:&#x2F;root&#x2F;Desktop&#x2F;charles&#x2F;bin:&#x2F;root&#x2F;Desktop&#x2F;jadx-1.2.0&#x2F;bin&quot; htop 查看破解情况 电脑：192.168.0.106 手机：192.168.0.102 虚拟机：192.168.0.107 虚拟网络编辑器选择获取ip的网卡，保证这三台机器在同一局域网内且互相ping通。 配置charlessocks proxy工作于传输层，更好的观察应用层协议和socks抓包。 开启ssl posternadb install 0714com.tunnelworkshop.postern_2018-10-07.apk QtScrcpy 设置投屏 配置socks5抓包代理 配置socks5抓包配置规则 打开socks vpn连接虚拟机抓包，虚拟机收到连接请求后点击Allow 在手机浏览器输入地址 chls.pro/ssl 或者 charlesproxy.com/getssl ，出现证书安装页面，点击安装，如果依旧app抓不到，需要把个人证书放到系统根目录 Android8 12345cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o remount,rw &#x2F;chmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o remount,ro &#x2F; Android 7 12345cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o rw,remount &#x2F;systemchmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o ro,remount &#x2F;system movetv分析1234.&#x2F;fs1428arm64 pyenv local 3.8.5frida -UF -l hookSocket.js -o moveTV.txt attach方式hook登录抓包，基于socks层抓包无法对抗，除非做了VPN检测frida -U -f com.cz.babySister -l hookSocket.js -o moveTV.txt spawn方式hook，输入%resume重新启动，或者直接在命令后加--no-pause jadx-gui movetv.apk 已经加壳一个Activity都找不到 脱壳FRIDA-DEXDumpgit clone https://github.com/hluwa/FRIDA-DEXDump.git 启动app放在前台 cd ~/Desktop/FRIDA-DEXDump/frida_dexdump &amp;&amp; python main.py 开始脱壳 1234android hooking list activities 查看所有Activitygrep -ril &quot;MainActivity&quot; * 从脱下的dex中查找MainActivitygrep -ril &quot;LoginActivity&quot; *jadx-gui com.cz.babySister&#x2F;0x748d44201c.dex 登录抓登录包获取memi1字段其实来源于android-id android hooking watch class com.cz.babySister.activity.LoginActivity –dump-args –dump-backtrace –dump-return hook类中所有方法 android hooking watch class_method com.cz.babySister.activity.LoginActivity.b –dump-args –dump-backtrace –dump-return hook登录b方法 进入b方法中调用的RunnableC0042q类中 android hooking watch class_method com.cz.babySister.c.a.a –dump-args –dump-backtrace –dump-return hook方法a 12345objection -g com.cz.babySister exploreandroid hooking search classes Settings android hooking list class_methods android.provider.Settings android hooking list class_methods android.provider.Settings$Secureandroid hooking watch class_method android.provider.Settings$Secure.getString --dump-args --dump-backtrace --dump-return 通过hook获取返回的结果50463fa80244d95f和chales中抓包的memi1完全一致 注册android hooking watch class_method com.cz.babySister.c.a.a –dump-args –dump-backtrace –dump-return 对比抓包结果 取证实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import base64import timeimport requestsrequests.packages.urllib3.disable_warnings()class tv: def __init__(self): self.root &#x3D; &#39;http:&#x2F;&#x2F;39.108.64.125&#x2F;WebRoot&#x2F;superMaster&#x2F;Server&#39; self.memi1 &#x3D; &quot;50463fa80244d95f&quot; self.rightkey &#x3D; &quot;376035775&quot; self.key &#x3D; &quot;308202d5308201bda00302010202041669d9bf300d06092a864886f70d01010b0500301b310b3009060355040613023836310c300a06035504031303776569301e170d3136303731383038313935395a170d3431303731323038313935395a301b310b3009060355040613023836310c300a0603550403130377656930820122300d06092a864886f70d01010105000382010f003082010a028201010095f85892400aae03ca4ed9dcd838d162290ae8dd51939aac6ecfde8282f207c4cd9e507929a279e0a36f1e4847330cb53908c92915b2c6a93d7064be452d073a472093f7ca14f4ab68f827582fe0988e9e4bc8a6ea3b56001cbbbb760f9eec571b0bbc97392e65aaf08c686f0e2ba353896d48a37c36716239977bd0e4dd878025cab497d8164537aec9f6599eefb98577dce972a1b794e211226520e23497beec3fd8548bb5b4d263120d40115cca28116bac32378df5033f536a0d7367fef78c587fefed28c5c9b35ba684ed6e46d9369c40950cf7ad7236d10b7a51dfd2a8f218db72323bbd19f46947410b1191f263012ad4ba8f749223e37591254ee7f50203010001a321301f301d0603551d0e041604143d43284bd5e4b0d322c9962a5b70aad4dcbc3634300d06092a864886f70d01010b050003820101000f04c51ff763311aa011777ba2842b441b15c316373d1e1ed4116cf86e29d55c6ed3fa4c475251b1fb4fac57195dbca0166ebe565d9834552a3758b97c4528bab1f7ab82bb3a9faa932f5bc10943f3daf52e0fe5889ffb58a6be67ea1c9a2fb37dc8aa6f3af476039a467336991a4e52dccd520195cd473eb5b984e702ed9ff638a14c3abb575a7a80ae4062084d1138a06a20e173be9df32df631311b07352898706198ddebaaa011f0da8e5f288f7cfb77505bc943f6476d6cc1feef56b68137aad91f23c4bb772169539d05653a6f0d75f7192164e822b934322f3a975df677903b1667f5dc1e9ddb185da3281d31bfb8f67a84bd23bbcb398f8bb637dd72&quot; def post(self, data&#x3D;None): if data is None: data &#x3D; &#123;&#125; return requests.post(url&#x3D;self.root, data&#x3D;data) def query(self, name, password): ret &#x3D; self.post(&#123;&#39;name&#39;: name, &#39;pass&#39;: password&#125;) print(&quot;query result is : &quot;) print(ret.content.decode(&#39;utf-8&#39;)) def register(self, name, password): ret &#x3D; self.post(&#123;&#39;name&#39;: name, &#39;pass&#39;: password, &#39;memi1&#39;: self.memi1, &#39;key&#39;: self.key, &#39;rightkey&#39;: self.rightkey, &#39;register&#39;: &#39;register&#39;&#125;) print(&quot;Register response data: &quot;) print(ret.content.decode(&#39;utf-8&#39;)) def login(self, name, password): ret &#x3D; self.post(&#123;&#39;name&#39;: name, &#39;pass&#39;: password, &#39;memi1&#39;: self.memi1, &#39;key&#39;: self.key, &#39;rightkey&#39;: self.rightkey, &#39;login&#39;: &#39;login&#39;&#125;) print(&quot;Login response data: &quot;) print(ret.content.decode(&#39;utf-8&#39;)) def updateSocre(self, name, password, jifen): t &#x3D; int(round(time.time() * 1000)) sign &#x3D; base64.b64encode(str(5 * t).encode(&#39;utf-8&#39;)).decode(&#39;utf-8&#39;) ret &#x3D; self.post(&#123;&#39;name&#39;: name, &#39;pass&#39;: password, &#39;jifen&#39;: jifen, &#39;time&#39;: t, &#39;sign&#39;: sign&#125;) print(&quot;UpdataScore response data: &quot;) print(ret.content.decode(&#39;utf-8&#39;))if __name__ &#x3D;&#x3D; &quot;__main__&quot;: tv &#x3D; tv() # print(tv.query(&quot;eeeeffff&quot;, &quot;gggghhhh&quot;)) # 注册账号 print(tv.register(&quot;onejane3&quot;, &quot;123456&quot;)) # time.sleep(3) # 登录账号 print(tv.login(&quot;onejane3&quot;, &quot;123456&quot;)) # 更新积分 # print(tv.updateSocre(&quot;mee4&quot;,&quot;mee4&quot;,&quot;1000&quot;)) Youpkhttps://bbs.pediy.com/thread-259854.htm linux平台下载最新的platform-tools刷机的时候，fastboot会报各种unknow command或接近的错误，把fastboot文件替换成以下随着aosp一起编译出来的即可： fastboot_aosp7.1.zip fastboot6.0.zip fastboot8.1.0r1.zip 下载Youpk_v1.1 重启至bootloader: adb reboot bootloader 解压 Youpk_sailfish.zip 并双击 flash-all.bat,（尽量在kali上刷机，./flash-all.sh,因为windows会给我们的编程生涯带来80%的苦难） adb install movetv.apk adb shell “echo com.cz.babySister &gt;&gt; /data/local/tmp/unpacker.config” 启动apk等待脱壳，每隔10秒将自动重新脱壳(已完全dump的dex将被忽略), 当日志打印unpack end时脱壳完成 adb pull /data/data/com.cz.babySister/unpacker/ mv unpacker youpk/ 调用修复工具 dexfixer.jar, 两个参数, 第一个为dump文件目录(必须为有效路径), 第二个为重组后的DEX目录(不存在将会创建) java -jar dexfixer.jar youpk/ youpk_out/ jadx-gui _data_app_com.cz.babySister-1_base.apk_54276.dex 查看脱壳后的dex 使用场景 整体加固 抽取: nop占坑型(类似某加密) naitve化, 在中解密(类似早期阿里) goto解密型(类似新版某加密?najia): https://bbs.pediy.com/thread-259448.htm 问题 dump中途退出或卡死，重新启动进程，再次等待脱壳即可 当前仅支持被壳保护的dex, 不支持App动态加载的dex/jar fart脱抽取型壳并回填dex 安装新环境vim /etc/proxychains4.conf 配置代理 12socks5 192.168.0.106 1080#http 127.0.0.1 12333 主机192.168.0.106 ssr开启运行局域网连接 配置新环境 12PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains pyenv install 3.9.0 创建python3.9.0环境PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains pip install objection&#x3D;&#x3D;1.9.5 安装objection 1.9.5套件包括frida-tools 9.2.4，frida 14.2.16 wget frida-server-14.2.16-android-arm64.xz 7z x frida-server-14.2.16-android-arm64.xz 12345adb push ~&#x2F;Desktop&#x2F;frida-server-14.2.16-android-arm64 &#x2F;data&#x2F;local&#x2F;tmp&#x2F;adb shellmv &#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server-14.2.16-android-arm64 &#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs1426arm64 chmod 777 &#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs1426arm64.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs1426arm64 事实证明，新版本不兼容还是用12.8.0的frida吧 调用fart基于hook和反射脱壳，对比发现youpk最优秀。 adb reboot bootloader cd ~/Desktop/sailfish-nzh54d 安卓8.0 ./flash-all.sh 刷回去 root及基础配置 123456789101112131415adb push Magisk-v20.4.zip &#x2F;sdcard adb push magisk-riru-v21.3.zip &#x2F;sdcard&#x2F;Download 使用magisk模块安装并重启adb push magisk-EdXposed-SandHook-v0.4.5.1_beta.4463.-release.zip &#x2F;sdcard&#x2F;Download 使用magisk模块安装并重启adb install EdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apk 安装xposedadb push MagiskHidePropsConf-v5.3.4.zip &#x2F;sdcard&#x2F;Download adb install JustTrustMePlus-debug.apk 用于结合xposed突破SSL Pinning抓包限制adb reboot bootloaderfastboot boot twrp-3.4.0-0-sailfish.img 进入recovery modeinstall Magisk-v20.4.zipadb install MagiskManager-v7.5.1.apk 模块安装MagiskHidePropsConf，riru，EdXposed，adb shell su通过Magisk获取root权限settings put global captive_portal_http_url https:&#x2F;&#x2F;www.google.cn&#x2F;generate_204 去除wifi上的×settings put global captive_portal_https_url https:&#x2F;&#x2F;www.google.cn&#x2F;generate_204settings put global ntp_server 1.hk.pool.ntp.org 修改时区props Edit MagiskHide props--ro.debuggable 设置全局可调试，getprop ro.debuggable 即可查看1,开启全局可调试 1234567pyenv local 3.8.0proxychains4 wget https:&#x2F;&#x2F;github.com&#x2F;hanbinglengyue&#x2F;FART.git7z x frida_fart.zip &amp;&amp; adb push lib&#x2F;fart* &#x2F;data&#x2F;app &amp;&amp; chmod 777 *.so 如果没有权限，放到&#x2F;sdcard中再放入&#x2F;data&#x2F;appcd Desktop&#x2F;FART-master&#x2F;frida_fart&#x2F; &amp;&amp; frida -UF -l frida_fart_reflection.js attach模式启动frida -U -f com.cz.babySister -l frida_fart_reflection.js --no-pause spawn模式启动fart() 全量主动调用frida -U -f com.cz.babySister -l frida_fart_hook.js --no-pause 基于安卓8，生成dex，hook连壳一起脱 12adb pull &#x2F;sdcard&#x2F;com.cz.babySister.activitygrep -ril &quot;LoginActivity&quot; *.dex var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"fart","slug":"fart","permalink":"http://onejane.github.io/tags/fart/"},{"name":"postern","slug":"postern","permalink":"http://onejane.github.io/tags/postern/"},{"name":"charles","slug":"charles","permalink":"http://onejane.github.io/tags/charles/"},{"name":"youpk","slug":"youpk","permalink":"http://onejane.github.io/tags/youpk/"},{"name":"dexdump","slug":"dexdump","permalink":"http://onejane.github.io/tags/dexdump/"}]},{"title":"爬虫基础篇之selenium登陆获取阿里腾讯cookie","slug":"爬虫基础篇之selenium登陆获取阿里腾讯cookie","date":"2021-04-21T02:25:19.000Z","updated":"2021-12-12T03:09:39.332Z","comments":true,"path":"2021/04/21/爬虫基础篇之selenium登陆获取阿里腾讯cookie/","link":"","permalink":"http://onejane.github.io/2021/04/21/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8Bselenium%E7%99%BB%E9%99%86%E8%8E%B7%E5%8F%96%E9%98%BF%E9%87%8C%E8%85%BE%E8%AE%AFcookie/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 简介selenium本身是自动化测试框架，只是在爬虫领域更能够显示出其一把梭的威力，所有网站比如淘宝，微博等必须登录状态才能访问页面，对数据进行抓取时，逆向分析js将是一条不归路，而自动化测试框架selenium完全模拟人的行为模式，对网站按钮的点击，元素的获取，内容文本的输入有着得天独厚的优势。不过相对于逆向加密参数执行的爬虫程序来说，selenium还是太过效率低下了，常规套路一般是通过selenium拿到cookie或者token后，再通过爬虫程序去抓取页面，事半功倍。 Alimama实战以阿里妈妈后台为例，通过分析我们拿到了请求json来自于https://pub.alimama.com/campaign/joinedSpecialCampaigns.json?toPage=1&amp;status=2&amp;perPageSize=40 不过单独访问该页面，会将我们地址重定向到登录界面，这种网站就必须我们登录再发起请求抓取数据了。 模拟登录该登录页面是淘宝的统一登录框架，右键重新加载时抓包拿到框架地址，去除无用参数拿到原始地址https://login.taobao.com/member/login.jhtml?style=mini&amp;newMini2=true&amp;from=alimama，避免其他请求干扰我们的判断。 步骤如下： 获取账户，密码，滑块，按钮的元素位置 输入账户密码 判断滑块存在并滑动滑块 点击登录 保存cookie并调用cookie发起请求 chromedriver初始化根据本机的chrome版本获取selenium的驱动程序chromedriver版本 特征隐藏面对一些网站通过ajax请求，同时携带一些难以破解加密参数，虽然selenium模拟浏览器行为操作，绕过这些反爬虫的手段，不过依旧有一些站点通过JavaScript 探测到Selenium启动的浏览器的天生存在的几十个特征来屏蔽这些爬虫的运行。通过https://bot.sannysoft.com/ 可以查看当前浏览器的一些特征值，正常浏览器打开如下： 而通过selenium打开该网站时，部分特征被检测到，这就被安全人员拿来作为关键参数，禁止改浏览器的数据请求。 比如某平台中对selenium的属性$cdc_asdjflasutopfhvcZLmcfl_做了校验，应对解决方案使用HexEdit 4.2修改chromedriver.exe 的$cdc_asdjflasutopfhvcZLmcfl_修改为同长度的字符串,如$ccccccccccccccccccccccccccc。 针对chrome弹窗请停用以开发者模式运行插件，可以通过Chrome.dll-patch75and76.exe放入chrome文件夹下包含包含chrome.dll文件的目录下并管理员身份执行。 针对CHROME正受到组件控制的提示，可以通过chrome_options.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])实现屏蔽’CHROME正受到组件控制’的提示。 针对chrome自带密码保存对爬虫的干扰影响，通过chrome_options.add_experimental_option(&quot;prefs&quot;, prefs)屏蔽。 针对封禁ip可以通过chrome_options.add_argument(&quot;--proxy-server=http://58.243.205.102:4543&quot;)开启ip代理。 设置请求头UA,browser.execute_cdp_cmd(&#39;Network.setUserAgentOverride&#39;, {&quot;userAgent&quot;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36&#39;}) 针对navigator属性中存在webdriver，新页面加载后browser.execute_script(&#39;Object.defineProperty(navigator,&quot;webdriver&quot;,{get:() =&gt; false,});&#39;)去除特征无效，可以通过CDP协议browser.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, {&quot;source&quot;: &quot;&quot;&quot;Object.defineProperty(navigator, &#39;webdriver&#39;, {get: () =&gt; undefined})&quot;&quot;&quot;, }) 不过仅仅靠隐藏几个特征是毫无意义的，针对众多的特征已经有大牛为我们做了完美隐藏，那就是stealth.min.js 道高一尺魔高一丈，完整隐藏特征代码如下： 1234567891011121314151617181920212223242526272829# chrome 版本78.0.3904.70，chromedriver版本78.0.3904.70# 设置代理# chrome_options.add_argument(&quot;--proxy-server&#x3D;http:&#x2F;&#x2F;58.243.205.102:4543&quot;)# chrome.exe --remote-debugging-port&#x3D;7222 本地启动selenium# chrome_options.add_experimental_option(&quot;debuggerAddress&quot;, &quot;127.0.0.1:7222&quot;)chrome_options &#x3D; Options()# 设置无头chrome_options.add_argument(&quot;--headless&quot;)chrome_options.add_argument( &#39;user-agent&#x3D;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.198 Safari&#x2F;537.36&#39;)# 屏蔽&#39;CHROME正受到组件控制&#39;的提示chrome_options.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])# 屏蔽保存密码prefs &#x3D; &#123;&quot;&quot;: &quot;&quot;&#125;prefs[&quot;credentials_enable_service&quot;] &#x3D; Falseprefs[&quot;profile.password_manager_enabled&quot;] &#x3D; Falsechrome_options.add_experimental_option(&quot;prefs&quot;, prefs)driver &#x3D; Chrome(&#39;.&#x2F;chromedriver&#39;, options&#x3D;chrome_options)#driver.execute_script(&#39;Object.defineProperty(navigator,&quot;webdriver&quot;,&#123;get:() &#x3D;&gt; false,&#125;);&#39;)#driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, &#123;&quot;source&quot;: &quot;&quot;&quot;Object.defineProperty(navigator, &#39;webdriver&#39;, &#123;get: () &#x3D;&gt; undefined&#125;)&quot;&quot;&quot;, &#125;)#driver.execute_cdp_cmd(&#39;Network.setUserAgentOverride&#39;, &#123;&quot;userAgent&quot;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;83.0.4103.97 Safari&#x2F;537.36&#39;&#125;) driver.set_page_load_timeout(10)with open(&#39;.&#x2F;stealth.min.js&#39;) as f: js &#x3D; f.read()driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, &#123; &quot;source&quot;: js&#125;) 保存cookie1234567891011121314151617181920212223242526def save_cookies(self): # 隐式等待，设置了一个最长等待时间 self.browser.implicitly_wait(10) # 最大化窗口 self.browser.maximize_window() # 向文本框发送账户密码 self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;input[@name&#x3D;&quot;fm-login-id&quot;]&#39;).send_keys(&#39;***&#39;) self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;input[@name&#x3D;&quot;fm-login-password&quot;]&#39;).send_keys(&#39;***&#39;) # 解决滑块 slide_block &#x3D; self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;nc_1_n1z&quot;]&#39;) if (slide_block.is_displayed()): # 点击移动滑块 action &#x3D; ActionChains(self.browser) action.click_and_hold(on_element&#x3D;slide_block) action.move_by_offset(xoffset&#x3D;258, yoffset&#x3D;0) action.pause(0.5).release().perform() # perform指定动作链 self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;button[@class&#x3D;&quot;fm-button fm-submit password-login&quot;]&#39;).click() time.sleep(5) if &quot;login_unusual&quot; in self.browser.current_url: print(&quot;gg了，要手机验证码了，救命啊啊啊啊啊&quot;) input(&quot;输入手机验证码啦：&quot;) self.cookies &#x3D; &#39;; &#39;.join( item for item in [item[&quot;name&quot;] + &quot;&#x3D;&quot; + item[&quot;value&quot;] for item in self.browser.get_cookies()]) with open(COOKIES_FILE_PATH, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as file: file.write(self.cookies) print(&quot;cookie写入成功：&quot;, self.cookies) 使用cookie登录123456789101112131415def taobao_login(self): print(&quot;登录中。。。。。&quot;) ok &#x3D; False while not ok: with open(COOKIES_FILE_PATH, &#39;r+&#39;, encoding&#x3D;&#39;utf-8&#39;) as file: self.headers[&quot;cookie&quot;] &#x3D; file.read() response &#x3D; self.session.get(self.shop_plan_url, headers&#x3D;self.headers, verify&#x3D;False) try: ok &#x3D; json.loads(response.text) except: self.browser.get(self.alimama_login_url) self.browser.delete_all_cookies() self.save_cookies() self.browser.close() self.browser.quit() Tencent实战由于腾讯优量汇中的报表不提供api，本次目标是抓取该报表中的广告收益数据。 通过抓包分析最关键的cookie为adnet_sso，只要拿到该cookie就可以成功请求数据，该cookie经过了cookie传递层层更新，太烦了，干脆selenium一把梭，登陆后拿到cookie存到文件中，访问api时添加cookie到header中即可。 模拟登录https://sso.e.qq.com/login/hub?sso_redirect_uri=https%3A%2F%2Fe.qq.com%2Fdev%2Flogin&amp;service_tag=14 我们肯定是避免扫码登录了，登录流程是当QQ账号登录界面出现时，点击账号密码登录，找到文本框输入qq号及密码后点击授权并登录按钮，获取selenium的cookie并保存到文件中，访问api数据时读取该cookie即可，如果异常则删除selenium的cookie重新登录保存cookie。 12345678910111213141516def adnet_login(self): print(&quot;登录中。。。。。&quot;) ok &#x3D; False while not ok: with open(COOKIES_FILE_PATH, &#39;r+&#39;, encoding&#x3D;&#39;utf-8&#39;) as file: self.headers[&quot;cookie&quot;] &#x3D; file.read() response &#x3D; self.session.post(self.get_date_url, data&#x3D;json.dumps(self.data), headers&#x3D;self.headers, verify&#x3D;False) try: res &#x3D; json.loads(response.text) ok &#x3D; True except: self.browser.get(self.adnet_login_url) self.browser.delete_all_cookies() self.save_cookies() self.browser.close() self.browser.quit() 初始化selenium的流程和Alimama的一致，腾讯广告的登录界面藏在id=&quot;qqLoginFrame&quot;的frame中的id=&quot;ptlogin_iframe&quot;的frame中，通过switch_to.frame直接切换到frame中获取元素，填写帐密实现登录保存cookie。 12345678910111213141516171819def save_cookies(self): self.browser.implicitly_wait(10) self.browser.maximize_window() self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;a[@id&#x3D;&quot;qqLogin&quot;]&#39;).click() # el_frame &#x3D; self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;qqLoginFrame&quot;]&#39;) # print(self.browser.page_source) self.browser.switch_to.frame(&#39;qqLoginFrame&#39;) self.browser.switch_to.frame(&#39;ptlogin_iframe&#39;) time.sleep(5) self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;a[contains(text(),&quot;帐号密码登录&quot;)]&#39;).click() self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;u&quot;]&#39;).send_keys(&#39;*&#39;) self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;p&quot;]&#39;).send_keys(&#39;*&#39;) self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;loginform&quot;]&#x2F;div[@class&#x3D;&quot;submit&quot;]&#x2F;a&#39;).click() time.sleep(5) self.cookies &#x3D; &#39;; &#39;.join( item for item in [item[&quot;name&quot;] + &quot;&#x3D;&quot; + item[&quot;value&quot;] for item in self.browser.get_cookies()]) with open(COOKIES_FILE_PATH, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as file: file.write(self.cookies) print(&quot;cookie写入成功：&quot;, self.cookies) 爬虫实现api请求是通过post提交payload格式的参数，爬虫实现如下 1234567891011def get_report_list(self): # 获取所有shop plan while True: try: response &#x3D; self.session.post(self.get_date_url, data&#x3D;json.dumps(self.data), headers&#x3D;self.headers, verify&#x3D;False) print(json.loads(response.text)[&quot;data&quot;][&quot;list&quot;]) response.raise_for_status() except Exception as e: print(&#39;获取优量汇主页请求失败！&#39;) self.adnet_login() raise e 常用操作不同系统12345678910chrome_options &#x3D; webdriver.ChromeOptions()if platform.system() &#x3D;&#x3D; &quot;Windows&quot;: driver &#x3D; webdriver.Chrome(&#39;chromedriver.exe&#39;, chrome_options&#x3D;chrome_options)elif platform.system() &#x3D;&#x3D; &quot;Linux&quot;: chrome_options.add_argument(&quot;--headless&quot;) chrome_options.add_argument(&#39;--disable-gpu&#39;) chrome_options.add_argument(&#39;--no-sandbox&#39;) driver &#x3D; webdriver.Chrome( executable_path&#x3D;&quot;&#x2F;usr&#x2F;bin&#x2F;chromedriver&quot;, chrome_options&#x3D;chrome_options) 获取元素信息12345678910111213141516def get_data(): divs &#x3D; driver.find_elements_by_xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;items&quot;]&#x2F;div[@class&#x3D;&quot;item J_MouserOnverReq &quot;]&#39;) for div in divs: info &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;div[@class&#x3D;&quot;row row-2 title&quot;]&#x2F;a&#39;).text price &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;strong&#39;).text deal &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;div[@class&#x3D;&quot;deal-cnt&quot;]&#39;).text shop &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;div[@class&#x3D;&quot;shop&quot;]&#x2F;a&#39;).text print(info, price, deal, shop, sep&#x3D;&quot;|&quot;) with open(&#39;taobao.csv&#39;, mode&#x3D;&#39;a&#39;, newline&#x3D;&quot;&quot;) as csvfile: csvwrite &#x3D; csv.writer(csvfile, delimiter&#x3D;&#39;,&#39;) csvwrite.writerow([info, price, deal, shop])browser.find_elements_by_xpath(&quot;&#x2F;&#x2F;div[@id&#x3D;&#39;J_DivItemDesc&#39;]&#x2F;descendant::*&#x2F;img&quot;) 查找后代元素 browser.find_elements_by_xpath(&quot;&#x2F;&#x2F;div[@id&#x3D;&#39;J_DivItemDesc&#39;]&#x2F;descendant::*&#x2F;img&quot;).tag_name 获取标签browser.find_elements_by_xpath(&quot;&#x2F;&#x2F;div[@id&#x3D;&#39;J_DivItemDesc&#39;]&#x2F;descendant::*&#x2F;img&quot;).get_attribute(&#39;value&#39;) 获取属性value信息或文本框信息js &#x3D; &#39;return document.getElementById(&quot;su&quot;).getAttribute(&quot;value&quot;)&#39;res &#x3D; driver.excute_script(js) 利用js获取元素属性值 鼠标操作1234567891011121314151617181920212223def get_data(): # 移动鼠标到距离元素的位置 title &#x3D; browser.find_element_by_xpath(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;title-bar&#39;]&quot;) ActionChains(browser).move_to_element_with_offset(title, 100, 600).perform() # 键盘指令 # browser.find_element_by_tag_name(&#39;body&#39;).send_keys(Keys.CONTROL + Keys.SHIFT + &#39;J&#39;) # hover到指定元素 # ActionChains(browser).move_to_element(browser.find_elements_by_xpath(&#39;&#x2F;&#x2F;tbody[@mx-ie&#x3D;&quot;mouseover&quot;]&#x2F;tr&#39;)[1]).perform() # 页面双击操作才能获取列表 ActionChains(browser).double_click(browser.find_element_by_xpath(&quot;&#x2F;&#x2F;body&quot;)).perform() tr_list &#x3D; browser.find_elements_by_xpath(&#39;&#x2F;&#x2F;tbody[contains(@mx-ie,&quot;mouseover&quot;)]&#x2F;tr&#39;) if len(tr_list) &#x3D;&#x3D; 0: # 页面重载 browser.execute_script(&quot;location.reload()&quot;) title &#x3D; browser.find_element_by_xpath(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;title-bar&#39;]&quot;) # 鼠标移动位置 ActionChains(browser).move_to_element_with_offset(title, 100, 600).perform() # 双击 ActionChains(browser).double_click(browser.find_element_by_xpath(&quot;&#x2F;&#x2F;body&quot;)).perform() # 判断元素属性是否包含 tr_list &#x3D; browser.find_elements_by_xpath(&#39;&#x2F;&#x2F;tbody[contains(@mx-ie,&quot;mouseover&quot;)]&#x2F;tr&#39;) # 滚轮直接滑到底部 browser.execute_script(&quot;window.scrollTo(0,document.body.scrollHeight);&quot;) 查找元素1234567891011121314151617181920212223# 通过不同的方式查找界面元素def findElement(by, value): if (by &#x3D;&#x3D; &quot;id&quot;): element &#x3D; browser.find_element_by_id(value) return element elif (by &#x3D;&#x3D; &quot;name&quot;): element &#x3D; browser.find_element_by_name(value) return element elif (by &#x3D;&#x3D; &quot;xpath&quot;): element &#x3D; browser.find_element_by_xpath(value) return element elif (by &#x3D;&#x3D; &quot;classname&quot;): element &#x3D; browser.find_element_by_class_name(value) return element elif (by &#x3D;&#x3D; &quot;css&quot;): element &#x3D; browser.find_element_by_css_selector(value) return element elif (by &#x3D;&#x3D; &quot;link_text&quot;): element &#x3D; browser.find_element_by_link_text(value) return element else: print(&quot;无对应方法，请检查&quot;) return None 元素存在123456789101112from selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdef is_element_present(locator): wait &#x3D; WebDriverWait(browser, 2) try: # 显式等待 wait.until(EC.visibility_of_element_located(locator)) except TimeoutException: return False return Trueis_element_present((By.XPATH, &#39;&#x2F;&#x2F;*[@id&#x3D;\\&quot;sufei-dialog-content\\&quot;]&#39;)) 点击元素1234567def move_element_click(xpath): if is_element_present((By.XPATH, xpath)): ele_loc &#x3D; browser.find_element_by_xpath(xpath) browser.execute_script(&quot;arguments[0].scrollIntoView();&quot;, ele_loc) ActionChains(browser).move_to_element(ele_loc).click().perform() time.sleep(random.randint(1, 3))move_element_click(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;dialog-contentbox&#39;]&#x2F;vframe&#x2F;div&#x2F;div&#x2F;button&quot;) hover元素1234def hover(by, value): element &#x3D; findElement(by, value) ActionChains(browser).move_to_element(element).perform()hover(&quot;xpath&quot;, &#39;&#x2F;&#x2F;tbody[contains(@mx-ie,&quot;mouseover&quot;)]&#x2F;tr[&#39; + str(tr_list.index(tr) + 1) + &#39;]&#39;) 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"selenium","slug":"selenium","permalink":"http://onejane.github.io/tags/selenium/"}]},{"title":"JS逆向之红岭创投encryption","slug":"JS逆向之红岭创投encryption","date":"2021-04-19T07:13:48.000Z","updated":"2021-12-12T03:09:39.273Z","comments":true,"path":"2021/04/19/JS逆向之红岭创投encryption/","link":"","permalink":"http://onejane.github.io/2021/04/19/JS%E9%80%86%E5%90%91%E4%B9%8B%E7%BA%A2%E5%B2%AD%E5%88%9B%E6%8A%95encryption/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 https://sso.my089.com/sso/login 抓包登录url： POST https://sso.my089.com/sso/login 参数： 12345678910111213username: 15806204095phone: encryption: e10adc3949ba59abbe56e057f20f883epassword: password2: randomPageId: dc88cc75d91f4ecaa519f232a9a66361checkCode: 4ctksession_kept: 30loginCategory: 0back_url: app_key: 16ae450f970448619c3ce7193982089eltcc: requestId: my089-21041920-0757-0529-1535-632509802406 分析搜索sso/login，进入了html页面，点击登录或者回车跳转到loginSubmit方法 搜索loginSubmit 加密方法在jQuery.md5.js中，将js整个拷出，修改得到md5方法，完成encryption的解密。 完整源码请关注微信公众号：ReverseCode，回复：JS逆向 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之万创帮sign","slug":"JS逆向之万创帮sign","date":"2021-04-18T03:46:33.000Z","updated":"2021-12-12T03:09:39.225Z","comments":true,"path":"2021/04/18/JS逆向之万创帮sign/","link":"","permalink":"http://onejane.github.io/2021/04/18/JS%E9%80%86%E5%90%91%E4%B9%8B%E4%B8%87%E5%88%9B%E5%B8%AEsign/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 https://m.wcbchina.com/invite/invite.html 抓包注册urlPOST https://m.wcbchina.com/api/userRegister/registerByInvite?rnd=0.5886187290129845 参数{“auth”:{“timestamp”:1618717702730,”sign”:”81D4F3A45B3202E33971304201135FE5”},”phone”:”15806204095”,”validateCode”:”123”,”inviteCode”:””} 分析搜索userRegister/registerByInvite，进入函数中，打上断点，发起注册请求，此刻的参数中害没有出现加密参数sign，postJson时传递了一个大json数据包括参数service,data和方法success,error 进入postJson方法，发现重组了请求地址，这就是为什么搜索api/userRegister/registerByInvite不到的原因 跟进A(a)函数，发现其中的h对象中是data参数有W()构成，W()正是构成sign的关键函数 完整源码请关注微信公众号：ReverseCode，回复：JS逆向 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之5173password","slug":"JS逆向之5173password","date":"2021-04-17T02:10:40.000Z","updated":"2021-12-12T03:09:39.225Z","comments":true,"path":"2021/04/17/JS逆向之5173password/","link":"","permalink":"http://onejane.github.io/2021/04/17/JS%E9%80%86%E5%90%91%E4%B9%8B5173password/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 抓包登录URL： POST https://passport.5173.com/?returnUrl=http%3A//www.5173.com/ 参数： 123456789smsLogin: 0userName: 15806204095password: 6a771c7ecf7ebe2c3d4c0075cdb96ae5mobileNo: smsCaptcha: category: passpod: __validationToken__: 1680e6a3947c43aea45d83e69b0d7291__validationDna__: 分析passwordpassword有32位，有可能是md5 搜索password，出现的地方太多了，懒得看，放弃。 点击登录按钮，肯定触发事件发送请求，搜索submit-btn无效结果。 搜索tnSubmit加上断点，点击登录按钮时，果然断在了这个function中，不过此刻Network面板的请求包已经发送出去了，gg了，没能拦截到https://passport.5173.com/?returnUrl=http%3a%2f%2fwww.5173.com%2f请求发送前的时间点。 再一次尝试，在加密password时肯定要获取该输入框的值，通过id获取元素的话，我们搜索#txtPass在所出现的位置都打上断点 点击登录时查看Network已经拦截在了ValidateSlide请求，还没有到登录请求 查看断点时打印o为aec712a02d8c835b92369e5d7e5494cf,并直接跳到return $[[&quot;ajax&quot;]]处，查看此时提交的data中的a[[&quot;serialize&quot;]]()为&quot;smsLogin=0&amp;userName=15806204095&amp;password=aec712a02d8c835b92369e5d7e5494cf&amp;mobileNo=&amp;smsCaptcha=&amp;category=&amp;passpod=&amp;__validationToken__=31004cd552c94687ba27d1c7258576f7&amp;__validationDna__=&quot;,其中的password就是之前打印的o参数。 由于password=o，现在只需要追踪这个o参数来源即可。往上追溯是onsubmit: function(f, o)中作为第二个参数o传递进来的，通过调用的堆栈查看上一级调用方法submitHandle。 submitHandler这段代码返回a.onsubmit(a, c)，其中c就是onsubmit: function(f, o) 中的o=password。由于a.usingTpm || a.passwordHash是true，那么这个c就是通过a.getPassword(a.pkey)获取。 进入getPassword后，this.ready &amp;&amp; this.activeTpm &amp;&amp; this.usingTpm为false，必然进入的是else中的c = hex_md5(hex_md5(c).substr(8, 16) + a);实现加密。 (c = b(&quot;#&quot; + this.passwordControlId).val()) &amp;&amp; this.passwordHash赋值必然是true，其中(c = b(&quot;#&quot; + this.passwordControlId).val())的结果为123456，即我们输入的密码，由于传入的a为42m2gl，所以加密逻辑整理为c = hex_md5(hex_md5(&quot;123456&quot;).substr(8, 16) + &quot;42m2gl&quot;) 那么问题来了，传入的a是哪里来的，通过搜索42m2gl，原来每次页面生成的时候页面会加载PasswordKey，通过PasswordKey和SecurityToken等key实现相互验证进行校验。 __validationToken____validationToken__这个字段6b16902a6b134dc9a2c333b965c9405f在请求里面无法搜到是因为页面已经刷新，通过fiddler抓包https://passport.5173.com/?returnUrl=http%3a%2f%2fwww.5173.com%2f历史可以看到首页加载时传入该参数 爬虫实现首次先请求https://passport.5173.com/?returnUrl=http%3a%2f%2fwww.5173.com%2f 获取页面中的PasswordKey的值和SecurityToken的值，通过两次md5密码hex_md5(hex_md5(&quot;123456&quot;).substr(8, 16) + &quot;42m2gl&quot;)拿到password加密结果，发起请求。 123456789101112131415161718192021222324252627282930313233343536373839404142def hex_md5(s): m &#x3D; hashlib.md5() m.update(str(s).encode(&quot;utf-8&quot;)) return m.hexdigest()headers &#x3D; &#123; &#39;Host&#39;: &#39;passport.5173.com&#39;, &#39;Origin&#39;: &#39;https:&#x2F;&#x2F;passport.5173.com&#39;, &#39;Pragma&#39;: &#39;no-cache&#39;, &#39;Referer&#39;: &#39;https:&#x2F;&#x2F;passport.5173.com&#x2F;?returnUrl&#x3D;http%3A&#x2F;&#x2F;www.5173.com&#x2F;&#39;, &#39;Sec-Fetch-Mode&#39;: &#39;cors&#39;, &#39;Sec-Fetch-Site&#39;: &#39;same-origin&#39;, &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;78.0.3904.70 Safari&#x2F;537.36&#39;, &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;,&#125;login_url &#x3D; &#39;https:&#x2F;&#x2F;passport.5173.com&#x2F;?returnUrl&#x3D;http%3A&#x2F;&#x2F;www.5173.com&#x2F;&#39;html &#x3D; requests.get(login_url).text# print(html)securityToken &#x3D; re.findall(&#39;SecurityToken:&quot;(.*?)&quot;,&#39;, html, re.M | re.S)[0]passwordKey &#x3D; re.findall(&#39;PasswordKey:&quot;(.*?)&quot;,&#39;, html, re.M | re.S)[0]print(passwordKey)print(securityToken)# 滑块 &#39;https:&#x2F;&#x2F;passport.5173.com&#x2F;Sso&#x2F;ValidateSlide?token&#x3D;&#123;&#125;&#39;.format(securityToken)# hex_md5(hex_md5(&quot;123456&quot;).substr(8, 16) + &quot;42m2gl&quot;)password &#x3D; hex_md5(hex_md5(&quot;123456&quot;)[8:8 + 16] + passwordKey)userName &#x3D; &#39;15806204096&#39;data &#x3D; &#123; &#39;smsLogin&#39;: &#39;0&#39;, &#39;userName&#39;: userName, &#39;password&#39;: password, &#39;mobileNo&#39;: &#39;&#39;, &#39;smsCaptcha&#39;: &#39;&#39;, &#39;category&#39;: &#39;&#39;, &#39;passpod&#39;: &#39;&#39;, &#39;__validationToken__&#39;: securityToken, &#39;__validationDna__&#39;: &#39;&#39;&#125;r &#x3D; requests.post(login_url, data, headers&#x3D;headers)print(r.text) 虽然password逻辑已经破解，不过登录时还需要验证码滑块的校验，以后有时间再写吧。。。 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之金逸电影params","slug":"JS逆向之金逸电影params","date":"2021-04-17T00:10:27.000Z","updated":"2021-12-12T03:09:39.274Z","comments":true,"path":"2021/04/17/JS逆向之金逸电影params/","link":"","permalink":"http://onejane.github.io/2021/04/17/JS%E9%80%86%E5%90%91%E4%B9%8B%E9%87%91%E9%80%B8%E7%94%B5%E5%BD%B1params/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 http://www.jycinema.com/wap/#/register 抓包登录url: POST http://www.jycinema.com/frontUIWebapp/appserver/photoMessageService/newsSendMessage 参数： params:ey622Jt557b2114Jp469bG373VO310dW8741i248ZX535Ii076Oi988Ix997NT571gw811Nj907Iw911ND991A5893NS763Is198In627Nl690bm498RU398eX141Bl991Ij727oi670cm475Vn649Ii854wi037Y2151hh831bm4625l109bE023lk146Ij946o3769LC284Jj066aG622Fu333bm353Vs667Q26149k642ZS856I6624Ik524ow241MD637A1091Ii342wi356bW787Vt825Ym215Vy105SW604Qi506Oi857Ii850fQ497==152 分析ey开头是base64中的{，fq是base64中的}，有可能是base64加密 搜索photoMessageService/newsSendMessage 定义了sendMg属性，那么必定被调用才发起请求，搜索.sendMg 点击获取验证码,请求参数中$scope.registerData.tel就是我们提交的手机号，那么加密必然是在getData中 跟进getData后对params进行处理生成{&quot;mobileNumber&quot;:&quot;15806204095&quot;,&quot;sendType&quot;:&quot;reg&quot;,&quot;channelId&quot;:7,&quot;channelCode&quot;:&quot;J0005&quot;,&quot;memberId&quot;:&quot;&quot;} 并发现了密码加密的函数，在下方通过$rootScope.getEncryption(params.params)调用生成密码。 由于Base64.encode有utf-8乱码问题，无法直接使用，var re_btou = new RegExp([&quot;[À-ß][-¿]&quot;, &quot;[à-ï][-¿]{2}&quot;, &quot;[ð-÷][-¿]{3}&quot;].join(&quot;|&quot;),&quot;g&quot;);通过base64.js源码提供Base64.encode(value)实现params加密关键函数getEncryption。 爬虫实现由于个人的js学的太孬了，在python调用js时报错execjs._exceptions.ProgramError: ReferenceError: Base64 is not defined,那么我只能避开，使用python实现base64加密并作为参数传入调用getEncryption。 1234567891011121314151617181920212223242526272829303132import jsonimport requestsimport execjsimport base64from requests_toolbelt import MultipartEncoderusername &#x3D; &quot;15806204095&quot;psssword &#x3D; &quot;123456&quot;with open(r&#39;jy_params.js&#39;, encoding&#x3D;&#39;utf-8&#39;, mode&#x3D;&#39;r&#39;) as f: JsData &#x3D; f.read()param &#x3D; &#123;&quot;mobileNumber&quot;: &quot;15806204095&quot;, &quot;sendType&quot;: &quot;reg&quot;, &quot;channelId&quot;: 7, &quot;channelCode&quot;: &quot;J0005&quot;, &quot;memberId&quot;: &quot;&quot;&#125;val &#x3D; base64.b64encode(json.dumps(param).encode())params &#x3D; execjs.compile(JsData).call(&#39;getEncryption&#39;, val.decode())print(params)headers &#x3D; &#123; &#39;Accept&#39;: &#39;application&#x2F;json, text&#x2F;plain, *&#x2F;*&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept-Language&#39;: &#39;zh-CN,zh;q&#x3D;0.9&#39;, &#39;Content-Length&#39;: &#39;341&#39;, &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8&#39;, &#39;Cookie&#39;: &#39;JSESSIONID&#x3D;DD188088D4E4EAC0098C9CCBCC32E52F; Hm_lvt_62d04228e1f84e012c1d9c0227f722c3&#x3D;1618618136; Hm_lpvt_62d04228e1f84e012c1d9c0227f722c3&#x3D;1618618136&#39;, &#39;Host&#39;: &#39;www.jycinema.com&#39;, &#39;Origin&#39;: &#39;http:&#x2F;&#x2F;www.jycinema.com&#39;, &#39;Proxy-Connection&#39;: &#39;keep-alive&#39;, &#39;Referer&#39;: &#39;http:&#x2F;&#x2F;www.jycinema.com&#x2F;wap&#x2F;&#39;, &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Linux; Android 6.0; Nexus 5 Build&#x2F;MRA58N) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;90.0.4430.72 Mobile Safari&#x2F;537.36&#39;,&#125;data &#x3D; &#123;&#39;params&#39;: params&#125;r &#x3D; requests.post(&quot;http:&#x2F;&#x2F;www.jycinema.com&#x2F;frontUIWebapp&#x2F;appserver&#x2F;photoMessageService&#x2F;newsSendMessage&quot;, data, headers&#x3D;headers)print(r.text) {“msg”:”短信发送成功”,”count”:0,”status”:”S”} 完整源码请关注微信公众号：ReverseCode，回复：JS逆向 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"违法应用fulao2取证分析","slug":"违法应用fulao2取证分析","date":"2021-04-15T00:08:51.000Z","updated":"2021-12-12T03:09:39.337Z","comments":true,"path":"2021/04/15/违法应用fulao2取证分析/","link":"","permalink":"http://onejane.github.io/2021/04/15/%E8%BF%9D%E6%B3%95%E5%BA%94%E7%94%A8fulao2%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 vip破解adb install -r -t fulao2.apk 通过jadx查询已经被混淆 hookEvent.js实现trace系统框架库android.view.View快速定位关键代码，trace所有的mOnClickListener，hook它们的onClick函数，实现点到哪里，定位到哪个类的功能。 前台运行fulao2.apk后，frida -UF -l hookEvent.js 启动hook 清晰度切换点击切换高清标清按钮，触发了发现在q0时的com.ilulutv.fulao2.film.l$t类，根据获取的类名进入jadx中搜索t，实现bool判断，下面我们手动将内存中的q0改成true。 12345pyenv local 3.8.0 objection -g com.ilulutv.fulao2 explore -P ~&#x2F;.objection&#x2F;pluginsplugin wallbreaker classdump --fullname com.ilulutv.fulao2.film.l\\$tplugin wallbreaker objectsearch com.ilulutv.fulao2.film.l\\$tplugin wallbreaker objectdump --fullname 0x26a2 获取到com.ilulutv.fulao2.film.l的对象实例 1plugin wallbreaker objectdump --fullname 0x2406 拿到内存中的对象数据 通过内存漫游修改q0的False的默认值，frida -UF -l fulao2.js 1234567891011121314151617181920212223function hookq0()&#123; Java.perform(function()&#123; Java.choose(&quot;com.ilulutv.fulao2.film.l&quot;,&#123; onMatch:function(ins)&#123; if(ins.e0.value)&#123; ins.q0.value &#x3D; true &#x2F;* if(ins.e0.value.toString().indexOf(&quot;宝宝睡&quot;)&gt;0)&#123; console.log(&quot;e0 value is :&quot;, ins.e0.value); &#x2F;&#x2F;ins.q0.value &#x3D; Java.use(&quot;java.lang.Boolean&quot;).\\$new(&quot;true&quot;); &#x2F;&#x2F;ins.q0.value &#x3D; true &#125; *&#x2F; &#125; &#125;,onComplete:function()&#123; console.log(&quot;search complete!&quot;) &#125; &#125;) &#125;)&#125;setImmediate(hookq0) android hooking search classes Boolean 获取Boolean类全路径java.lang.Boolean 重新调用plugin wallbreaker objectdump –fullname 0x2406 查看q0的值 这样就实现了标清切换高清的功能，破解了vip的切换视频清晰度。这种基于本地代码判断容易破解，基于服务器判断就只能根据逻辑漏洞判断。可以通过setInterval实现不断在内存循环调用，将内存中所有实例的q0改成true。 线路切换frida -UF -l hookEvent.js attach模式 frida -U -f com.ilulutv.fulao2 -l hookEvent.js –no-pause spawn模式一开始把所有View的OnClick类hook上，不用从内存中枚举 点击线路切换按钮，触发了com.ilulutv.fulao2.film.l$s和com.ilulutv.fulao2.film.l$m类方法 通过jadx查看这两个类方法 由于com.ilulutv.fulao2.film.l$s和之前的com.ilulutv.fulao2.film.l$t类似，都是以q0判断，不过没有生效，现在关注com.ilulutv.fulao2.film.l$m中的OnClick里的i方法 查看jadx的i方法 进入g()方法 通过hook androidx.fragment.app.Fragment.g方法，点击切换高清1的线路按钮，触发并返回了调用栈 登录抓包frida -UF -l hookSocket.js -o login.txt 所有内容包括手机号全部加密，除了一些请求头，gzip协议头关键字是1f 8b ，包括视频 图片都是加密的 图片下载12android hooking search classes ImageViewplugin wallbreaker objectsearch android.widget.ImageView 1234plugin wallbreaker classsearch bitmapandroid hooking search classes bitmap 将所有相关类保存到file.txt中，sed -i -e &#39;s&#x2F;^&#x2F;android hooking watch class &#x2F;&#39; file.txtobjection -g com.ilulutv.fulao2 explore -c file.txt 批量hookplugin wallbreaker objectsearch android.graphics.Bitmap Java.choose属于内存的搜刮，将现有内存的Bigmap对象实例保存，基于hook的话可以将未来持续增长的setInterval定时保存一份内存中的图片setInterval(main,5*1000) 1android hooking watch class_method android.graphics.BitmapFactory.decodeByteArray --dump-args --dump-backtrace --dump-return 通过批量hook拿到下拉触发的方法进行hook打印堆栈，glide是流式图片展示的框架 通过jadx搜索com.ilulutv.fulao2.other.helper.glide.b.a，decodeByteArray应该是解密开始了，返回b2应该就是明文。 开始hook Base64系统库，因为系统库不可能被混淆，下拉加载图片发现确实经过了android.util.Base64.encodeToString 1android hooking watch class_method android.util.Base64.encodeToString --dump-args --dump-backtrace --dump-return frida -UF -l fulao2.js -o /root/raw.txt 通过hook发现Base64.encodeToString得到的和SSLOutputStream得到的数据流一致 12345678910111213141516171819202122232425262728293031323334353637function hookImageByteCiphered()&#123; # 传输中的流 Java.perform(function()&#123; Java.use(&quot;android.util.Base64&quot;).encodeToString.overload(&#39;[B&#39;, &#39;int&#39;).implementation &#x3D; function(bytearray,int)&#123; var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;IMAGE DATA:bytearray,int&#x3D;&gt;&quot;,ByteString.of(bytearray).hex(),int) var result &#x3D; this.encodeToString(bytearray,int) return result; &#125; &#125;)&#125;function hook_SSLsocketandroid8()&#123; Java.perform(function()&#123; console.log(&quot;hook_SSLsocket&quot;) Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket\\$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTPS write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;HTTPS bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) &#x2F;&#x2F;console.log(jhexdump(bytearry,int1,int2)); console.log(jhexdump(bytearry)); return result; &#125; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket\\$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTPS read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;HTTPS bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) &#x2F;&#x2F;console.log(jhexdump(bytearry,int1,int2)); &#x2F;&#x2F;console.log(jhexdump(bytearry)); return result; &#125; &#125;)&#125; 说明com.ilulutv.fulao2.other.i.b.a((ByteBuffer) obj)确实是https传输的流，也是加密前的流，ffd8ff 是png文件头，通过后面的代码实现解密。 12android hooking search classes BitmapFactoryandroid hooking watch class_method android.graphics.BitmapFactory.decodeByteArray --dump-args --dump-backtrace --dump-return 开始hook BitmapFactory.decodeByteArray(b2, 0, b2.length) frida -UF -l fulao2.js 12345678910111213141516171819202122function hookImage()&#123; Java.perform(function()&#123; Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory\\$Options&#39;) .implementation &#x3D; function(data, offset, length, opts)&#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); &#x2F;&#x2F;console.log(&quot;data, offset, length, opts&#x3D;&gt;&quot;,data, offset, length, opts) &#x2F;&#x2F;console.log(&quot;IMAGE DATA:bytearray,int&#x3D;&gt;&quot;,ByteString.of(data).hex()) var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot;+guid()+&quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;,path) var file &#x3D; Java.use(&quot;java.io.File&quot;).\\$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).\\$new(file); fos.write(data); fos.close(); fos.close(); return result; &#125; &#125;)&#125; python调用保存fulao2.js 将解密后的字节数组发送给python，二进制写入图片 12345678910function hookImage()&#123; Java.perform(function()&#123; Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory\\$Options&#39;) .implementation &#x3D; function(data, offset, length, opts)&#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); send(data) return result; &#125; &#125;)&#125; 调用fulao2.js发送到本机 123456789101112131415161718192021222324252627282930313233343536373839import fridaimport jsonimport timeimport uuidimport base64import redef my_message_handler(message, payload): print(message) print(payload) if message[&quot;type&quot;] &#x3D;&#x3D; &quot;send&quot;: print(message[&quot;payload&quot;]) #image &#x3D; re.findall(&quot;(-?\\d+)&quot;, message[&quot;payload&quot;]) image &#x3D; message[&quot;payload&quot;] intArr &#x3D; [] for m in image: ival &#x3D; int(m) if ival &lt; 0: ival +&#x3D; 256 intArr.append(ival) bs &#x3D; bytes(intArr) fileName &#x3D; str(uuid.uuid1()) + &quot;.jpg&quot; f &#x3D; open(fileName,&#39;wb&#39;) f.write(bs) f.close() device &#x3D; frida.get_usb_device()target &#x3D; device.get_frontmost_application()session &#x3D; device.attach(target.pid)# 加载脚本with open(&quot;fulao2.js&quot;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot; , my_message_handler) #调用错误处理script.load()# 脚本会持续运行等待输入input() 不能够以战术的勤奋，掩盖战略的懒惰。 大多数人努力的程度还谈不上拼天分。 脱机二进制写入图片12objection -g com.ilulutv.fulao2 explore -P ~&#x2F;.objection&#x2F;pluginsandroid hooking watch class_method android.graphics.BitmapFactory.decodeByteArray --dump-args --dump-backtrace --dump-return hook解密方法，下拉获取调用栈 jadx搜索com.ilulutv.fulao2.other.helper.glide.b.a，抓包抓到的二进制数据流是encodeToString之前的b.a返回的数据，可以将协议中内容直接解密，不需要app参与，可以直接hook收发包 1android hooking watch class_method com.ilulutv.fulao2.other.i.b.a --dump-args --dump-backtrace --dump-return 下拉加载图片，关注Hooking com.ilulutv.fulao2.other.i.b.a(java.nio.ByteBuffer)，可以看到其他协议的解密也通过这个方法 由于返回是[object Object]，看不出结果还是通过hook实现吧。尽量不要用hookImageByteCiphered，因为其他类可能也用到了Base64 12345678910function hookImageByteCiphered() &#123; Java.perform(function () &#123; Java.use(&quot;android.util.Base64&quot;).encodeToString.overload(&#39;[B&#39;, &#39;int&#39;).implementation &#x3D; function (bytearray, int) &#123; var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;IMAGE DATA:bytearray,int&#x3D;&gt;&quot;, ByteString.of(bytearray).hex(), int) var result &#x3D; this.encodeToString(bytearray, int) return result; &#125; &#125;)&#125; 通过hook ByteBuffer获取com.ilulutv.fulao2.other.i.b.a 的入参实现hook com.ilulutv.fulao2.other.i.b.a((ByteBuffer) obj) 12345678910111213function hookByteBuffer() &#123; Java.perform(function () &#123; Java.use(&quot;com.ilulutv.fulao2.other.i.b&quot;).a.overload(&#39;java.nio.ByteBuffer&#39;).implementation &#x3D; function (bf) &#123; var result &#x3D; this.a(bf) &#x2F;&#x2F; [b &#x2F;&#x2F;var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) &#x2F;&#x2F;console.log(&quot;result is &#x3D;&gt; &quot;,result); send(result) &#x2F;&#x2F;console.log( gson.$new().toJson(result)) return result; &#125; &#125;)&#125; frida -UF -l fulao2.js 下拉显示图片，将打印返回的字节数组的结果，通过python实现解密后结果用于脱机处理。 通过hook byte[] b2 = com.ilulutv.fulao2.other.i.b.b(decode, Base64.decode(bytes2, 0), encodeToString);中的com.ilulutv.fulao2.other.i.b.b android hooking list class_methods com.ilulutv.fulao2.other.i.b 获取需要hook的方法 android hooking watch class_method net.idik.lib.cipher.so.CipherClient.decodeImgKey –dump-args –dump-backtrace –dump-return 获取hook的返回 android hooking search classes base64 获取android.util.Base64方法 123456789101112131415function hookdecodeimgkey() &#123; Java.perform(function () &#123; var base64 &#x3D; Java.use(&quot;android.util.Base64&quot;) Java.use(&quot;com.ilulutv.fulao2.other.i.b&quot;).b.overload(&#39;[B&#39;, &#39;[B&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function (key, iv, image) &#123; var result &#x3D; this.b(key, iv, image); console.log(&quot;key&quot;, base64.encodeToString(key, 0)); console.log(&quot;iv&quot;, base64.encodeToString(iv, 0)); return result; &#125; &#125;) &#x2F;* key svOEKGb5WD0ezmHE4FXCVQ&#x3D;&#x3D; iv 4B7eYzHTevzHvgVZfWVNIg&#x3D;&#x3D; *&#x2F;&#125; frida -UF -l fulao2.js 下拉加载图片 查看加密方式com.ilulutv.fulao2.other.i.b.b python实现解密 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pycrypto 1234567891011121314151617def IMGdecrypt(bytearray): imgkey &#x3D; base64.decodebytes( bytes(&quot;svOEKGb5WD0ezmHE4FXCVQ&#x3D;&#x3D;&quot;, encoding&#x3D;&#39;utf8&#39;)) imgiv &#x3D; base64.decodebytes( bytes(&quot;4B7eYzHTevzHvgVZfWVNIg&#x3D;&#x3D;&quot;, encoding&#x3D;&#39;utf8&#39;)) cipher &#x3D; AES.new(imgkey, AES.MODE_CBC, imgiv) # enStr +&#x3D; (len(enStr) % 4)*&quot;&#x3D;&quot; # decryptByts &#x3D; base64.urlsafe_b64decode(enStr) msg &#x3D; cipher.decrypt(bytearray) def unpad(s): return s[0:-s[-1]] return unpad(msg)# 拿到数据后Base64解密bs &#x3D; IMGdecrypt(bs) 将比较耗性能的加解密计算放到电脑端处理，减少了手机端的资源损耗，实现脱机处理。抓包后直接使用以上算法解码。 查看BitmapFactory.decodeByteArray返回的类型 12android hooking search classes Bitmapandroid hooking list class_methods android.graphics.Bitmap 123456789101112131415161718192021222324function getObjClassName(obj) &#123; if (!jclazz) &#123; var jclazz &#x3D; Java.use(&quot;java.lang.Class&quot;); &#125; if (!jobj) &#123; var jobj &#x3D; Java.use(&quot;java.lang.Object&quot;); &#125; return jclazz.getName.call(jobj.getClass.call(obj));&#125;function hookImage()&#123; Java.perform(function()&#123; Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory$Options&#39;) .implementation &#x3D; function(data, offset, length, opts)&#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) console.log(&quot;result is &#x3D;&gt;&quot;,gson.$new().toJson(result)) &#x2F;&#x2F; 打印BitmapFactory对象属性，说明BitmapFactory.decodeByteArray返回对象 console.log(&quot;className is &#x3D;&gt;&quot;,getObjClassName(result)) console.log(&#39;Object.getOwnPropertyNames()&#x3D;&gt;&#39;,Object.getOwnPropertyNames(result.$className)) return result; &#125; &#125;)&#125; 安卓保存图片12android hooking search classes CompressFormatplugin wallbreaker classdump --fullname android.graphics.Bitmap$CompressFormat frida -UF -l fulao2.js 123456789101112131415161718192021222324function hookImage()&#123; Java.perform(function()&#123; Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory$Options&#39;) .implementation &#x3D; function(data, offset, length, opts)&#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot; + guid() + &quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;, path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); result.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value, 100, fos) console.log(&quot;success!&quot;) fos.flush(); fos.close(); return result; &#125; &#125;)&#125; 多线程保存创建线程com.onejane.runnable，android hooking search classes onejane 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788function hookImage() &#123; Java.perform(function () &#123; var Runnable &#x3D; Java.use(&quot;java.lang.Runnable&quot;); var saveImg &#x3D; Java.registerClass(&#123; name: &quot;com.onejane.runnable&quot;, implements: [Runnable], fields: &#123; bm: &quot;android.graphics.Bitmap&quot;, &#125;, methods: &#123; $init: [&#123; returnType: &quot;void&quot;, argumentTypes: [&quot;android.graphics.Bitmap&quot;], implementation: function (bitmap) &#123; this.bm.value &#x3D; bitmap; &#125; &#125;], run: function () &#123; var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot; + guid() + &quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;, path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); this.bm.value.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value, 100, fos) console.log(&quot;success!&quot;) fos.flush(); fos.close(); &#125; &#125; &#125;); Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory$Options&#39;).implementation &#x3D; function (data, offset, length, opts) &#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); &#x2F;&#x2F;var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) &#x2F;&#x2F;send(data) &#x2F;&#x2F;send(gson.$new().toJson(data)) &#x2F;&#x2F;console.log(&quot;data, offset, length, opts&#x3D;&gt;&quot;,data, offset, length, opts) &#x2F;&#x2F;console.log(&quot;IMAGE DATA:bytearray,int&#x3D;&gt;&quot;,ByteString.of(data).hex()) &#x2F;* var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot;+guid()+&quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;,path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); fos.write(data); fos.flush(); fos.close(); *&#x2F; &#x2F;*var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) console.log(&quot;result is &#x3D;&gt;&quot;,gson.$new().toJson(result)) # 打印BitmapFactory对象属性，说明BitmapFactory.decodeByteArray返回 console.log(&quot;className is &#x3D;&gt;&quot;,getObjClassName(result)) console.log(&#39;Object.getOwnPropertyNames()&#x3D;&gt;&#39;,Object.getOwnPropertyNames(result.$className))*&#x2F; &#x2F;* var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot; + guid() + &quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;, path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); result.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value, 100, fos) console.log(&quot;success!&quot;) fos.flush(); fos.close(); *&#x2F; var runnable &#x3D; saveImg.$new(result); runnable.run() return result; &#125; &#125;)&#125; so分析CipherClient类中所有的返回都是CipherCore.get 而CipherCore又加载了cipher-lib的so库 1234objection -g com.ilulutv.fulao2 explore -P ~&#x2F;.objection&#x2F;pluginsmemory list modules 搜索cipher-libls -alt &#x2F;data&#x2F;app&#x2F;com.ilulutv.fulao2-6tvMrrptF1h1A4NvQbV85A&#x3D;&#x3D;&#x2F;lib&#x2F;arm&#x2F;memory list exports libcipher-lib.so 查看该so中有哪些导出函数 其中的getString对应了private static native String getString(String str); 1cp libcipher-lib.so &#x2F;sdcard&#x2F;Download&#x2F; 取出so后丢到IDA中分析 通过jnitrace trace下所有native的执行流。 1234.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs1428arm64 pyenv local 3.8.5pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple jnitracejnitrace -m attach -l libcipher-lib.so com.ilulutv.fulao2 下拉加载图片 查看trace的调用栈,默认是spawn so层再次调用java层方法AESEncryptor 1android hooking watch class net.idik.lib.cipher.so.encrypt.AESEncryptor 下拉图片加载，虽然到native进行转化，但是啥也没干，重新从java层调用加解密 由于每次hook时app总是崩掉，objection在app启动时直接执行hook方法 1objection -g com.ilulutv.fulao2 explore -P ~&#x2F;.objection&#x2F;plugins -s &quot;android hooking watch class_method net.idik.lib.cipher.so.encrypt.AESEncryptor.decrypt --dump-args --dump-backtrace --dump-return&quot; 堆栈说明确实从native层到了java层 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"JS逆向之爱拍password","slug":"js逆向之爱拍password","date":"2021-04-13T02:33:44.000Z","updated":"2021-12-12T03:09:39.285Z","comments":true,"path":"2021/04/13/js逆向之爱拍password/","link":"","permalink":"http://onejane.github.io/2021/04/13/js%E9%80%86%E5%90%91%E4%B9%8B%E7%88%B1%E6%8B%8Dpassword/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 http://www.aipai.com/ 抓包登录url： POST http://www.aipai.com/login.php 参数： 123456action: loginNewuser: 15806204095password: 202cb962ac59075b964b07152d234b70keeplogin: 1comouterTime: 1userNowTime: 1618281089 分析参数中只有password加密，搜索/login.php,出现在了sea.js,header.js?t=20210312,global.js的多个地方中 逐步分析各个位置的/login.php,初步定位到两个地方的js处可能是加密password 的位置，因为这两处附近都有user,action等其他参数生成。 这两处同样的通过md5函数加密password所在id的内容，我们为这两处加上断点，重新登录发现停在了header.js?t=20210312 F10单步逐行跳过到metadata=&#39;action=&#39;+ action +&#39;&amp;account=&#39;+ user +&#39;&amp;password=&#39;+ _ts.md5(pass) +&#39;&amp;keeplogin=&#39;+ keep +&#39;&amp;comouterTime=&#39;+ keep +&#39;&amp;userNowTime=&#39;+ userNowTime; 通过Watch面板拿到idPass，pass和_ts.md5(pass)的值 点击进入md5方法，打上断点后，F9单步跳入后抠出md5算法js 爬虫实现通过python调用js实现password的逆向分析。 1234567891011121314151617181920import requestsimport execjsusername &#x3D; &quot;15806204095&quot;password &#x3D; &quot;123&quot;with open(r&#39;aipai_password.js&#39;, encoding&#x3D;&#39;utf-8&#39;, mode&#x3D;&#39;r&#39;) as f: JsData &#x3D; f.read()password &#x3D; execjs.compile(JsData).call(&#39;pwd&#39;, password)print(password)data &#x3D; &#123; &#39;action&#39;: &#39;loginNew&#39;, &#39;user&#39;: username, &#39;password&#39;: password, &#39;keeplogin&#39;: &#39;1&#39;, &#39;comouterTime&#39;: &#39;1&#39;, &#39;userNowTime&#39;: &#39;1618281089&#39;,&#125;r &#x3D; requests.post(&quot;http:&#x2F;&#x2F;www.aipai.com&#x2F;login.php&quot;, data)print(r.text) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之拉勾password","slug":"js逆向之拉勾password","date":"2021-04-12T11:43:44.000Z","updated":"2021-12-12T03:09:39.285Z","comments":true,"path":"2021/04/12/js逆向之拉勾password/","link":"","permalink":"http://onejane.github.io/2021/04/12/js%E9%80%86%E5%90%91%E4%B9%8B%E6%8B%89%E5%8B%BEpassword/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 https://www.lagou.com/ 抓包登录url: GET https://passport.lagou.com/login/login.json 参数： 1234567jsoncallback: jQuery11130510950445912626_1618227551741isValidate: trueusername: 15806204095password: 990eb670f81e82f546cfaaae1587279arequest_form_verifyCode: challenge: c7a96a290ed4d75ca2a8bf139172dbe0_: 1618227551745 分析参数中password和challenge看起来是加密参数，其实challenge是极验验证码请求的参数，本文针对password进行参数分析，暂时先不做讨论。 搜索login/login.json并格式化js后，发现改password通过md5实现加密，在Watch界面输入g查看g的内容 放行程序后，在g.isValidate &amp;&amp; (g.password = md5(g.password)处重新打上断点并登录 那么分析得出password=md5(“veenike”+md5(passwrod)+”veenike”) 爬虫实现12345678910import requestsfrom hashlib import md5username &#x3D; &#39;15806204095&#39;pwd &#x3D; &#39;123&#39;md5_pwd &#x3D; md5((&quot;veenike&quot; + md5(pwd.encode(&#39;utf8&#39;)).hexdigest() + &quot;veenike&quot;).encode(&quot;utf8&quot;)).hexdigest()print(md5_pwd)url &#x3D; &#39;https:&#x2F;&#x2F;passport.lagou.com&#x2F;login&#x2F;login.json?jsoncallback&#x3D;jQuery111306946515748870927_1618229101639&amp;isValidate&#x3D;true&amp;username&#x3D;&#39;+username+&#39;&amp;password&#x3D;+&#39;+md5_pwd+&#39;+&amp;request_form_verifyCode&#x3D;&amp;challenge&#x3D;c3bebcad0648898aa58cb3f4dbf2f820&amp;_&#x3D;1618229101642&#39;r &#x3D;requests.get(url)print(r.text) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之中关村在线pwd","slug":"js逆向之中关村在线pwd","date":"2021-04-12T03:19:07.000Z","updated":"2021-12-12T03:09:39.285Z","comments":true,"path":"2021/04/12/js逆向之中关村在线pwd/","link":"","permalink":"http://onejane.github.io/2021/04/12/js%E9%80%86%E5%90%91%E4%B9%8B%E4%B8%AD%E5%85%B3%E6%9D%91%E5%9C%A8%E7%BA%BFpwd/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 https://www.zol.com.cn/ 抓包本登录页面既然是框架，找到php页面，https://service.zol.com.cn/user/siteLogin.php?type=small&amp;callback=userLoginCallback&amp;backurl=https://www.zol.com.cn/ 直接访问该php网址，避免其他请求干扰分析 登录url: POST https://service.zol.com.cn/user/ajax/siteLogin/login.php 请求头： 12345678910111213141516:authority: service.zol.com.cn:method: POST:path: &#x2F;user&#x2F;ajax&#x2F;siteLogin&#x2F;login.php:scheme: httpsaccept: application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01accept-encoding: gzip, deflate, braccept-language: zh-CN,zh;q&#x3D;0.9content-length: 138content-type: application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8cookie: ip_ck&#x3D;5cKC7&#x2F;vxj7QuMjUzODE2LjE2MTgxOTc3OTM%3D; lv&#x3D;1618197793; vn&#x3D;1; Hm_lvt_ae5edc2bc4fc71370807f6187f0a2dd0&#x3D;1618197793; questionnaire_pv&#x3D;1618185602; Hm_lpvt_ae5edc2bc4fc71370807f6187f0a2dd0&#x3D;1618197883origin: https:&#x2F;&#x2F;service.zol.com.cnreferer: https:&#x2F;&#x2F;service.zol.com.cn&#x2F;user&#x2F;siteLogin.php?type&#x3D;small&amp;callback&#x3D;userLoginCallback&amp;backurl&#x3D;https:&#x2F;&#x2F;www.zol.com.cn&#x2F;sec-fetch-mode: corssec-fetch-site: same-originuser-agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;78.0.3904.70 Safari&#x2F;537.36x-requested-with: XMLHttpRequest 参数： 1234567userid: 15806204096pwd: 74ce2ba17b2c218246e778fb5e895c95isAuto: 1backurl: http:&#x2F;&#x2F;www.zol.com.cn&#x2F;tmallBtn: 0activeBtn: 0headPicid: 0 分析全局搜索siteLogin/login.php 中关村非常的耿直，加密使用md5,var md5Password = CryptoJS.MD5(password+&quot;zol&quot;) + &#39;&#39;;输入123提交的pwd为74ce2ba17b2c218246e778fb5e895c95，通过md5比对 爬虫实现拷贝Form Data到请求头加引号.py中自动生成dict格式 12345678910111213141516171819import requestsfrom hashlib import md5username &#x3D; &#39;15806204095&#39;pwd &#x3D; &#39;123&#39;md5_pwd &#x3D; md5((pwd + &#39;zol&#39;).encode(&#39;utf8&#39;)).hexdigest()print(md5_pwd)url &#x3D; &#39;https:&#x2F;&#x2F;service.zol.com.cn&#x2F;user&#x2F;ajax&#x2F;siteLogin&#x2F;login.php&#39;data &#x3D; &#123; &#39;userid&#39;: username, &#39;pwd&#39;: md5_pwd, &#39;isAuto&#39;: &#39;1&#39;, &#39;backurl&#39;: &#39;http:&#x2F;&#x2F;www.zol.com.cn&#x2F;&#39;, &#39;tmallBtn&#39;: &#39;0&#39;, &#39;activeBtn&#39;: &#39;0&#39;, &#39;headPicid&#39;: &#39;0&#39;,&#125;r &#x3D;requests.post(url,data)print(r.text) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之融金所sign","slug":"js逆向之融金所sign","date":"2021-04-11T02:20:26.000Z","updated":"2021-12-12T03:09:39.286Z","comments":true,"path":"2021/04/11/js逆向之融金所sign/","link":"","permalink":"http://onejane.github.io/2021/04/11/js%E9%80%86%E5%90%91%E4%B9%8B%E8%9E%8D%E9%87%91%E6%89%80sign/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 https://m.rjs.com/member/user.html#1 抓包登录url: POST https://m.rjs.com/japi/account/login.json 请求头： 12345678910111213141516171819:authority: m.rjs.com:method: POST:path: &#x2F;japi&#x2F;account&#x2F;login.json:scheme: httpsaccept: application&#x2F;json, text&#x2F;plain, *&#x2F;*accept-encoding: gzip, deflate, braccept-language: zh-CN,zh;q&#x3D;0.9content-length: 172content-type: application&#x2F;jsoncookie: riskTipTimes1&#x3D;1; Hm_lvt_7ff1e43d61e6b35b46f6bb33c3aba9bb&#x3D;1618099071; Hm_lpvt_7ff1e43d61e6b35b46f6bb33c3aba9bb&#x3D;1618099071datatype: jsonorigin: https:&#x2F;&#x2F;m.rjs.comreferer: https:&#x2F;&#x2F;m.rjs.com&#x2F;member&#x2F;user.htmlsec-ch-ua: &quot;Google Chrome&quot;;v&#x3D;&quot;89&quot;, &quot;Chromium&quot;;v&#x3D;&quot;89&quot;, &quot;;Not\\&quot;A\\\\Brand&quot;;v&#x3D;&quot;99&quot;sec-ch-ua-mobile: ?1sec-fetch-dest: emptysec-fetch-mode: corssec-fetch-site: same-originUser-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;50.0.2661.87 Safari&#x2F;537.36 参数： 1&#123;&quot;platform&quot;:&quot;wap&quot;,&quot;session_token&quot;:&quot;&quot;,&quot;session_id&quot;:&quot;&quot;,&quot;data&quot;:&#123;&quot;userName&quot;:&quot;15806204085&quot;,&quot;password&quot;:&quot;123&quot;&#125;,&quot;sign&quot;:&quot;b6a20a0b1c82b87d65b78b2943bb3fbc&quot;,&quot;timestamp&quot;:1618099099626&#125; 分析搜索japi/account/login.json 无果 搜索account/login.json 1234567891011121314151617181920loginAction: function() &#123; if (this.checkLoginKey() &amp;&amp; this.checkLoginPwd()) &#123; var e &#x3D; this; c.Common.fajax(&#123; url: &quot;account&#x2F;login.json&quot;, easyOriginData: &#123; userName: e.loginKey, password: e.loginPwd &#125;, success: function(t) &#123; 1 &#x3D;&#x3D; t.status ? (c.Common.cookie.set(&quot;session_token_dp&quot;, t.data.sessionToken, &quot;&#x2F;&quot;, &quot;&#x2F;&quot;, 168), c.Common.cookie.set(&quot;platform&quot;, &quot;wap&quot;, &quot;&#x2F;&quot;, &quot;&#x2F;&quot;, 168), c.Common.localStore.set(&quot;session_token_dp&quot;, t.data.sessionToken), c.Common.localStore.set(&quot;uid_dp&quot;, t.data.uid), c.Common.cookie.set(&quot;secretKey&quot;, t.data.secretKey, &quot;&#x2F;&quot;, &quot;&#x2F;&quot;, 168), c.Common.alert(&quot;simpleSuccess&quot;, &quot;登录成功&quot;, 1, e.goHref, &quot;&#x2F;member-undp&#x2F;index.html&quot;)) : e.alert(t.message) &#125; &#125;) &#125;&#125;, 打上断点调试，此时并没有出现sign,说明sign应该是在fajax中生成，进入fajax中，逐步调试，t[&quot;sign&quot;] = i(f + &quot;&amp;&quot; + i(o.genSignData(t.data)) + &quot;&amp;&quot; + d),这一步出现了sign进行填值，f为/account/login.json d是””空字符串 接下来分析i(o.genSignData(t.data))中的o.genSignData(t.data),其中t.data为账户密码的对象 genSignDatai(o.genSignData(t.data))分析，先进入o.genSignData函数，拆分出来js如下 123456789101112131415161718192021222324var genSignData &#x3D; function(e) &#123; var t &#x3D; &quot;&quot; , n &#x3D; []; for (var r in e) n.push(r); n &#x3D; n.sort(); for (var i &#x3D; 0; i &lt; n.length; i++) &#123; var o &#x3D; n[i] , s &#x3D; e[o] , l &#x3D; !1; if (&quot;object&quot; &#x3D;&#x3D; (&quot;undefined&quot; &#x3D;&#x3D; typeof s ? &quot;undefined&quot; : (0, a.default)(s))) &#123; var c &#x3D; &quot;&#123;&quot;; for (var u in s) c +&#x3D; u + &quot;&#x3D;&quot; + s[u] + &quot;, &quot;, l &#x3D; !0; l &amp;&amp; (s &#x3D; c.substring(0, c.length - 2) + &quot;&#125;&quot;) &#125; &quot;sign&quot; !&#x3D; o &amp;&amp; null !&#x3D;&#x3D; s &amp;&amp; void 0 !&#x3D;&#x3D; s &amp;&amp; &quot;&quot; !&#x3D;&#x3D; s &amp;&amp; (&quot;object&quot; !&#x3D; (&quot;undefined&quot; &#x3D;&#x3D; typeof s ? &quot;undefined&quot; : (0, a.default)(s)) || l) &amp;&amp; (t +&#x3D; (0 &#x3D;&#x3D; i ? &quot;&quot; : &quot;&amp;&quot;) + o + &quot;&#x3D;&quot; + s) &#125; return null !&#x3D; t &amp;&amp; &quot;&quot; !&#x3D; t &amp;&amp; &quot;&amp;&quot; &#x3D;&#x3D; t.substr(0, 1) &amp;&amp; (t &#x3D; t.substr(1, t.length)), t&#125; 单独运行时报错Uncaught ReferenceError: a is not defined,打印a.default 进入a.default,该三元运算所得结果即为控制台打印结果，必然前面的是完全匹配的 123 t.default &#x3D; &quot;function&quot; &#x3D;&#x3D; typeof s.default &amp;&amp; &quot;symbol&quot; &#x3D;&#x3D;&#x3D; l(a.default) ? function(e) &#123; return &quot;undefined&quot; &#x3D;&#x3D; typeof e ? &quot;undefined&quot; : l(e)&#125; 该l函数在上面也有定义如下 那么我们定义函数k即a.default如下,替换genSignData完成函数解密password=123&amp;userName=15806204095 123var k &#x3D; function(e)&#123; return&quot;undefined&quot;&#x3D;&#x3D;typeof e?&quot;undefined&quot;: typeof e&#125; ii(o.genSignData(t.data))分析，接下来就是i函数的分析，进入i函数 第一次调用i函数时，先调用o函数进行加密，再调用wordsToBytes转成字节，返回bytesToHex生成16进制字符串，整体逻辑理清后进入o函数。 o 该函数中引用了n(694),n(247).utf8,n(974),n(247).bin,通过debug可知以上都生成了加密函数 这些加密函数搜索分别发现出现在了694:function，247:function等等，可以断定，这些函数其实就是作为变量在o函数中调用 扣出694,247,974的代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293var liu94 &#x3D; function (e, t) &#123; var t &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&quot; , n &#x3D; &#123; rotl: function (e, t) &#123; return e &lt;&lt; t | e &gt;&gt;&gt; 32 - t &#125;, rotr: function (e, t) &#123; return e &lt;&lt; 32 - t | e &gt;&gt;&gt; t &#125;, endian: function (e) &#123; if (e.constructor &#x3D;&#x3D; Number) return 16711935 &amp; n.rotl(e, 8) | 4278255360 &amp; n.rotl(e, 24); for (var t &#x3D; 0; t &lt; e.length; t++) e[t] &#x3D; n.endian(e[t]); return e &#125;, randomBytes: function (e) &#123; for (var t &#x3D; []; e &gt; 0; e--) t.push(Math.floor(256 * Math.random())); return t &#125;, bytesToWords: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0, r &#x3D; 0; n &lt; e.length; n++, r +&#x3D; 8) t[r &gt;&gt;&gt; 5] |&#x3D; e[n] &lt;&lt; 24 - r % 32; return t &#125;, wordsToBytes: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; 32 * e.length; n +&#x3D; 8) t.push(e[n &gt;&gt;&gt; 5] &gt;&gt;&gt; 24 - n % 32 &amp; 255); return t &#125;, bytesToHex: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; e.length; n++) t.push((e[n] &gt;&gt;&gt; 4).toString(16)), t.push((15 &amp; e[n]).toString(16)); return t.join(&quot;&quot;) &#125;, hexToBytes: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; e.length; n +&#x3D; 2) t.push(parseInt(e.substr(n, 2), 16)); return t &#125;, bytesToBase64: function (e) &#123; for (var n &#x3D; [], r &#x3D; 0; r &lt; e.length; r +&#x3D; 3) for (var i &#x3D; e[r] &lt;&lt; 16 | e[r + 1] &lt;&lt; 8 | e[r + 2], a &#x3D; 0; a &lt; 4; a++) 8 * r + 6 * a &lt;&#x3D; 8 * e.length ? n.push(t.charAt(i &gt;&gt;&gt; 6 * (3 - a) &amp; 63)) : n.push(&quot;&#x3D;&quot;); return n.join(&quot;&quot;) &#125;, base64ToBytes: function (e) &#123; e &#x3D; e.replace(&#x2F;[^A-Z0-9+\\&#x2F;]&#x2F;gi, &quot;&quot;); for (var n &#x3D; [], r &#x3D; 0, i &#x3D; 0; r &lt; e.length; i &#x3D; ++r % 4) 0 !&#x3D; i &amp;&amp; n.push((t.indexOf(e.charAt(r - 1)) &amp; Math.pow(2, -2 * i + 8) - 1) &lt;&lt; 2 * i | t.indexOf(e.charAt(r)) &gt;&gt;&gt; 6 - 2 * i); return n &#125; &#125;; return n;&#125;var er47 &#x3D; &#123; utf8: &#123; stringToBytes: function (e) &#123; return er47.bin.stringToBytes(unescape(encodeURIComponent(e))) &#125;, bytesToString: function (e) &#123; return decodeURIComponent(escape(er47.bin.bytesToString(e))) &#125; &#125;, bin: &#123; stringToBytes: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; e.length; n++) t.push(255 &amp; e.charCodeAt(n)); return t &#125;, bytesToString: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; e.length; n++) t.push(String.fromCharCode(e[n])); return t.join(&quot;&quot;) &#125; &#125;&#125;;var jiu74 &#x3D; function (e, t) &#123; function n(e) &#123; return !!e.constructor &amp;&amp; &quot;function&quot; &#x3D;&#x3D; typeof e.constructor.isBuffer &amp;&amp; e.constructor.isBuffer(e) &#125; function r(e) &#123; return &quot;function&quot; &#x3D;&#x3D; typeof e.readFloatLE &amp;&amp; &quot;function&quot; &#x3D;&#x3D; typeof e.slice &amp;&amp; n(e.slice(0, 0)) &#125; return function (e) &#123; return null !&#x3D; e &amp;&amp; (n(e) || r(e) || !!e._isBuffer) &#125;&#125; 在o函数中改写t,r,i,a 1234var t &#x3D; liu94() , r &#x3D; er47.utf8 , i &#x3D; jiu74() , a &#x3D; er47.bin 最终只要将o函数中exports的函数return出来即可 1234567891011res &#x3D; function (e, n) &#123; console.log(e) if (void 0 &#x3D;&#x3D;&#x3D; e || null &#x3D;&#x3D;&#x3D; e) throw new Error(&quot;Illegal argument &quot; + e); var r &#x3D; t.wordsToBytes(o(e, n)); console.log(r) return n &amp;&amp; n.asBytes ? r : n &amp;&amp; n.asString ? a.bytesToString(r) : t.bytesToHex(r)&#125;&#x2F;&#x2F;res(&quot;password&#x3D;123&amp;userName&#x3D;158062204095&quot;, undefined);&#x2F;&#x2F;console.log(&#39;--------&gt;&#39;,res(origin, undefined))return res; 由于o(e,n)中的即为o.genSignData生成的账密参数password=123&amp;userName=15806204095，n为undefined，那么我们就可以直接调用该方法返回真正的sign。 console.log(encrypt()(&quot;/account/login.json&quot;+&quot;&amp;&quot;+encrypt()(genSignData(UP))+&quot;&amp;&quot;+&quot;&quot;)); 查看抓包后的结果如下 爬虫实现12345678910111213import jsonimport requestsimport execjsusername &#x3D; &quot;15806204095&quot;psssword &#x3D; &quot;123&quot;with open(r&#39;rjs_sign.js&#39;, encoding&#x3D;&#39;utf-8&#39;, mode&#x3D;&#39;r&#39;) as f: JsData &#x3D; f.read()sign &#x3D; execjs.compile(JsData).call(&#39;request&#39;,username,psssword)data &#x3D; json.dumps(&#123;&quot;platform&quot;:&quot;wap&quot;,&quot;session_token&quot;:&quot;&quot;,&quot;session_id&quot;:&quot;&quot;,&quot;data&quot;:&#123;&quot;userName&quot;:username,&quot;password&quot;:psssword&#125;,&quot;sign&quot;:sign,&quot;timestamp&quot;:1618153079455&#125;)r &#x3D;requests.post(&quot;https:&#x2F;&#x2F;m.rjs.com&#x2F;japi&#x2F;account&#x2F;login.json&quot;,data)print(r.text) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"hook抓包trace定位实战","slug":"hook抓包trace定位实战","date":"2021-04-10T02:54:10.000Z","updated":"2021-12-12T03:09:39.284Z","comments":true,"path":"2021/04/10/hook抓包trace定位实战/","link":"","permalink":"http://onejane.github.io/2021/04/10/hook%E6%8A%93%E5%8C%85trace%E5%AE%9A%E4%BD%8D%E5%AE%9E%E6%88%98/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 移动TVnpm install –save @types/frida-gum 配置vscode的frida自动代码提示 123456adb install movetv.apkgit clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;FRIDA-DEXDump.gitpython main.py 打开app操作一会积分查看视频开始脱壳cd com.cz.babySistergrep -ril &quot;LoginActivity&quot; * 查看该类在那个dex中frida -UF -l hookEvent.js 点击登录时，触发打印LoginActivity完整路径 通过jadx-gui 查看com.cz.babySister.activity.LoginActivity的onClick方法 12345678objection -g com.cz.babySister exploreandroid hooking search classes user 查找和用户相关的类android hooking search classes personandroid hooking watch class com.cz.babySister.javabean.UserInfo 查看该类在jadx中哪些地方调用了plugin load &#x2F;root&#x2F;.objection&#x2F;plugins&#x2F;Wallbreakerplugin wallbreaker objectsearch com.cz.babySister.javabean.UserInfo 内存搜索UserInfoplugin wallbreaker objectdump --fullname 0x112swa 查看内存中UserInfo信息android hooking list class_methods com.cz.babySister.javabean.UserInfo frida -U -f com.cz.babySister -l jifen.js --no-pause 有壳不能spawn,从登录开始hook frida -UF -l jifen.js 服务器检测校验了无法查看视频，客户端修改无效 123456789101112131415161718192021function hook_jifen()&#123; Java.perform(function()&#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) Java.use(&quot;com.cz.babySister.javabean.UserInfo&quot;).setJifen.implementation &#x3D; function(str) &#123; var result &#x3D; this.setJifen(javaString.$new(&quot;1000&quot;)) console.log(&quot;setJifen is :&quot; ,str) console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return result; &#125; Java.use(&quot;com.cz.babySister.javabean.UserInfo&quot;).setJifen.implementation &#x3D; function() &#123; var result &#x3D; this.getJifen() console.log(&quot;getJifen is :&quot;,result) console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return javaString.$new(&quot;1000&quot;) &#125; &#125;)&#125;function main()&#123; hook_jifen()&#125;setImmediate(main) 通过console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()));打印调用栈，找到最下面的com.cz.babySister.alipay.k.run，查看com.cz.babySister.alipay下的所有类，jadx搜索支付失败 123456789101112function hook_jifen2()&#123; Java.perform(function()&#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) Java.use(&quot;com.cz.babySister.alipay.o&quot;).b.implementation&#x3D;function()&#123; console.log(&quot;success&quot;) return javaString.$new(&quot;9000&quot;) &#125; &#125;)&#125;function main()&#123; hook_jifen2()&#125; 依旧失败，可能做了支付订单校验。 调用栈中害打印了com.cz.babySister.utils.ParseJson.parseRegisterName,查看com.cz.babySister.utils.ParseJson类，所有内容都是从该类中出现，jadx查看该类的调用处，出现queryJifen 进入a.a方法，a2就是json，所有查询从a.a中返回json，通过objection对该类进行hook，登录时查看调用的方法基本都是a.a 12android hooking watch class com.cz.babySister.c.a --dump-args --dump-return android hooking watch_method class com.cz.babySister.c.a.a --dump-args --dump-return 每次看成人台时都会queryJifen判断积分是否不足，不过Return Value是服务器判断了积分是否充足，充足才返回可以看的地址，没有逻辑漏洞了。 搜索memi1的来源 12android hooking watch class_method android.content.Context.getString --dump-args --dump-returnandroid hooking watch class_method android.content.Context.getText --dump-args --dump-return context在app启动后立即生成且销毁，因为有壳的原因，无法hook，只有一次捕捉机会 1234android hooking watch class android.provider.Settings$Secure --dump-args --dump-return 每次context实时获取的android hooking watch class_method android.provider.Settings$Secure.getString --dump-args --dump-return --dump-backtraceplugin wallbreaker objectsearch android.app.ContextImpl$ApplicationContentResolverplugin wallbreaker objectdump --fullname 0x2502 记一次frida实战——对某视频APP的脱壳、hook破解、模拟抓包、协议分析一条龙服务 fulao2adb install -r fulao2.apk 1234567891011.&#x2F;fs128arm64frida -UF -l hookSocket.js -o &#x2F;root&#x2F;Desktop&#x2F;img.txt 启动app后开始抓包，GET到的地址结合域名发现图片是被加密的objection -g com.ilulutv.fulao2 explore -P ~&#x2F;.objection&#x2F;pluginsandroid hooking search classes imageViewplugin wallbreaker objectsearch android.widget.ImageView 查看内存中的对象plugin wallbreaker objectdump --fullname 0x20212 打印内存对象属性内容android hooking search classes Bitmap 把所有Bitmap相关的类拷贝到文件bitmap.txt中，前面加上android hooking watch classplugin wallbreaker objectdump --fullname 0x2045 查看内存Bitmap属性，即图片属性objection -g com.ilulutv.fulao2 explore -c bitmap.txt 批量hook,如果app崩了查看最后一个hook的类，在文件中删除重新挂上objectionandroid hooking watch class_method android.graphics.BitmapFactory.decodeStream --dump-args --dump-backtrace --dump-return 下拉加载图片，堆栈中加载了glide图片加载库android hooking watch class_method android.graphics.BitmapFactory.decodeByteArray --dump-args --dump-backtrace --dump-return 堆栈中打印了业务代码com.ilulutv.fulao2.other.helper.glide.b.a jadx打开fulao2，搜索com.ilulutv.fulao2.other.helper.glide.b类的a方法 1android hooking list class_methods android.graphics.BigmapFactory 查看decodeByteArray返回值 其中byte[] c2 = com.ilulutv.fulao2.other.i.b.c(decode, Base64.decode(bytes2, 0), encodeToString);解密 hook网络流打印下载图片内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function hookRAW()&#123; Java.perform(function()&#123; console.log(&quot;hooking RAW...&quot;) Java.use(&quot;com.ilulutv.fulao2.other.i.b&quot;).a.overload(&#39;java.nio.ByteBuffer&#39;).implementation &#x3D; function(bytebuffer)&#123; var result &#x3D; this.a(bytebuffer) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;result is &#x3D;&gt; &quot;,ByteString.of(result).hex()) return result &#125; &#125;) &#125;function hook_SSLsocketandroid8()&#123; Java.perform(function()&#123; console.log(&quot;hook_SSLsocket&quot;) &#x2F;&#x2F; concrypt本质对libssl.so进行操作 Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTPS write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) &#x2F;&#x2F;console.log(jhexdump(bytearry,int1,int2)); &#x2F;&#x2F; console.log(jhexdump(bytearry)); return result; &#125; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTPS read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) &#x2F;&#x2F;console.log(jhexdump(bytearry,int1,int2)); &#x2F;&#x2F; console.log(jhexdump(bytearry)); return result; &#125; &#125;)&#125;function main()&#123; hookRAW() hook_SSLsocketandroid8()&#125;setImmediate(main) frida -UF -l fulao2.js -o hookRAW.txt 下拉内容查看log图片，对比抓包hook_SSLsocketandroid8结果和hookRAW结果的内容是否一致，说明com.ilulutv.fulao2.other.i.b.a((ByteBuffer) obj)确实是要加密的内容，明文在com.ilulutv.fulao2.other.i.b.b(decode, Base64.decode(bytes2, 0), encodeToString) 根据return com.bumptech.glide.load.q.d.e.a(BitmapFactory.decodeByteArray(b2, 0, b2.length), this.f11769a);,hook系统库查看解密后图片内容 1234567891011function hookClean()&#123; Java.perform(function()&#123; &#x2F;&#x2F; hook 系统库 不会被混淆 ,图片文件头jpeg都是ffd8ff Java.use(&quot;android.graphics.BigmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;,&#39;android.graphics.BitmapFactory$Options&#39;).implementation &#x3D; function (ba,int1,int2,op)&#123; var result &#x3D; this.decodeByteArray(ba,in1,int2,op) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;ba is&#x3D;&gt;&quot;,ByteString.of(ba).hex()) return result; &#125; &#125;)&#125; byte下载图片，frida -UF -l fulao2.js -o hookRAW.txt 下拉加载图片 1234567891011121314151617181920212223242526function guid() &#123; function S4() &#123; return (((1+Math.random())*0x10000)|0).toString(16).substring(1); &#125; return (S4()+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+S4()+S4()); &#125;function hookClean()&#123; Java.perform(function()&#123; &#x2F;&#x2F; hook 系统库 不会被混淆 ,图片文件头jpeg都是ffd8ff Java.use(&quot;android.graphics.BigmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;,&#39;android.graphics.BitmapFactory$Options&#39;).implementation &#x3D; function (ba,int1,int2,op)&#123; var result &#x3D; this.decodeByteArray(ba,in1,int2,op) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;ba is&#x3D;&gt;&quot;,ByteString.of(ba).hex()) var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot;+guid()+&quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;,path) &#x2F;&#x2F; android hooking search classes File var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) &#x2F;&#x2F; android hooking search classes FileOutputStream var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); fos.write(data); fos.close(); fos.close(); return result; &#125; &#125;)&#125; 根据正常图片访问方式，利用安卓api，通过Bigmap对象压缩到文件输出流 12345678910111213141516171819202122function hookClean()&#123; Java.perform(function()&#123; &#x2F;&#x2F; hook 系统库 不会被混淆 ,图片文件头jpeg都是ffd8ff Java.use(&quot;android.graphics.BigmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;,&#39;android.graphics.BitmapFactory$Options&#39;).implementation &#x3D; function (ba,int1,int2,op)&#123; var result &#x3D; this.decodeByteArray(ba,in1,int2,op) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;ba is&#x3D;&gt;&quot;,ByteString.of(ba).hex()) var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot;+guid()+&quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;,path) &#x2F;&#x2F; android hooking search classes File var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) &#x2F;&#x2F; android hooking search classes FileOutputStream var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); &#x2F;&#x2F; android hooking list class_methods android.graphics.Bitmap 查看compress实例方法 result.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value,100,fos) &#x2F;&#x2F; fos.write(data); fos.close(); fos.close(); return result; &#125; &#125;)&#125; compress占用主线程资源，阻塞主线程导致程序崩溃，可以另起线程专门用来下载图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344function hookImage() &#123; Java.perform(function () &#123; var Runnable &#x3D; Java.use(&quot;java.lang.Runnable&quot;); var saveImg &#x3D; Java.registerClass(&#123; name: &quot;com.roysue.runnable&quot;, implements: [Runnable], fields: &#123; bm: &quot;android.graphics.Bitmap&quot;, &#125;, methods: &#123; $init: [&#123; returnType: &quot;void&quot;, argumentTypes: [&quot;android.graphics.Bitmap&quot;], implementation: function (bitmap) &#123; this.bm.value &#x3D; bitmap; &#125; &#125;], run: function () &#123; var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot; + guid() + &quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;, path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); this.bm.value.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value, 100, fos) console.log(&quot;success!&quot;) fos.flush(); fos.close(); &#125; &#125; &#125;); Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory$Options&#39;).implementation &#x3D; function (data, offset, length, opts) &#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); var runnable &#x3D; saveImg.$new(result); runnable.run() return result; &#125; &#125;)&#125; 不建议多线程在手机端运行，可以将线程发送PC端执行 fulao2.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function hookImage() &#123; Java.perform(function () &#123; var Runnable &#x3D; Java.use(&quot;java.lang.Runnable&quot;); var saveImg &#x3D; Java.registerClass(&#123; name: &quot;com.roysue.runnable&quot;, implements: [Runnable], fields: &#123; bm: &quot;android.graphics.Bitmap&quot;, &#125;, methods: &#123; $init: [&#123; returnType: &quot;void&quot;, argumentTypes: [&quot;android.graphics.Bitmap&quot;], implementation: function (bitmap) &#123; this.bm.value &#x3D; bitmap; &#125; &#125;], run: function () &#123; var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot; + guid() + &quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;, path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); this.bm.value.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value, 100, fos) console.log(&quot;success!&quot;) fos.flush(); fos.close(); &#125; &#125; &#125;); Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory$Options&#39;).implementation &#x3D; function (data, offset, length, opts) &#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); send(data) return result; &#125; &#125;)&#125;function main()&#123; hookImage()&#125;setImmediate(main) fulao2.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import fridaimport jsonimport timeimport uuidimport base64import re def my_message_handler(message, payload): print(message) print(payload) if message[&quot;type&quot;] &#x3D;&#x3D; &quot;send&quot;: #image &#x3D; re.findall(&quot;(-?\\d+)&quot;, message[&quot;payload&quot;]) image &#x3D; message[&quot;payload&quot;] print(image) # 保存image intArr &#x3D; [] # 位数的转换 for m in image: ival &#x3D; int(m) if ival &lt; 0: ival +&#x3D; 256 intArr.append(ival) bs &#x3D; bytes(intArr) fileName &#x3D; str(uuid.uuid1()) + &quot;.jpg&quot; f &#x3D; open(fileName, &#39;wb&#39;) f.write(bs) f.close()device &#x3D; frida.get_usb_device()target &#x3D; device.get_frontmost_application()session &#x3D; device.attach(target.pid)# 加载脚本with open(&quot;fulao2.js&quot;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot;, my_message_handler) # 调用错误处理script.load()# 脚本会持续运行等待输入input() 接下来尝试从抓到的包中解密协议，获取解密后的图片在hookRAW中实现脱机 fulao2.js 1234567891011121314151617function hookRAW()&#123; Java.perform(function()&#123; console.log(&quot;hooking RAW...&quot;) Java.use(&quot;com.ilulutv.fulao2.other.i.b&quot;).a.overload(&#39;java.nio.ByteBuffer&#39;).implementation &#x3D; function(bytebuffer)&#123; var result &#x3D; this.a(bytebuffer) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;result is &#x3D;&gt; &quot;,ByteString.of(result).hex()) send(result) return result &#125; &#125;) &#125;function main()&#123; hookRAW()&#125;setImmediate(main) fulao2.py中image = message[&quot;payload&quot;]需要解密，进入decodeImageKey实现 进入CipherCore 发现从so库中加载的加密协议 12memory list modules 找到libcipher-lib.somemory list exports libcipher-lib.so 搜索getString 分析拿到byte之后通过base64加密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import fridaimport jsonimport timeimport uuidimport base64import refrom Crypto.Cipher import AESimport base64def IMGdecrypt(bytearray): # hook String decodeImgKey &#x3D; CipherClient.decodeImgKey(); imgkey &#x3D; base64.decodebytes( bytes(&quot;svOEKGb5WD0ezmHE4FXCVQ&#x3D;&#x3D;&quot;, encoding&#x3D;&#39;utf8&#39;)) imgiv &#x3D; base64.decodebytes( bytes(&quot;4B7eYzHTevzHvgVZfWVNIg&#x3D;&#x3D;&quot;, encoding&#x3D;&#39;utf8&#39;)) cipher &#x3D; AES.new(imgkey, AES.MODE_CBC, imgiv) # enStr +&#x3D; (len(enStr) % 4)*&quot;&#x3D;&quot; # decryptByts &#x3D; base64.urlsafe_b64decode(enStr) msg &#x3D; cipher.decrypt(bytearray) def unpad(s): return s[0:-s[-1]] return unpad(msg)def my_message_handler(message, payload): print(message) print(payload) if message[&quot;type&quot;] &#x3D;&#x3D; &quot;send&quot;: #image &#x3D; re.findall(&quot;(-?\\d+)&quot;, message[&quot;payload&quot;]) image &#x3D; message[&quot;payload&quot;] print(image) intArr &#x3D; [] # 位数的转换 for m in image: ival &#x3D; int(m) if ival &lt; 0: ival +&#x3D; 256 intArr.append(ival) bs &#x3D; bytes(intArr) # 拿到数据后Base64解密 bs &#x3D; IMGdecrypt(bs) fileName &#x3D; str(uuid.uuid1()) + &quot;.jpg&quot; f &#x3D; open(fileName, &#39;wb&#39;) f.write(bs) f.close()device &#x3D; frida.get_usb_device()target &#x3D; device.get_frontmost_application()session &#x3D; device.attach(target.pid)# 加载脚本with open(&quot;fulao2.js&quot;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot;, my_message_handler) # 调用错误处理script.load()# 脚本会持续运行等待输入input() VIP破解 切换高清视频，提示vip限定功能，无法切换vip，尝试hook按钮点击事件，frida -UF -l hookEvent.js,点击切换清晰度 jadx搜索com.ilulutv.fulao2.film.l.t 12plugin wallbreaker objectsearch com.ilulutv.fulao2.film.l$tplugin wallbreaker objectdump --fullname 0x2a76 12plugin wallbreaker objectdump --fullname 0x28f2 查看在看视频实例android heap search instances com.ilulutv.fulao2.film.l 尝试将this.f11151d.q0改为true,完成VIP功能中的清晰度切换 12345678910111213141516function hookVIP()&#123; Java.perform(function()&#123; Java.choose(&quot;com.ilulutv.fulao2.film.l&quot;,&#123; onMatch:function(ins)&#123; console.log(&quot;found ins:&#x3D;&gt;&quot;,ins) ins.q0.value&#x3D;true; &#125;,onComplete:function()&#123; console.log(&quot;search complete&quot;) &#125; &#125;) &#125;)&#125;function main()&#123; hookVIP()&#125;setInterval(main,500) 抓取所有收发包 frida -U -f com.ilulutv.fulao2 -l hookSocket.js -o traffic.txt 所有通信都是加密了，不是在https层加密，而是在业务层，那就尝试hook所有的cipher objection -g com.ilulutv.fulao2 explore -c cipher.txt 123android hooking watch class com.cz.babySister.c.a android hooking watch class_method javax.crypto.Cipher.init --dump-args --dump-return --dump-backtraceandroid hooking list class_methods com.ilulutv.fulao2.other.i.b 将所有的方法复制到ciph.txt中，前面添加上android hooking watch class_method,后面添加--dump-args --dump-return --dump-backtrace objection -g com.ilulutv.fulao2 explore -c cipher.txt 关闭app重新hook，打印出所有的通信内容包括加解密所有内容 查看com.ilulutv.fulao2.other.i.b.a ，改包将其中的vip改为true，expire修改过期时间 当所有业务返回都被加解密了，可以尝试hook系统库，不可被混淆加密 第一题.apkjadx-gui 第一题.apk 123objection -g com.kanxue.pediy1 exploreandroid hooking search classes com.kanxue.pediy1android hooking watch classe com.kanxue.pediy1.VVVV frida -UF -l question.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var CONTEXT &#x3D; null;&#x2F;&#x2F; 获取类名function getObjClassName(obj) &#123; if (!jclazz) &#123; var jclazz &#x3D; Java.use(&quot;java.lang.Class&quot;); &#125; if (!jobj) &#123; var jobj &#x3D; Java.use(&quot;java.lang.Object&quot;); &#125; return jclazz.getName.call(jobj.getClass.call(obj));&#125;function hookReturn() &#123; Java.perform(function () &#123; Java.use(&quot;com.kanxue.pediy1.VVVVV&quot;).VVVV.implementation &#x3D; function (context, str) &#123; var result &#x3D; this.VVVV(context, str) console.log(&quot;context,str,result &#x3D;&gt; &quot;, context, str, result); console.log(&quot;context className is &#x3D;&gt; &quot;, getObjClassName(context)); CONTEXT &#x3D; context; return true; &#125; &#125;)&#125;function invoke() &#123; Java.perform(function () &#123; &#x2F;&#x2F;console.log(&quot;CONTEXT IS &#x3D;&gt; &quot;,CONTEXT) var MainActivity &#x3D; null; Java.choose(&quot;com.kanxue.pediy1.MainActivity&quot;, &#123; onMatch: function (instance) &#123; MainActivity &#x3D; instance; &#125;, onComplete: function () &#123; &#125; &#125;) var CONTEXT2 &#x3D; Java.use(&quot;com.kanxue.pediy1.MainActivity$1&quot;).$new(MainActivity); var javaString &#x3D; Java.use(&quot;java.lang.String&quot;).$new(&quot;12345&quot;); for (var x &#x3D; 0; x &lt; (99999 + 1); x++) &#123; &#x2F;&#x2F; 静态函数VVVV 使用use直接调用 var result &#x3D; Java.use(&quot;com.kanxue.pediy1.VVVVV&quot;).VVVV(CONTEXT2, String(x)); console.log(&quot;now x is &#x3D;&gt; &quot;, String(x)) if (result) &#123; console.log(&quot;found result is &#x3D;&gt; &quot;, String(x)) break; &#125; &#125; &#125;)&#125;function main() &#123; hookReturn() invoke()&#125;setImmediate(main) 主动调用的参数构造两种方案： 一种先hook 自己单独new 域中反射获取 12cd ~&#x2F;.pyenvtree -NCfhl | grep agent.js 加上构造函数hook,如com.kanxue.pediy1.MainActivity$1 第二题.apkjadx-gui 第二题.apk 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function invoke2() &#123; Java.perform(function () &#123; &#x2F;&#x2F; console.log(&quot;CONTEXT IS &#x3D;&gt; &quot;,CONTEXT) var MainActivity &#x3D; null; Java.choose(&quot;com.kanxue.pediy1.MainActivity&quot;,&#123; onMatch:function(instance)&#123; MainActivity &#x3D; instance; &#125;, onComplete:function()&#123;&#125; &#125;) &#x2F;&#x2F; var CONTEXT2 &#x3D; Java.use(&quot;com.kanxue.pediy1.MainActivity$1&quot;).$new(MainActivity); var loader1 &#x3D; null; var loader2 &#x3D; null; Java.enumerateClassLoaders(&#123; onMatch: function (loader) &#123; try &#123; if (loader.findClass(&quot;com.kanxue.pediy1.VVVVV&quot;)) &#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); &#x2F;&#x2F; 切换classLoader loader2 &#x3D; loader; Java.classFactory.loader &#x3D; loader2; &#125;else if(loader.findClass(&quot;com.kanxue.pediy1.MainActivity&quot;))&#123; console.log(&quot;Successfully found loader&quot;) console.log(loader); loader1 &#x3D; loader; &#125;else&#123; &#125; &#125; catch (error) &#123; console.log(&quot;find error:&quot; + error) &#125; &#125;, onComplete: function () &#123; console.log(&quot;end1&quot;) &#125; &#125;) var javaString &#x3D; Java.use(&quot;java.lang.String&quot;).$new(&quot;12345&quot;); for (var x &#x3D; 0; x &lt; (99999 + 1); x++) &#123; var result1 &#x3D; MainActivity.stringFromJNI(String(100000 - x)); var result2 &#x3D; Java.use(&quot;com.kanxue.pediy1.VVVVV&quot;).VVVV(String(result1)); console.log(&quot;now x is &#x3D;&gt; &quot;, String(x)) if (result2) &#123; console.log(&quot;found result2 is &#x3D;&gt; &quot;, String(100000 - x)) break; &#125; &#125; &#125;)&#125; frida -UF -l traceNativelibssl.js 拿到函数_ZTVNST3__19strstreamE ,修改if(exports[j].name.indexOf(&quot;ZTVNSt3&quot;)&gt;=0){,if(exports[j].name.indexOf(&quot;ZTVNSt3&quot;)&gt;=0){, 举杯邀Frida，对影成三题 123456789101112131415161718192021222324&#x2F;&#x2F; hook native函数，使其不要执行，Interceptor.replacefunction hookSTRSTR() &#123; var kill_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;); Interceptor.attach(strstr, &#123; onEnter: function (args) &#123; console.log(&quot;Entering &#x3D;&gt;&quot;) console.log(&quot;args[0] &#x3D;&gt; &quot;, args[0].readCString()) console.log(&quot;args[1] &#x3D;&gt; &quot;, args[1].readCString()) &#125;, onLeave: function (retval) &#123; &#125; &#125;)&#125;function replaceKill()&#123; var kill_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;kill&quot;); &#x2F;&#x2F; var kill &#x3D; new NativeFunction(kill_addr,&quot;int&quot;,[&#39;int&#39;,&#39;int&#39;]); Interceptor.replace(kill_addr,new NativeCallback(function(arg0,arg1)&#123; console.log(&quot;arg0&#x3D;&gt; &quot;,arg0) console.log(&quot;arg1&#x3D;&gt; &quot;,arg1) &#125;,&quot;int&quot;,[&#39;int&#39;,&#39;int&#39;]))&#125; var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"wallbreaker","slug":"wallbreaker","permalink":"http://onejane.github.io/tags/wallbreaker/"}]},{"title":"爬虫基础篇之Scrapy抓取京东","slug":"爬虫基础篇之Scrapy抓取京东","date":"2021-04-09T05:54:41.000Z","updated":"2021-12-12T03:09:39.331Z","comments":true,"path":"2021/04/09/爬虫基础篇之Scrapy抓取京东/","link":"","permalink":"http://onejane.github.io/2021/04/09/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BScrapy%E6%8A%93%E5%8F%96%E4%BA%AC%E4%B8%9C/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 虚拟环境同一台服务器上不同的项目可能依赖的包不同版本，新版本默认覆盖旧版本，可能导致其他项目无法运行，通过虚拟环境，完全隔离各个项目各个版本的依赖包，实现运行环境互不影响。 virtualenv1234567891011121314pip install virtualenv 安装virtualenvpython -m pip install --upgrade pip 升级pippip install -i https:&#x2F;&#x2F;pypi.doubanio.com&#x2F;simple&#x2F; --trusted-host pypi.doubanio.com scrapypip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple 使用清华源pip uninstall scrapy 卸载django virtualenv scrapytest 默认环境创建虚拟环境cd scrapytest&#x2F;Scripts &amp;&amp; activate.bat &amp;&amp; python 进入3.7虚拟环境virtualenv -p D:\\Python27\\python.exe scrapytestcd scrapytest&#x2F;Scripts &amp;&amp; activate.bat &amp;&amp; python 进入2.7虚拟环境deactivate.bat 退出虚拟环境apt-get install python-virtualenv 安装虚拟环境virtualenv py2 &amp;&amp; cd py2 &amp;&amp; cd bin &amp;&amp; source activate &amp;&amp; python 进入2.7虚拟环境virtualenv -p &#x2F;usr&#x2F;bin&#x2F;python3 py3 &amp;&amp; &amp;&amp; cd py3 &amp;&amp; cd bin &amp;&amp; source activate &amp;&amp; python 进入3.7虚拟环境 virtualenvwrapper123456789101112131415161718192021222324252627pip install virtualenvwrapperpip install virtualenvwrapper-win 解决workon不是内部指令workon 列出所有虚拟环境新建环境变量 WORKON_HOME&#x3D;E:\\envsmkvirtualenv py3scrapy 新建并进入虚拟环境deactivate 退出虚拟环境workon py3scrapy 进入指定虚拟环境 pip install -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple scrapy 安装scrapy源 若缺少lxml出错https:&#x2F;&#x2F;www.lfd.uci.edu&#x2F;~gohlke&#x2F;pythonlibs&#x2F;寻找对应版本的lxml的whl源 python -m pip install --upgrade pip 更新pip pip install lxml-4.1.1-cp35-cp35m-win_amd64.whl 若缺少Twisted出错http:&#x2F;&#x2F;www.lfd.uci.edu&#x2F;~gohlke&#x2F;pythonlibs&#x2F;#lxml搜对应版本Twisted pip install Twisted‑17.9.0‑cp35‑cp35m‑win_amd64.whlmkvirtualenv --python&#x3D;D:\\Python27\\python.exe py2scrapy 一般不会出问题 pip install -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple scrapy pip install virtualenvwrapper find &#x2F; -name virualenvwrapper.sh vim ~&#x2F;.bashrc export WORKON_HOME&#x3D;$HOME&#x2F;.virtualenvs source &#x2F;home&#x2F;wj&#x2F;.local&#x2F;bin&#x2F;virtualenvwrapper.sh source ~&#x2F;.bashrc mkvirtualenv py2scrapy 指向生成~&#x2F;.virtualenvdeactivate 退出虚拟环境mkdirtualenv --python&#x3D;&#x2F;usr&#x2F;bin&#x2F;python3 py3scrapyrmvirtualenv py3scrapy 删除虚拟环境 Scrapy 12345678910pip install -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F; scrapy 安装scrapyscrapy startproject mall_spider 创建mall_spider项目scrapy genspider jd_category https:&#x2F;&#x2F;dc.3.cn&#x2F;category&#x2F;get 创建分类爬虫scrapy genspider --list 查看爬虫生成模板scrapy genspider -t crawl lagou www.lagou.com 创建全站爬虫pip freeze &gt; requirements.txt 生成依赖到文件pip install -r requirements.txt 一键安装依赖scrapy shell http:&#x2F;&#x2F;blog.jobbole.com&#x2F; 可以在脚本中调试xpath或者chrome浏览器右键copy xpath,chrome浏览器右键copy selectorscrapy shell -s USER_AGENT&#x3D;&quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64; rv:51.0) Gecko&#x2F;20100101 Firefox&#x2F;51.0&quot; https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;56320032view(response) 需求1.1 抓取首页的分类信息 抓取数据: 各级分类的名称 和 URL 1.2 抓取商品信息 抓取: 商品名称, 商品价格, 商品评论数量, 商品店铺, 商品促销, 商品选项, 商品图片的URL 由于全网爬虫, 抓取页面非常多, 为了提高抓的速度, 选择使用scrapy框架 + scrapy_redis分布式组件 由于京东全网的数据量达到了亿级, 存储又是结构化数据, 数据库, 选择使用MongoDB; 实现我们采用广度优先策略, 我们把类别和商品信息的抓取分开来做. 模型类别模型1234567891011121314class Category(scrapy.Item): &quot;&quot;&quot;商品类别&quot;&quot;&quot; # 大分类名称 b_category_name &#x3D; scrapy.Field() # 大分类URL b_category_url &#x3D; scrapy.Field() # 中分类名称 m_category_name &#x3D; scrapy.Field() # 中分类URL m_category_url &#x3D; scrapy.Field() # 小分类名称 s_category_name &#x3D; scrapy.Field() # 小分类URL s_category_url &#x3D; scrapy.Field() 数据模型123456789101112131415161718192021class Product(scrapy.Item): # 商品类别 product_category &#x3D; scrapy.Field() # 商品ID product_sku_id &#x3D; scrapy.Field() # 商品名称 product_name &#x3D; scrapy.Field() # 商品图片URL product_img_url &#x3D; scrapy.Field() # 商品店铺 product_shop &#x3D; scrapy.Field() # 图书信息, 作者,出版社 product_book_info &#x3D; scrapy.Field() # 商品选项 product_option &#x3D; scrapy.Field() # 商品评论数量 product_comments &#x3D; scrapy.Field() # 商品促销 product_ad &#x3D; scrapy.Field() # 商品价格 product_price &#x3D; scrapy.Field() 分类爬虫分析, 分类信息的URL 目标: 确定分类信息的URL 步骤: 进入到京东首页 右键检查, 打开开发者工具, 搜索 家用电器 确定分类的URL 图解: 结论: 分类URL: https://dc.3.cn/category/get 创建爬虫, 抓取数据 目标: 抓取分类数据, 交给引擎 步骤: 创建类别爬虫 \b指定起始URL 解析数据, 交给引擎 创建爬虫 进入项目目录: cd mall_spider 创建爬虫: scrapy genspider category_spider jd.com 指定起始URL 修改起始URL: https://dc.3.cn/category/get 解析数据, 交给引擎 分析数据格式: 整体数据 各级分类位置 分类信息格式 格式1: jiadian.jd.com|家用电器||0 特点: 第一项分类URL,第二项分类名称 格式2: 652-654|摄影摄像||0 对应的URL: https://channel.jd.com/652-654.html 特点:第一项是频道ID, 包含一个 - 格式3: 1318-2628-12131|户外风衣||0 对应URL: https://list.jd.com/list.html?cat=1318,2628,12131 特点: 第一项为分类ID, 包含两个 - 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class JdCategorySpider(scrapy.Spider): name &#x3D; &#39;jd_category&#39; allowed_domains &#x3D; [&#39;3.cn&#39;] start_urls &#x3D; [&#39;https:&#x2F;&#x2F;dc.3.cn&#x2F;category&#x2F;get&#39;] def parse(self, response): # print(response.body.decode(&#39;GBK&#39;)) result &#x3D; json.loads(response.body.decode(&#39;GBK&#39;)) datas &#x3D; result[&#39;data&#39;] # 遍历数据列表 for data in datas: item &#x3D; Category() b_category &#x3D; data[&#39;s&#39;][0] b_category_info &#x3D; b_category[&#39;n&#39;] # print(&#39;大分类: &#123;&#125;&#39;.format(b_category_info)) item[&#39;b_category_name&#39;], item[&#39;b_category_url&#39;] &#x3D; self.get_category_name_url(b_category_info) # 中分类信息列表 m_category_s &#x3D; b_category[&#39;s&#39;] # 遍历中分类列表 for m_category in m_category_s: # 中分类信息 m_category_info &#x3D; m_category[&#39;n&#39;] # print(&#39;中分类: &#123;&#125;&#39;.format(m_category_info)) item[&#39;m_category_name&#39;], item[&#39;m_category_url&#39;] &#x3D; self.get_category_name_url(m_category_info) # 小分类数据列表 s_category_s &#x3D; m_category[&#39;s&#39;] for s_category in s_category_s: s_category_info &#x3D; s_category[&#39;n&#39;] # print(&#39;小分类: &#123;&#125;&#39;.format(s_category_info)) item[&#39;s_category_name&#39;], item[&#39;s_category_url&#39;] &#x3D; self.get_category_name_url(s_category_info) # print(item) # 把数据交给引擎 yield item def get_category_name_url(self, category_info): &quot;&quot;&quot; 根据分类信息, 提取名称和URL :param category_info: 分类信息 :return: 分类的名称和URL 分析数据格式(三类数据格式) - book.jd.com&#x2F;library&#x2F;science.html|科学技术||0 - 1713-3287|计算机与互联网||0 - Https:&#x2F;&#x2F;channel.jd.com&#x2F;&#123;&#125;.html - 9987-12854-12856|屏幕换新||0 - Https:&#x2F;&#x2F;list.jd.com&#x2F;list.html?cat&#x3D;&#123;&#125; - 把 - 替换为逗号, 然后填充到占位的地方. &quot;&quot;&quot; category &#x3D; category_info.split(&#39;|&#39;) # 分类URL category_url &#x3D; category[0] # 分类名称 category_name &#x3D; category[1] # 处理第一类分类URL if category_url.count(&#39;jd.com&#39;) &#x3D;&#x3D; 1: # URL进行补全 category_url &#x3D; &#39;https:&#x2F;&#x2F;&#39; + category_url elif category_url.count(&#39;-&#39;) &#x3D;&#x3D; 1: # 1713-3287|计算机与互联网||0 category_url &#x3D; &#39;https:&#x2F;&#x2F;channel.jd.com&#x2F;&#123;&#125;.html&#39;.format(category_url) else: # 9987-12854-12856|屏幕换新||0 # 把URL中 &#96;-&#96; 替换为 &#96;,&#96; category_url &#x3D; category_url.replace(&#39;-&#39;, &#39;,&#39;) # 补全URL category_url &#x3D; &#39;https:&#x2F;&#x2F;list.jd.com&#x2F;list.html?cat&#x3D;&#123;&#125;&#39;.format(category_url) # 返回类别的名称 和 URL return category_name, category_url 保存分类数据12345# 在settings.py开启, 类别的PipelineROBOTSTXT_OBEY &#x3D; False 不遵守网络协议ITEM_PIPELINES &#x3D; &#123; &#39;mall_spider.pipelines.CategoryPipeline&#39;: 300,&#125; 步骤: open_spider方法中, 链接\bMongoDB数据库, 获取要操作的集合 process_item 方法中, 向MongoDB中插入类别\b数据 close_spider 方法中, 关闭MongoDB的链接 123456789101112131415161718192021222324252627&quot;&quot;&quot;实现保存分类的Pipeline类- open_spider方法中, 链接MongoDB数据库, 获取要操作的集合- process_item 方法中, 向MongoDB中插入类别数据- close_spider 方法中, 关闭MongoDB的链接&quot;&quot;&quot;class CategoryPipeline(object): def open_spider(self, spider): &quot;&quot;&quot;当爬虫启动的时候执行1次&quot;&quot;&quot; if isinstance(spider, JdCategorySpider): # open_spider方法中, 链接MongoDB数据库, 获取要操作的集合 self.client &#x3D; MongoClient(MONGODB_URL) self.collection &#x3D; self.client[&#39;jd&#39;][&#39;category&#39;] def process_item(self, item, spider): # process_item 方法中, 向MongoDB中插入类别数据 if isinstance(spider, JdCategorySpider): self.collection.insert_one(dict(item)) return item def close_spider(self, spider): # close_spider 方法中, 关闭MongoDB的链接 if isinstance(spider, JdCategorySpider): self.client.close() 商品爬虫总体设计: 把MongoDB中存储的分类信息, 放到redis_key指定列表中 支持分布式爬虫, 当然也可以在一台电脑上运行多次, 以启动多个进程,充分使用CPU的多核. 所以这里的爬虫, 先从一个分类开始抓就可以了, 后面再改造为分布式 分析 列表页 提取商品 skuid 实现翻页 获取下一页URL \b没有下一页的情况 详情页由于PC和手机页面商品信息, 在js中, 且比较分散, 并且每次请求数量页比较大, 我们这里使用手机抓包, 抓到json数据. 商品基本信息 图: URL: https://cdnware.m.jd.com/c1/skuDetail/apple/7.3.0/32426231880.json; 最后一部分是商品skuid 可以获取到的信息: 商品名称, 商品店铺信息 , 商品类别id, \b商品品牌id, 商品选项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 &#123;\"code\": \"0\",\"wareInfo\": &#123; \"recommendInfo\": &#123; \"recommendList\": null &#125;, // 商品店铺信息 \"shopInfo\": &#123; \"shop\": &#123; \"shopId\": 1000000127, \"name\": \"京东Apple产品专营店\", ... &#125;, \"basicInfo\": &#123; \"gift\": false, \"bookInfo\": &#123; // 如果是书, 这里是书的选项信息 \"display\": false &#125;, \"colorSizeInfo\": &#123; // 商品选项信息列表 有的没有 \"colorSize\": [&#123; \"buttons\": [&#123; \"no\": \"1\", \"skuList\": [\"100000177738\", \"100000287117\", \"100000287145\", \"100000309448\", \"100000309450\", \"100000375233\", \"100000435832\", \"100000458753\", \"100000458755\", \"100001860767\", \"100001860773\"], \"text\": \"金色\" &#125;, &#123; \"no\": \"2\", \"skuList\": [\"100000177764\", \"100000287113\", \"100000287135\", \"100000435780\", \"100000435816\", \"100000435818\", \"100000569049\", \"100000602206\", \"100000602208\", \"100001860765\", \"100002539302\"], \"text\": \"深空灰色\" &#125;, &#123; \"no\": \"3\", \"skuList\": [\"100000177740\", \"100000177784\", \"100000287147\", \"100000435834\", \"100000458737\", \"100000458739\", \"100000602174\", \"100000602176\", \"100000602204\", \"100001860789\", \"100002539304\"], \"text\": \"银色\" &#125;], \"title\": \"颜色\" &#125;, &#123; \"buttons\": [&#123; \"no\": \"1\", \"skuList\": [\"100000177738\", \"100000177740\", \"100000177764\", \"100000177784\", \"100000287113\", \"100000287117\", \"100000287135\", \"100000287145\", \"100000287147\"], \"text\": \"公开版\" &#125;, ... ], \"title\": \"版本\" &#125;, &#123; \"buttons\": [&#123; \"no\": \"1\", \"skuList\": [\"100000177764\", \"100000287145\", \"100000287147\", \"100000375233\", \"100000435818\", \"100000458739\", \"100000458755\", \"100000602204\", \"100000602208\", \"100001860765\", \"100001860773\", \"100001860789\"], \"text\": \"64GB\" &#125;, ... ], \"title\": \"内存\" &#125;], \"colorSizeTips\": \"#与其他已选项无法组成可售商品，请重选\" &#125;, ... // 品牌ID \"brandID\": \"14026\", ... // 商品图片 \"wareImage\": [&#123; \"small\": \"https://m.360buyimg.com/mobilecms/s720x720_jfs/t1/3/15/4536/138660/5b997bf8Ed72ebce7/819dcf182d743897.jpg!q70.jpg.webp\", ... &#125; ... ], ... // 商品名称 \"name\": \"Apple iPhone XS Max (A2104) 256GB 深空灰色 移动联通电信4G手机 双卡双待\", // 商品类别id \"category\": \"9987;653;655\" &#125; &#125; &#125; 商品促销信息(PC端): 图: URL: https://cd.jd.com/promotion/v2?skuId=4749506&amp;area=1_72_4137_0&amp;cat=737%2C794%2C798 参数 skuId=4749506: 商品sku_id area=1_72_4137_0: 购买者区域, 固定的 cat=737%2C794%2C798: 类别 数据 123456789&#123; ... // 商品促销信息 \"ads\": [&#123; \"id\": \"AD_4749506\", \"ad\": \"【即刻预约，21号秒杀到手价2999】\\n1、前100名晒单送腾讯企鹅影院季卡，联系客服领取！！\\n2、曲面爆款，5.5万好评推荐！&lt;a target=\\\"_blank\\\" href=\\\"https://item.jd.com/7055876.html\\\"&gt;升级55Q1D超清全面屏电视&lt;/a&gt;\" &#125;], ... &#125; 商品评论信息(PC端) 图: URL: https://club.jd.com/comment/productCommentSummaries.action?referenceIds=4749506 参数 referenceIds=4749506: 商品sku_id 数据: 12345678910&#123;\"CommentsCount\":[ &#123; \"CommentCountStr\":\"10万+\", \"CommentCount\":100000, //评论数量 \"AverageScore\":5, \"GoodRate\":0.98, //好评率 \"PoorCountStr\":\"600+\", \"PoorCount\":600, // 差评数量 ... &#125;]&#125; 商品价格信息: 图: URL: https://p.3.cn/prices/mgets?skuIds=J_4749506 参数: skuIds=J_4749506 商品的sku_id 数据: 12345678[ &#123; \"op\": \"5499.00\", \"m\": \"5999.00\", \"id\": \"J_4749506\", //商品skuid \"p\": \"3299.00\" // 商品价格 &#125; ] 代码实现 步骤: 重写start_requests方法, 根据分类信息构建列表页的请求 解析列表页, 提取商品的skuid, 构建商品基本的信息请求; 实现翻页 解析商品基本信息, 构建商品促销信息的请求 解析促销信息,构建商品评价信息的请求, 解析商品评价信息, 构建价格信息的请求 解析价格信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121class JdProductSpider(scrapy.Spider): name &#x3D; &#39;jd_product&#39; allowed_domains &#x3D; [&#39;jd.com&#39;, &#39;p.3.cn&#39;] def start_requests(self): category &#x3D; &#123; &quot;b_category_name&quot; : &quot;家用电器&quot;, &quot;b_category_url&quot; : &quot;https:&#x2F;&#x2F;jiadian.jd.com&quot;, &quot;m_category_name&quot; : &quot;洗衣机&quot;, &quot;m_category_url&quot; : &quot;https:&#x2F;&#x2F;list.jd.com&#x2F;list.html?cat&#x3D;737,794,880&quot;, &quot;s_category_name&quot; : &quot;洗衣机配件&quot;, &quot;s_category_url&quot; : &quot;https:&#x2F;&#x2F;list.jd.com&#x2F;list.html?cat&#x3D;737,794,877&quot; &#125; yield scrapy.Request(category[&#39;s_category_url&#39;], self.parse, meta&#x3D;&#123;&#39;category&#39;: category&#125;) def parse(self, response): # 获取类别信息 category &#x3D; response.meta[&#39;category&#39;] # 获取类别的URL category_url &#x3D; response.url.split(&#39;&amp;&#39;)[0] # 获取所有商品的sku_ids sku_ids &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[contains(@class, &quot;j-sku-item&quot;)]&#x2F;@data-sku&#39;).extract() # 遍历sku_ids, 构建基本详情信息的请求 for sku_id in sku_ids: item &#x3D; &#123; &#39;product_category&#39;: category, &#39;product_sku_id&#39;:sku_id &#125; product_url &#x3D; &#39;https:&#x2F;&#x2F;cdnware.m.jd.com&#x2F;c1&#x2F;skuDetail&#x2F;apple&#x2F;7.3.0&#x2F;&#123;&#125;.json&#39;.format(sku_id) yield scrapy.Request(product_url, callback&#x3D;self.parse_product, meta&#x3D;&#123;&#39;item&#39;: item&#125;) # 获取下一页的URL next_url &#x3D; response.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;&quot;pn-next&quot;]&#x2F;@href&#39;).extract_first() if next_url: # 补全URL next_url &#x3D; response.urljoin(next_url) # 构建下一页请求 yield scrapy.Request(next_url, callback&#x3D;self.parse, meta&#x3D;&#123;&#39;category&#39;: category&#125;) def parse_product(self, response): # 取出传递过来的数据 item &#x3D; response.meta[&#39;item&#39;] # 把响应数据数据转为字典 product_dic &#x3D; json.loads(response.text) # 获取商品名称 item[&#39;product_name&#39;] &#x3D; product_dic[&#39;wareInfo&#39;][&#39;basicInfo&#39;][&#39;name&#39;] if item[&#39;product_name&#39;]: # 获取类别id, 把 &#96;;&#96; 替换为 , item[&#39;product_category_id&#39;] &#x3D; product_dic[&#39;wareInfo&#39;][&#39;basicInfo&#39;][&#39;category&#39;].replace(&#39;;&#39;, &#39;,&#39;) # 获取店铺信息 product_shop &#x3D; jsonpath(product_dic, &#39;$..shop&#39;) if product_shop: product_shop &#x3D; product_shop[0] if product_shop is None: item[&#39;product_shop&#39;] &#x3D; &#123;&#39;name&#39;:&#39;京东自营&#39;&#125; else: item[&#39;product_shop&#39;] &#x3D; &#123; &quot;shopId&quot;: product_shop[&#39;shopId&#39;], &quot;name&quot;: product_shop[&#39;name&#39;], &quot;score&quot;: product_shop[&#39;score&#39;], &quot;url&quot;: product_shop[&#39;url&#39;], &#125; # 如果是书, 记录书的信息 if product_dic[&#39;wareInfo&#39;][&#39;basicInfo&#39;][&#39;bookInfo&#39;][&#39;display&#39;]: item[&#39;product_book_info&#39;] &#x3D; product_dic[&#39;wareInfo&#39;][&#39;basicInfo&#39;][&#39;bookInfo&#39;] # 删除display del item[&#39;book_info&#39;][&#39;display&#39;] # 获取商品选购信息 color_sizes &#x3D; jsonpath(product_dic, &#39;$..colorSize&#39;) product_option &#x3D; &#123;&#125; if color_sizes: for color_size in color_sizes[0]: title &#x3D; color_size[&#39;title&#39;] texts &#x3D; jsonpath(color_size, &#39;$..text&#39;) product_option.update(&#123;title:texts&#125;) # print(product_option) item[&#39;product_option&#39;] &#x3D; product_option # 商品图片 item[&#39;product_img_url&#39;] &#x3D; jsonpath(product_dic, &#39;$..wareImage[0].small&#39;)[0] # 构建促销信息的请求 ad_url &#x3D; &#39;https:&#x2F;&#x2F;cd.jd.com&#x2F;promotion&#x2F;v2?skuId&#x3D;&#123;&#125;&amp;area&#x3D;1_72_4137_0&amp;cat&#x3D;&#123;&#125;&#39;.format(item[&#39;product_sku_id&#39;], item[&#39;product_category_id&#39;]) yield scrapy.Request(ad_url, callback&#x3D;self.parse_ad, meta&#x3D;&#123;&#39;item&#39;: item&#125;) def parse_ad(self, response): &quot;&quot;&quot;获取商品促销&quot;&quot;&quot; item &#x3D; response.meta[&#39;item&#39;] ad_dic &#x3D; json.loads(response.body.decode(&#39;GB18030&#39;)) ad &#x3D; ad_dic[&#39;ads&#39;][0][&#39;ad&#39;] item[&#39;product_ad&#39;] &#x3D; ad # for key, value in item.items(): # print(&#39;&#123;&#125; &#x3D; &#123;&#125;&#39;.format(key, value)) # 构建平均信息请求 comments_url &#x3D; &#39;https:&#x2F;&#x2F;club.jd.com&#x2F;comment&#x2F;productCommentSummaries.action?referenceIds&#x3D;&#123;&#125;&#39;.format(item[&#39;product_sku_id&#39;]) yield scrapy.Request(comments_url, callback&#x3D;self.parse_comments, meta&#x3D;&#123;&#39;item&#39;: item&#125;) def parse_comments(self, response): &quot;&quot;&quot;解析商品评论信息&quot;&quot;&quot; item &#x3D; response.meta[&#39;item&#39;] comments_dic &#x3D; json.loads(response.text) comments &#x3D; &#123; &#39;comment_count&#39;: jsonpath(comments_dic, &#39;$..CommentCount&#39;)[0], &#39;good_rate&#39;: jsonpath(comments_dic, &#39;$..GoodRate&#39;)[0], &#39;poor_count&#39;: jsonpath(comments_dic, &#39;$..PoorCount&#39;)[0], &#125; item[&#39;product_comments&#39;] &#x3D; comments # print(item) # 构建价格请求 price_url &#x3D; &#39;https:&#x2F;&#x2F;p.3.cn&#x2F;prices&#x2F;mgets?skuIds&#x3D;J_&#123;&#125;&#39;.format(item[&#39;product_sku_id&#39;]) yield scrapy.Request(price_url, callback&#x3D;self.parse_price, meta&#x3D;&#123;&#39;item&#39;: item&#125;) def parse_price(self, response): &quot;&quot;&quot;解析价格&quot;&quot;&quot; item &#x3D; response.meta[&#39;item&#39;] item[&#39;product_price&#39;] &#x3D; json.loads(response.text)[0][&#39;p&#39;] # print(item) yield item 分布式 步骤: 修改爬虫类 在settings文件中配置scrapy_redis 写一个程序用于把MongoDB中分类信息, 放入到爬虫redis_key指定的列表中 修改爬虫类 步骤: 修改继承关系: 继承RedisSpider 指定redis_key 把重写start_requests 改为 重写 make_request_from_data 123456789101112131415from scrapy_redis.spiders import RedisSpiderimport pickle# 1. 修改继承关系: 继承RedisSpiderclass JdProductSpider(RedisSpider): name &#x3D; &#39;jd_product&#39; allowed_domains &#x3D; [&#39;jd.com&#39;, &#39;p.3.cn&#39;] # 2. 指定redis_key redis_key &#x3D; &#39;jd_product:start_category&#39; # 3. 把重写start_requests 改为 重写 make_request_from_data def make_request_from_data(self, data): # 把从Redis中读取到分类信息, 转换为字典 category &#x3D; pickle.loads(data) return scrapy.Request(category[&#39;s_category_url&#39;], self.parse, meta&#x3D;&#123;&#39;category&#39;: category&#125;) 注意: 在make_request_from_data不能使用 yield 必须使用 return 在settings文件中配置scrapy_redis 1234567891011121314# MongoDB数据库的URLMONGO_URL &#x3D; &#39;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#39;# REDIS数据链接REDIS_URL &#x3D; &#39; redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;0&#39;# 去重容器类: 用于把已爬指纹存储到基于Redis的set集合中DUPEFILTER_CLASS &#x3D; &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;# 调度器: 用于把待爬请求存储到基于Redis的队列SCHEDULER &#x3D; &quot;scrapy_redis.scheduler.Scheduler&quot;# 是不进行调度持久化:# 如果是True, 当程序结束的时候, 会保留Redis中已爬指纹和待爬的请求# 如果是False, 当程序结束的时候, 会清空Redis中已爬指纹和待爬的请求SCHEDULER_PERSIST &#x3D; True 把MongoDB中分类信息, 放入到爬虫redis_key指定的列表中 步骤: 在项目文件夹下创建 add_category_to_redis.py 实现方法 add_category_to_redis: 链接MongoDB 链接Redis 读取MongoDB中分类信息, 序列化后, 添加到商品爬虫redis_key指定的list 关闭MongoDB 在if __name__ == &#39;__main__&#39;:中调用add_category_to_redis方法 代码 123456789101112131415161718192021222324from redis import StrictRedisfrom pymongo import MongoClientimport picklefrom mall_spider.settings import MONGO_URL, REDIS_URLfrom mall_spider.spiders.jd_product import JdProductSpider# 把MongoDB中分类信息, 添加到Redis中def add_category_to_redis(): # 链接MongoDB client = MongoClient(MONGO_URL) # 链接Redis redis = StrictRedis.from_url(REDIS_URL) cursor = client['jd']['category'].find() # 读取MongoDB中分类信息, 序列化后, 添加到商品爬虫redis_key指定的list for category in cursor: redis.rpush(JdProductSpider.redis_key, pickle.dumps(category)) # 关闭MongoDB的链接 client.close()if __name__ == '__main__': add_category_to_redis() 保存商品数据步骤 在 open_spider方法, 建立MongoDB数据库连接, 获取要操作的集合 在 process_item方法, 把数据插入到MongoDB中 在close_spider方法, 关闭数据库连接 代码 1234567891011121314151617181920class ProductPipeline(object): def open_spider(self, spider): if isinstance(spider, JdProductSpider): # 建立MongoDB数据库链接 self.client = MongoClient(MONGO_URL) # 获取要操作集合 self.category = self.client['jd']['product'] def process_item(self, item, spider): if isinstance(spider, JdProductSpider): # 把数据插入到mongo中 self.category.insert_one(dict(item)) return item def close_spider(self, spider): \"\"\"关闭\"\"\" if isinstance(spider, JdProductSpider): self.client.close() 在settings.py中开启这个管道 12345ITEM_PIPELINES = &#123; 'mall_spider.pipelines.CategoryPipeline': 300, # 开启商品管道 'mall_spider.pipelines.ProductPipeline': 301,&#125; 反爬为了避免IP反爬, 我们实现随机User-Agent和代理IP的中间件 步骤: 实现随机User-Agent的中间件 实现代理IP中间件 在settings.py 文件开启, 下载器中间件 实现随机User-Agent的中间件 步骤 准备User-Agent列表 在middlewares.py中, 实现RandomUserAgent类 实现process_request方法 如果是请求是 https://cdnware.m.jd.com 开头的, 就是设置一个iPhone的user-agent 否则从User-Agent列表中随机取出一个 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import requestsimport random# 准备请求头USER_AGENTS = [ \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\", \"Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\", \"Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\", \"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\", \"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\", \"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\", \"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\", \"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\", \"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 LBBROWSER\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)\", \"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1\", \"Mozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko/20110307 Firefox/4.0b13pre\", \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko/20100101 Firefox/16.0\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11\", \"Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10\"]class RandomUserAgent(object): def process_request(self, request, spider): if request.url.startswith('https://cdnware.m.jd.com'): # 如果使用手机抓包, 获取到商品信息; 生成请求请求头 request.headers['user-agent'] = 'JD4iPhone/164880 (iPhone; iOS 12.1.2; Scale/2.00)' else: # 随机获取一个请求头, 进行设置 request.headers['user-agent'] = random.choice(USER_AGENTS) 实现代理IP中间件 步骤: 在middlewares.py中, 实现ProxyMiddleware类 实现process_request方法 \b从代理池中获取一个随机的代理IP, 需指定代理IP的协议, 和访问的域名 设置给request.meta[‘proxy’] \b实现process_exception方法 当请求出现异常的时候, 代理池哪些代理IP在本域名下是不可以用的 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849\"\"\"9.2. 实现代理IP中间件步骤: 在middlewares.py中, 实现ProxyMiddleware类 实现process_request方法 \b从代理池中获取一个随机的代理IP 设置给request.meta['proxy']\"\"\"from twisted.internet import deferfrom twisted.internet.error import TimeoutError, DNSLookupError, \\ ConnectionRefusedError, ConnectionDone, ConnectError, \\ ConnectionLost, TCPTimedOutErrorfrom twisted.web.client import ResponseFailedfrom scrapy.core.downloader.handlers.http11 import TunnelErrorclass ProxyMiddleware(object): EXCEPTIONS_TO_RETRY = (defer.TimeoutError, TimeoutError, DNSLookupError, ConnectionRefusedError, ConnectionDone, ConnectError, ConnectionLost, TCPTimedOutError, ResponseFailed, IOError, TunnelError) def process_request(self, request, spider): \"\"\" 从代理池中获取一个随机的代理IP 设置给request.meta['proxy'] \"\"\" response = requests.get('http://localhost:6868/random?protocol=https&amp;domain=jd.com') request.meta['proxy'] = response.content.decode() request.meta['dont_redirect'] = True return None def process_exception(self, request, exception, spider): if isinstance(exception, self.EXCEPTIONS_TO_RETRY): # 获取代理IP proxy = request.meta['proxy'] # 提取IP地址 ip = re.findall('https://(.+):\\d+', proxy)[0] params = &#123; 'ip': ip, 'domain': 'jd.com' &#125; requests.get('http://localhost:6868/disable_domain', params=params) # 构建请求返回 req = request.copy() req.dont_filter = True return req 在settings.py中开启上面的两个下载器中间件 12345# 配置下载器中间件DOWNLOADER_MIDDLEWARES = &#123;'mall_spider.middlewares.RandomUserAgent': 500,'mall_spider.middlewares.ProxyMiddl eware': 543,&#125; 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"http://onejane.github.io/tags/scrapy/"},{"name":"scrapy_redis","slug":"scrapy-redis","permalink":"http://onejane.github.io/tags/scrapy-redis/"},{"name":"mongo","slug":"mongo","permalink":"http://onejane.github.io/tags/mongo/"}]},{"title":"爬虫基础篇之斗鱼弹幕","slug":"爬虫基础篇之斗鱼弹幕","date":"2021-04-08T11:55:37.000Z","updated":"2021-12-12T03:09:39.334Z","comments":true,"path":"2021/04/08/爬虫基础篇之斗鱼弹幕/","link":"","permalink":"http://onejane.github.io/2021/04/08/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E6%96%97%E9%B1%BC%E5%BC%B9%E5%B9%95/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 Socket asyncore 模块为异步socket的服务器客户端通信提供简单的接口。该模块提供了异步socket服务客户端和服务器的基础架构。 相比python原生的socket api，asyncore具备有很大的优势，asyncore对原生的socket进行封装，提供非常简洁优秀的接口，利用asyncore覆写相关需要处理的接口方法，就可以完成一个socket的网络编程，从而不需要处理复杂的socket网络状况以及多线程处理等等。 demo服务端1netcat-win32-1.12&gt;nc -l -p 9000 启动服务端 客户端telnet 127.0.0.1 9000 客户端连接到服务器 发送信息 定义类继承自asyncore.dispatcher 1class SocketClient(asyncore.dispatcher): 实现类中的回调代码 实现构造函数 调用父类方法 1asyncore.dispatcher.__init__(self) 创建 Socket 对象 1self.create_socket() 连接服务器 12address = (host,port)self.connect(address) 实现 handle_connect 回调函数 当 Socket 连接服务器成功时回调该函数 12def handle_connect(self): print(\"连接成功\") 实现 writable 回调函数 描述是否有数据需要被发送到服务器。返回值为 True 表示可写，False 表示不可写，如果不实现默认返回为 True，当返回 True 时，回调函数 handle_write 将被触发 12def writable(self): return True 实现 handle_write 回调函数 当有数据需要发送时（writable 回调函数返回True时），该函数被触发，通常情况下在该函数中编写 send 方法发送数据 1234def handle_write(self): # 内部实现对服务器发送数据的代码 # 调用 send 方法发送数据，参数是字节数据 self.send('hello world\\n'.encode('utf-8')) 实现 readable 回调函数 描述是否有数据从服务端读取。返回 True 表示有数据需要读取，False 表示没有数据需要被读取，当不实现默认返回为 True，当返回 True 时，回调函数 handle_read 将被触发 12def readable(self): return True 实现 handle_read 回调函数 当有数据需要读取时触发（readable 回调函数返回 True 时），该函数被触发，通常情况下在该函数中编写 recv 方法接收数据 12345def handle_read(self): # 主动接收数据，参数是需要接收数据的长度 # 返回的数据是字节数据 result = self.recv(1024) print(result) 实现 handle_error 回调函数 当程序运行过程发生异常时回调 1234def handle_error(self): # 编写处理错误方法 t,e,trace = sys.exc_info() self.close() 实现 handle_close 回调函数 当连接被关闭时触发 123def handle_close(self): print(\"连接关闭\") self.close() 创建对象并且执行 asyncore.loop 进入运行循环 timeout 表示一次循环所需要的时长 123client = SocketClient('127.0.0.1',9000)# 开始启动运行循环asyncore.loop(timeout=5) 抓取弹幕开发流程根据斗鱼弹幕服务器第三方接入协议v1.6.2.pdf 官方提供协议文档建立弹幕客户端开发流程。 连接初始化 使用TCP连接服务器 IP地址：openbarrage.douyutv.com 端口：8601 客户端向弹幕服务器发送登录请求，登录弹幕服务器 弹幕服务器收到客户端登录请求并完成登录后，返回登录成功消息给客户端 客户端收到登录成功消息后发送进入弹幕分组请求给弹幕服务器 弹幕服务器接受到客户端弹幕分组请求后将客户端添加到请求指定的弹幕分组中 服务过程 客户端每隔 45 秒发送心跳给弹幕服务器，弹幕服务器回复心跳信息给客户端 弹幕服务器如有广播信息，则推送给客户端，服务器消息协议 断开连接 客户端发送登出消息 客户端关闭 TCP 连接 数据包结构 消息长度:4 字节小端整数，表示整条消息(包括自身)长度(字节数)。 消息长度出现两遍，二者相同。 消息类型:2 字节小端整数，表示消息类型。取值如下: 689 客户端发送给弹幕服务器的文本格式数据 690 弹幕服务器发送给客户端的文本格式数据。 加密字段:1字节，暂时未用，默认为 0。 保留字段:1字节，暂时未用，默认为 0。 数据部分:n字节+1字节，斗鱼独创序列化文本数据，结尾必须为‘\\0’。(所有协议内容均为 UTF-8 编码) 数据包封装 对数据包进行对象化封装，对数据的封装方便以后使用，实现对象和二进制数据之间的转换 通过参数构建数据包对象 实现获取数据包长度的方法 实现获取二进制数据的方法 实现发送数据包 构建发送数据包的队列容器 1self.send_queue = Queue() 实现回调函数，判断容器中有数据就发送没有数据不发送 1234567891011121314151617def writable(self): return self.send_queue.qsize() &gt; 0def handle_write(self): # 从发送数据包队列中获取数据包对象 dp = self.send_queue.get() # 获取数据包的长度，并且发送给服务器 dp_length = dp.get_length() dp_length_data = dp_length.to_bytes(4,byteorder='little',signed=False) self.send(dp_length_data) # 发送数据包二进制数据 self.send(dp.get_bytes()) self.send_queue.task_done() pass 实现登录函数 构建登录数据包 12content = \"type@=loginreq/roomid@=&#123;&#125;/\".format(room_id)login_dp = DataPacket(DATA_PACKET_TYPE_SEND,content=content) 把数据包添加到发送数据包容器中 12# 把数据包添加到发送数据包容器中 self.send_queue.put(login_dp) 实现接收数据 构建接收数据包队列 12# 存放接收的数据包对象self.recv_queue = Queue() 读取回调函数中读取数据 读取长度 1234# 读取长度,二进制数据data_length_data = self.recv(4)# 通过二进制获取length 具体数据data_length = int.from_bytes(data_length_data,byteorder='little',signed=False) 读取内容 12# 通过数据包的长度获取数据data = self.recv(data_length) 构建数据包对象 数据包构造函数中解析二进制来构建数据包对象 12345self.type = int.from_bytes(data_bytes[4:6],byteorder='little',signed=False)self.encrypt_flag = int.from_bytes(data_bytes[6:7],byteorder='little',signed=False)self.preserve_flag = int.from_bytes(data_bytes[7:8],byteorder='little',signed=False)# 构建数据部分self.content = str(data_bytes[8:-1],encoding='utf-8') 通过二进制数据构建数据包对象 12# 通过二进制数据构建数据包对象dp = DataPacket(data_bytes=data) 把数据包放入接收数据包容器中 12# 把数据包放入接收数据包容器中self.recv_queue.put(dp) 构建处理线程专门处理接收数据包容器中数据 构建线程 1234# 构建一个专门处理接收数据包容器中的数据包的线程self.callback_thread = threading.Thread(target=self.do_callback)self.callback_thread.setDaemon(True)self.callback_thread.start() 实现回调函数处理接收的数据包 123456789101112def do_callback(self): ''' 专门负责处理接收数据包容器中的数据 :return: ''' while True: # 从接收数据包容器中获取数据包 dp = self.recv_queue.get() # 对数据进行处理 print(dp.content) pass 实现外部传入回调函数 通过外部指定回调函数实现自定义数据处理 添加参数 callback 构造函数中添加参数 123def __init__(self,host,port,callback=None): # 定义外部传入的自定义回调函数 self.callback = callback 外部传入自定义回调函数 123456789101112131415def data_callback(dp): ''' 自定义回调函数 :param dp: 数据包对象 :return: ''' print(\"data_callback:\",dp.content) passif __name__ == '__main__': client = DouyuClient('openbarrage.douyutv.com',8601,callback=data_callback) client.login_room_id(4494106) asyncore.loop(timeout=10) 在处理接收数据包的线程中调用回调函数 123456789101112def do_callback(self): ''' 专门负责处理接收数据包容器中的数据 :return: ''' while True: # 从接收数据包容器中获取数据包 dp = self.recv_queue.get() # 对数据进行处理 if self.callback is not None: self.callback(dp) self.recv_queue.task_done() 数据内容序列化与反序列化 键 key 和值 value 直接采用‘@=’分割 数组采用‘/’分割 如果 key 或者 value 中含有字符‘/’，则使用‘@S’转义 如果 key 或者 value 中含有字符‘@’，使用‘@A’转义 例子 多个键值对数据:key1@=value1/key2@=value2/key3@=value3/ 数组数据:value1/value2/value3/ 登录 123456789101112131415def login_room_id(self, room_id): # 2.客户端向弹幕服务器发送登录请求，登录弹幕服务器 self.room_id &#x3D; room_id send_data &#x3D; &#123; &quot;type&quot;: &quot;loginreq&quot;, &quot;roomid&quot;: str(room_id) &#125; # 构建登录数据包 content &#x3D; encode_content(send_data) login_dp &#x3D; DataPacket(DATA_PACKET_TYPE_SEND, content&#x3D;content) # 把数据包添加到发送数据包容器中 self.send_queue.put(login_dp) 加入弹幕分组 参看斗鱼弹幕文档,-9999 为海量弹幕 12345678910111213141516def join_room_group(self): &#39;&#39;&#39; 4.客户端收到登录成功消息后发送进入弹幕分组请求给弹幕服务器 :return: &#39;&#39;&#39; send_data &#x3D; &#123; &quot;type&quot;: &quot;joingroup&quot;, &quot;rid&quot;: str(self.room_id), &quot;gid&quot;: &#39;-9999&#39; &#125; content &#x3D; encode_content(send_data) dp &#x3D; DataPacket(type&#x3D;DATA_PACKET_TYPE_SEND, content&#x3D;content) self.send_queue.put(dp) pass 心跳机制 作用是让服务器解决假死连接问题，客户端必须每隔45秒发送一次请求，否则就会被主动断开。 实现发送心跳函数 构建心跳数据包 把数据包添加到发送数据包容器队列中 构建心跳线程 构建心跳线程 添加触发机制 添加暂停机制 12345678def send_heart_data_packet(self): # 6.客户端每隔 45 秒发送心跳给弹幕服务器，弹幕服务器回复心跳信息给客户端 send_data &#x3D; &#123; &quot;type&quot;: &quot;mrkl&quot; &#125; content &#x3D; encode_content(send_data) dp &#x3D; DataPacket(type&#x3D;DATA_PACKET_TYPE_SEND, content&#x3D;content) self.send_queue.put(dp) WebSocket以上方案已经失效，斗鱼弹幕已使用websocket实现，不过都是协议而已，基础逻辑没有变化。 通过抓包获取wss的地址及端口 查看抓包中的Messages中的二进制信息，数据格式和1.6.2保持一致。 run_forever是核心逻辑通过while循环实现自动重连，建立_job_open时调用_one_hello登录加入群组，通过_job_heartbeat持续接受心跳机制。 123456789101112131415161718192021222324252627282930313233343536373839async def run_forever(self) -&gt; None: &quot;&quot;&quot; 重写 @return: &quot;&quot;&quot; self._waiting_end &#x3D; self._loop.create_future() while not self._closed: self._logger_info(f&#39;正在启动 &#123;self._area_id&#125; 号数据连接&#39;) if self._waiting_pause is not None: self._logger_info(f&#39;暂停启动 &#123;self._area_id&#125; 号数据连接，等待 RESUME 指令&#39;) await self._waiting_pause async with self._opening_lock: if self._closed: self._logger_info(f&#39;&#123;self._area_id&#125; 号数据连接确认收到关闭信号，正在处理&#39;) break # 未成功建立数据连接，循环重试 if await self._prepare_client() and await self._job_open(): tasks &#x3D; [self._loop.create_task(i()) for i in self._funcs_task] self._task_main &#x3D; self._loop.create_task(self._job_main()) tasks.append(self._task_main) task_heartbeat &#x3D; self._loop.create_task(self._job_heartbeat()) tasks.append(task_heartbeat) else: continue _, pending &#x3D; await asyncio.wait(tasks, return_when&#x3D;asyncio.FIRST_COMPLETED) self._logger_info(f&#39;&#123;self._area_id&#125; 号数据连接异常或主动断开，正在处理剩余信息&#39;) for i in pending: if i !&#x3D; self._task_main: i.cancel() await self._job_close() if pending: await asyncio.wait(pending) self._logger_info(f&#39;&#123;self._area_id&#125; 号数据连接退出，剩余任务处理完毕&#39;) await self._conn.clean() self._waiting_end.set_result(True) 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"asyncore","slug":"asyncore","permalink":"http://onejane.github.io/tags/asyncore/"},{"name":"socket","slug":"socket","permalink":"http://onejane.github.io/tags/socket/"},{"name":"asyncio","slug":"asyncio","permalink":"http://onejane.github.io/tags/asyncio/"},{"name":"websocket","slug":"websocket","permalink":"http://onejane.github.io/tags/websocket/"}]},{"title":"爬虫基础篇之IP代理池","slug":"爬虫基础篇之IP代理池","date":"2021-03-30T08:09:50.000Z","updated":"2021-12-12T03:09:39.331Z","comments":true,"path":"2021/03/30/爬虫基础篇之IP代理池/","link":"","permalink":"http://onejane.github.io/2021/03/30/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BIP%E4%BB%A3%E7%90%86%E6%B1%A0/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 代理池介绍由众多ip组成提供多个稳定可用代理IP的ip池。 当我们做爬虫时，最常见的反爬手段就是IP反爬，当同一个IP访问网站超出频控限制，将会被限制访问，那么代理IP池应运而生。资金充足的情况下个人建议还是付费ip代理池，比较免费ip时效性低，且难以维护。 本文将介绍通过requests库多线程抓取多个免费代理ip网站数据落库mongo后并动态维护保证IP高度可用，以API形式暴露接口获取代理IP的解决方案。 爬取流程 代理IP采集模块： 采集代理IP -&gt; 检测代理IP -&gt;如果不可用用, 直接过滤掉, 如果可用, 指定默认分数 -&gt; 存入数据库中 代理IP检测模块： 从数据库中获取所有代理IP -&gt; 检测代理IP -&gt; 如果代理IP不可用用, 就把分数-1, 如果分数为0从数据库中删除, 否则更新数据库, 如果代理IP可用, 恢复为默认分值,更新数据库 代理API模块：从数据库中高可用的代理IP给爬虫使用; 模块爬虫模块从代理IP网站上采集代理IP ,对抓取的ip进行校验(获取代理响应速度, 协议类型, 匿名类型), 并存储到数据库中。 校验模块网站上所标注的响应速度,协议类型和匿名类型是不准确的，通过httpbin.org进行检测，获取指定代理的响应速度, 支持的协议以及匿名程度。 数据库模块使用MongoDB来存储代理IP并实现对代理IP的增删改查操作。 检测模块定时从数据库读取所有的代理IP，对代理IP进行逐一检测, 开启多个协程, 以提高检测速度，如果该代理不可用, 就让这个代理分数-1, 当代理的分数到0了, 就删除该代理; 如果检测到代理可用就恢复为满分。 API模块根据协议类型和域名获取多个随机的高质量代理IP，根据代理IP不可用域名, 告诉代理池这个代理IP在该域名下不可用, 下次获取这个域名的代理IP时候, 就不会再获取这个代理IP了, 从而保证代理IP高可用性。 其他模块数据模型 代理IP的数据模型, 用于封装代理IP相关信息, 比如ip,端口号, 响应速度, 协议类型, 匿名类型,分数等。 程序入口 代理池提供一个统一的启动入口 工具模块 日志模块: 用于记录日志信息 http模块: 用于获取随机User-Agent的请求头 配置文件 用于默认代理的分数, 配置日志格式, 文件, 启动的爬虫, 检验的间隔时间 等。 实战思路1：依据流程图，逐步实现各个模块，当需要依赖其他模块时，暂停当前模块，开发其他模块功能，实现完毕再回头开发联调。 思路2：先实现不依赖其他模块的基础模块，再逐步实现具体的功能模块，比如爬虫模块, 检测模块, 代理API模块。 这里我们选择思路2实现爬虫代理IP池，因为思路1适合个人完成，不适合分工合作，且不易维护，思路跳来跳去，必须逻辑清晰。 数据模型domainsettings.py 中 定义MAX_SCORE = 50, 表示代理IP的默认最高分数 12345678910111213141516171819202122232425class Proxy(object): def __init__(self, ip, port, protocol&#x3D;-1, nick_type&#x3D;-1, speed&#x3D;-1, area&#x3D;None, score&#x3D;MAX_SCORE, disable_domains&#x3D;[]): # ip: 代理的IP地址 self.ip &#x3D; ip # port: 代理IP的端口号 self.port &#x3D; port # protocol: 代理IP支持的协议类型, http是0, https是1, https和http都支持是2，-1不可用 self.protocol &#x3D; protocol # nick_type: 代理IP的匿名程度, 高匿: 0, 匿名: 1, 透明: 2 self.nick_type &#x3D; nick_type # speed: 代理IP的响应速度, 单位s self.speed &#x3D; speed # area: 代理IP所在地区 self.area &#x3D; area # score: 代理IP的评分, 用于衡量代理的可用性; self.score &#x3D; score # 默认分值可以通过配置文件进行配置.在进行代理可用性检查的时候, 每遇到一次请求失败就减1份, 减到0的时候从池中删除.如果检查代理可用, 就恢复默认分值 # disable_domains: 不可用域名列表, 有些代理IP在某些域名下不可用, 但是在其他域名下可用 self.disable_domains &#x3D; disable_domains # 3. 提供 __str__ 方法, 返回数据字符串 def __str__(self): # 返回数据字符串 return str(self.__dict__) 日志模块log导入settings中日志配置信息,如下LOG_LEVEL = logging.DEBUG # 默认等级LOG_FMT = ‘%(asctime)s %(filename)s [line:%(lineno)d] %(levelname)s: %(message)s’ # 默认日志格式LOG_DATEFMT = ‘%Y-%m-%d %H:%M:%S’ # 默认时间格式LOG_FILENAME = ‘log.log’ # 默认日志文件名称 12345678910111213141516171819202122232425262728293031323334353637383940class Logger(object): def __init__(self): # 1. 获取一个logger对象 self._logger &#x3D; logging.getLogger() # 2. 设置format对象 self.formatter &#x3D; logging.Formatter(fmt&#x3D;LOG_FMT,datefmt&#x3D;LOG_DATEFMT) # 3. 设置日志输出 # 3.1 设置文件日志模式 self._logger.addHandler(self._get_file_handler(LOG_FILENAME)) # 3.2 设置终端日志模式 self._logger.addHandler(self._get_console_handler()) # 4. 设置日志等级 self._logger.setLevel(LOG_LEVEL) def _get_file_handler(self, filename): &#39;&#39;&#39;返回一个文件日志handler&#39;&#39;&#39; # 1. 获取一个文件日志handler filehandler &#x3D; logging.FileHandler(filename&#x3D;filename,encoding&#x3D;&quot;utf-8&quot;) # 2. 设置日志格式 filehandler.setFormatter(self.formatter) # 3. 返回 return filehandler def _get_console_handler(self): &#39;&#39;&#39;返回一个输出到终端日志handler&#39;&#39;&#39; # 1. 获取一个输出到终端日志handler console_handler &#x3D; logging.StreamHandler(sys.stdout) # 2. 设置日志格式 console_handler.setFormatter(self.formatter) # 3. 返回handler return console_handler @property def logger(self): return self._logger# 初始化并配一个logger对象，达到单例的# 使用时，直接导入logger就可以使用logger &#x3D; Logger().logger 请求模块http返回随机请求头和随机User-Agent,对抗反爬 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 1. 准备User-Agent的列表USER_AGENTS &#x3D; [ &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident&#x2F;4.0; WOW64; Trident&#x2F;4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit&#x2F;523.15 (KHTML, like Gecko, Safari&#x2F;419.3) Arora&#x2F;0.3 (Change: 287 c9dfb30)&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux; en-US) AppleWebKit&#x2F;527+ (KHTML, like Gecko, Safari&#x2F;419.3) Arora&#x2F;0.6&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko&#x2F;20070215 K-Ninja&#x2F;2.1.1&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko&#x2F;20080705 Firefox&#x2F;3.0 Kapiko&#x2F;3.0&quot;, &quot;Mozilla&#x2F;5.0 (X11; Linux i686; U;) Gecko&#x2F;20070322 Kazehakase&#x2F;0.4.5&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora&#x2F;1.9.0.8-1.fc10 Kazehakase&#x2F;0.5.6&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;535.11 (KHTML, like Gecko) Chrome&#x2F;17.0.963.56 Safari&#x2F;535.11&quot;, &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit&#x2F;535.20 (KHTML, like Gecko) Chrome&#x2F;19.0.1036.7 Safari&#x2F;535.20&quot;, &quot;Opera&#x2F;9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto&#x2F;2.9.168 Version&#x2F;11.52&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;536.11 (KHTML, like Gecko) Chrome&#x2F;20.0.1132.11 TaoBrowser&#x2F;2.0 Safari&#x2F;536.11&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.71 Safari&#x2F;537.1 LBBROWSER&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;535.11 (KHTML, like Gecko) Chrome&#x2F;17.0.963.84 Safari&#x2F;535.11 LBBROWSER&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser&#x2F;7.0.3698.400)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident&#x2F;4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 5.1) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.89 Safari&#x2F;537.1&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.89 Safari&#x2F;537.1&quot;, &quot;Mozilla&#x2F;5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit&#x2F;533.17.9 (KHTML, like Gecko) Version&#x2F;5.0.2 Mobile&#x2F;8C148 Safari&#x2F;6533.18.5&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko&#x2F;20110307 Firefox&#x2F;4.0b13pre&quot;, &quot;Mozilla&#x2F;5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko&#x2F;20100101 Firefox&#x2F;16.0&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.11 (KHTML, like Gecko) Chrome&#x2F;23.0.1271.64 Safari&#x2F;537.11&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko&#x2F;20100922 Ubuntu&#x2F;10.10 (maverick) Firefox&#x2F;3.6.10&quot;]# 实现一个方法, 获取随机User-Agent的请求头def get_request_headers(): headers &#x3D; &#123; &#39;User-Agent&#39;: random.choice(USER_AGENTS), &#39;Accept&#39;: &#39;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8&#39;, &#39;Accept-Language&#39;: &#39;en-US,en;q&#x3D;0.5&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#125; return headers 校验模块httpbin_validator 检查代理IP速度 和 匿名程度; 代理IP速度: 就是从发送请求到获取响应的时间间隔 匿名程度检查: 对 http://httpbin.org/get 或 https://httpbin.org/get 发送请求 如果 响应的origin 中有’,’分割的两个IP就是透明代理IP 如果 响应的headers 中包含 Proxy-Connection 说明是匿名代理IP 否则就是高匿代理IP 检查代理IP协议类型 如果 http://httpbin.org/get 发送请求可以成功, 说明支持http协议 如果 https://httpbin.org/get 发送请求可以成功, 说明支持https协议 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778def check_proxy(proxy): &quot;&quot;&quot; 用于检查指定 代理IP 响应速度, 匿名程度, 支持协议类型 :param proxy: 代理IP模型对象 :return: 检查后的代理IP模型对象 &quot;&quot;&quot; # 准备代理IP字典 proxies &#x3D; &#123; &#39;http&#39;:&#39;http:&#x2F;&#x2F;&#123;&#125;:&#123;&#125;&#39;.format(proxy.ip, proxy.port), &#39;https&#39;:&#39;https:&#x2F;&#x2F;&#123;&#125;:&#123;&#125;&#39;.format(proxy.ip, proxy.port), &#125; # 测试该代理IP http, http_nick_type, http_speed &#x3D; __check_http_proxies(proxies) https, https_nick_type, https_speed &#x3D; __check_http_proxies(proxies, False) # 代理IP支持的协议类型, http是0, https是1, https和http都支持是2 if http and https: proxy.protocol &#x3D; 2 proxy.nick_type &#x3D; http_nick_type proxy.speed &#x3D; http_speed elif http: proxy.protocol &#x3D; 0 proxy.nick_type &#x3D; http_nick_type proxy.speed &#x3D; http_speed elif https: proxy.protocol &#x3D; 1 proxy.nick_type &#x3D; https_nick_type proxy.speed &#x3D; https_speed else: proxy.protocol &#x3D; -1 proxy.nick_type &#x3D; -1 proxy.speed &#x3D; -1 return proxydef __check_http_proxies(proxies, is_http&#x3D;True): # 匿名类型: 高匿: 0, 匿名: 1, 透明: 2 nick_type &#x3D; -1 # 响应速度, 单位s speed &#x3D; -1 if is_http: test_url &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39; else: test_url &#x3D; &#39;https:&#x2F;&#x2F;httpbin.org&#x2F;get&#39; try: # 获取开始时间 start &#x3D; time.time() # 发送请求, 获取响应数据 response &#x3D; requests.get(test_url, headers&#x3D;get_request_headers(), proxies&#x3D;proxies, timeout&#x3D;TEST_TIMEOUT) if response.ok: # 计算响应速度 speed &#x3D; round(time.time() - start, 2) # 匿名程度 # 把响应的json字符串, 转换为字典 dic &#x3D; json.loads(response.text) # 获取来源IP: origin origin &#x3D; dic[&#39;origin&#39;] proxy_connection &#x3D; dic[&#39;headers&#39;].get(&#39;Proxy-Connection&#39;, None) if &#39;,&#39; in origin: # 1. 如果 响应的origin 中有&#39;,&#39;分割的两个IP就是透明代理IP nick_type &#x3D; 2 elif proxy_connection: # 2. 如果 响应的headers 中包含 Proxy-Connection 说明是匿名代理IP nick_type &#x3D; 1 else: # 3. 否则就是高匿代理IP nick_type &#x3D; 0 return True, nick_type, speed return False, nick_type, speed except Exception as ex: # logger.exception(ex) return False, nick_type, speed 数据库模块mongo_pool 在init中, 建立数据连接, 获取要操作的集合, 在 del 方法中关闭数据库连接 提供基础的增删改查功能 提供代理API模块使用的功能 实现查询功能: 根据条件进行查询, 可以指定查询数量, 先分数降序, 速度升序排, 保证优质的代理IP在上面. 实现根据协议类型 和 要访问网站的域名, 获取代理IP列表 实现根据协议类型 和 要访问网站的域名, 随机获取一个代理IP 实现把指定域名添加到指定IP的disable_domain列表中. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121class MongoPool(object): def __init__(self): # 1.1. 在init中, 建立数据连接 self.client &#x3D; MongoClient(MONGO_URL) # 1.2 获取要操作的集合 self.proxies &#x3D; self.client[&#39;proxies_pool&#39;][&#39;proxies&#39;] def __del__(self): # 1.3 关闭数据库连接 self.client.close() def insert_one(self, proxy): &quot;&quot;&quot;2.1 实现插入功能&quot;&quot;&quot; count &#x3D; self.proxies.count_documents(&#123;&#39;_id&#39;: proxy.ip&#125;) if count &#x3D;&#x3D; 0: # 我们使用proxy.ip作为, MongoDB中数据的主键: _id dic &#x3D; proxy.__dict__ dic[&#39;_id&#39;] &#x3D; proxy.ip self.proxies.insert_one(dic) logger.info(&#39;插入新的代理:&#123;&#125;&#39;.format(proxy)) else: logger.warning(&quot;已经存在的代理:&#123;&#125;&quot;.format(proxy)) def update_one(self, proxy): &quot;&quot;&quot;2.2 实现修改该功能&quot;&quot;&quot; self.proxies.update_one(&#123;&#39;_id&#39;: proxy.ip&#125;, &#123;&#39;$set&#39;:proxy.__dict__&#125;) def delete_one(self, proxy): &quot;&quot;&quot;2.3 实现删除代理: 根据代理的IP删除代理&quot;&quot;&quot; self.proxies.delete_one(&#123;&#39;_id&#39;: proxy.ip&#125;) logger.info(&quot;删除代理IP: &#123;&#125;&quot;.format(proxy)) def find_all(self): &quot;&quot;&quot;2.4 查询所有代理IP的功能&quot;&quot;&quot; cursor &#x3D; self.proxies.find() for item in cursor: # 删除_id这个key item.pop(&#39;_id&#39;) proxy &#x3D; Proxy(**item) yield proxy def find(self, conditions&#x3D;&#123;&#125;, count&#x3D;0): &quot;&quot;&quot; 3.1 实现查询功能: 根据条件进行查询, 可以指定查询数量, 先分数降序, 速度升序排, 保证优质的代理IP在上面. :param conditions: 查询条件字典 :param count: 限制最多取出多少个代理IP :return: 返回满足要求代理IP(Proxy对象)列表 &quot;&quot;&quot; cursor &#x3D; self.proxies.find(conditions, limit&#x3D;count).sort([ (&#39;score&#39;, pymongo.DESCENDING),(&#39;speed&#39;, pymongo.ASCENDING) ]) # 准备列表, 用于存储查询处理代理IP proxy_list &#x3D; [] # 遍历 cursor for item in cursor: item.pop(&#39;_id&#39;) proxy &#x3D; Proxy(**item) proxy_list.append(proxy) # 返回满足要求代理IP(Proxy对象)列表 return proxy_list def get_proxies(self, protocol&#x3D;None, domain&#x3D;None, count&#x3D;0, nick_type&#x3D;0): &quot;&quot;&quot; 3.2 实现根据协议类型 和 要访问网站的域名, 获取代理IP列表 :param protocol: 协议: http, https :param domain: 域名: jd.com :param count: 用于限制获取多个代理IP, 默认是获取所有的 :param nick_type: 匿名类型, 默认, 获取高匿的代理IP :return: 满足要求代理IP的列表 &quot;&quot;&quot; # 定义查询条件 conditions &#x3D; &#123;&#39;nick_type&#39;: nick_type&#125; # 根据协议, 指定查询条件 if protocol is None: # 如果没有传入协议类型, 返回支持http和https的代理IP conditions[&#39;protocol&#39;] &#x3D; 2 elif protocol.lower() &#x3D;&#x3D; &#39;http&#39;: conditions[&#39;protocol&#39;] &#x3D; &#123;&#39;$in&#39;: [0, 2]&#125; else: conditions[&#39;protocol&#39;] &#x3D; &#123;&#39;$in&#39;: [1, 2]&#125; if domain: conditions[&#39;disable_domains&#39;] &#x3D; &#123;&#39;$nin&#39;: [domain]&#125; # 满足要求代理IP的列表 return self.find(conditions, count&#x3D;count) def random_proxy(self, protocol&#x3D;None, domain&#x3D;None, count&#x3D;0, nick_type&#x3D;0): &quot;&quot;&quot; 3.3 实现根据协议类型 和 要访问网站的域名, 随机获取一个代理IP :param protocol: 协议: http, https :param domain: 域名: jd.com :param count: 用于限制获取多个代理IP, 默认是获取所有的 :param nick_type: 匿名类型, 默认, 获取高匿的代理IP :return: 满足要求的随机的一个代理IP(Proxy对象) &quot;&quot;&quot; proxy_list &#x3D; self.get_proxies(protocol&#x3D;protocol, domain&#x3D;domain, count&#x3D;count, nick_type&#x3D;nick_type) # 从proxy_list列表中, 随机取出一个代理IP返回 return random.choice(proxy_list) def disable_domain(self, ip, domain): &quot;&quot;&quot; 3.4 实现把指定域名添加到指定IP的disable_domain列表中. :param ip: IP地址 :param domain: 域名 :return: 如果返回True, 就表示添加成功了, 返回False添加失败了 &quot;&quot;&quot; # print(self.proxies.count_documents(&#123;&#39;_id&#39;: ip, &#39;disable_domains&#39;:domain&#125;)) if self.proxies.count_documents(&#123;&#39;_id&#39;: ip, &#39;disable_domains&#39;:domain&#125;) &#x3D;&#x3D; 0: # 如果disable_domains字段中没有这个域名, 才添加 self.proxies.update_one(&#123;&#39;_id&#39;:ip&#125;, &#123;&#39;$push&#39;: &#123;&#39;disable_domains&#39;: domain&#125;&#125;) return True return False 爬虫模块base_spider 在base_spider.py文件中,定义一个BaseSpider类, 继承object 提供三个类成员变量: urls: 代理IP网址的URL的列表 group_xpath: 分组XPATH, 获取包含代理IP信息标签列表的XPATH detail_xpath: 组内XPATH, 获取代理IP详情的信息XPATH, 格式为: {‘ip’:’xx’, ‘port’:’xx’, ‘area’:’xx’} 提供初始方法, 传入爬虫URL列表, 分组XPATH, 详情(组内)XPATH 对外提供一个获取代理IP的方法 遍历URL列表, 获取URL 根据发送请求, 获取页面数据 解析页面, 提取数据, 封装为Proxy对象 返回Proxy对象列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 1. 在base_spider.py文件中,定义一个BaseSpider类, 继承objectclass BaseSpider(object): # 2. 提供三个类成员变量: # urls: 代理IP网址的URL的列表 urls &#x3D; [] # group_xpath: 分组XPATH, 获取包含代理IP信息标签列表的XPATH group_xpath &#x3D; &#39;&#39; # detail_xpath: 组内XPATH, 获取代理IP详情的信息XPATH, 格式为: &#123;&#39;ip&#39;:&#39;xx&#39;, &#39;port&#39;:&#39;xx&#39;, &#39;area&#39;:&#39;xx&#39;&#125; detail_xpath &#x3D; &#123;&#125; # 3. 提供初始方法, 传入爬虫URL列表, 分组XPATH, 详情(组内)XPATH def __init__(self, urls&#x3D;[], group_xpath&#x3D;&#39;&#39;, detail_xpath&#x3D;&#123;&#125;): if urls: self.urls &#x3D; urls if group_xpath: self.group_xpath &#x3D; group_xpath if detail_xpath: self.detail_xpath &#x3D; detail_xpath def get_page_from_url(self, url): &quot;&quot;&quot;根据URL 发送请求, 获取页面数据&quot;&quot;&quot; response &#x3D; requests.get(url, headers&#x3D;get_request_headers()) print(url) print(response.status_code) return response.content def get_first_from_list(self, lis): # 如果列表中有元素就返回第一个, 否则就返回空串 return lis[0] if len(lis) !&#x3D; 0 else &#39;&#39; def get_proxies_from_page(self, page): &quot;&quot;&quot;解析页面, 提取数据, 封装为Proxy对象&quot;&quot;&quot; element &#x3D; etree.HTML(page) # 获取包含代理IP信息的标签列表 trs &#x3D; element.xpath(self.group_xpath) # 遍历trs, 获取代理IP相关信息 for tr in trs: ip &#x3D; self.get_first_from_list(tr.xpath(self.detail_xpath[&#39;ip&#39;])) port &#x3D; self.get_first_from_list(tr.xpath(self.detail_xpath[&#39;port&#39;])) area &#x3D; self.get_first_from_list(tr.xpath(self.detail_xpath[&#39;area&#39;])) proxy &#x3D; Proxy(ip, port, area&#x3D;area) # print(proxy) # 使用yield返回提取到的数据 yield proxy def get_proxies(self): # 4. 对外提供一个获取代理IP的方法 # 4.1 遍历URL列表, 获取URL for url in self.urls: # print(url) # 4.2 根据发送请求, 获取页面数据 page &#x3D; self.get_page_from_url(url) # 4.3 解析页面, 提取数据, 封装为Proxy对象 proxies &#x3D; self.get_proxies_from_page(page) # 4.4 返回Proxy对象列表 yield from proxies 具体爬虫实现proxy_spiders 实现西刺代理爬虫: http://www.xicidaili.com/nn/1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 实现ip3366代理爬虫: http://www.ip3366.net/free/?stype=1&amp;page=1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 实现快代理爬虫: https://www.kuaidaili.com/free/inha/1/ 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 实现proxylistplus代理爬虫: https://list.proxylistplus.com/Fresh-HTTP-Proxy-List-1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 实现66ip爬虫: http://www.66ip.cn/1.html 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 由于66ip网页进行js + cookie反爬, 需要重写父类的get_page_from_url方法 访问http://www.66ip.cn/1.html 时返回一堆js，并不返回具体ip信息，通过逐步增加请求头中的Cookie时发现真正生效的Cookie为_ydclearance，控制台打开Preserve log发现页面第一次1.html做了跳转，历史请求中都没有出现_ydclearance的cookie，第二次请求1.html时已经携带了_ydclearance说明该cookie已经不是服务端响应生成，而是由客户端js生成。 一开始我们访问http://www.66ip.cn/1.html 时返回一堆js，执行这段js，就是用来生成_ydclearance的。那么分析这段js本身做了加密，js中通过定义函数jp并调用后，由于qo=eval，那么等同于最终调用了eval(po)，真正js在 “po” 中。 1result &#x3D; re.findall(&#39;window.onload&#x3D;setTimeout\\(&quot;(.+?)&quot;, 200\\);\\s*(.+?)\\s*&lt;&#x2F;script&gt;&#39; ,text) 通过正则提取 jp(107) 调用函数方法, 以及函数内容 function jp(WI) { var qo, mo=&quot;&quot; ...，通过将替换eval拿到返回的真实js 12func_str &#x3D; result[0][1]func_str &#x3D; func_str.replace(&#39;eval(&quot;qo&#x3D;eval;qo(po);&quot;)&#39;, &#39;return po&#39;) 执行js并将返回作为Cookie添加到请求头中 12345context &#x3D; js2py.EvalJs()context.execute(func_str)context.execute(&#39;code &#x3D; &#123;&#125;;&#39;.format(result[0][0]))cookie_str &#x3D; re.findall(&quot;document.cookie&#x3D;&#39;(.+?); &quot;, context.code)[0]headers[&#39;Cookie&#39;] &#x3D; cookie_str 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125class XiciSpider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;https:&#x2F;&#x2F;www.xicidaili.com&#x2F;nn&#x2F;&#123;&#125;&#39;.format(i) for i in range(1, 11)] # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;ip_list&quot;]&#x2F;tr[position()&gt;1]&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[3]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[4]&#x2F;a&#x2F;text()&#39; &#125;&quot;&quot;&quot;2. 实现ip3366代理爬虫: http:&#x2F;&#x2F;www.ip3366.net&#x2F;free&#x2F;?stype&#x3D;1&amp;page&#x3D;1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath&quot;&quot;&quot;class Ip3366Spider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;http:&#x2F;&#x2F;www.ip3366.net&#x2F;free&#x2F;?stype&#x3D;&#123;&#125;&amp;page&#x3D;&#123;&#125;&#39;.format(i, j) for i in range(1, 4, 2) for j in range(1, 8)] # # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;list&quot;]&#x2F;table&#x2F;tbody&#x2F;tr&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[1]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[5]&#x2F;text()&#39; &#125;&quot;&quot;&quot;3. 实现快代理爬虫: https:&#x2F;&#x2F;www.kuaidaili.com&#x2F;free&#x2F;inha&#x2F;1&#x2F; 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath&quot;&quot;&quot;class KaiSpider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;https:&#x2F;&#x2F;www.kuaidaili.com&#x2F;free&#x2F;inha&#x2F;&#123;&#125;&#x2F;&#39;.format(i) for i in range(1, 6)] # # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;list&quot;]&#x2F;table&#x2F;tbody&#x2F;tr&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[1]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[5]&#x2F;text()&#39; &#125; # 当我们两个页面访问时间间隔太短了, 就报错了; 这是一种反爬手段. def get_page_from_url(self, url): # 随机等待1,3s time.sleep(random.uniform(1, 3)) # 调用父类的方法, 发送请求, 获取响应数据 return super().get_page_from_url(url)&quot;&quot;&quot;4. 实现proxylistplus代理爬虫: https:&#x2F;&#x2F;list.proxylistplus.com&#x2F;Fresh-HTTP-Proxy-List-1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath&quot;&quot;&quot;class ProxylistplusSpider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;https:&#x2F;&#x2F;list.proxylistplus.com&#x2F;Fresh-HTTP-Proxy-List-&#123;&#125;&#39;.format(i) for i in range(1, 7)] # # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;page&quot;]&#x2F;table[2]&#x2F;tbody&#x2F;tr[position()&gt;2]&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[3]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[5]&#x2F;text()&#39; &#125;&quot;&quot;&quot;5. 实现66ip爬虫: http:&#x2F;&#x2F;www.66ip.cn&#x2F;1.html 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 由于66ip网页进行js + cookie反爬, 需要重写父类的get_page_from_url方法&quot;&quot;&quot;class Ip66Spider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;http:&#x2F;&#x2F;www.66ip.cn&#x2F;&#123;&#125;.html&#39;.format(i) for i in range(1, 11)] # # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;main&quot;]&#x2F;div&#x2F;div[1]&#x2F;table&#x2F;tbody&#x2F;tr[position()&gt;1]&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[1]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[3]&#x2F;text()&#39; &#125; # 重写方法, 解决反爬问题 def get_page_from_url(self, url): headers &#x3D; get_request_headers() response &#x3D; requests.get(url, headers&#x3D;headers) if response.status_code &#x3D;&#x3D; 521: # 生成cookie信息, 再携带cookie发送请求 # 生成 &#96;_ydclearance&#96; cookie信息,控制台preserve log,第一个页面就是加密页面521用来做反爬跳转 # 1. 确定 _ydclearance 是从哪里来的; # 观察发现: 这个cookie在前两个页面都没有返回，说明信息不使用通过服务器响应设置过来的; 那么他就是通过js生成. # 2. 第一次发送请求的页面中, 有一个生成这个cookie的js; 执行这段js, 生成我们需要的cookie # 这段js是经过加密处理后的js, 真正js在 &quot;po&quot; 中. # 提取 &#96;jp(107)&#96; 调用函数的方法, 以及函数 result &#x3D; re.findall(&#39;window.onload&#x3D;setTimeout\\(&quot;(.+?)&quot;, 200\\);\\s*(.+?)\\s*&lt;&#x2F;script&gt; &#39;, response.content.decode(&#39;GBK&#39;)) # print(result) # 我希望执行js时候, 返回真正要执行的js # 把 &#96;eval(&quot;qo&#x3D;eval;qo(po);&quot;)&#96; 替换为 return po func_str &#x3D; result[0][1] func_str &#x3D; func_str.replace(&#39;eval(&quot;qo&#x3D;eval;qo(po);&quot;)&#39;, &#39;return po&#39;) # print(func_str) # 获取执行js的环境 context &#x3D; js2py.EvalJs() # 加载(执行) func_str context.execute(func_str) # 执行这个方法, 生成我们需要的js # code &#x3D; gv(50) context.execute(&#39;code &#x3D; &#123;&#125;;&#39;.format(result[0][0])) # 打印最终生成的代码 # print(context.code) cookie_str &#x3D; re.findall(&quot;document.cookie&#x3D;&#39;(.+?); &quot;, context.code)[0] # print(cookie_str) headers[&#39;Cookie&#39;] &#x3D; cookie_str response &#x3D; requests.get(url, headers&#x3D;headers) return response.content.decode(&#39;GBK&#39;) else: return response.content.decode(&#39;GBK&#39;) 运行爬虫模块run_spiders 创建RunSpider类 提供一个运行爬虫的run方法 根据配置文件信息, 加载爬虫, 把爬虫对象放到列表中 遍历爬虫对象列表, 获取代理, 检测代理(代理IP检测模块), 写入数据库(数据库模块) 使用异步来执行每一个爬虫任务 每隔一定的时间, 执行一次爬取任务 settings配置RUN_SPIDERS_INTERVAL作为爬虫运行时间间隔的配置, 单位为小时 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class RunSpider(object): def __init__(self): # 创建MongoPool对象 self.mongo_pool &#x3D; MongoPool() # 3.1 在init方法中创建协程池对象 self.coroutine_pool &#x3D; Pool() def get_spider_from_settings(self): &quot;&quot;&quot;根据配置文件信息, 获取爬虫对象列表.&quot;&quot;&quot; # 遍历配置文件中爬虫信息, 获取每个爬虫全类名 for full_class_name in PROXIES_SPIDERS: # core.proxy_spider.proxy_spiders.Ip66Spider # 获取模块名 和 类名 module_name, class_name &#x3D; full_class_name.rsplit(&#39;.&#39;, maxsplit&#x3D;1) # 根据模块名, 导入模块 module &#x3D; importlib.import_module(module_name) # 根据类名, 从模块中, 获取类 cls &#x3D; getattr(module, class_name) # 创建爬虫对象 spider &#x3D; cls() # print(spider) yield spider def run(self): # 2.1 根据配置文件信息, 获取爬虫对象列表. spiders &#x3D; self.get_spider_from_settings() # 2.2 遍历爬虫对象列表, 获取爬虫对象, 遍历爬虫对象的get_proxies方法, 获取代理IP for spider in spiders: # 2.5 处理异常, 防止一个爬虫内部出错了, 影响其他的爬虫. # 3.3 使用异步执行这个方法 # self.__execute_one_spider_task(spider) self.coroutine_pool.apply_async(self.__execute_one_spider_task,args&#x3D;(spider, )) # 3.4 调用协程的join方法, 让当前线程等待 协程 任务的完成. self.coroutine_pool.join() def __execute_one_spider_task(self, spider): # 3.2 把处理一个代理爬虫的代码抽到一个方法 # 用于处理一个爬虫任务的. try: # 遍历爬虫对象的get_proxies方法, 获取代理I for proxy in spider.get_proxies(): # print(proxy) # 2.3 检测代理IP(代理IP检测模块) proxy &#x3D; check_proxy(proxy) # 2.4 如果可用,写入数据库(数据库模块) # 如果speed不为-1, 就说明可用 if proxy.speed !&#x3D; -1: # 写入数据库(数据库模块) self.mongo_pool.insert_one(proxy) except Exception as ex: logger.exception(ex) @classmethod def start(cls): # 4. 使用schedule模块, 实现每隔一定的时间, 执行一次爬取任务 # 4.1 定义一个start的类方法 # 4.2 创建当前类的对象, 调用run方法 rs &#x3D; RunSpider() rs.run() # 4.3 使用schedule模块, 每隔一定的时间, 执行当前对象的run方法 # 4.3.1 修改配置文件, 增加爬虫运行时间间隔的配置, 单位为小时 schedule.every(RUN_SPIDERS_INTERVAL).hours.do(rs.run) while True: schedule.run_pending() time.sleep(1) 检测模块proxy_test 创建ProxyTester类，检查代理IP可用性, 保证代理池中代理IP基本可用 提供一个 run 方法, 用于处理检测代理IP核心逻辑 从数据库中获取所有代理IP 遍历代理IP列表 检查代理可用性 如果代理不可用, 让代理分数-1, 如果代理分数等于0就从数据库中删除该代理, 否则更新该代理IP 如果代理可用, 就恢复该代理的分数, 更新到数据库中 为了提高检查的速度, 使用异步来执行检测任务 把要检测的代理IP, 放到队列中 把检查一个代理可用性的代码, 抽取到一个方法中; 从队列中获取代理IP, 进行检查; 检查完毕, 调度队列的task_done方法 通过异步回调, 使用死循环不断执行这个方法, 开启多个一个异步任务, 来处理代理IP的检测; 可以通过配置文件指定异步数量 使用schedule模块, 每隔一定的时间, 执行一次检测任务 定义类方法 start, 用于启动检测模块 在start方法中 创建本类对象 调用run方法 每间隔一定时间, 执行一下, run方法 setting.py 文件, 检查代理IP可用性间隔时间的配置 RUN_SPIDERS_INTERVAL = 2 # 修改配置文件, 增加爬虫运行时间间隔的配置, 单位为小时TEST_PROXIES_ASYNC_COUNT = 10 # 配置检测代理IP的异步数量TEST_PROXIES_INTERVAL = 2 # 配置检查代理IP的时间间隔, 单位是小时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class ProxyTester(object): def __init__(self): # 创建操作数据库的MongoPool对象 self.mongo_pool &#x3D; MongoPool() # 3.1 在&#96;init&#96;方法, 创建队列和协程池 self.queue &#x3D; Queue() self.coroutine_pool &#x3D; Pool() def __check_callback(self, temp): self.coroutine_pool.apply_async(self.__check_one_proxy, callback&#x3D;self.__check_callback) def run(self): # 提供一个 run 方法, 用于处理检测代理IP核心逻辑 # 2.1 从数据库中获取所有代理IP proxies &#x3D; self.mongo_pool.find_all() # 2.2 遍历代理IP列表 for proxy in proxies: # 3.2 把要检测的代理IP, 放到队列中 self.queue.put(proxy) # 3.5 开启多个一个异步任务, 来处理代理IP的检测; 可以通过配置文件指定异步数量 for i in range(TEST_PROXIES_ASYNC_COUNT): # 3.4 通过异步回调, 使用死循环不断执行这个方法, self.coroutine_pool.apply_async(self.__check_one_proxy, callback&#x3D;self.__check_callback) # 让当前线程, 等待队列任务完成 self.queue.join() def __check_one_proxy(self): # 检查一个代理IP的可用性 # 3.3 把检查一个代理可用性的代码, 抽取到一个方法中; # 从队列中获取代理IP, 进行检查; 检查完毕 proxy &#x3D; self.queue.get() # 2.3 检查代理可用性 proxy &#x3D; check_proxy(proxy) # 2.4 如果代理不可用, 让代理分数-1, if proxy.speed &#x3D;&#x3D; -1: proxy.score -&#x3D; 1 # 如果代理分数等于0就从数据库中删除该代理 if proxy.score &#x3D;&#x3D; 0: self.mongo_pool.delete_one(proxy) else: # 否则更新该代理IP self.mongo_pool.update_one(proxy) else: # 2.5 如果代理可用, 就恢复该代理的分数, 更新到数据库中 proxy.score &#x3D; MAX_SCORE self.mongo_pool.update_one(proxy) # 调度队列的task_done方法 self.queue.task_done() @classmethod def start(cls): # 4.2.1 创建本类对象 proxy_tester &#x3D; cls() # 4.2.2 调用run方法 proxy_tester.run() # 4.2.3 每间隔一定时间, 执行一下, run方法 schedule.every(TEST_PROXIES_INTERVAL).hours.do(proxy_tester.run) while True: schedule.run_pending() time.sleep(1) API模块proxy_api 创建ProxyApi类，为爬虫提供高可用代理IP的服务接口 实现初始方法 初始一个Flask的Web服务 实现根据协议类型和域名, 提供随机的获取高可用代理IP的服务 可用通过 protocol 和 domain 参数对IP进行过滤 protocol: 当前请求的协议类型 domain: 当前请求域名 实现根据协议类型和域名, 提供获取多个高可用代理IP的服务 可用通过protocol 和 domain 参数对IP进行过滤 实现给指定的IP上追加不可用域名的服务 如果在获取IP的时候, 有指定域名参数, 将不在获取该IP, 从而进一步提高代理IP的可用性. 实现run方法, 用于启动Flask的WEB服务 实现start的类方法, 用于通过类名, 启动服务 settings中配置PROXIES_MAX_COUNT配置获取的代理IP最大数量; 这个越小可用性就越高; 但是随机性越差 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class ProxyApi(object): def __init__(self): # 2. 实现初始方法 # 2.1 初始一个Flask的Web服务 self.app &#x3D; Flask(__name__) # 创建MongoPool对象, 用于操作数据库 self.mongo_pool &#x3D; MongoPool() @self.app.route(&#39;&#x2F;random&#39;) def random(): &quot;&quot;&quot; localhost:6868&#x2F;random?protocol&#x3D;https&amp;domain&#x3D;jd.com 2.2 实现根据协议类型和域名, 提供随机的获取高可用代理IP的服务 可用通过 protocol 和 domain 参数对IP进行过滤 protocol: 当前请求的协议类型 domain: 当前请求域名 &quot;&quot;&quot; protocol &#x3D; request.args.get(&#39;protocol&#39;) domain &#x3D; request.args.get(&#39;domain&#39;) proxy &#x3D; self.mongo_pool.random_proxy(protocol, domain, count&#x3D;PROXIES_MAX_COUNT) if protocol: return &#39;&#123;&#125;:&#x2F;&#x2F;&#123;&#125;:&#123;&#125;&#39;.format(protocol, proxy.ip, proxy.port) else: return &#39;&#123;&#125;:&#123;&#125;&#39;.format(proxy.ip, proxy.port) @self.app.route(&#39;&#x2F;proxies&#39;) def proxies(): &quot;&quot;&quot; localhost:6868&#x2F;proxies?protocol&#x3D;https&amp;domain&#x3D;jd.com 2.3 实现根据协议类型和域名, 提供获取多个高可用代理IP的服务 可用通过protocol 和 domain 参数对IP进行过滤 实现给指定的IP上追加不可用域名的服务 &quot;&quot;&quot; # 获取协议: http&#x2F;https protocol &#x3D; request.args.get(&#39;protocol&#39;) # 域名: 如:jd.com domain &#x3D; request.args.get(&#39;domain&#39;) proxies &#x3D; self.mongo_pool.get_proxies(protocol, domain, count&#x3D;PROXIES_MAX_COUNT) # proxies 是一个 Proxy对象的列表, 但是Proxy对象不能进行json序列化, 需要转换为字典列表 # 转换为字典列表 proxies &#x3D; [proxy.__dict__ for proxy in proxies] # 返回json格式值串 return json.dumps(proxies) @self.app.route(&#39;&#x2F;disable_domain&#39;) def disable_domain(): &quot;&quot;&quot; localhost:6868&#x2F;disable_domain?ip&#x3D;120.92.174.12&amp;domain&#x3D;jd.com 2.4 如果在获取IP的时候, 有指定域名参数, 将不在获取该IP, 从而进一步提高代理IP的可用性. &quot;&quot;&quot; ip &#x3D; request.args.get(&#39;ip&#39;) domain &#x3D; request.args.get(&#39;domain&#39;) if ip is None: return &#39;请提供ip参数&#39; if domain is None: return &#39;请提供域名domain参数&#39; self.mongo_pool.disable_domain(ip, domain) return &quot;&#123;&#125; 禁用域名 &#123;&#125; 成功&quot;.format(ip, domain) def run(self): &quot;&quot;&quot;3. 实现run方法, 用于启动Flask的WEB服务&quot;&quot;&quot; self.app.run(&#39;0.0.0.0&#39;, port&#x3D;6868) @classmethod def start(cls): # 4. 实现start的类方法, 用于通过类名, 启动服务 proxy_api &#x3D; cls() proxy_api.run() 启动入口main 定义一个run方法用于启动动代理池，开启三个进程, 分别用于启动爬虫, 检测代理IP, WEB服务 定义一个列表, 用于存储要启动的进程 创建 启动爬虫 的进程, 添加到列表中 创建 启动检测 的进程, 添加到列表中 创建 启动提供API服务 的进程, 添加到列表中 遍历进程列表, 启动所有进程 遍历进程列表, 让主进程等待子进程的完成 在 if __name__ == &#39;__main__&#39;: 中调用run方法 12345678910111213141516171819202122def run(): # 1. 定义一个列表, 用于存储要启动的进程 process_list &#x3D; [] # 2. 创建 启动爬虫 的进程, 添加到列表中 process_list.append(Process(target&#x3D;RunSpider.start)) # 3. 创建 启动检测 的进程, 添加到列表中 process_list.append(Process(target&#x3D;ProxyTester.start)) # 4. 创建 启动提供API服务 的进程, 添加到列表中 process_list.append(Process(target&#x3D;ProxyApi.start)) # 5. 遍历进程列表, 启动所有进程 for process in process_list: # 设置守护进程 process.daemon &#x3D; True process.start() # 6. 遍历进程列表, 让主进程等待子进程的完成 for process in process_list: process.join()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: run() 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"requests","slug":"requests","permalink":"http://onejane.github.io/tags/requests/"},{"name":"pymongo","slug":"pymongo","permalink":"http://onejane.github.io/tags/pymongo/"},{"name":"flask","slug":"flask","permalink":"http://onejane.github.io/tags/flask/"}]},{"title":"爬虫基础篇之页面请求解析","slug":"爬虫基础篇之页面请求解析","date":"2021-03-30T08:09:50.000Z","updated":"2021-12-12T03:09:39.334Z","comments":true,"path":"2021/03/30/爬虫基础篇之页面请求解析/","link":"","permalink":"http://onejane.github.io/2021/03/30/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 CSS选择器html中为指定元素指定显示效果，比如颜色，背景，字体等不同的属性，这些样式都是通过css选择器告诉浏览器指定样式风格。 表达式 含义 #animal 获取id为animal的所有元素 .animal 获取class为animal的所有元素 a.active 获取类为active的a标签 .animal &gt; .pig 获取类animal直接子元素中类为.pig的元素 .animal .pig 获取类animal后代元素中类为.pig的元素 a[href*=”animal”] 获取包含类animal的a元素 a[href^=”http”] 获取href以http开头的a元素 a[href$=”gov.cn”] 获取href以gov.cn结尾的a元素 div[class=”animal”][ctype=”pig”] 获取多属性同时具备的元素 div &gt; a:nth-child(2) 获取div下的第二个a元素 .pig , .animal 同时选择两个class的所有元素 p:nth-last-child(1) 获取倒数第一个p元素 p:nth-child(even) p:nth-child(odd) 获取奇数偶数节点 h3 + span 获取h3 后面紧跟着的兄弟节点 span h3 ~ span 获取h3 后面所有的兄弟节点 span 实战链家目标抓取网站：https://su.lianjia.com/ershoufang/pg 抓取内容：分页抓取二手房的标题，地址，信息，关注量，标签，总价，单价等 分析 通过获取网页源代码发现所有的二手房信息都直接渲染在页面上，那么可以直接请求页面地址分析二手房源码后，通过parsel库parsel.Selector(html_data)转为我们可以使用选择器分析的对象。 通过css选择器.clear.LOGCLICKDATA拿到所有的二手房信息所在的li元素 在li元素下可以css选择器获取所有的.title a::text标题，.positionInfo a::text地址，.followInfo::text关注量等信息。 1234567891011121314selector &#x3D; parsel.Selector(html_data)lis &#x3D; selector.css(&#39;.clear.LOGCLICKDATA&#39;)for li in lis: title &#x3D; li.css(&#39;.title a::text&#39;).get() # 标题 address &#x3D; li.css(&#39;.positionInfo a::text&#39;).getall() # 地址 address &#x3D; &#39;,&#39;.join(address) houseInfo &#x3D; li.css(&#39;.houseInfo::text&#39;).get() # 信息 followInfo &#x3D; li.css(&#39;.followInfo::text&#39;).get() # 关注 tags &#x3D; li.css(&#39;.tag span::text&#39;).get() # 标签 tags &#x3D; &#39;,&#39;.join(tags) totalPrice &#x3D; li.css(&#39;.totalPrice span::text&#39;).get() + &#39;万&#39; # 总价 unitePrice &#x3D; li.css(&#39;.unitPrice span::text&#39;).get() # 单价 title_url &#x3D; li.css(&#39;.title a::attr(href)&#39;).get() # 标题 print(title, address, houseInfo, followInfo, tags, totalPrice, unitePrice, title_url, sep&#x3D;&quot;---&quot;) 爬取完成点击下一页的时候，页面url添加了路径参数pg{}，那么可以通过加该字段实现分页抓取。 猫眼电影分析目标抓取网站：https://maoyan.com/board 抓取内容：热映口碑榜的电影名，主演，上映时间等。 老规矩，查看网页源代码电影数据完整返回给前端，没有做异步请求。那么直接访问猫眼的热映口碑榜通过parsel库解析成Selector对象，开始利用css选择器分析页面字段。 通过控制台源码发现类.board-wrapper下dd元素包含了所有的电影信息，那么遍历其下的标签列表根据css选择器筛选拿到需要的数据即可。 1234567891011121314selector &#x3D; parsel.Selector(html_data)print(selector)dds &#x3D; selector.css(&#39;.board-wrapper dd&#39;)for dd in dds: title &#x3D; dd.css(&#39;.name a::attr(title)&#39;).get() star &#x3D; dd.css(&#39;.star::text&#39;).get().strip() releasetime &#x3D; dd.css(&#39;.releasetime::text&#39;).get() score &#x3D; dd.css(&#39;.score i::text&#39;).getall() score &#x3D; &#39;&#39;.join(score) print(title, star, releasetime, score) with open(&#39;maoyan.csv&#39;, mode&#x3D;&#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;, newline&#x3D;&#39;&#39;) as f: csv_write &#x3D; csv.writer(f) csv_write.writerow([title, star, releasetime, score]) 爬取完成 喜马拉雅分析目标网站：https://www.ximalaya.com/xiangsheng/9723091 抓取内容：下载当前主题的所有页面的音频文件。 老规矩，查看网页源代码发现所有的音频标签会在当前页面ur后添加音频的id跳转到一个新的页面，如：https://www.ximalaya.com/xiangsheng/9723091/45982355 点击播放后，控制台的Media出现请求的音频地址,如：https://aod.cos.tx.xmcdn.com/group31/M01/36/04/wKgJSVmC6drBDNayAh_Q8WincwI414.m4a 通过控制台搜索音频关键字段，找到返回音频地址的请求https://www.ximalaya.com/revision/play/v1/audio?id=46106992&amp;ptype=1 该请求参数由音频id和ptype=1组成，通过css选择器.sound-list li.lF_ a::attr(href)分析列表页的音频的href拿到音频id，通过css选择器.sound-list li.lF_ a::attr(title)拿到音频标题。点击下一页发现只是在原url后添加p{page}字段，综上通过open函数写入音频文件完成下载。 12345678910111213141516171819202122titles &#x3D; selector.css(&#39;.sound-list li.lF_ a::attr(title)&#39;).getall()href &#x3D; selector.css(&#39;.sound-list li.lF_ a::attr(href)&#39;).getall()# zip() 可以讲两个列表进行打包, 遍历之后 是一个元组data &#x3D; zip(titles, href)for index in data: title &#x3D; index[0] mp3_id &#x3D; index[1].split(&#39;&#x2F;&#39;)[-1] # f&#39;&#123;mp3_id&#125;&#39; &#39;&#123;&#125;&#39;.format(mp3_id) 字符串格式化方法 index_url &#x3D; f&#39;https:&#x2F;&#x2F;www.ximalaya.com&#x2F;revision&#x2F;play&#x2F;v1&#x2F;audio?id&#x3D;&#123;mp3_id&#125;&amp;ptype&#x3D;1&#39; response_1 &#x3D; requests.get(url&#x3D;index_url, headers&#x3D;headers) # 什么是json数据 字典嵌套字典 还嵌套一些列表 # json数据取值和字典取值方式是一样的 根据关键词提取内容 通俗的讲 就是根据左边的内容提取右边的内容 # print(response_1.text) mp3_url &#x3D; response_1.json()[&#39;data&#39;][&#39;src&#39;] print(title, mp3_url) # 保存数据 # 保存数据: 如果是图片&#x2F;音频&#x2F;视频 等 都是要获取它的二进制数据,要以二进制的数据保存 mp3_content &#x3D; requests.get(url&#x3D;mp3_url).content # 相对路径 with open(&#39;相声\\\\&#39; + title + &#39;.mp3&#39;, mode&#x3D;&#39;wb&#39;) as f: f.write(mp3_content) print(&#39;正在保存: &#39;, title) 爬取完成 XPATH选择器XPath (XML Path Language) 是由国际标准化组织W3C指定的，用来在 XML 和 HTML 文档中选择节点的语言。目前主流浏览器 (chrome、firefox，edge，safari) 都支持XPath语法，xpath有 1 和 2 两个版本，目前浏览器支持的是 xpath 1的语法，且比CSS选择器功能更强大。 表达式 含义 /html/body/div 选择根节点html下面的body下面的div元素，/从子节点找，//从所有子节点包括子节点的子节点中找 //div/* 所有div节点下所有元素 //*[@id=’west’] id为west的元素 //select[@class=’single_choice’] class为single_choice的select元素 //p[@class=”capital huge-city”] 多元素组合选择 //*[@multiple] 具有multiple属性的元素 //*[contains(@style,’color’)] style包含color的元素 //*[starts-with(@style,’color’)] 以style是color开头的元素，//*[ends-with(@style,’color’)]结尾元素 //div/p[2] 所有div下的第二个p标签 //p[last()] 最后一个p元素 //div/p[last()-2] 所有div下倒数第三个p元素 //option[position()&lt;=2] option类型的第1-2个元素 //*[@class=’multi_choice’]/*[position()&gt;=last()-2] 选择class属性为multi_choice的后3个子元素 //option|//h4 所有的option元素 和所有的 h4 元素 //*[@id=’china’]/.. 选择 id 为 china 的节点的父节点 //*[@id=’china’]/../../.. 上上父节点 //*[@class=’single_choice’]/following-sibling::div 选择后续节点中的div节点 等同于CSS选择器.single_choice ~ * //[@class=’single_choice’]/preceding-sibling:: 前面兄弟节点 实战新笔趣阁分析目标网站：http://www.xbiquge.la/10/10489/ 抓取内容：抓取三寸人间所有章节的文章保存。 章节列表只有小说章节信息，点击每个章节跳转到章节页面，通常xpath表达式//div[@id=&quot;info&quot;]/h1/text()拿到书籍名称，所有的章节都依赖于于id为list的div下的dl下的dd下的a标签的href属性跳转到章节页面。 拼接主域名http://www.xbiquge.la即可跳转到章节详情页面，通过xpath表达式//*[@id=&quot;content&quot;]/text()拿到详情页面小说的完整内容 1234567891011121314151617181920212223242526272829303132# 开文件流 打开一个文件 把我们数据写入到文件中去 a是追加写入 写入完第一章就继续追加写入第二章with open(book_name + &#39;.txt&#39;, &#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;)as f: f.write(book_name+&#39;\\n&#39;) # title 章节的名称 urls 每个章节的详情链接 # 遍历获取到该本书的每个章节和对应的内容详情链接 zip一次性遍历多个列表 for title,urls in zip(book_title,book_url): c_url&#x3D;&#39;http:&#x2F;&#x2F;www.xbiquge.la&#39;+urls print(title) print(c_url) # 异常处理 try: #捕捉异常 #参数1：单个章节的url:以获取到这个章节的小说内容的html源码 参数2：headers 参数3：请求等待时间3秒 titles_url &#x3D; requests.get(c_url, headers&#x3D;headers, timeout&#x3D;3).content.decode(&#39;utf-8&#39;) except: # 如果捕捉异常怎么办 请求失败那就再请求一遍 titles_url &#x3D; requests.get(c_url, headers&#x3D;headers).content.decode(&#39;utf-8&#39;) # 那我们还差一个小说文本内容对不对 那每个章节链接我们有了 # 每个章节里面的内容是不是好解决 一样xpath语法给他获取下来 # 通过xpath获取到小说文本内容 book_content &#x3D; etree.HTML(titles_url).xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;content&quot;]&#x2F;text()&#39;) f.write(title) # 先写入章节名称 f.write(&#39;\\n&#39;) # f.write不能够写列表，但可以写字符串格式（二进制）。。。 所以要for循环 for line in book_content: f.write(line) # 再写入章节对应的内容 f.write(&#39;\\n&#39;) # 每写完一章换行 一共1000多个章节 爬取完成 其实很多情况下不需要自己去分析dom节点定位css或xpath表达式，chrome已经为我们集成了插件。 JSON很多情况页面不直接返回html或xml文本元素，或者这些文本分析起来很困难的情况下，可以通过控制台中的xhr模式抓取后端请求回来的json数据，直接解析json即可拿到想要的数据。 实战拉勾分析目标网站：https://www.lagou.com/jobs/list_C%2B%2B?labelWords=&amp;fromSearch=true&amp;suginput= 抓取内容：抓取首页职位地址，公司名，规模等信息保存。 搜索C++后，打开控制台将结果中的带薪年假搜索拿到实际请求路径https://www.lagou.com/jobs/positionAjax.json?needAddtionalResult=false，该请求是post请求，参数如下 12345data &#x3D; &#123; &quot;first&quot;: &quot;true&quot;, &quot;pn&quot;: &quot;1&quot;, &quot;kd&quot;: &quot;C++&quot;&#125; 通过控制台Preview分析返回的json数据，data[&#39;content&#39;][&#39;positionResult&#39;][&#39;result&#39;]即为职位信息 不过当我们直接请求时会报dtacess deny,可能对请求头中的参数做了校验。 12345678Traceback (most recent call last): File &quot;F:&#x2F;MyProject&#x2F;CrawlerBase&#x2F;lagou&#x2F;lagou.py&quot;, line 21, in &lt;module&gt; result &#x3D; data[&#39;content&#39;][&#39;positionResult&#39;][&#39;result&#39;]KeyError: &#39;content&#39;&#123;&#39;clientIp&#39;: &#39;61.155.198.*&#39;, &#39;msg&#39;: &#39;dtaccess deny &#39;, &#39;state&#39;: 2410, &#39;status&#39;: False&#125; 我们将Cookie和User-Agent加入header后，即可以完整请求到json数据，进行数据分析。 123456789101112131415161718resp &#x3D; requests.post(api_url, headers&#x3D;headers)pprint(resp.json())data &#x3D; resp.json()result &#x3D; data[&#39;content&#39;][&#39;positionResult&#39;][&#39;result&#39;]# [print(r) for r in result]for r in result: d &#x3D; &#123; &#39;city&#39;: r[&#39;city&#39;], &#39;companyFullName&#39;: r[&#39;companyFullName&#39;], &#39;companySize&#39;: r[&#39;companySize&#39;], &#39;education&#39;: r[&#39;education&#39;], &#39;positionName&#39;: r[&#39;positionName&#39;], &#39;salary&#39;: r[&#39;salary&#39;], &#39;workYear&#39;: r[&#39;workYear&#39;] &#125; with open(&#39;拉钩职位.csv&#39;,mode&#x3D;&#39;a&#39;,encoding&#x3D;&#39;utf-8&#39;) as f: f.write(&quot;,&quot;.join(d.values())) f.write(&quot;\\n&quot;) 爬取完成 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"xpath","slug":"xpath","permalink":"http://onejane.github.io/tags/xpath/"},{"name":"css","slug":"css","permalink":"http://onejane.github.io/tags/css/"},{"name":"json","slug":"json","permalink":"http://onejane.github.io/tags/json/"}]},{"title":"爬虫基础篇之多线程实现","slug":"爬虫基础篇之多线程实现","date":"2021-03-28T00:18:03.000Z","updated":"2021-12-12T03:09:39.333Z","comments":true,"path":"2021/03/28/爬虫基础篇之多线程实现/","link":"","permalink":"http://onejane.github.io/2021/03/28/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 执行流程python并不像java这类高级语言需要将文件编译为机器码交给虚拟机执行，而是由python虚拟机一条条地将py语句解释运行，故而称之为解释型语言。 python先将py文件编译成字节码，交给字节码虚拟机后，虚拟机从编译得到的PyCodeObject对象在当前的上下文环境逐条执行字节码指令，完成整个程序的执行流程。 字节码在python虚拟机程序里对应的是PyCodeObject对象， .pyc文件是字节码在磁盘上的表现形式。 例如：在python test.py过程中会将test.py进行编译成字节码并解释执行，当test.py中加载了其他模块，如import urllib2，python会将urllib2.py进行编译成字节码，生成urllib2.pyc，并重新对字节码解释执行。加载模块时，当.py和.pyc同时存在时，优先运行.pyc文件，若.pyc文件比.py编译时间早，执行流程也会优先重新编译.py文件并更新.pyc文件。 .pyc文件通过内置模块py_compile来编译生成test.pyc,或者通过python -m test.py生成test.pyc GIL由于物理上的科技发展，各CPU厂商在核心频率上已经被多核CPU所取代，为了更有效的利用多核处理器的性能，就出现了多线程的编程技巧，又因为Python GIL的存在让Python虚拟机在进行运算时无法有效利用多核心，几乎只能单线程处理任务，所以将任务并行化，分散到多个线程或多个进程的实现和GIL本身的存在是天生冲突的矛盾。 首先，GIL不是python的特性，是实现python解析器(CPython)时的语法标准，并不是python的特性，类似的还有JPython等就没有GIL，但是CPython是大部分环境下默认的Python执行环境，自然而然CPython==python，自然而然GIL成为的python天生的缺陷。 当多核CPU出现在市场的时候，python为了支持多线程，首要解决的就是线程之间的数据完整性和数据同步性，GIL应运而生，简单粗暴的为线程加上了一把大锁，后起之库们默认都接受了这种实现方案，省去考虑额外线程间的内存锁和同步操作，导致大量的三方库都极度依赖GIL来实现线程安全。GIL这把全局排他锁，是多线程处理的致命伤，效率极底，因为python的线程就是C的一个pthread，通过操作系统的调度算法调度，为在调度过程中各线程平均利用CPU的时间，python会计算已执行的代码量，达到阈值强制释放GIL锁，触发一次操作系统的调度。 任何一个线程在唤起时可以成功获取到GIL，但是多核CPU上，release和acquire几乎没有间隔，导致其他核上的线程被唤醒时，主线程已经再次拿到GIL，导致被唤醒的其他线程只能白白浪费CPU时间，眼睁睁看着另一个线程拿个GIL快乐的执行，当达到切换时间后进入待调度状态，再次唤醒再次等待，恶性循环。 多线程方案multiprocessing一定程度弥补了thread库由于GIL锁导致低效的缺陷，完整的实现了一套thread接口，但是只是使用了多进程而本身不是多进程，原理上每个进程有自己独立的GIL，不会出现进程间的GIL争抢，但是增加了线程间数据通讯和同步的麻烦，由于不同进程间无法看到对方的数据状态，只能在主线程声明一个队列，通过队列的实现解决数据本身的问题，无疑徒增的代码的开发与维护成本。 concurrent提供了多线程ThreadPoolExecutor和多进程ProcessPoolExecutor两种并发模型。 计算密集型任务永远最多只能榨干单核CPU，如果需要提升效率，必须通过ProcessPoolExecutor fork出多个子进程来分担计算任务。 IO密集型任务CPU使用效率极低，虽然使用多线程加倍CPU使用率，但是还远远到不了饱和(100%)的地步，在单核心可以应付整体计算的前提下，自然是应该选择资源占用少的模式，也就是多线程模式。主线程是通过队列将任务传递给多个子线程的。一旦主线程将任务塞进任务队列，子线程们就会开始争抢，最终只有一个线程能抢到这个任务，并立即进行执行，执行完后将结果放进Future对象就完成了这个任务的完整执行过程。 concurrent的线程池有个重大的缺陷，那就是任务队列是无界的。如果队列的生产者任务生产的太快，而线程池消费太慢处理不过来，任务就会堆积。如果堆积一直持续下去，内存就会持续增长直到OOM，任务队列里堆积的所有任务全部彻底丢失。 主线程将任务塞进TaskQueue(普通内存队列)，拿到Future对象 唯一的管理线程从TaskQueue获取任务，塞进CallQueue(分布式跨进程队列) 子进程从CallQueue中争抢任务进行处理 子进程将处理结果塞进ResultQueue(分布式跨进程队列) 管理线程从ResultQueue中获取结果，塞进Future对象 主线程从Future对象中拿到结果 进程池模型中的跨进程队列是用multiprocessing.Queue实现的。它使用无名套接字sockerpair来完成的跨进程通信，socketpair和socket的区别就在于socketpair不需要端口，不需要走网络协议栈，通过内核的套接字读写缓冲区直接进行跨进程通信。multiprocessing.Queue是支持双工通信，数据流向是父子双向，只不过在concurrent的进程池实现中只用到了单工通信。CallQueue是从父到子，ResultQueue是从子到父。 当父进程要传递任务给子进程时，先使用pickle将任务对象进行序列化成字节数组，然后将字节数组通过socketpair的写描述符写入内核的buffer中。子进程接下来就可以从buffer中读取到字节数组，然后再使用pickle对字节数组进行反序列化来得到任务对象，这样总算可以执行任务了。同样子进程将结果传递给父进程走的也是一样的流程，只不过这里的socketpair是ResultQueue内部创建的无名套接字。 实战doutula上文讲到通过分析页面元素分页抓取doutula表情包并保存图片的的案例，由于网络请求结果返回往往比IO存储图片要快，接下来通过多线程的方式实现在IO相对较慢的前提下使用多线程处理存储图片。核心代码如下： 123456789101112131415def main(page): &quot;&quot;&quot;函数入口&quot;&quot;&quot; for page in range(1, page + 1): print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正在爬去第&#123;&#125;页数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;.format(page)) # 定义最多 max_workers 个线程的线程池来异步执行调用。如果 max_workers 为 None 或没有指定，将默认为机器处理器的个数 thread_pool &#x3D; concurrent.futures.ThreadPoolExecutor(max_workers&#x3D;3) res &#x3D; send_request(&#39;https:&#x2F;&#x2F;www.doutula.com&#x2F;photo&#x2F;list&#x2F;?page&#x3D;&#123;&#125;&#39;.format(str(page))) # 封装解析函数 src_url &#x3D; parse_data(res.text) for file, url in src_url: image_response &#x3D; send_request(url) # 提交线程请求，save_data是封装保存函数，file和image_response.content是save_data的入参 thread_pool.submit(save_data, file, image_response.content) # 关闭线程池 thread_pool.shutdown() guazi同时执行多个线程的确可以提高程序效率，但并非线程越多越好，相对计算机而言，线程越多越吃资源，成百上千个线程可能直接瘫痪。故而多线程在运行时，设置最大线程锁，设置最大线程同时允许处理任务，多线程threading使用Semaphore(无上限)或BoundedSemaphore(初始设置最大值), 如果release调用检查计数器的值是否超过了计数器最大值则出ValueError 实现并发限制。 例如：通过semaphore信号量可以利用内置计数器来控制同时运行线程的数量，启动线程(消耗信号量)内置计数器会自动减一，线程结束(释放信号量)内置计数器会自动加一；内置计数器为零，启动线程会阻塞，直到有本线程结束或者其他线程结束为止; 以下我们对瓜子二手车数据进行多线程抓取，并保存到csv中。 分析当我们访问第一页时，https://www.guazi.com/su/buy/o1 当我们访问第二页时，https://www.guazi.com/su/buy/o2 以此类推，不难得出分页数据以start_url = &#39;https://www.guazi.com/su/buy/o&#39;+str(i)形式拼接，i为页码数，根据页面控制台的Elements分析所有的数据都存在于含有类carlist clearfix js-top的ul节点下的所有li节点下，我们可以通过解析得到html代码转化为bs4库的BeautifulSoup对象，利用BeautifulSoup的api获取这些li节点的元素属性，解析拿到类型，年份，里程，售价，具体BeautifulSoup语法出门右转见中文文档。 12345678910111213141516171819202122232425def get_data(html): # 将之前抓取的html页面解析生成BeautifulSoup对象 soup &#x3D; BeautifulSoup(html, &#39;html.parser&#39;) # 调用api获取含有类carlist clearfix js-top的ul节点下的所有li节点 infos &#x3D; soup.find(&#39;ul&#39;, &#123;&#39;class&#39;: &#39;carlist clearfix js-top&#39;&#125;).find_all(&#39;li&#39;) # 打开文件开始写入 with open(&#39;.&#x2F;guazi.csv&#39;, &#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;) as f: pic_urls &#x3D; [] for info in infos: leixing &#x3D; info.find(&#39;h2&#39;).get_text() nianfen1 &#x3D; info.find(&#39;div&#39;, &#123;&#39;class&#39;: &#39;t-i&#39;&#125;).get_text() # 通过正则分割年份字符串 nianfen2 &#x3D; re.sub(r&#39;|&#39;, &#39;&#39;, nianfen1).split(&#39;|&#39;) nianfen &#x3D; nianfen2[0] licheng &#x3D; nianfen2[1] didian &#x3D; &#39;苏州&#39; shoujia &#x3D; info.find(&#39;div&#39;, &#123;&#39;class&#39;: &#39;t-price&#39;&#125;).find(&#39;p&#39;).get_text() try: yuanjia &#x3D; info.find(&#39;div&#39;, &#123;&#39;class&#39;: &#39;t-price&#39;&#125;).find(&#39;em&#39;).get_text() except AttributeError: yuanjia &#x3D; &#39;&#39; tupian &#x3D; info.find(&#39;a&#39;).find(&#39;img&#39;)[&#39;src&#39;] pic_urls.append(tupian) f.write(&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;\\n&quot;.format(leixing, nianfen, licheng, didian, shoujia, yuanjia)) return pic_urls get_data拿到所有的数据属性后，接下来通过含有信号量的多线程方式调用封装好的download_pics方法批量抓取图片。 1234567891011121314# 定义最多10个线程同时允许thread_lock &#x3D; threading.BoundedSemaphore(value&#x3D;10)def main(): n &#x3D; 0 for i in range(1,51): start_url &#x3D; &#39;https:&#x2F;&#x2F;www.guazi.com&#x2F;su&#x2F;buy&#x2F;o&#39;+str(i) html &#x3D; getHtmlText(start_url) pic_urls &#x3D; get_data(html) for url in pic_urls: n+&#x3D;1 print(&#39;正在下载第&#123;&#125;张图片&#39;.format(n)) # 上锁 避免下载同一张 thread_lock.acquire() t &#x3D; threading.Thread(target&#x3D;download_pics,args&#x3D;(url,n)) 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","permalink":"http://onejane.github.io/tags/ThreadPoolExecutor/"},{"name":"BoundedSemaphore","slug":"BoundedSemaphore","permalink":"http://onejane.github.io/tags/BoundedSemaphore/"}]},{"title":"爬虫基础篇之基本库的使用","slug":"爬虫基础篇之基本库的使用","date":"2021-03-28T00:18:03.000Z","updated":"2021-12-12T03:09:39.332Z","comments":true,"path":"2021/03/28/爬虫基础篇之基本库的使用/","link":"","permalink":"http://onejane.github.io/2021/03/28/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 爬虫介绍爬虫目的 大数据时代所谓的人工智能都需要建立海量基础的数据上，一切一切的分析都是一数据为基础核心，那么对于企业来说，合理采集数据是既节省成本同时间也可以完成业务分析的捷径。 企业需要大量数据进行测试，对网站或app的负载，流量，服务器的CPU进行测试，采集数据是保证大数据量业务上线正常流转的必备前提。 所有搜索引擎的底层都是一个个的自动化爬虫，在海量的互联网信息中进行分析处理收录。 各大企业都希望自己的产品搜索靠前，对于SEO来说，除了充钱，足够了解爬虫可以从原理上实现搜索引擎的工作原理，实现SEO优化。 从技术层面来说，爬虫虽不是成体系型的一种技术栈，不过技术涉及领域极光，包括html解析，js逆向，安卓底层逆向，汇编分析，反爬虫与反反爬虫的对抗等等，其实以上也属于网络安全层的一个方向，文明爬虫，技术无罪。 什么是最好的语言当之无愧强类型语言Python，毋庸置疑，一来Python的三方库种类繁多且爬虫框架日新月异，请求与解析模块成熟，且拥有很多有趣的语法糖可以快速处理数据。相对于代码量臃肿的java来说语法简单，学习曲线短，因为java需要jvm虚拟机的编译成字节码的过程，对于爬虫来讲，Python免编译即可跨平台运行，且基于C++更接近底层，性能在一定程度上领超java，故优先选择python(别跟我提php)。 当然玩到最后语言只是一种实现方式而已，只是这些路都通往罗马，哪条在实际场景中更方便到达而已。比如：安卓逆向过程hook框架中，xposed和frida是我们的首选，两者各有优劣，视不同场景而定。 Xposed是一个在andoid平台上比较成熟的hook框架，可以完美的在dalvik虚拟机上做到hook任意java方法，配置安装环境繁琐，兼容性差，无法对native层实现底层注入。 Frida是一个跨平台的hook框架，可以hook Java和native层，且不需要每次都重启手机，需要我们手动将java的语法转为frida的实现方式，无法像Xposed用于实践生产中。 爬虫路对抗现状 这是一张老图，当然现在很多网站在请求头中实现了对selenium，phantomjs底层的api监控，总之，道高一尺魔高一丈，攻防之间，其乐无穷。 实战话不多说，直接开干。鲁迅曾经说过，他在爬虫生涯中超过一半的苦难均由Windows赐予，所以我建议还是用kali或者ubuntu吧，如果嫌麻烦，就退一步用centos吧，当然你用windows出现的问题需要自行google解决，基础篇目测应该不存在，用windows可以直接跳到doutula内容。 服务器搭建这里就不聊kali或者ubuntu在虚拟机的搭建了，简单介绍一下使用vagrant创建centos虚拟机吧， 进入vagrant官网，vagrant安装好后进入镜像仓库搜索需要安装的镜像。 mkdir centos7 &amp;&amp; vagrant init centos/7 &amp;&amp; vagrant up &amp;&amp; vagrant ssh 创建并开启镜像，自动生成Vagrantfile，默认网络nat，初始配置如下 config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot; 配置NAT网络，选其一即可config.vm.network &quot;public_network&quot;, ip: &quot;192.168.0.102&quot; 配置桥接网络 yum list installed | grep openssh-server 确保安装了 openssh-server，否则yum install openssh-server vi /etc/ssh/sshd_config 并注释#PasswordAuthentication yes,打开Port,ListenAddress,PermitRootLoin,PasswordAuthentication执行service sshd restart 实现远程连接 安装nodejs并配置淘宝源npm config set registry http://registry.npm.taobao.org/ 多环境配置由于python2已经废弃维护，往后皆基于python3实战开发。进入python官网下载python 3.7.0，或者通过清华大学源下载anaconda 5.3.1会自动下载常用库。 为了避免不同项目间引用的依赖包冲突，我们将不同项目维护不同的环境。 123456789101112yum install -y wget zlib-devel gcc bzip2-devel openssl-devel libffi-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel net-tools ftp vsftpd 安装常用包mkdir &#x2F;usr&#x2F;local&#x2F;python3 由于默认centos已经有了python2，避免环境冲突，配置多环境python3wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.7.0&#x2F;Python-3.7.0.tgz 下载python3的包tar zxf Python-3.7.0.tgz 解压cd Python-3.7.0&#x2F; &amp;&amp; .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3 编译make &amp;&amp; make installvim &#x2F;etc&#x2F;profile 配置环境变量PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;export PATHsource &#x2F;etc&#x2F;profileln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3 配置软链接ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip3 12345678910pip3 install --upgrade pippip install virtualenvwrapper 安装虚拟环境vim ~&#x2F;.bashrc 配置环境变量VIRTUALENVWRAPPER_PYTHON&#x3D;&#x2F;usr&#x2F;bin&#x2F;python3export WORKON_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;python3&#x2F;venvsource ~&#x2F;.bashrc 编译mkvirtualenv --python&#x3D;&#x2F;usr&#x2F;bin&#x2F;python3 baseSpider 指定python3创建名为baseSpider环境mkvirtualenv --python&#x3D;&#x2F;usr&#x2F;bin&#x2F;python2 baseSpider2 指定python2创建名为baseSpider2环境workon baseSpider 进入baseSpider环境deactivate 退出环境 doutula这是一个表情包网站，本次就以本网站的最新表情页面作为案例。 ctrl+u获取网页源代码，发现本页面所有的表情包都以html表情直接显示在页面上，那么只需要使用requests库请求URL，parsel库来解析页面，通过xpath或者css选择器获取页面元素。 通过点击分页，该页面的url会跳转时添加page参数，从https://www.doutula.com/photo/list/变成https://www.doutula.com/photo/list/?page=2,重新向服务器发起请求。 1234import requestsbase_url &#x3D; &#39;https:&#x2F;&#x2F;www.doutula.com&#x2F;photo&#x2F;list&#x2F;&#39;response &#x3D; requests.get(url&#x3D;base_url)print(response.content) 打印出来的结果是b&#39;&lt;html&gt;\\r\\n&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;\\r\\n&lt;body bgcolor=&quot;white&quot;&gt;\\r\\n&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;\\r\\n&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;\\r\\n&lt;/body&gt;\\r\\n&lt;/html&gt;\\r\\n&#39;,说明做了反爬，可能对请求头的参数做了校验。先尝试将User-Agent加入请求头中，再次发起请求。 123456import requestsbase_url &#x3D; &#39;https:&#x2F;&#x2F;www.doutula.com&#x2F;photo&#x2F;list&#x2F;?page&#x3D;&#123;&#125;&#39;.format(1)headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&#39;&#125;response &#x3D; requests.get(url&#x3D;base_url, headers&#x3D;headers)print(response.content) 果然将页面内容完整打印出来，所有的图片地址也都明文显示在页面上。通过分析页面上的图片元素的dom节点，所有的图片节点都存在于类col-xs-6 col-sm-3的a标签下的img元素，通过xpath表达式可以取出这些元素下的属性，包括图片地址data-original，说明alt等。 12345678910111213for page in range(1,3466): print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正在爬去第&#123;&#125;页数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;.format(page)) base_url &#x3D; &#39;https:&#x2F;&#x2F;www.doutula.com&#x2F;photo&#x2F;list&#x2F;?page&#x3D;&#123;&#125;&#39;.format(page) headers &#x3D; &#123;&#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&#39;&#125; response &#x3D; requests.get(url&#x3D;base_url,headers&#x3D;headers) html_data&#x3D;response.text selector &#x3D; parsel.Selector(html_data) result_list &#x3D; selector.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;&quot;col-xs-6 col-sm-3&quot;]&#39;) for result in result_list: img_url &#x3D; result.xpath(&#39;.&#x2F;img&#x2F;@data-original&#39;).extract_first() img_title &#x3D; result.xpath(&#39;.&#x2F;img&#x2F;@alt&#39;).extract_first() print(img_url+&quot;---&quot;+img_title) 接下来在通过IO流将图片存储到本地完成基础图片爬取。 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"requests","slug":"requests","permalink":"http://onejane.github.io/tags/requests/"},{"name":"parsel","slug":"parsel","permalink":"http://onejane.github.io/tags/parsel/"}]},{"title":"加壳与脱壳之二代壳函数抽取","slug":"加壳与脱壳之二代壳函数抽取","date":"2021-03-25T00:07:35.000Z","updated":"2022-04-09T04:23:24.224Z","comments":true,"path":"2021/03/25/加壳与脱壳之二代壳函数抽取/","link":"","permalink":"http://onejane.github.io/2021/03/25/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E4%BA%8C%E4%BB%A3%E5%A3%B3%E5%87%BD%E6%95%B0%E6%8A%BD%E5%8F%96/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 函数抽取宣告一代壳整体保护的结束，由此进入二代壳的时代，本文将对Dalvik和Art下函数抽取的加固方法原理介绍及实现函数抽取的代码保护方案。 Dalvik Android中实现「类方法指令抽取方式」加固方案原理解析：对dex结构简单介绍，定位函数指令地址，实现函数抽取壳的demo，对getPwd函数进行指令抽取，类被加载时重填恢复指令。 Android免Root权限通过Hook系统函数修改程序运行时内存指令逻辑：为了修改原有系统对dex加载流程，需要hook系统某些关键函数，自然可以在原有函数逻辑中添加需要自定义的逻辑功能，再添加一些恢复保护函数的填充。 源码分析实现函数抽取壳需要保证对函数恢复的时机肯定早于函数被调用的时机，不然app逻辑被破坏了，即当函数被调用时指令流必须已经被修复了，否则app逻辑被破坏导致app崩了。再选择时机，Android中实现「类方法指令抽取方式」加固方案原理解析中选择了dexFindClass函数。 对于函数来说在被调用之前，首先dex加载(dexclassloader动态加载)，对类加载的函数调用时需要进行一些准备，需要经过装载-链接-初始化，在这些加载过程中有非常多的时机供我们选择，Dalvik源代码编译生成的system/lib/libdvm.so通过ida打开，搜索文中的dexFindClass函数，获取导出的函数名可实现函数抽取。hook的时机点肯定是早于被调用的时机点，当dex被dexclassloader加载完后，需要加载dex其他类(隐式加载+显式加载)。搜索libcore库中loadClass加载一个dex中的类的流程:DexClassLoader-&gt;BaseDexClassLoader-&gt;ClassLoader的loadClass,完整体现了双亲委派的特性。 1234567891011121314151617486 protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123; &#x2F;&#x2F; 为了提高加载类效率，使用父节点加载如果已经加载直接返回，否则进行双亲委派的父节点加载487 Class&lt;?&gt; clazz &#x3D; findLoadedClass(className);488489 if (clazz &#x3D;&#x3D; null) &#123;490 try &#123;491 clazz &#x3D; parent.loadClass(className, false);492 &#125; catch (ClassNotFoundException e) &#123;493 &#x2F;&#x2F; Don&#39;t want to see this.494 &#125;495496 if (clazz &#x3D;&#x3D; null) &#123;497 clazz &#x3D; findClass(className);498 &#125;499 &#125;500501 return clazz;502 &#125; 对于使用DexClassLoader第一次加载类的parent节点是pathClassLoader或被指定的bootClassLoader,因为类只由当前的classloader加载必然是找不到的，因此进入BaseDexClassLoader的findClass实现中。 12345678910111252 protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;53 List&lt;Throwable&gt; suppressedExceptions &#x3D; new ArrayList&lt;Throwable&gt;();54 Class c &#x3D; pathList.findClass(name, suppressedExceptions);55 if (c &#x3D;&#x3D; null) &#123;56 ClassNotFoundException cnfe &#x3D; new ClassNotFoundException(&quot;Didn&#39;t find class \\&quot;&quot; + name + &quot;\\&quot; on path: &quot; + pathList);57 for (Throwable t : suppressedExceptions) &#123;58 cnfe.addSuppressed(t);59 &#125;60 throw cnfe;61 &#125;62 return c;63 &#125; 紧接着进入pathList.findClass，其中pathList是在BaseDexClassLoader构造函数中实例化化，跟着进入pathList.findClass，调用了dex.loadClassBinaryName查找类 1234567891011121314151617317 public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;318 for (Element element : dexElements) &#123;319 DexFile dex &#x3D; element.dexFile;320321 if (dex !&#x3D; null) &#123; &#x2F;&#x2F; 尝试从每个dex中遍历找到类所在的dex中并返回类所在dex322 Class clazz &#x3D; dex.loadClassBinaryName(name, definingContext, suppressed); 323 if (clazz !&#x3D; null) &#123;324 return clazz;325 &#125;326 &#125;327 &#125;328 if (dexElementsSuppressedExceptions !&#x3D; null) &#123;329 suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));330 &#125;331 return null;332 &#125; 跟着进入loadClassBinaryName,其中调用了native层实现defineClassNative 1234567891011121314151617181920214 public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) &#123;215 return defineClass(name, loader, mCookie, suppressed);216 &#125;217218 private static Class defineClass(String name, ClassLoader loader, int cookie,219 List&lt;Throwable&gt; suppressed) &#123;220 Class result &#x3D; null;221 try &#123;222 result &#x3D; defineClassNative(name, loader, cookie);223 &#125; catch (NoClassDefFoundError e) &#123;224 if (suppressed !&#x3D; null) &#123;225 suppressed.add(e);226 &#125;227 &#125; catch (ClassNotFoundException e) &#123;228 if (suppressed !&#x3D; null) &#123;229 suppressed.add(e);230 &#125;231 &#125;232 return result;233 &#125; dalvik下Full Search搜索defineClassNative，进入/dalvik/vm/native/dalvik_system_DexFile.cpp的Dalvik_dalvik_system_DexFile_defineClassNative方法，如注释中所说从一个dex文件中加载一个类 123456789101112131415161718192021222324252627282930349static void Dalvik_dalvik_system_DexFile_defineClassNative(const u4* args,350 JValue* pResult)351&#123;352 StringObject* nameObj &#x3D; (StringObject*) args[0]; &#x2F;&#x2F; 类名353 Object* loader &#x3D; (Object*) args[1]; &#x2F;&#x2F; classloader354 int cookie &#x3D; args[2]; &#x2F;&#x2F; java层cookie355 ClassObject* clazz &#x3D; NULL;356 DexOrJar* pDexOrJar &#x3D; (DexOrJar*) cookie; &#x2F;&#x2F; 将int型cookie转为DexOrJar指针357 DvmDex* pDvmDex;358 char* name;359 char* descriptor;360361 name &#x3D; dvmCreateCstrFromString(nameObj);362 descriptor &#x3D; dvmDotToDescriptor(name);363 ALOGV(&quot;--- Explicit class load &#39;%s&#39; l&#x3D;%p c&#x3D;0x%08x&quot;,364 descriptor, loader, cookie);365 free(name);366367 if (!validateCookie(cookie))368 RETURN_VOID();369370 if (pDexOrJar-&gt;isDex)371 pDvmDex &#x3D; dvmGetRawDexFileDex(pDexOrJar-&gt;pRawDexFile);372 else373 pDvmDex &#x3D; dvmGetJarFileDex(pDexOrJar-&gt;pJarFile);374375 &#x2F;* once we load something, we can&#39;t unmap the storage *&#x2F;376 pDexOrJar-&gt;okayToFree &#x3D; false;377378 clazz &#x3D; dvmDefineClass(pDvmDex, descriptor, loader); 进入dvmGetRawDexFileDex，只是取出指针中的pDvmDex 12362INLINE DvmDex* dvmGetRawDexFileDex(RawDexFile* pRawDexFile) &#123;63 return pRawDexFile-&gt;pDvmDex;64&#125; 进入dvmDefineClass 12345671413ClassObject* dvmDefineClass(DvmDex* pDvmDex, const char* descriptor,1414 Object* classLoader)1415&#123;1416 assert(pDvmDex !&#x3D; NULL);14171418 return findClassNoInit(descriptor, classLoader, pDvmDex);1419&#125; 进入findClassNoInit，首先调用了clazz = dvmLookupClass(descriptor, loader, true);对当前加载的类名进行计算查询，如没有则返回为空，对于第一次加载必然是没有的，接着进入pClassDef = dexFindClass(pDvmDex-&gt;pDexFile, descriptor);，即Android中实现「类方法指令抽取方式」加固方案原理解析中选择的时机点，并通过hook掉类被加载时的时机，对抽取函数的恢复，实现函数还原，因此必然需要早于函数执行的时机，保证app正常运行。由于有些函数符号没有导出，就不是很容易进行hook，而在libdvm.so中的dexFindClass在IDA中是被导出的，方便hook。以上就是Dalvik下函数抽取壳的简单原理。 ARTArt下实现难点：dex2oat编译流程，dex2oat是可以进行脱壳，dex2oat完成了对抽取的dex进行编译生成了oat文件，后续的函数运行中，从oat中取出函数编译生成的二进制代码来执行，因此函数对dex填充后，如果时机不对，时机在dex2oat后，自然从dex2oat后那么我们动态修改的dex中的smali指令流就不会生效，因为后面app运行调用的真正的代码就会从dex2oat编译生成的oat文件，和以前的dex无关了。因此如果希望填充回去smali指令生效要么禁用dex2oat实现阻止编译，这样对加载到内存中的dex文件进行填充始终会保持生效，要么保持dex2oat编译，但是还原代码时机要早于dex2oat就ok了，保证dex2oat再次对dex编译的时候，dex已经是一个完整dex，不会影响我们填充的代码，但是肯定dex文件存在完整的时候，可以利用dex2oat编译的流程进行脱壳，一般加壳厂商都是牺牲掉app一部分的运行效率，干掉dex2oat的过程，因为google本身提倡dex2oat就是为了提升app运行效率。 禁用dex2oat编译回到ART下DexClassLoader动态加载dex的流程，在art下搜索GenerateOatFileNoChecks，该函数完成调用dex2oat进行编译 GenerateOatFileNoChecks中调用Dex2Oat函数 12616OatFileAssistant::ResultOfAttemptToUpdate OatFileAssistant::GenerateOatFileNoChecks(617 OatFileAssistant::OatFileInfo&amp; info, CompilerFilter::Filter filter, std::string* error_msg) &#123; Dex2Oat最终调用return Exec(argv, error_msg);，Exec中调用了int status = ExecAndReturnCode(arg_vector, error_msg);,其中ExecAndReturnCode通过pid_t pid = fork();进行fork一个子进程，在子进程中调用了execve(program, &amp;args[0], envp);完成对dex2oat这个二进制程序的调用。整个流程中任意一个环节被打断，dex2oat将会被干掉，无法继续运行。 TurboDex就是干掉dex2oat为了让dex在第一次动态加载时快速加载完成，因为不干掉dex2oat，art虚拟机就会调用dex2oat对当前的dex进行编译，编译过程非常耗时，可以很大地提升dexclassloader加载dex 的效率，该项目就是通过hook了execv方法实现。 众所周知,Android中在Runtime加载一个 未优化的Dex文件 (尤其在 ART 模式)需要花费 很长的时间. 当你在App中使用 插件化框架 的时候, 首次加载插件就需要耗费很长的时间. TurboDex 就是为了解决这一问题而生, 就像是给AndroidVM开启了上帝模式, 在引入TurboDex后, 无论你加载了多大的Dex文件,都可以在毫秒级别内完成. 接下来通过hook execve实现干掉dex2oat，可以通过爱奇艺xhook的GOT进行表hook干掉dex2oat，也可以用inline库hook。 SecondShell_80项目中：hooklibc中的execve的函数，干掉dexclassloader加载dex过程中dex2oat的流程。 myexecve 123456789101112131415161718192021222324252627&#x2F;&#x2F; 系统函数(在libc库中定义)被调用进入替换原始逻辑void* *myexecve(const char *__file, char *const *__argv, char *const *__envp) &#123; LOGD(&quot;process:%d,enter execve:%s&quot;, getpid(), __file); if (strstr(__file, &quot;dex2oat&quot;)) &#123; return NULL; &#125; else &#123; return oriexecve(__file, __argv, __envp); &#125;&#125;&#x2F;&#x2F; 实现干掉dex2oat的逻辑，加载原始的dex文件void hooklibc() &#123; LOGD(&quot;go into hooklibc&quot;); &#x2F;&#x2F;7.0 命名空间限制 libc有直接权限调用 void *libc_addr &#x3D; dlopen_compat(&quot;libc.so&quot;, RTLD_NOW); void *execve_addr &#x3D; dlsym_compat(libc_addr, &quot;execve&quot;); if (execve_addr !&#x3D; NULL) &#123; &#x2F;&#x2F; 需要hook函数地址，替换的地址，保存原函数地址在自己函数逻辑中进行调用 if (ELE7EN_OK &#x3D;&#x3D; registerInlineHook((uint32_t) execve_addr, (uint32_t) myexecve, (uint32_t **) &amp;oriexecve)) &#123; if (ELE7EN_OK &#x3D;&#x3D; inlineHook((uint32_t) execve_addr)) &#123; LOGD(&quot;inlineHook execve success&quot;); &#125; else &#123; LOGD(&quot;inlineHook execve failure&quot;); &#125; &#125; &#125;&#125; 启动SecondShell_80项目，并授予sdcard权限，查看logcat，检索dex2oat FART正餐前甜点：ART下几个通用简单高效的dump内存中dex方法中找一个好时机点实现art下二代函数抽取壳对抽空函数的还原，LoadClassMembers完成对要加载的class的准备工作，准备SetSFields,SetDirectMethodsPtr,要对当前已经加载的dex内容进行修改某一个被抽空的函数，首先定位到当前函数的CodeItem的地址进行修复，这过程中出现的时机点可以hook掉。LoadMethod设置了CodeItem的偏移，ArtMethod* method = klass-&gt;GetDirectMethodUnchecked(i, image_pointer_size_);初始化了method对象，此时内容还没有被填充，ArtMethod中关键变量dex_code_item_offset，在我们class被加载完后，准备好当前class每个函数对应的ArtMethod对象，禁用掉dex2oat以后，自然类中所有的函数都在解释模式下运行，必然找到当前ArtMethod的CodeItem在内存中的偏移，进行取出一条条smali指令流解释执行。LoadMethod(self, dex_file, it, klass, method);传入的dex_file为当前的dex对象，method为当前要准备的ArtMethod对象，每个ArtMethod对象都和java层的函数一一对应，这些函数都可以被hook掉，因为都在函数被调用前执行，都能实现对其的填充。 1234567891011123305void ClassLinker::LoadMethod(const DexFile&amp; dex_file,3306 const ClassDataItemIterator&amp; it,3307 Handle&lt;mirror::Class&gt; klass,3308 ArtMethod* dst) &#123;3309 uint32_t dex_method_idx &#x3D; it.GetMemberIndex();3310 const DexFile::MethodId&amp; method_id &#x3D; dex_file.GetMethodId(dex_method_idx);3311 const char* method_name &#x3D; dex_file.StringDataByIdx(method_id.name_idx_);33123313 ScopedAssertNoThreadSuspension ants(&quot;LoadMethod&quot;);3314 dst-&gt;SetDexMethodIndex(dex_method_idx); &#x2F;&#x2F; 设置MethodIndex3315 dst-&gt;SetDeclaringClass(klass.Get()); &#x2F;&#x2F; 设置类3316 dst-&gt;SetCodeItemOffset(it.GetMethodCodeItemOffset()); &#x2F;&#x2F; 指向smali指令在内存中的偏移 如果hook了LoadMethod函数，被调用完后ArtMethod对象的CodeItemOffset就完成了设置，且第五个参数就是ArtMethod对象的指针，可以很容易取出ArtMethod参数的CodeItemOffset，定位到了当前要填充的函数的smali指令流在内存中的偏移位置，避免了大量代码解析dex在内存中的映射。 实现函数抽取壳案例用loadDex.apk和4.dex。 定位函数要抽取的位置com.kanxue.test02.TestClass.testFunc的函数置空。使用010Editor打开4.dex，方法太多了导出csv 导出的csv用010打开，检索TestClass，出现索引号1028 回过头来再看4.dex中的TestClass的位置 code_item占了32个字节 GDA查看4.dex该方法,右键-Show Hex 对应010中选中部分全部改成0，即完成函数抽取。 dex header本身对dex校验，改完后还需要修改校验头部分 python checksum.py 返回CheckSum = 0x2785815e,则修改校验头部分，使其成为一个合法的dex文件 gda再次打开该dex，完成函数抽取。 接下来完成对testFunc的填充，并正常调用testFunc中的代码。 通过hooklibc的execve禁用掉dex2oat 选中了LoadMethod函数的hook，原型是oriloadmethod，并添加了自己的逻辑。需要当testFunc被初始化时需要将原有的smali指令流利用myloadmethod填充回去， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475void hookART() &#123; LOGD(&quot;go into hookART&quot;); void *libart_addr &#x3D; dlopen_compat(&quot;&#x2F;system&#x2F;lib&#x2F;libart.so&quot;, RTLD_NOW); if (libart_addr !&#x3D; NULL) &#123; void *loadmethod_addr &#x3D; dlsym_compat(libart_addr, &quot;_ZN3art11ClassLinker10LoadMethodERKNS_7DexFileERKNS_21ClassDataItemIteratorENS_6HandleINS_6mirror5ClassEEEPNS_9ArtMethodE&quot;); if (loadmethod_addr !&#x3D; NULL) &#123; if (ELE7EN_OK &#x3D;&#x3D; registerInlineHook((uint32_t) loadmethod_addr, (uint32_t) myloadmethod, (uint32_t **) &amp;oriloadmethod)) &#123; if (ELE7EN_OK &#x3D;&#x3D; inlineHook((uint32_t) loadmethod_addr)) &#123; LOGD(&quot;inlineHook loadmethod success&quot;); &#125; else &#123; LOGD(&quot;inlineHook loadmethod failure&quot;); &#125; &#125; &#125; &#125;&#125;void *myloadmethod(void *a, void *b, void *c, void *d, void *e) &#123; LOGD(&quot;process:%d,before run loadmethod:&quot;, getpid()); struct ArtMethod *artmethod &#x3D; (struct ArtMethod *) e; struct DexFile *dexfile &#x3D; (struct DexFile *) b; LOGD(&quot;process:%d,enter loadmethod:dexfilebegin:%p,size:%d&quot;, getpid(), dexfile-&gt;begin, dexfile-&gt;size);&#x2F;&#x2F;0,57344 char dexfilepath[100] &#x3D; &#123;0&#125;; sprintf(dexfilepath, &quot;&#x2F;sdcard&#x2F;%d_%d.dex&quot;, dexfile-&gt;size, getpid()); int fd &#x3D; open(dexfilepath, O_CREAT | O_RDWR, 0666); if (fd &gt; 0) &#123; &#x2F;&#x2F; 得到dex file的起始地址和大小，可以将此刻dex dump下来，用来对比 write(fd, dexfile-&gt;begin, dexfile-&gt;size); close(fd); &#125; &#x2F;&#x2F; oriloadmethod未被调用时，artmethod未被初始化，值为空。当调用了原始的oriloadmethod关键变量被初始化好，如dex_method_index_和dex_code_item_offset_，取出artmethod void *result &#x3D; oriloadmethod(a, b, c, d, e); LOGD(&quot;process:%d,enter loadmethod:code_offset:%d,idx:%d&quot;, getpid(), artmethod-&gt;dex_code_item_offset_, artmethod-&gt;dex_method_index_); byte *code_item_addr &#x3D; static_cast&lt;byte *&gt;(dexfile-&gt;begin) + artmethod-&gt;dex_code_item_offset_; LOGD(&quot;process:%d,enter loadmethod:dexfilebegin:%p,size:%d,beforedumpcodeitem:%p&quot;, getpid(), dexfile-&gt;begin, dexfile-&gt;size, code_item_addr); &#x2F;&#x2F; 当地址为15203时，即testFunc函数(010中)，进行原有指令数组进行填充 if (artmethod-&gt;dex_method_index_ &#x3D;&#x3D; 15203) &#123;&#x2F;&#x2F;TestClass.testFunc-&gt;methodidx LOGD(&quot;process:%d,enter loadmethod:dexfilebegin:%p,size:%d,start repire method&quot;, getpid(), dexfile-&gt;begin, dexfile-&gt;size); byte *code_item_addr &#x3D; (byte *) dexfile-&gt;begin + artmethod-&gt;dex_code_item_offset_; LOGD(&quot;process:%d,enter loadmethod:dexfilebegin:%p,size:%d,beforedumpcodeitem:%p&quot;, getpid(), dexfile-&gt;begin, dexfile-&gt;size, code_item_addr); int result &#x3D; mprotect(dexfile-&gt;begin, dexfile-&gt;size, PROT_WRITE); byte *code_item_start &#x3D; static_cast&lt;byte *&gt;(code_item_addr) + 16; &#x2F;&#x2F; 16字节后才是函数填充全0的指令流 LOGD(&quot;process:%d,enter loadmethod:dexfilebegin:%p,size:%d,code_item_start:%p&quot;, getpid(), dexfile-&gt;begin, dexfile-&gt;size, code_item_start); byte inst[16] &#x3D; &#123;0x1a, 0x00, 0xed, 0x34, 0x1a, 0x01, 0x43, 0x32, 0x71, 0x20, 0x91, 0x05, 0x10, 0x00, 0x0e, 0x00&#125;; for (int i &#x3D; 0; i &lt; sizeof(inst); i++) &#123; &#x2F;&#x2F; 逐个赋值 code_item_start[i] &#x3D; inst[i]; &#125; &#x2F;&#x2F;2343-&gt;i am from com.kanxue.test02.TestClass.testFunc code_item_start[2] &#x3D; 0x43;&#x2F;&#x2F;34ed-&gt;kanxue code_item_start[3] &#x3D; 0x23; memset(dexfilepath, 0, 100); sprintf(dexfilepath, &quot;&#x2F;sdcard&#x2F;%d_%d.dex_15203_2&quot;, dexfile-&gt;size, getpid()); fd &#x3D; open(dexfilepath, O_CREAT | O_RDWR, 0666); if (fd &gt; 0) &#123; write(fd, dexfile-&gt;begin, dexfile-&gt;size); close(fd); &#125; &#125; LOGD(&quot;process:%d,after loadmethod:code_offset:%d,idx:%d&quot;, getpid(), artmethod-&gt;dex_code_item_offset_, artmethod-&gt;dex_method_index_);&#x2F;&#x2F;0,57344 return result;&#125; 将修复后的4_chouqu.dex推送到/sdcard中 通过初始化后的code_item的偏移直接定位dex在内存中地址，并进行修正，实现art下函数抽取的解决方案，并没有通过大量代码art中的头文件去解析dex结构信息。 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"classloader","slug":"classloader","permalink":"http://onejane.github.io/tags/classloader/"}]},{"title":"加壳与脱壳之一代壳dex保护","slug":"加壳与脱壳之一代壳dex保护","date":"2021-03-16T12:27:25.000Z","updated":"2021-12-12T03:09:39.289Z","comments":true,"path":"2021/03/16/加壳与脱壳之一代壳dex保护/","link":"","permalink":"http://onejane.github.io/2021/03/16/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E4%B8%80%E4%BB%A3%E5%A3%B3dex%E4%BF%9D%E6%8A%A4/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 Dalvik4.4.4dex加载源码分析虽然加壳技术有所不同，第一步依然是dump内存中dex，虽然安卓4.4后Dalvik淡出视野，但是影响深远。Dalvik系统DexClassLoader加载dex具体流程： 在libcore目录下搜索DexClassLoader源码只有一个构造函数 dexPath：需要加载的dex路径optimizedDirectory：dex优化过程中产生的odex的存放路径libraryPath：当前classloader需要加载so的路径parent：双亲委派中的当前dexclassloader的父节点设置的classloader 1234public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), libraryPath, parent);&#125; 由于只调用了父类的构造函数，我们进入父类BaseDexClassLoader封装大量的函数，真正逻辑存在BaseDexClassLoader的构造函数中实现，调用了父类的构造函数，该类存在与/libcore/libart和/libcore/libdvm，说明在安卓4.4中已经开始引入art相关逻辑。 12345public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(parent); this.pathList &#x3D; new DexPathList(this, dexPath, libraryPath, optimizedDirectory);&#125; 进入Dalvik的ClassLoader的构造函数，将当前的ClassLoader的父节点作为传入的parent。 123456ClassLoader(ClassLoader parentLoader, boolean nullAllowed) &#123; if (parentLoader &#x3D;&#x3D; null &amp;&amp; !nullAllowed) &#123; throw new NullPointerException(&quot;parentLoader &#x3D;&#x3D; null &amp;&amp; !nullAllowed&quot;); &#125; parent &#x3D; parentLoader;&#125; 再进入new DexPathList再初始化pathList实例，进入DexPathList构造函数，前面对参数校验，真正起作用this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,suppressedExceptions);,makeDexElements方法调用了loadDexFile返回的dex添加到element数组并返回数组。 loadDexFile中再度调用了DexFile.loadDex(file.getPath(), optimizedPath, 0)，该方法新建了一个DexFile对象，return new DexFile(sourcePathName, outputPathName, flags);，在Dexfile中调用了openDexFile(sourceName, outputName, flags)完成了对dex的处理，openDexFile中调用了openDexFileNative，其中又调用openDexFileNative方法,跟进openDexFileNative发现是一个使用c/c++实现的native函数，native private static int openDexFileNative。该方法处理类/libcore/dalvik/src/main/java/dalvik/system/DexFile.java中，对应的实现文件就是dalvik_system_DexFile查看方法Dalvik_dalvik_system_DexFile_openDexFileNative，其中调用了dvmRawDexFileOpen实现对dex文件的打开。 123456789if (hasDexExtension(sourceName) &#x2F;&#x2F; 对当前文件后缀的校验 &amp;&amp; dvmRawDexFileOpen(sourceName, outputName, &amp;pRawDexFile, false) &#x3D;&#x3D; 0) &#123; ALOGV(&quot;Opening DEX file &#39;%s&#39; (DEX)&quot;, sourceName); pDexOrJar &#x3D; (DexOrJar*) malloc(sizeof(DexOrJar)); pDexOrJar-&gt;isDex &#x3D; true; pDexOrJar-&gt;pRawDexFile &#x3D; pRawDexFile; pDexOrJar-&gt;pDexMemory &#x3D; NULL;&#125; 在dvmRawDexFileOpen中dexFd = open(fileName, O_RDONLY);打开dex文件，verifyMagicAndGetAdler32(dexFd, &amp;adler32) &lt; 0对dex魔术字校验，cachedName = dexOptGenerateCacheFileName(fileName, NULL);生成优化后的odex文件路径，dvmOptimizeDexFile(optFd, dexOffset, fileSize,fileName, modTime, adler32, isBootstrap);优化当前的dex，跟进发现存在于DexPrepare.cpp中的dvmOptimizeDexFile(int fd, off_t dexOffset, long dexLength,const char* fileName, u4 modWhen, u4 crc, bool isBootstrap),该方法中pid = fork();fd为打开的dex文件的id，dexLength为dex文件的大小，pid=fork()新建了子进程用于调用/bin/dexopt对当前dex文件进行优化，结果生成odex文件。bin/dexopt的main方法中传入的文件校验是dex时，调用static int fromDex(int argc, char* const argv[])首先调用dvmPrepForDexOpt对当前优化环境准备，再调用dvmContinueOptimization对当前的fd文件进行优化 123dexLength &lt; (int) sizeof(DexHeader) 字节长度判断mapAddr &#x3D; mmap(NULL, dexOffset + dexLength, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); mmap对当前dex文件的内容进行内存映射rewriteDex(((u1*) mapAddr) + dexOffset, dexLength, doVerify, doOpt, &amp;pClassLookup, NULL); 重写dex(起始地址，长度，...) 查看static bool rewriteDex(u1* addr, int len, bool doVerify, bool doOpt,DexClassLookup** ppClassLookup, DvmDex** ppDvmDex)方法参数有加载到内存中dex的起始地址，字节数。该方法中暴露出在Dalvik中脱壳点的相关函数，dvmDexFileOpenPartial函数中出现dexFileParse，参数包含起始地址和字节数。 以上即是dexclassloader在动态加载dex时Dalvik实现的逻辑处理，很多时机点都出现了加载的dex的起始地址，就是最好的脱壳时机。很多脱壳方法都是对**dvmDexFileOpenPartial和dexFileParse进行下断点或者进行hook，取出第一个参数(起始地址)和第二个参数(dex长度)，在第一次DexPrepare.cpp中，其实在mmap对dex内存映射时包含dex文件，对当前映射区域进行dump也可以脱下从文件形式加载dex，在rewriteDex**时也出现了dex文件加载的起始地址和大小，自然也是可以进行dump等等。通过Cydia、xposed、frida都可以对实现对关键时机的hook，取出前两个参数，拿到起始地址和长度，dump下来内存区域即可实现脱壳。 定制源码脱壳对新的一些加壳厂商的产品依然有效，除非厂商对这些函数进行hook修改，或者参考Dalvik修改实现自己的逻辑。进入Ubuntu 1604x64_4.4的编译环境虚拟机，tom/admin，4.4的源码为hammerhead及其驱动。通过编译源码的方式实现以下为部分脱壳点： dvmDexFileOpenPartial搜索 dvmDexFileOpenPartial 发现在/dalvik/vm/DvmDex.cpp文件中，使用Geany打开 ~/SourceCode/android-4.4.4_r1/dalvik/vm/DvmDex.cpp，找到dvmDexFileOpenPartial方法，只需要保存起始地址和大小即可。 修改int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex) 123456789101112131415#include &lt;sys&#x2F;stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;&#x2F;&#x2F;新建保存路径用于拼接脱壳app产生的dex路径，对每个脱壳的app的脱下的dex单独起名char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dvmDexFileOpenPartial.dex&quot;,len,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,addr,len); close(fd);&#125; dexFileParse搜索**dexFileParse**发现存在/dalvik/libdex/DexFile.cpp中，使用geany编辑器打开DexFile.cpp 修改DexFile* dexFileParse(const u1* data, size_t length, int flags) 123456789101112131415#include &lt;sys&#x2F;stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;&#x2F;&#x2F;新建保存路径用于拼接脱壳app产生的dex路径，对每个脱壳的app的脱下的dex单独起名char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dvmFileParse.dex&quot;,length,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,data,length); close(fd);&#125; mmap搜索 mmap 存在于/dalvik/vm/analysis/DexPrepare.cpp的中， 修改bool dvmContinueOptimization(int fd, off_t dexOffset, long dexLength, const char* fileName, u4 modWhen, u4 crc, bool isBootstrap) 1234567891011char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dvmContinueOptimization.dex&quot;,dexLength,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,mapAddr,dexOffset + dexLength); close(fd);&#125; 第一次映射到内存中需要将dex通过010Editor修正，删除64 65 78 0A前的字符。 rewriteDex搜索rewriteDex位于/dalvik/vm/analysis/DexPrepare.cpp， 修改static bool rewriteDex(u1* addr, int len, bool doVerify, bool doOpt, DexClassLookup** ppClassLookup, DvmDex** ppDvmDex) 1234567891011char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_rewriteDex.dex&quot;,len,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,addr,len); close(fd);&#125; dexSwapVerify搜索dexSwapVerify存在于/dalvik/libdex/DexSwapVerify.cpp 修改int dexSwapAndVerify(u1* addr, int len) 1234567891011char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dexSwapAndVerify.dex&quot;,len,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,addr,len); close(fd);&#125; 编译1234~&#x2F;SourceCode&#x2F;android-4.4.4_r1$ source build&#x2F;envsetup.sh~&#x2F;SourceCode&#x2F;android-4.4.4_r1$ lunch7 选择aosp_hammerhead-userdebug~&#x2F;SourceCode&#x2F;android-4.4.4_r1$ time make -j4 如果报错直接make单线程编译 生成路径~/SourceCode/android/4.4.4_r1/out/target/product/hammerhead，将boot.img,cache.img,ramdisk.img,system.img,userdata.img拷出来 adb reboot bootloaderfastboot flash system system.img 常用的img有boot,cache,ramdisk,system,userdata 安装LoadDex.apk，并把ClassLoaderTest生成的classes.dex放入/sdcard。在Activity启动的时候加载/sdcard的classes.dex的TestActivity并打印I&#39;m from TestActivity.onCreate，这就是一代壳的基本原理。 重启系统后/sdcard中已经出现一些系统中脱下的dex，启动LoadDex，grep -ril &quot;TestActivity&quot; ./*.dex 找到LoadDex中脱下的dex，gda可以看到优化后的odex的TestActivity中onCreate方法 真实案例a.apk 快递100 《百度》加固 启动后进入/sdcard , grep -ril “SplashActivity” ./*.dex b.apk 货拉拉司机版《爱加密》企业版本加固 启动后进入/sdcard , grep -ril “mvp/ui/SplashActivity” ./*.dex，内容都为null，说明用了函数抽取。 ART8.0.0InMemoryDexClassLoader源码分析加载内存中的解密字节流过程art的具体流程： 在Android 8.0中libcore搜索InMemoryDexClassLoader两个构造函数，分别加载一个或多个dex，super(dexBuffers, parent);调用了父类的构造函数。进入父类BaseDexClassLoader.java的构造函数 1234567public BaseDexClassLoader(ByteBuffer[] dexFiles, ClassLoader parent) &#123; // TODO We should support giving this a library search path maybe. // 设置parent super(parent); // 初始化DexPathList对象 this.pathList = new DexPathList(this, dexFiles);&#125; 跟进public DexPathList(ClassLoader definingContext, ByteBuffer[] dexFiles)构造函数，前几步对传参判断，紧接着对传入的so库的处理 123456this.definingContext = definingContext;// TODO It might be useful to let in-memory dex-paths have native libraries.this.nativeLibraryDirectories = Collections.emptyList();this.systemNativeLibraryDirectories = splitPaths(System.getProperty(\"java.library.path\"), true);this.nativeLibraryPathElements = makePathElements(this.systemNativeLibraryDirectories); 传入的dex只需要看this.dexElements = makeInMemoryDexElements(dexFiles, suppressedExceptions);摘除核心代码如下： 12345678910private static Element[] makeInMemoryDexElements(ByteBuffer[] dexFiles, List&lt;IOException&gt; suppressedExceptions) &#123; Element[] elements = new Element[dexFiles.length]; int elementPos = 0; for (ByteBuffer buf : dexFiles) &#123; DexFile dex = new DexFile(buf); elements[elementPos++] = new Element(dex); &#125; return elements;&#125; 进入DexFile(buf)的构造函数中，发现openInMemoryDexFile将buf在内存中打开返回了mCookie 12345DexFile(ByteBuffer buf) throws IOException &#123; mCookie = openInMemoryDexFile(buf); mInternalCookie = mCookie; mFileName = null;&#125; 查看openInMemoryDexFile方法，分别根据条件创建了两次cookie 1234567private static Object openInMemoryDexFile(ByteBuffer buf) throws IOException &#123; if (buf.isDirect()) &#123; return createCookieWithDirectBuffer(buf, buf.position(), buf.limit()); &#125; else &#123; return createCookieWithArray(buf.array(), buf.position(), buf.limit()); &#125;&#125; 分别查看createCookieWithDirectBuffer和createCookieWithArray两个方法，发现是两个native函数 12private static native Object createCookieWithDirectBuffer(ByteBuffer buf, int start, int end);private static native Object createCookieWithArray(byte[] buf, int start, int end); 在art模块中Full Search createCookieWithDirectBuffer,进入DexFile_createCookieWithDirectBuffer 12345678910111213141516171819202122static jobject DexFile_createCookieWithDirectBuffer(JNIEnv* env, jclass, &#x2F;&#x2F; 静态函数 第一个是jclass当前类 jobject buffer, &#x2F;&#x2F; 传入内存中的字节流 jint start, jint end) &#123; uint8_t* base_address &#x3D; reinterpret_cast&lt;uint8_t*&gt;(env-&gt;GetDirectBufferAddress(buffer)); if (base_address &#x3D;&#x3D; nullptr) &#123; ScopedObjectAccess soa(env); ThrowWrappedIOException(&quot;dexFileBuffer not direct&quot;); return 0; &#125; std::unique_ptr&lt;MemMap&gt; dex_mem_map(AllocateDexMemoryMap(env, start, end)); if (dex_mem_map &#x3D;&#x3D; nullptr) &#123; DCHECK(Thread::Current()-&gt;IsExceptionPending()); return 0; &#125; size_t length &#x3D; static_cast&lt;size_t&gt;(end - start); memcpy(dex_mem_map-&gt;Begin(), base_address, length); &#x2F;&#x2F; 对当前字节流进行内存拷贝memcpy，传入begin和length就是dex的起始地址，可以进行dump return CreateSingleDexFileCookie(env, std::move(dex_mem_map));&#125; createCookieWithDirectBuffer和createCookieWithArray都进行了CreateSingleDexFileCookie 12345678910static jobject CreateSingleDexFileCookie(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; data) &#123; std::unique_ptr&lt;const DexFile&gt; dex_file(CreateDexFile(env, std::move(data))); &#x2F;&#x2F; 根据传入dex文件在内存中信息创建了DexFile实例 if (dex_file.get() &#x3D;&#x3D; nullptr) &#123; DCHECK(env-&gt;ExceptionCheck()); return nullptr; &#125; std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files; dex_files.push_back(std::move(dex_file)); return ConvertDexFilesToJavaArray(env, nullptr, dex_files); &#x2F;&#x2F; 对该dex_files进行返回&#125; 通过CreateDexFile创建DexFile对象 12345678910111213141516171819202122232425static const DexFile* CreateDexFile(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; dex_mem_map) &#123; &#x2F;&#x2F; 返回dex文件在内存中映射的地址 std::string location &#x3D; StringPrintf(&quot;Anonymous-DexFile@%p-%p&quot;, dex_mem_map-&gt;Begin(), dex_mem_map-&gt;End()); std::string error_message; std::unique_ptr&lt;const DexFile&gt; dex_file(DexFile::Open(location, 0, std::move(dex_mem_map), &#x2F;* verify *&#x2F; true, &#x2F;* verify_location *&#x2F; true, &amp;error_message)); if (dex_file &#x3D;&#x3D; nullptr) &#123; ScopedObjectAccess soa(env); ThrowWrappedIOException(&quot;%s&quot;, error_message.c_str()); return nullptr; &#125; if (!dex_file-&gt;DisableWrite()) &#123; ScopedObjectAccess soa(env); ThrowWrappedIOException(&quot;Failed to make dex file read-only&quot;); return nullptr; &#125; return dex_file.release();&#125; 进入DexFile::Open，其中又调用了OpenCommon函数 1234567891011121314151617181920212223std::unique_ptr&lt;const DexFile&gt; DexFile::Open(const std::string&amp; location, &#x2F;&#x2F; 加载dex文件的路径 uint32_t location_checksum, std::unique_ptr&lt;MemMap&gt; map, &#x2F;&#x2F; 内存的映射 bool verify, bool verify_checksum, std::string* error_msg) &#123; ScopedTrace trace(std::string(&quot;Open dex file from mapped-memory &quot;) + location); CHECK(map.get() !&#x3D; nullptr); if (map-&gt;Size() &lt; sizeof(DexFile::Header)) &#123; *error_msg &#x3D; StringPrintf( &quot;DexFile: failed to open dex file &#39;%s&#39; that is too short to have a header&quot;, location.c_str()); return nullptr; &#125; std::unique_ptr&lt;DexFile&gt; dex_file &#x3D; OpenCommon(map-&gt;Begin(), map-&gt;Size(), location, location_checksum, kNoOatDexFile, verify, verify_checksum, error_msg); 进入OpenCommon函数 1234567891011121314151617std::unique_ptr&lt;DexFile&gt; DexFile::OpenCommon(const uint8_t* base, &#x2F;&#x2F; 加载dex文件的起始地址 size_t size, const std::string&amp; location, uint32_t location_checksum, const OatDexFile* oat_dex_file, bool verify, bool verify_checksum, std::string* error_msg, VerifyResult* verify_result) &#123; if (verify_result !&#x3D; nullptr) &#123; *verify_result &#x3D; VerifyResult::kVerifyNotAttempted; &#125; std::unique_ptr&lt;DexFile&gt; dex_file(new DexFile(base, size, location, location_checksum, oat_dex_file)); &#x2F;&#x2F; 创建新的DexFile实例，构造函数也包含起始地址和大小 说明InMemoryDexClassLoader在对内存中bytebuffer的dex信息进行加载流程中涉及很多函数逻辑都包含dex信息的起始地址和大小。InMemoryDexClassLoader并没有对内存中dex信息进行编译生成相应的oat文件，这是与DexClassLoader的不同。 InMemoryDexClassLoader通用脱壳点： CreateSingleDexFileCookie的data参数可以获取起始地址 CreateDexFile DexFile::Open OpenCommon DexFile::DexFile DexClassLoader加载dex源码分析DexClassLoader只有一个构造函数 1234public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), librarySearchPath, parent);&#125; 进入父类BaseDexClassLoader.java的构造函数 123456789public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(parent); this.pathList &#x3D; new DexPathList(this, dexPath, librarySearchPath, null); if (reporter !&#x3D; null) &#123; reporter.report(this.pathList.getDexPaths()); &#125;&#125; 同样的进入DexPathList的核心逻辑this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,suppressedExceptions, definingContext);,调用了makeDexElements，其中加载dex文件loadDexFile(file, optimizedDirectory, loader, elements); 12345678910private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader, Element[] elements) throws IOException &#123; if (optimizedDirectory &#x3D;&#x3D; null) &#123; return new DexFile(file, loader, elements); &#125; else &#123; String optimizedPath &#x3D; optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements); &#125;&#125; DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements)调用了5个参数的loadDex,进入loadDex函数 1234static DexFile loadDex(String sourcePathName, String outputPathName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; return new DexFile(sourcePathName, outputPathName, flags, loader, elements); &#x2F;&#x2F; 创建DexFile实例&#125; 进入DexFile五参数构造函数 123456DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; mCookie &#x3D; openDexFile(fileName, null, 0, loader, elements); mInternalCookie &#x3D; mCookie; mFileName &#x3D; fileName; &#x2F;&#x2F;System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; fileName&#x3D;&quot; + fileName);&#125; 进入openDexFile中调用了native函数private static native Object openDexFileNative(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements); 1234567return openDexFileNative(new File(sourceName).getAbsolutePath(), (outputName &#x3D;&#x3D; null) ? null : new File(outputName).getAbsolutePath(), flags, loader, elements); Full Search搜索art目录下的openDexFileNative， 123456789101112131415161718192021222324252627282930313233343536373839static jobject DexFile_openDexFileNative(JNIEnv* env, jclass, &#x2F;&#x2F; 静态函数 jstring javaSourceName, &#x2F;&#x2F; 加载的dex路径 jstring javaOutputName ATTRIBUTE_UNUSED, jint flags ATTRIBUTE_UNUSED, jobject class_loader, jobjectArray dex_elements) &#123; ScopedUtfChars sourceName(env, javaSourceName); if (sourceName.c_str() &#x3D;&#x3D; nullptr) &#123; return 0; &#125; Runtime* const runtime &#x3D; Runtime::Current(); ClassLinker* linker &#x3D; runtime-&gt;GetClassLinker(); std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files; std::vector&lt;std::string&gt; error_msgs; const OatFile* oat_file &#x3D; nullptr; &#x2F;&#x2F; 出现oat dex_files &#x3D; runtime-&gt;GetOatFileManager().OpenDexFilesFromOat(sourceName.c_str(), class_loader, dex_elements, &#x2F;*out*&#x2F; &amp;oat_file, &#x2F;*out*&#x2F; &amp;error_msgs); &#x2F;&#x2F; 调用OpenDexFilesFromOat编译生成oat流程 if (!dex_files.empty()) &#123; jlongArray array &#x3D; ConvertDexFilesToJavaArray(env, oat_file, dex_files); if (array &#x3D;&#x3D; nullptr) &#123; ScopedObjectAccess soa(env); for (auto&amp; dex_file : dex_files) &#123; if (linker-&gt;IsDexFileRegistered(soa.Self(), *dex_file)) &#123; dex_file.release(); &#125; &#125; &#125; return array; &#125; return nullptr; &#125;&#125; DexClassLoader第一次动态加载解密的dex时必然没有进行编译生成oat，查看OpenDexFilesFromOat,首先OatFileAssistant oat_file_assistant(dex_location,kRuntimeISA,!runtime-&gt;IsAotCompiler());新建了OatFileAssistant 对象，if (!oat_file_assistant.IsUpToDate())由于没有生成oat对象的，进入判断中的MakeUpToDate函数，其中调用了return GenerateOatFileNoChecks(info, target, error_msg);GenerateOatFileNoChecks最终进入调用dex2oat编译生成oat的流程 123456789if (!Dex2Oat(args, error_msg)) &#123; &#x2F;&#x2F; Manually delete the oat and vdex files. This ensures there is no garbage &#x2F;&#x2F; left over if the process unexpectedly died. vdex_file-&gt;Erase(); unlink(vdex_file_name.c_str()); oat_file-&gt;Erase(); unlink(oat_file_name.c_str()); return kUpdateFailed;&#125; Dex2Oat中准备相关二进制程序参数的相关信息，最终调用return Exec(argv, error_msg);实现dex2oat编译的过程，进入Exec中调用了ExecAndReturnCode，其中首次pid_t pid=fork()进行了进程fork，在子进程当中使用execve(program, &amp;args[0], envp);执行dex2oat实际执行流程。 说明我们在整个流程中其中某个函数进行修改或者hook都会导致dex2oat流程结束，强制结束dex2oat流程，可以让我们在DexClassLoader在加载dex时过程变的很有效率，减少dex2oat编译的流程，要想实现art下的函数抽取技术，也是要阻断dex2oat的流程。当我们阻断了dex2oat会导致openDexFileNative中 oat_file 文件无法生成，在调用OatFileManager::OpenDexFilesFromOat中进入尝试判断原始dex文件oat_file_assistant.HasOriginalDexFiles()并通过DexFile::Open进行加载dex 123456789101112131415161718if (dex_files.empty()) &#123; if (oat_file_assistant.HasOriginalDexFiles()) &#123; if (Runtime::Current()-&gt;IsDexFileFallbackEnabled()) &#123; static constexpr bool kVerifyChecksum &#x3D; true; if (!DexFile::Open( dex_location, dex_location, kVerifyChecksum, &#x2F;*out*&#x2F; &amp;error_msg, &amp;dex_files)) &#123; LOG(WARNING) &lt;&lt; error_msg; error_msgs-&gt;push_back(&quot;Failed to open dex files from &quot; + std::string(dex_location) + &quot; because: &quot; + error_msg); &#125; &#125; else &#123; error_msgs-&gt;push_back(&quot;Fallback mode disabled, skipping dex files.&quot;); &#125; &#125; else &#123; error_msgs-&gt;push_back(&quot;No original dex files found for dex location &quot; + std::string(dex_location)); &#125;&#125; 进入DexFile::Open中可看到File fd = OpenAndReadMagic(filename, &amp;magic, error_msg);到此出现了第一个脱壳点OpenAndReadMagic，此时dex还未加载到内存当中。紧接着开始判断dex魔术头，并进入DexFile::OpenFile函数 12345678910111213if (IsDexMagic(magic)) &#123; std::unique_ptr&lt;const DexFile&gt; dex_file(DexFile::OpenFile(fd.Release(), &#x2F;&#x2F; 文件描述符，可以作为脱壳点 location, &#x2F;* verify *&#x2F; true, verify_checksum, error_msg)); if (dex_file.get() !&#x3D; nullptr) &#123; dex_files-&gt;push_back(std::move(dex_file)); return true; &#125; else &#123; return false; &#125;&#125; 进入DexFile::OpenFile函数发现通过MemMap::MapFile将dex进行了内存映射 12345678map.reset(MemMap::MapFile(length, PROT_READ, MAP_PRIVATE, fd, 0, &#x2F;*low_4gb*&#x2F;false, location.c_str(), error_msg)); 再进入OpenCommon函数中，参数中也包含了dex文件的映射区域的起始地址，出现了第二个脱壳点。 12345678std::unique_ptr&lt;DexFile&gt; dex_file &#x3D; OpenCommon(map-&gt;Begin(), map-&gt;Size(), location, dex_header-&gt;checksum_, kNoOatDexFile, verify, verify_checksum, error_msg); 跟进DexFile::OpenCommon中，发现其中调用了DexFile的构造函数 12345std::unique_ptr&lt;DexFile&gt; dex_file(new DexFile(base, size, location, location_checksum, oat_dex_file)); 至此出现了第三个脱壳点DexFile::DexFile 12345DexFile::DexFile(const uint8_t* base, size_t size, const std::string&amp; location, uint32_t location_checksum, const OatDexFile* oat_dex_file) 通用脱壳点： OpenAndReadMagic OpenCommon DexFile::DexFile 通过对比：InMemoryDexClassLoader和DexClassLoader的脱壳点，发现OpenCommon是两者通用脱壳点。 定制源码脱壳DexFile::OpenCommon修改/art/runtime/dex_file.cc中DexFile::OpenCommon方法 12345678910 int pid&#x3D;getpid(); char dexfilepath[100]&#x3D;&#123;0&#125;; sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_OpenCommon.dex&quot;,(int)size,pid); int fd&#x3D;open(dexfilepath,O_CREAT|O_RDWR,666); if (fd&gt;0)&#123;int number&#x3D;write(fd,base,size);if(number&gt;0)&#123;&#125;close(fd); &#125; DexFile::DexFile修改/art/runtime/dex_file.cc中DexFile::DexFile方法 12345678910 int pid&#x3D;getpid(); char dexfilepath[100]&#x3D;&#123;0&#125;; sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_DexFile.dex&quot;,(int)size,pid); int fd&#x3D;open(dexfilepath,O_CREAT|O_RDWR,666); if (fd&gt;0)&#123;int number&#x3D;write(fd,base,size);if(number&gt;0)&#123;&#125;close(fd); &#125; 编译1234~&#x2F;Android8.0&#x2F;android-8.0.0_r1$ source build&#x2F;envsetup.sh~&#x2F;Android8.0&#x2F;android-8.0.0_r1$ lunch23 选择aosp_sailfish-userdebug~&#x2F;Android8.0&#x2F;android-8.0.0_r1$ time make -j4 如果报错直接make单线程编译 生成路径~/Android8.0/android-8.0.0_r1/out/target/product/sailfish，将boot.img,ramdisk.img,system.img,system_other.img,userdata.img,vendor.img拷出来 123456fastboot flash boot boot.imgfastboot flash vendor vendor.imgfastboot flash system_a system.imgfastboot flash system_b system_other.imgfastboot flash userdata userdata.imgfastboot reboot 安装LoadDex.apk，并把ClassLoaderTest生成的classes.dex放入/sdcard。并在设置中授予该app读写sdcard的权限。在Activity启动的时候加载/sdcard的classes.dex的TestActivity并打印I&#39;m from TestActivity.onCreate，这就是一代壳的基本原理。 重启系统后/sdcard中已经出现一些系统中脱下的dex，启动LoadDex，grep -ril &quot;TestActivity&quot; ./*.dex 找到LoadDex中脱下的dex，DexClassLoader加载的插件dex已经被dump下来，gda可以看到优化后的odex的TestActivity中onCreate方法。 真实案例a.apk 《百度》加固 启动后进入/sdcard , grep -ril “SplashActivity” ./*.dex b.apk 《爱加密》企业版本加固 启动后进入/sdcard , grep -ril “mvp/ui/SplashActivity” ./*.dex，内容都为null，说明用了函数抽取，这就是需要fart解决的问题。 以上方案都是针对于没有dex2oat的情况，实际上对于一些壳没有禁用dex2oat的编译过程，且使用dexclassloader进行编译，最终会进入dex2oat流程，这个流程也是可以进行脱壳的。 ExecAndReturnCode中调用execve(program, &amp;args[0], envp);调用dex2oat二进制程序对dex的文件加载。,dex2oat流程也可以脱壳,main函数中调用了Dex2oat,int result = static_cast&lt;int&gt;(art::Dex2oat(argc, argv));,跟进Setup()方法最后会出现对要编译dex文件的处理，如下代码对当前要编译的文件进行遍历，逐个进行注册，这个地方可以完成dex的脱壳。CompileApp也出现了DexFile对象等等非常多的流程出现Dexfile对象，都可以成为脱壳点 除了对dex加载过程中还有其他脱壳点，比如对class进行load过程中，对art method的准备阶段，甚至每个函数的执行过程中都可以进行脱壳，这就是art下众多脱壳点的原因，因为非常多的流程都可以获取到dex文件的位置信息。 Dalvik下一代壳通用解决方案 ART下一代壳通用解决方案 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"Dalvik","slug":"Dalvik","permalink":"http://onejane.github.io/tags/Dalvik/"},{"name":"ART","slug":"ART","permalink":"http://onejane.github.io/tags/ART/"}]},{"title":"Socket&Websocket&Protobuf自吐通杀","slug":"Socket&Websocket&Protobuf自吐通杀","date":"2021-03-14T10:00:50.000Z","updated":"2021-12-12T03:09:39.280Z","comments":true,"path":"2021/03/14/Socket&Websocket&Protobuf自吐通杀/","link":"","permalink":"http://onejane.github.io/2021/03/14/Socket&Websocket&Protobuf%E8%87%AA%E5%90%90%E9%80%9A%E6%9D%80/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 Socket所有的应用层都逃不掉底层用Socket来传输,只要掌握了Socket，对上层应用就是降维打击。 新建HttpSocket项目，并在AndroidManifest.xml配置网络权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true)&#123; newHttp(); try &#123; Thread.sleep(10*1000); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125; private static void newHttp()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; String url &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&quot;; URL urlConn &#x3D; new URL(url); HttpURLConnection connection &#x3D; (HttpURLConnection)urlConn.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.connect(); int responseCode &#x3D; connection.getResponseCode(); if (responseCode &#x3D;&#x3D; HttpURLConnection.HTTP_OK) &#123; InputStream inputStream &#x3D; connection.getInputStream(); String result &#x3D; is2String(inputStream); Log.d(&quot;onejane&quot;,&quot;result&#x3D;&#x3D;&#x3D;&#x3D;&quot;+result); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private static String is2String(InputStream inputStream) throws IOException &#123; byte[] buffer &#x3D; new byte[1024]; ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream(); for (int len &#x3D; 0; (len &#x3D; inputStream.read(buffer)) &gt; 0;) &#123; baos.write(buffer, 0, len); &#125; String result &#x3D; new String(baos.toByteArray(), &quot;utf-8&quot;); System.out.println(result); return result ; &#125;&#125; 关键类定位objection -g com.onejane.httpsocket explore android heap search instances java.net.Socket 查看堆内存中是否有该实例 android hooking search classes Socket 搜索与Socket相关的类 android hooking watch class java.net.Socket 默认hook类的所有方法没有构造函数 android hooking watch class_method java.net.Socket.$init –dump-args –dump-backtrace –dump-return 手动调用hook构造函数 vim ~/.pyenv/versions/3.8.0/lib/python3.8/site-packages/objection/agent.js 输入:9211跳转到9211行，加上.concat([“$init”])，会影响objection的稳定性 将与Socket相关的类添加前缀android hooking watch class存入socket.txt objection -g com.onejane.httpsocket explore -c ~/Desktop/socket.txt 批量hook，如果崩掉，需要将崩掉的类从文本中移除 okhttp底层走的socket android hooking watch class_method java.net.AbstractPlainSocketImpl.acquireFD --dump-args --dump-backtrace --dump-return 根据hook的结果拿到java.net.SocketOutputStream.write方法就是socket写入时调用的方法，针对该方法进行hook android hooking watch class_method java.net.SocketOutputStream.write --dump-args --dump-backtrace --dump-return SocketInputStream.read的hook结果复制到010Editor，搜索1f8b,删除前面所有字符，保存为gzip,解压查看结果就是百度网页结果 socket自吐实现http与https的socket自吐，修改url地址http://www.baidu.com/为https://www.baidu.com/, 有这两个自吐，可以通杀所有协议层的收发包内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function hook_socket()&#123; Java.perform(function()&#123; console.log(&quot;hook_socket;&quot;) Java.use(&quot;java.net.SocketOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTP write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; Java.use(&quot;java.net.SocketInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTP read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; &#125;)&#125;function hook_SSLsocketandroid8()&#123; Java.perform(function()&#123; console.log(&quot;hook_SSLsocket&quot;) Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTPS write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTPS read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; &#125;)&#125;function hook_SSLsocket2android10()&#123; Java.perform(function()&#123; console.log(&quot; hook_SSLsocket2&quot;) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_write.implementation &#x3D; function(long,NS,fd,NC,bytearray,int1,int2,int3)&#123; var result &#x3D; this .SSL_write(long,NS,fd,NC,bytearray,int1,int2,int3); console.log(&quot;SSL_write(long,NS,fd,NC,bytearray,int1,int2,int3),result&#x3D;&gt;&quot;,long,NS,fd,NC,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex()); return result; &#125; Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_read.implementation &#x3D; function(long,NS,fd,NC,bytearray,int1,int2,int3)&#123; var result &#x3D; this .SSL_read(long,NS,fd,NC,bytearray,int1,int2,int3); console.log(&quot;SSL_read(long,NS,fd,NC,bytearray,int1,int2,int3),result&#x3D;&gt;&quot;,long,NS,fd,NC,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex()); return result; &#125; &#125;)&#125;function main()&#123; console.log(&quot;Main&quot;) hook_socket(); hook_SSLsocketandroid8(); &#x2F;&#x2F;hook_SSLsocket2android10();&#125;setImmediate(main) frida -UF -l hookSocket.js 使用git clone https://github.com/peiniwan/Ganhuo.git 编译源码编译安装GanHuo.apk查看代码家栏,通过010Editor获取转换后的Unicode码，即为抓包结果 Websocket虚拟机网卡切换为桥接模式:192.168.0.104 server wget https://github.com/gotify/server/releases/download/v2.0.20/gotify-linux-amd64.zip unzip gotify-linux-amd64.zip chmod +x gotify-linux-amd64 ./gotify-linux-amd64 client adb install Gotify.apk 输入server地址http://192.168.0.104 admin/admin cli wget -O gotify https://github.com/gotify/cli/releases/download/v1.2.0/gotify-cli-linux-amd64 chmod +x gotify mv gotify /usr/bin/gotify gotify init gotify push -t “my title” -p 10 “my message” 服务器向手机发送消息 hook_okhttp3_logging添加十六进制转换，在控制台中以字符串显示 123456function jhexdump(array) &#123; var ptr &#x3D; Memory.alloc(array.length); for(var i &#x3D; 0; i &lt; array.length; ++i) Memory.writeS8(ptr.add(i), array[i]); console.log(hexdump(ptr, &#123; offset: 0, length: array.length, header: false, ansi: false &#125;));&#125; 使用console.log(jhexdump(bytearry))替换console.log(“bytearray contents=&gt;”, ByteString.of(bytearry).hex()) frida -UF -l hookSocket.js 使用socket自吐依旧可以通杀抓包 pm list packages|grep -i gotify 获取包名 frida -U -f com.github.gotify -l hookSocket.js –no-pause -o gotify.log objection -g com.github.gotify explore android hooking search classes websocket 查找内存中和websocket相关的类很少，可以通过android hooking watch class * ,存入websocket.txt文件批量hook 123objection -g com.github.gotify explore -c ~&#x2F;Desktop&#x2F;gotify&#x2F;websocket.txtplugin wallbreaker objectsearch com.github.gotify.client.model.Message 获取内存中的Message对象pluginwallbreaker objectdump --fullname 0x2576 获取该对象中字段在内存中的内容 android hooking search classes websocket 发现okhttp3.WebSocket,通过hook_okhttp3_logging脚本进行hook抓包frida -U -f com.github.gotify -l hookOkhttp3.js --no-pause，logcat|grep okhttpGET 查看可以抓到ok3的websocket包 android hooking search classes com.xabber.xmpp.smack 基于xmpp协议聊天软件xabber搜索包名并批量hook android hooking watch class_method java.lang.String.toString –dump-args -dump-backtrace –dump-return hookWebSocketvim hookWebSocket.js 综合基于hook和枚举的方式抓包websocket 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384function hook_okhttp3() &#123; &#x2F;&#x2F; 1. frida Hook java层的代码必须包裹在Java.perform中，Java.perform会将Hook Java相关API准备就绪。 Java.perform(function () &#123; Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;okhttp3logging.dex.dex&quot;).load(); &#x2F;&#x2F; 只修改了这一句，换句话说，只是使用不同的拦截器对象。 var MyInterceptor &#x3D; Java.use(&quot;com.roysue.octolesson2ok3.okhttp3Logging&quot;); var MyInterceptorObj &#x3D; MyInterceptor.$new(); var Builder &#x3D; Java.use(&quot;okhttp3.OkHttpClient$Builder&quot;); console.log(Builder); Builder.build.implementation &#x3D; function () &#123; this.networkInterceptors().add(MyInterceptorObj); console.log(&quot;hook Build.build successfully !&quot;) return this.build(); &#125;; console.log(&quot;hooking_okhttp3...&quot;); &#125;);&#125;function EnumerateClient()&#123; Java.perform(function()&#123; &#x2F;&#x2F;Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;r0gson.dex&quot;).load(); &#x2F;&#x2F;const gson &#x3D; Java.use(&#39;com.r0ysue.gson.Gson&#39;); var gson2 &#x3D; Java.use(&#39;com.google.gson.Gson&#39;); &#x2F;&#x2F; 加载包含CurlInterceptor拦截器的DEX Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;myok2curl.dex&quot;).load(); console.log(&quot;loading dex successful!&quot;) const curlInterceptor &#x3D; Java.use(&quot;com.moczul.ok2curl.CurlInterceptor&quot;); const loggable &#x3D; Java.use(&quot;com.moczul.ok2curl.logger.Loggable&quot;); var Log &#x3D; Java.use(&quot;android.util.Log&quot;); var TAG &#x3D; &quot;okhttpGETcurl&quot;; &#x2F;&#x2F;注册类————一个实现了所需接口的类 var MyLogClass &#x3D; Java.registerClass(&#123; name: &quot;okhttp3.MyLogClass&quot;, implements: [loggable], methods: &#123; log: function (MyMessage) &#123; Log.v(TAG, MyMessage); &#125;&#125; &#125;); const mylog &#x3D; MyLogClass.$new(); &#x2F;&#x2F; 得到所需拦截器对象 var curlInter &#x3D; curlInterceptor.$new(mylog); &#x2F;&#x2F; 加载包含logging-interceptor拦截器的DEX Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;okhttplogging.dex&quot;).load(); var MyInterceptor &#x3D; Java.use(&quot;com.r0ysue.learnokhttp.okhttp3Logging&quot;); var MyInterceptorObj &#x3D; MyInterceptor.$new(); Java.choose(&quot;okhttp3.OkHttpClient&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;1. found instance:&quot;,instance) console.log(&quot;2. instance.interceptors():&quot;,instance.interceptors().$className) console.log(&quot;3. instance._interceptors:&quot;,instance._interceptors.value.$className) &#x2F;&#x2F;console.log(&quot;4. interceptors:&quot;,gson2.$new().toJson(instance.interceptors())) console.log(&quot;5. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(instance.interceptors().toArray())) var newInter &#x3D; Java.use(&quot;java.util.ArrayList&quot;).$new(); newInter.addAll(instance.interceptors()); console.log(&quot;6. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(newInter.toArray())); console.log(&quot;7. interceptors:&quot;,newInter.$className); newInter.add(MyInterceptorObj); newInter.add(curlInter); instance._interceptors.value &#x3D; newInter; &#125;,onComplete:function()&#123; console.log(&quot;Search complete!&quot;) &#125; &#125;) &#125;)&#125;function main()&#123; hook_okhttp3(); EnumerateClient(); &#125;setImmediate(main) OkHttpLogger-Fridafrida -UF -l OkHttpLogger-Frida/okhttp_poker.js 抓包websocket Protobuf直播/弹幕协议Protobuf逆向分析，手把手教你使用ProtoBuf，通过gRPC服务在Android上进行网络请求 服务端192.168.0.102 官方教程 123456789101112131415161718192021systemctl stop firewalld.service systemctl disable firewalld.servicesetenforce 0/etc/selinux/config 修改为SELINUX=disabledtar -zxvf jdk-8u60-linux-x64.tar.gzmv jdk1.8.0_60/ /usr/local/tar -zxf apache-maven-3.6.3-bin.tar.gz -C /usr/local/vim /etc/profileJAVA_HOME=/usr/local/jdk1.8.0_60JRE_HOME=$JAVA_HOME/jreMAVEN_HOME=/usr/local/apache-maven-3.6.3PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin::$MAVEN_HOME/binCLASSPATH=:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/dt.jarexport JAVA_HOME JRE_HOME PATH CLASSPATH MAVEN_HOMEsource /etc/profilegit clone -b v1.36.1 https://github.com/grpc/grpc-javagit checkout -b v1.32.1 避免无法连接国外仓库ggcd grpc-java/examples./gradlew installDist./build/install/examples/bin/hello-world-server 启动server端口在50051./build/install/examples/bin/hello-world-client 通过HelloRequest发送Hello World 客户端192.168.0.104 git clone https://github.com/xuexiangjys/Protobuf-gRPC-Android.git ，其中helloworld.proto通过protoc编译生成HelloReply.java 手动编译，idea中安装GenProtobuf将binary进行encode和decode wget https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-linux-x86_64.zip unzip protoc-3.13.0-linux-x86_64.zip as-Tools-Configure GenProtobuf 右键hellooworld.proto点击quick gen protobuf here 实现手动编译，生成的编译代码使用了大量的google的protobuf基础库 安装启动Protobuf-gRPC-Android，保证服务端和客户端互相ping通，可以通过nc 192.168.0.102 50052 给服务端发送数据，服务端使用nc -l 50052接收，如果互通消息就可以收到，否则使用NPS将服务端的50051端口服务映射到指定服务器ip的指定端口(需要在服务端安装nps客户端，在nps服务端配置该nps客户端)。 如果没有响应，ps -ef|grep protobuf 获取到进程id后，logcat|grep -i 22916 查看log，退出重进gRPC-普通请求按钮，输入服务端ip，端口及内容发送请求。 1234567adb shellps -ef|grep protobuf 获取包名.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64 启动frida serverpyenv local 3.8.0objection -g com.xuexiang.protobufdemo exploreandroid hooking search classes protobuf 将打印出的类前面加上android hooking watch class,存入hook_list.txtobjection -g com.xuexiang.protobufdemo explore -c &#x2F;root&#x2F;Desktop&#x2F;hook_list.txt 实现批量hook，点击发送请求，从请求找寻找调用到的protobuf类相关方法 关注打印出来的几个函数： com.google.protobuf.WireFormat.makeTagcom.google.protobuf.CodedOutputStream$OutputStreamEncoder.write([B, int, int)com.google.protobuf.CodedInputStream.readTag()com.google.protobuf.WireFormat.getTagFieldNumber(int)com.google.protobuf.Utf8.encode(java.lang.CharSequence, [B, int, int)com.google.protobuf.CodedInputStream.newInstance([B, int, int, boolean) 1android hooking watch class_method com.google.protobuf.Utf8.encode --dump-args --dump-backtrace --dump-return 同理，makeTag的调用栈也是从用户代码中的writeTo调用而来。 frida -UF -l hookSocket.js -o protobuf.txt 通杀自吐打印出protubuf的包数据 12plugin wallbreaker objectsearch com.xuexiang.protobufdemo.HelloReplyplugin wallbreaker objectdump --fullname 0x22ea 内存漫游的源码 Protobuf协议逆向和仿真&amp;举个栗子 抓包+逆向app分析protobuf -Protobuf协议解析文档-某音弹幕 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"Socket","slug":"Socket","permalink":"http://onejane.github.io/tags/Socket/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://onejane.github.io/tags/WebSocket/"},{"name":"Protobuf","slug":"Protobuf","permalink":"http://onejane.github.io/tags/Protobuf/"},{"name":"XMPP","slug":"XMPP","permalink":"http://onejane.github.io/tags/XMPP/"}]},{"title":"Spring-Cloud-Alibaba","slug":"Spring-Cloud-Alibaba","date":"2021-03-11T08:03:07.000Z","updated":"2021-12-12T03:09:39.280Z","comments":true,"path":"2021/03/11/Spring-Cloud-Alibaba/","link":"","permalink":"http://onejane.github.io/2021/03/11/Spring-Cloud-Alibaba/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 SpringCloudAlibabaSpring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。 依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。 Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。 Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。 Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。 Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。 Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 虚拟机安装virtualbox 6 vagrant安装好后进入镜像仓库搜索需要安装的镜像 mkdir centos7 &amp;&amp; vagrant init centos/7 &amp;&amp; vagrant up &amp;&amp; vagrant ssh 创建并开启镜像，修改网络桥接 如果太慢，进入centos/7仓库下载，手动加载vagrant box add centos/7 CentOS-7-x86_64-Vagrant-2004_01.VirtualBox.box vim Vagrantfile 修改配置并重启vagrant reload，保存虚拟机与主机可ping通，sudo passwd root 设置root权限 12# config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot; host-onlyconfig.vm.network &quot;public_network&quot; 桥接 安装nodejs并配置淘宝源npm config set registry http://registry.npm.taobao.org/ 安装docker 1234567891011121314151617sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-enginesudo yum install -y yum-utilssudo yum-config-manager \\ --add-repo \\ https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.reposudo yum install -y docker-ce docker-ce-cli containerd.ioyum list docker-ce --showduplicates | sort -rsudo systemctl start dockersudo docker imagessudo systemctl enable docker 镜像加速器 12345678sudo mkdir -p &#x2F;etc&#x2F;dockersudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;3gki6pei.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker mysql 12345678910docker run -p 3306:3306 --name mysql \\-v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysal \\-v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql \\-e MYSQL_ROOT_PASSWORD&#x3D;root \\-d mysql:5.7docker exec -it mysql &#x2F;bin&#x2F;bashmysql -uroot -prootuse mysql;alter user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;root&#39;;flush privileges; vi /mydata/mysql/conf/my.cnf 修改编码配置 1234567891011[client]default-character-set&#x3D;utf8[mysql]default-character-set&#x3D;utf8[mysqld]init_connect&#x3D;&#39;SET collation_connection &#x3D; utf8_unicode_ci&#39;init_connect&#x3D;&#39;SET NAMES utf8&#39;character-set-server&#x3D;utf8collation-server&#x3D;utf8_unicode_ciskip-character-set-client-handshakeskip-name-resolve docker restart mysql &amp;&amp; cat /etc/mysql/my.cnf &amp;&amp; docker update mysql –restart=always redis vi /mydata/redis/conf/redis.conf 配置appendonly yes持久化硬盘 12345docker run -p 6379:6379 --name redis -v &#x2F;mydata&#x2F;redis&#x2F;data:&#x2F;data \\-v &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf \\-d redis:3.2 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf --appendonly yesdocker exec -it redis redis-clidocker update redis --restart&#x3D;always maven 123456789101112131415161718&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt; &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt;&lt;&#x2F;mirror&gt; &lt;profile&gt; &lt;id&gt;jdk18&lt;&#x2F;id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt; &lt;jdk&gt;1.8&lt;&#x2F;jdk&gt; &lt;&#x2F;activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;&#x2F;maven.compiler.compilerVersion&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;profile&gt; idea安装lombok，mybatisX插件 vscode安装Auto Close Tag,Auto Rename Tag,Chinese,Eslint,HTML CSS Support,HTML Snippets,JavaScript(ES6),Live Server,open in browser,Vetur,Vue 2 Snippets插件 git配置 12345git config --global user.name &quot;username&quot; &#x2F;&#x2F;（名字） # 配置邮箱git config --global user.email &quot;username@email.com&quot; &#x2F;&#x2F;(注册账号时用的邮箱)ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; 进入git bash生成公私钥cat ~&#x2F;.ssh&#x2F;id_rsa.pubssh -T git@gitee.com 测试是否成功即可 Nacos注册中心新建Spring Initializr作为provider项目jdk1.8并导入Web中的Spring Web和Spring Cloud Routing的OpenFeign组件，设置-Xmx100m 启动Application使用最大内存 启动nacos-server-1.3.1.zip访问nacos 修改依赖如下 123456789101112131415161718192021222324252627282930313233343536373839&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;&#x2F;spring-cloud.version&gt; &lt;spring-cloud-alibaba.version&gt;2.1.0.RELEASE&lt;&#x2F;spring-cloud-alibaba.version&gt;&lt;&#x2F;properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt; 添加application.yml配置 123456789spring: application: name: provider cloud: nacos: discovery: server-addr: 127.0.0.1:8848server: port: 8000 ProviderApplication启动类添加@EnableDiscoveryClient,启动后在nacos控制台查看已经上线的服务 Nacos配置中心默认配置读取application.properties添加配置 12user.name&#x3D;onejaneuser.age&#x3D;20 Controller实现读取 123456789101112@RestController@RequestMapping(&quot;test&quot;)public class UserController &#123; @Value(&quot;$&#123;user.name&#125;&quot;) private String name; @Value(&quot;$&#123;user.age&#125;&quot;) private Integer age; @RequestMapping(&quot;&#x2F;user&quot;) public void test()&#123; System.out.println(name+&quot;:&quot;+age); &#125;&#125; Nacos配置项目添加config依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; Provider项目创建bootstrap.properties 12spring.application.name&#x3D;providerspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848 Nacos中配置provider.properties，默认规则，取public命名空间的应用名.properties，类型为Properties，相同与application.properties时优先使用配置中心的配置。 12user.name&#x3D;onejane1user.age&#x3D;23 多环境配置配置命名空间provider，命名空间ID为f7d49148-09a8-4ca1-8a40-c52e9cb627b5，在该命名空间下配置provider.properties，Group为prod 12user.name&#x3D;onejane2user.age&#x3D;23 配置bootstrap.properties 1234spring.application.name&#x3D;providerspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848spring.cloud.nacos.config.namespace&#x3D;f7d49148-09a8-4ca1-8a40-c52e9cb627b5spring.cloud.nacos.config.group&#x3D;prod 命名空间，用于配置隔离，默认新增的所有配置都在public空间。 1、开发，测试，生产：利用命名空间来做环境隔离。在bootstrap.properties；配置spring.cloud.nacos.config.namespace需要使用哪个命名空间下的配置 2、每一个微服务之间互相隔离配置，每一个微服务都创建自己的命名空间，只加载自己命名空间下的所有配置 每个微服务创建自己的命名空间，使用配置分组区分环境，dev，test，prod 多文件配置在Nacos中provider微服务命名空间配置datasource.yml 123456spring: datasource: username: root password: root url: jdbc:mysql:&#x2F;&#x2F;172.20.1.185:3306&#x2F;user driver-class-name: com.mysql.jdbc.Driver 配置mybatis.yml 12345mybatis-plus: mapper-locations: classpath:&#x2F;mapper&#x2F;**&#x2F;*.xml global-config: db-config: id-type: auto 配置service.yml 123456789spring: application: name: provider cloud: nacos: discovery: server-addr: 127.0.0.1:8848 server: port: 7000 注释application.yml中所有配置并在bootstrap.properties中实现多文件配置 1234567891011121314151617spring.application.name&#x3D;providerspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848spring.cloud.nacos.config.namespace&#x3D;f7d49148-09a8-4ca1-8a40-c52e9cb627b5spring.cloud.nacos.config.group&#x3D;prodspring.cloud.nacos.config.ext-config[0].data-id&#x3D;datasource.ymlspring.cloud.nacos.config.ext-config[0].group&#x3D;devspring.cloud.nacos.config.ext-config[0].refresh&#x3D;truespring.cloud.nacos.config.ext-config[1].data-id&#x3D;mybatis.ymlspring.cloud.nacos.config.ext-config[1].group&#x3D;devspring.cloud.nacos.config.ext-config[1].refresh&#x3D;truespring.cloud.nacos.config.ext-config[2].data-id&#x3D;other.ymlspring.cloud.nacos.config.ext-config[2].group&#x3D;devspring.cloud.nacos.config.ext-config[2].refresh&#x3D;true Mybatis-Plus持久化引入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;3.2.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.17&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;version&gt;1.18.8&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 配置数据源 123456789101112131415spring: datasource: username: root password: root url: jdbc:mysql:&#x2F;&#x2F;172.20.1.185:3306&#x2F;user driver-class-name: com.mysql.jdbc.Driver jackson: date-format: yyyy-MM-dd HH:mm:ss # 输出日期自动转换mybatis-plus: mapper-locations: classpath:&#x2F;mapper&#x2F;**&#x2F;*.xml global-config: db-config: id-type: auto logic-delete-value: 1 # 逻辑删除 logic-not-delete-value: 0 配置扫描包 1@MapperScan(&quot;com.onejane.demo.provider.dao&quot;) 添加实体类 123456789101112131415@Data@TableName(&quot;user_info&quot;)public class UserInfoEntity implements Serializable &#123; private static final long serialVersionUID &#x3D; 1L; @TableId private Long id; private String name; private Long age; &#x2F;** * 是否显示[0-不显示，1显示] 用于逻辑删除 *&#x2F; @TableLogic(value &#x3D; &quot;1&quot;,delval &#x3D; &quot;0&quot;) private Integer status;&#125; 逻辑删除实现 1234567@AutowiredUserInfoSerivce userInfoSerivce;@RequestMapping(&quot;&#x2F;delete&quot;)public R delete(Long[] ids)&#123; userInfoSerivce.removeByIds(Arrays.asList(ids)); return R.ok();&#125; 分页查询实现 1234567891011121314151617181920public interface UserInfoSerivce extends IService&lt;UserInfoEntity&gt; &#123; PageUtils queryPage(Map&lt;String, Object&gt; params);&#125;@Service(&quot;userInfoService&quot;)public class UserInfoServiceImpl extends ServiceImpl&lt;UserInfoDao, UserInfoEntity&gt; implements UserInfoSerivce &#123; @Override public PageUtils queryPage(Map&lt;String, Object&gt; params) &#123; IPage&lt;UserInfoEntity&gt; page &#x3D; this.page( new Query&lt;UserInfoEntity&gt;().getPage(params), new QueryWrapper&lt;UserInfoEntity&gt;() ); return new PageUtils(page); &#125;&#125;@RequestMapping(&quot;&#x2F;list&quot;)public R list(@RequestParam Map&lt;String, Object&gt; params)&#123; PageUtils page &#x3D; userInfoSerivce.queryPage(params); return R.ok().put(&quot;page&quot;, page);&#125; 分页配置 12345678910111213141516@Configuration@EnableTransactionManagement &#x2F;&#x2F;开启事务@MapperScan(&quot;com.onejane.demo.provider.dao&quot;)public class MyBatisConfig &#123; &#x2F;&#x2F;引入分页插件 @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor paginationInterceptor &#x3D; new PaginationInterceptor(); &#x2F;&#x2F; 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false paginationInterceptor.setOverflow(true); &#x2F;&#x2F; 设置最大单页限制数量，默认 500 条，-1 不受限制 paginationInterceptor.setLimit(1000); return paginationInterceptor; &#125;&#125; Feign远程调用新建Spring Initializr作为consumer项目jdk1.8并导入Web中的Spring Web和Spring Cloud Routing的OpenFeign组件，设置-Xmx100m 启动Application使用最大内存 provider提供api，启动类配置@EnableDiscoveryClient后启动应用 consumer中引入nacos依赖 123456789101112131415161718192021222324252627282930313233&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;&#x2F;spring-cloud.version&gt; &lt;spring-cloud-alibaba.version&gt;2.1.0.RELEASE&lt;&#x2F;spring-cloud-alibaba.version&gt;&lt;&#x2F;properties&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt; Member作为consumer获取feign调用，定义feign方法 1234567@FeignClient(&quot;provider&quot;)public interface ProviderFeignService &#123; @RequestMapping(&quot;&#x2F;test&#x2F;list&quot;) public void test();&#125; consumer在控制器中申请远程调用，并在启动类中开启feign调用@EnableFeignClients(basePackages = &quot;com.onejane.demo.consumer.feign&quot;)并将consumer加入nacos注册中心@EnableDiscoveryClient 12345@FeignClient(&quot;provider&quot;)public interface ProviderFeignService &#123; @RequestMapping(&quot;&#x2F;test&#x2F;user&quot;) public void test();&#125; 在application.yml中配置nacos 123456789spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 application: name: consumerserver: port: 7000 开启feign远程调用 12345678910@RestController@RequestMapping(&quot;test&quot;)public class UserInfoController &#123; @Autowired ProviderFeignService providerFeignService; @RequestMapping(&quot;&#x2F;user&quot;) public void test()&#123; providerFeignService.test(); &#125;&#125; Gateway网关修改provider项目新增server.servlet.context-path: /provider 新建Spring Initializr作为网关项目项目jdk1.8并导入Spring Cloud Routing的Gateway组件 pom依赖修改 12345678910&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;&#x2F;spring-cloud.version&gt;&lt;&#x2F;properties&gt; application.properties添加配置 123spring.cloud.nacos.discovery.server-addr&#x3D;127.0.0.1:8848spring.application.name&#x3D;gatewayserver.port&#x3D;88 在nacos中配置微服务命名空间gateway,ID为7601cb5a-a9dd-43d8-a1b9-a37952674df2，添加配置文件gateway.yml 123spring: application: name: gateway bootstrap.properties配置命名空间 123spring.application.name&#x3D;gatewayspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848spring.cloud.nacos.config.namespace&#x3D;7601cb5a-a9dd-43d8-a1b9-a37952674df2 application.yml中添加网关配置，访问http://localhost:88/?url=qq 则跳转到https://www.qq.com?url=qq， 访问http://localhost:88/?url=baidu 则跳转到https://www.baidu.com?url=baidu 123456789101112131415161718192021222324spring: cloud: gateway: routes: - id: test_route uri: https:&#x2F;&#x2F;www.baidu.com predicates: - Query&#x3D;url,baidu - id: qq_route uri: https:&#x2F;&#x2F;www.qq.com predicates: - Query&#x3D;url,qq - id: provider_route uri: lb:&#x2F;&#x2F;provider predicates: - Path&#x3D;&#x2F;api&#x2F;provider&#x2F;** filters: - RewritePath&#x3D;&#x2F;api&#x2F;(?&lt;segment&gt;.*),&#x2F;$\\&#123;segment&#125; application: name: gateway# http:&#x2F;&#x2F;localhost:88&#x2F;api&#x2F;provider&#x2F;test&#x2F;user &#x3D;&#x3D;&gt; http:&#x2F;&#x2F;localhost:8000&#x2F;provider&#x2F;test&#x2F;user 在启动类中配置@EnableDiscoveryClient，并过滤掉数据库配置@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) 跨域12345678910111213141516171819@Configurationpublic class GulimallCorsConfiguration &#123; @Bean public CorsWebFilter corsWebFilter()&#123; UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource(); CorsConfiguration corsConfiguration &#x3D; new CorsConfiguration(); &#x2F;&#x2F;1、配置跨域 corsConfiguration.addAllowedHeader(&quot;*&quot;); corsConfiguration.addAllowedMethod(&quot;*&quot;); corsConfiguration.addAllowedOrigin(&quot;*&quot;); corsConfiguration.setAllowCredentials(true); source.registerCorsConfiguration(&quot;&#x2F;**&quot;,corsConfiguration); return new CorsWebFilter(source); &#125;&#125; 阿里云oss引入阿里云oss依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alicloud-oss&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; application.yml配置阿里云AccessKey 12345678spring: cloud: alicloud: access-key: *** secret-key: *** oss: endpoint: oss-cn-beijing.aliyuncs.com bucket: onejane-opencv 上传图片一般先通过服务端签名后前端直传 JSR303通过自定义校验，分组校验及全局校验实现对Spring MVC入参的参数校验。 加入validation依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;&#x2F;groupId&gt; &lt;artifactId&gt;validation-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0.1.Final&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 加入校验注解 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;** * 品牌id *&#x2F;@NotNull(message &#x3D; &quot;修改必须指定品牌id&quot;,groups &#x3D; &#123;UpdateGroup.class&#125;)@Null(message &#x3D; &quot;新增不能指定id&quot;,groups &#x3D; &#123;AddGroup.class&#125;)@TableIdprivate Long brandId;&#x2F;** * 品牌名 *&#x2F;@NotBlank(message &#x3D; &quot;品牌名必须提交&quot;,groups &#x3D; &#123;AddGroup.class,UpdateGroup.class&#125;)private String name;&#x2F;** * 品牌logo地址 *&#x2F;@NotBlank(groups &#x3D; &#123;AddGroup.class&#125;)@URL(message &#x3D; &quot;logo必须是一个合法的url地址&quot;,groups&#x3D;&#123;AddGroup.class,UpdateGroup.class&#125;)private String logo;&#x2F;** * 介绍 *&#x2F;private String descript;&#x2F;** * 显示状态[0-不显示；1-显示] *&#x2F;@NotNull(groups &#x3D; &#123;AddGroup.class, UpdateStatusGroup.class&#125;)@ListValue(vals&#x3D;&#123;0,1&#125;,groups &#x3D; &#123;AddGroup.class, UpdateStatusGroup.class&#125;)private Integer showStatus;&#x2F;** * 检索首字母 *&#x2F;@NotEmpty(groups&#x3D;&#123;AddGroup.class&#125;)@Pattern(regexp&#x3D;&quot;^[a-zA-Z]$&quot;,message &#x3D; &quot;检索首字母必须是一个字母&quot;,groups&#x3D;&#123;AddGroup.class, UpdateGroup.class&#125;)private String firstLetter;&#x2F;** * 排序 *&#x2F;@NotNull(groups&#x3D;&#123;AddGroup.class&#125;)@Min(value &#x3D; 0,message &#x3D; &quot;排序必须大于等于0&quot;,groups&#x3D;&#123;AddGroup.class,UpdateGroup.class&#125;)private Integer sort; 建立分组校验类 123public interface AddGroup &#123;&#125;public interface UpdateGroup &#123;&#125;public interface UpdateStatusGroup &#123;&#125; 自定义异常注解 12345678910111213@Documented@Constraint(validatedBy &#x3D; &#123; ListValueConstraintValidator.class &#125;)@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)@Retention(RUNTIME)public @interface ListValue &#123; String message() default &quot;&#123;com.onejane.demo.provider.valid.ListValue.message&#125;&quot;; Class&lt;?&gt;[] groups() default &#123; &#125;; Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;; int[] vals() default &#123; &#125;;&#125; 自定义异常实现 12345678910111213141516171819202122232425262728public class ListValueConstraintValidator implements ConstraintValidator&lt;ListValue,Integer&gt; &#123; private Set&lt;Integer&gt; set &#x3D; new HashSet&lt;&gt;(); &#x2F;&#x2F;初始化方法 @Override public void initialize(ListValue constraintAnnotation) &#123; int[] vals &#x3D; constraintAnnotation.vals(); for (int val : vals) &#123; set.add(val); &#125; &#125; &#x2F;&#x2F;判断是否校验成功 &#x2F;** * * @param value 需要校验的值 * @param context * @return *&#x2F; @Override public boolean isValid(Integer value, ConstraintValidatorContext context) &#123; return set.contains(value); &#125;&#125; 控制器层加入字段校验配置 12345678910111213141516171819202122232425262728293031323334353637@RequestMapping(&quot;&#x2F;save&quot;)public R save(@Validated(&#123;AddGroup.class&#125;) @RequestBody BrandEntity brand&#x2F;*,BindingResult result*&#x2F;)&#123;&#x2F;&#x2F; if(result.hasErrors())&#123;&#x2F;&#x2F; Map&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F; &#x2F;&#x2F;1、获取校验的错误结果&#x2F;&#x2F; result.getFieldErrors().forEach((item)-&gt;&#123;&#x2F;&#x2F; &#x2F;&#x2F;FieldError 获取到错误提示&#x2F;&#x2F; String message &#x3D; item.getDefaultMessage();&#x2F;&#x2F; &#x2F;&#x2F;获取错误的属性的名字&#x2F;&#x2F; String field &#x3D; item.getField();&#x2F;&#x2F; map.put(field,message);&#x2F;&#x2F; &#125;);&#x2F;&#x2F;&#x2F;&#x2F; return R.error(400,&quot;提交的数据不合法&quot;).put(&quot;data&quot;,map);&#x2F;&#x2F; &#125;else &#123;&#x2F;&#x2F; 为避免每次请求都判断异常输出，通过ExceptionControllerAdvice实现全局异常控制 brandService.save(brand); return R.ok();&#125;&#x2F;** * 修改 *&#x2F;@RequestMapping(&quot;&#x2F;update&quot;)public R update(@Validated(UpdateGroup.class) @RequestBody BrandEntity brand)&#123; brandService.updateById(brand); return R.ok();&#125;&#x2F;** * 修改状态 *&#x2F;@RequestMapping(&quot;&#x2F;update&#x2F;status&quot;)public R updateStatus(@Validated(UpdateStatusGroup.class) @RequestBody BrandEntity brand)&#123; brandService.updateById(brand); return R.ok();&#125; 全局异常控制配置 123456789101112131415161718192021222324252627@Slf4j&#x2F;&#x2F;@ResponseBody&#x2F;&#x2F;@ControllerAdvice(basePackages &#x3D; &quot;com.onejane.demo.provider.controller&quot;)@RestControllerAdvice(basePackages &#x3D; &quot;com.onejane.demo.provider.controller&quot;)public class ExceptionControllerAdvice &#123; @ExceptionHandler(value&#x3D; MethodArgumentNotValidException.class) public R handleVaildException(MethodArgumentNotValidException e)&#123; log.error(&quot;数据校验出现问题&#123;&#125;，异常类型：&#123;&#125;&quot;,e.getMessage(),e.getClass()); BindingResult bindingResult &#x3D; e.getBindingResult(); Map&lt;String,String&gt; errorMap &#x3D; new HashMap&lt;&gt;(); bindingResult.getFieldErrors().forEach((fieldError)-&gt;&#123; errorMap.put(fieldError.getField(),fieldError.getDefaultMessage()); &#125;); return R.error(BizCodeEnume.VAILD_EXCEPTION.getCode(),BizCodeEnume.VAILD_EXCEPTION.getMsg()).put(&quot;data&quot;,errorMap); &#125; @ExceptionHandler(value &#x3D; Throwable.class) public R handleException(Throwable throwable)&#123; log.error(&quot;错误：&quot;,throwable); return R.error(BizCodeEnume.UNKNOW_EXCEPTION.getCode(),BizCodeEnume.UNKNOW_EXCEPTION.getMsg()); &#125;&#125; var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"nacos","slug":"nacos","permalink":"http://onejane.github.io/tags/nacos/"},{"name":"feign","slug":"feign","permalink":"http://onejane.github.io/tags/feign/"},{"name":"gateway","slug":"gateway","permalink":"http://onejane.github.io/tags/gateway/"},{"name":"sentinel","slug":"sentinel","permalink":"http://onejane.github.io/tags/sentinel/"}]},{"title":"opencv实现盲水印","slug":"opencv实现盲水印","date":"2021-03-11T01:53:40.000Z","updated":"2021-12-12T03:09:39.286Z","comments":true,"path":"2021/03/11/opencv实现盲水印/","link":"","permalink":"http://onejane.github.io/2021/03/11/opencv%E5%AE%9E%E7%8E%B0%E7%9B%B2%E6%B0%B4%E5%8D%B0/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 主要用于图片版权追溯，用户指纹识别等场景，保证用户版权以及作为防盗反爬关键性法律证据。 opencvwindows解压opencv-3.4.2.tar.gz，项目运行是在VM options中加入库环境-Djava.library.path=D:\\opencv3.4.2\\opencv\\build\\java\\x64;D:\\opencv3.4.2\\opencv\\build\\x64\\vc14\\bin linux配置docker容器 vim Dockerfile 1234567891011121314151617181920FROM docker.io&#x2F;centos:7MAINTAINER OneJaneWORKDIR &#x2F;usrRUN mkdir &#x2F;usr&#x2F;local&#x2F;javaADD jdk-8u60-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;java&#x2F;ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_60ENV JRE_HOME $JAVA_HOME&#x2F;jreENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib:$CLASSPATHENV PATH $JAVA_HOME&#x2F;bin:$PATHRUN mkdir -p &#x2F;usr&#x2F;local&#x2F;opencv_make&#x2F;buildADD opencv-3.4.2 &#x2F;usr&#x2F;local&#x2F;opencv_makeRUN yum -y install gtk2 gimp-libs zlib libtiff libjpeg libpng gstreamer libavc1394 libraw1394 jasper-utils swig python libtool nasmRUN cd &#x2F;usr&#x2F;local&#x2F;opencv_make&#x2F;build &amp;&amp; cmake -D CMAKE_BUILD_TYPE&#x3D;RELEASE -D CMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;opencv_make&#x2F;build -DBUILD_TESTS&#x3D;OFF ..RUN cd &#x2F;usr&#x2F;local&#x2F;opencv_make&#x2F;build &amp;&amp; makeRUN cp &#x2F;usr&#x2F;local&#x2F;opencv_make&#x2F;build&#x2F;lib&#x2F;libopencv_java342.so &#x2F;usr&#x2F;libADD apache-tomcat-8.5.46 &#x2F;usr&#x2F;local&#x2F;tomcatRUN echo &quot;tail -f &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;logs&#x2F;catalina.out &quot; &gt;&gt; &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;bin&#x2F;catalina.shEXPOSE 8080ENTRYPOINT [&quot;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;bin&#x2F;catalina.sh&quot;]CMD [&quot;start&quot;] 打包上传到docker hub 123456docker build -t&#x3D;&#39;motor-tomcat8-opencv3&#39; .docker logindocker tag 9d98e987fc07 onejane&#x2F;motor-tomcat8-opencv3:latestdocker push onejane&#x2F;motor-tomcat8-opencv3:latestdocker pull docker.io&#x2F;onejane&#x2F;motor-tomcat8-opencv3docker run -di --name opencv -p 8080:8080 9d98e987fc07 盲水印加入依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.openpnp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;opencv&lt;&#x2F;artifactId&gt; &lt;version&gt;3.4.2-1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 加解盲水印 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207import org.opencv.core.Point;import org.opencv.core.*;import org.opencv.imgcodecs.Imgcodecs;import javax.imageio.ImageIO;import java.awt.*;import java.awt.image.BufferedImage;import java.awt.image.DataBufferByte;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import static org.opencv.core.Core.BORDER_CONSTANT;import static org.opencv.core.Core.copyMakeBorder;import static org.opencv.imgproc.Imgproc.putText;public class DarkWatermarkUtil &#123; private static List&lt;Mat&gt; planes &#x3D; new ArrayList&lt;Mat&gt;(); private static List&lt;Mat&gt; allPlanes &#x3D; new ArrayList&lt;Mat&gt;(); public static Mat addImageWatermarkWithText(Mat image, String watermarkText) &#123; &#x2F;&#x2F;优化图像的尺寸 &#x2F;&#x2F;Mat padded &#x3D; optimizeImageDim(image); Mat complexImage &#x3D; new Mat(); Mat padded &#x3D; splitSrc(image); padded.convertTo(padded, CvType.CV_32F); planes.add(padded); planes.add(Mat.zeros(padded.size(), CvType.CV_32F)); Core.merge(planes, complexImage); &#x2F;&#x2F; dft Core.dft(complexImage, complexImage); &#x2F;&#x2F; 添加文本水印 Scalar scalar &#x3D; new Scalar(0, 0, 0); Point point &#x3D; new Point(60, 60); putText(complexImage, watermarkText, point, Core.FONT_HERSHEY_DUPLEX, 0.8D, scalar, 2); Core.flip(complexImage, complexImage, -1); putText(complexImage, watermarkText, point, Core.FONT_HERSHEY_DUPLEX, 0.8D, scalar, 2); Core.flip(complexImage, complexImage, -1); return antitransformImage(complexImage, allPlanes,padded); &#125; public static Mat getImageWatermarkWithText(Mat image) &#123; List&lt;Mat&gt; planes &#x3D; new ArrayList&lt;Mat&gt;(); Mat complexImage &#x3D; new Mat(); Mat padded &#x3D; splitSrc(image); padded.convertTo(padded, CvType.CV_32F); planes.add(padded); planes.add(Mat.zeros(padded.size(), CvType.CV_32F)); Core.merge(planes, complexImage); &#x2F;&#x2F; dft Core.dft(complexImage, complexImage); Mat magnitude &#x3D; createOptimizedMagnitude(complexImage); planes.clear(); return magnitude; &#125; private static Mat splitSrc(Mat mat) &#123;&#x2F;&#x2F; mat &#x3D; optimizeImageDim(mat); Mat padded &#x3D; new Mat(); Core.split(mat, allPlanes); if (allPlanes.size() &gt; 1) &#123; for (int i &#x3D; 0; i &lt; allPlanes.size(); i++) &#123; if (i &#x3D;&#x3D; 0) &#123; padded &#x3D; allPlanes.get(i); break; &#125; &#125; &#125; else &#123; padded &#x3D; mat; &#125; return padded; &#125; private static Mat antitransformImage(Mat complexImage, List&lt;Mat&gt; allPlanes,Mat padded) &#123; Mat invDFT &#x3D; new Mat(); Core.idft(complexImage, invDFT, Core.DFT_SCALE | Core.DFT_REAL_OUTPUT, 0); Mat restoredImage &#x3D; new Mat(); invDFT.convertTo(restoredImage, CvType.CV_8U); if (allPlanes.size() &#x3D;&#x3D; 0) &#123; allPlanes.add(restoredImage); &#125; else &#123; allPlanes.set(0, restoredImage); &#125; Mat lastImage &#x3D; new Mat(); Core.merge(allPlanes, lastImage); planes.clear(); allPlanes.clear(); complexImage.release(); invDFT.release(); restoredImage.release(); padded.release(); return lastImage; &#125; private static Mat optimizeImageDim(Mat image) &#123; Mat padded &#x3D; new Mat(); int addPixelRows &#x3D; Core.getOptimalDFTSize(image.rows()); int addPixelCols &#x3D; Core.getOptimalDFTSize(image.cols()); copyMakeBorder(image, padded, 0, addPixelRows - image.rows(), 0, addPixelCols - image.cols(), BORDER_CONSTANT, Scalar.all(0)); return padded; &#125; private static Mat createOptimizedMagnitude(Mat complexImage) &#123; List&lt;Mat&gt; newPlanes &#x3D; new ArrayList&lt;Mat&gt;(); Mat mag &#x3D; new Mat(); Core.split(complexImage, newPlanes); Core.magnitude(newPlanes.get(0), newPlanes.get(1), mag); Core.add(Mat.ones(mag.size(), CvType.CV_32F), mag, mag); Core.log(mag, mag); shiftDFT(mag); mag.convertTo(mag, CvType.CV_8UC1); Core.normalize(mag, mag, 0, 255, Core.NORM_MINMAX, CvType.CV_8UC1); return mag; &#125; private static void shiftDFT(Mat image) &#123; image &#x3D; image.submat(new Rect(0, 0, image.cols() &amp; -2, image.rows() &amp; -2)); int cx &#x3D; image.cols() &#x2F; 2; int cy &#x3D; image.rows() &#x2F; 2; Mat q0 &#x3D; new Mat(image, new Rect(0, 0, cx, cy)); Mat q1 &#x3D; new Mat(image, new Rect(cx, 0, cx, cy)); Mat q2 &#x3D; new Mat(image, new Rect(0, cy, cx, cy)); Mat q3 &#x3D; new Mat(image, new Rect(cx, cy, cx, cy)); Mat tmp &#x3D; new Mat(); q0.copyTo(tmp); q3.copyTo(q0); tmp.copyTo(q3); q1.copyTo(tmp); q2.copyTo(q1); tmp.copyTo(q2); &#125; public static BufferedImage Mat2BufImg(Mat matrix, String fileExtension) &#123; &#x2F;&#x2F; convert the matrix into a matrix of bytes appropriate for &#x2F;&#x2F; this file extension MatOfByte mob &#x3D; new MatOfByte(); Imgcodecs.imencode(fileExtension, matrix, mob); &#x2F;&#x2F; convert the &quot;matrix of bytes&quot; into a byte array byte[] byteArray &#x3D; mob.toArray(); BufferedImage bufImage &#x3D; null; try &#123; InputStream in &#x3D; new ByteArrayInputStream(byteArray); bufImage &#x3D; ImageIO.read(in); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bufImage; &#125; public static Mat BufImg2Mat(BufferedImage original, int imgType, int matType) &#123; if (original &#x3D;&#x3D; null) &#123; throw new IllegalArgumentException(&quot;original &#x3D;&#x3D; null&quot;); &#125;&#x2F;&#x2F; System.loadLibrary(&quot;opencv_java342&quot;);&#x2F;&#x2F; System.loadLibrary(Core.NATIVE_LIBRARY_NAME);&#x2F;&#x2F; System.load(&quot;D:\\\\opencv3.4.2\\\\opencv\\\\build\\\\java\\\\x64\\\\opencv_java342.dll&quot;); &#x2F;&#x2F;System.out.println(Core.NATIVE_LIBRARY_NAME); &#x2F;&#x2F; Don&#39;t convert if it already has correct type if (original.getType() !&#x3D; imgType) &#123; &#x2F;&#x2F; Create a buffered image BufferedImage image &#x3D; new BufferedImage(original.getWidth(), original.getHeight(), imgType); &#x2F;&#x2F; Draw the image onto the new buffer Graphics2D g &#x3D; image.createGraphics(); try &#123; g.setComposite(AlphaComposite.Src); g.drawImage(original, 0, 0, null); &#125; finally &#123; g.dispose(); &#125; &#125; byte[] pixels &#x3D; ((DataBufferByte) original.getRaster().getDataBuffer()).getData(); Mat mat &#x3D; Mat.eye(original.getHeight(), original.getWidth(), matType); mat.put(0, 0, pixels); return mat; &#125; static &#123; &#x2F;&#x2F;加载opencv动态库 System.loadLibrary(Core.NATIVE_LIBRARY_NAME); &#125; public static void main(String[] args) &#123; &#x2F;&#x2F; 加盲水印&#x2F;&#x2F; Mat img &#x3D; Imgcodecs.imread(&quot;&#x2F;tmp&#x2F;s.jpg&quot;);&#x2F;&#x2F; Mat watermarkImg &#x3D; addImageWatermarkWithText(img,&quot;onejane&quot;);&#x2F;&#x2F; Imgcodecs.imwrite(&quot;&#x2F;tmp&#x2F;s_encode.jpg&quot;, watermarkImg); &#x2F;&#x2F; 解盲水印 Mat img &#x3D; Imgcodecs.imread(&quot;&#x2F;tmp&#x2F;s_encode.jpg&quot;); Mat watermarkImg &#x3D; getImageWatermarkWithText(img); Imgcodecs.imwrite(&quot;s_decode.jpg&quot;, watermarkImg); &#125;&#125; 在maven中配置插件，将依赖打包入jar 1234567891011121314151617181920212223&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;3.1&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;&#x2F;source&gt; &lt;target&gt;1.8&lt;&#x2F;target&gt; &lt;encoding&gt;utf8&lt;&#x2F;encoding&gt; &lt;&#x2F;configuration&gt;&lt;&#x2F;plugin&gt;&lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;&#x2F;artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.allen.capturewebdata.Main&lt;&#x2F;mainClass&gt; &lt;&#x2F;manifest&gt; &lt;&#x2F;archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;&#x2F;descriptorRef&gt; &lt;&#x2F;descriptorRefs&gt; &lt;&#x2F;configuration&gt;&lt;&#x2F;plugin&gt; java -cp pirate_tools_aliyun_image-1.2.5-jar-with-dependencies.jar com.onejane.image.DarkWatermarkUtil 主动调用实现类，获取解开的盲水印 阿里云 上传待添加水印的图片到OSS Bucket 根据添加的盲水印类型准备水印信息。 图片类型：准备水印图片并上传水印图片到OSS Bucket。 文字类型：准备水印文字内容。 调用PutProject接口创建项目，并设置Type为PhotoStarter，或者通过智能媒体管理控制台新建项目 引入pom依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;&#x2F;groupId&gt; &lt;artifactId&gt;imm20170906&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 实现加解盲水印 123456789101112131415161718192021222324252627282930313233343536373839public static com.aliyun.imm20170906.Client createClient(String accessKeyId, String accessKeySecret) throws Exception &#123; Config config &#x3D; new Config() .setAccessKeyId(accessKeyId) .setAccessKeySecret(accessKeySecret); config.endpoint &#x3D; &quot;imm.cn-beijing.aliyuncs.com&quot;; return new com.aliyun.imm20170906.Client(config);&#125;public static void main(String ss[]) &#123; try &#123; com.aliyun.imm20170906.Client Imgclient &#x3D; createClient(accessKeyId, accessKeySecret); EncodeBlindWatermarkRequest encodeBlindWatermarkRequest &#x3D; new EncodeBlindWatermarkRequest(); encodeBlindWatermarkRequest.setModel(&quot;DWT_IBG&quot;); encodeBlindWatermarkRequest.setImageUri(&quot;oss:&#x2F;&#x2F;onejane-opencv&#x2F;DSC02804.JPG&quot;);&#x2F;&#x2F; encodeBlindWatermarkRequest.setWatermarkUri(&quot;oss:&#x2F;&#x2F;onejane-opencv&#x2F;water.png&quot;);&#x2F;&#x2F; encodeBlindWatermarkRequest.setTargetImageType(&quot;png&quot;); encodeBlindWatermarkRequest.setContent(&quot;哈罗摩托&quot;); encodeBlindWatermarkRequest.setProject(&quot;onejane&quot;); encodeBlindWatermarkRequest.setTargetUri(&quot;oss:&#x2F;&#x2F;onejane-opencv&#x2F;DSC02804_encode.JPG&quot;);&#x2F;&#x2F; encodeBlindWatermarkRequest.setTargetUri(&quot;oss:&#x2F;&#x2F;onejane-opencv&#x2F;DSC02804_img_encode.JPG&quot;); EncodeBlindWatermarkResponse encodeBlindWatermarkResponse &#x3D; Imgclient.encodeBlindWatermark(encodeBlindWatermarkRequest); System.out.println(JSON.toJSONString(encodeBlindWatermarkResponse)); DecodeBlindWatermarkRequest decodeBlindWatermarkRequest &#x3D; new DecodeBlindWatermarkRequest(); decodeBlindWatermarkRequest.setImageQuality(90); decodeBlindWatermarkRequest.setModel(&quot;DWT_IBG&quot;);&#x2F;&#x2F; decodeBlindWatermarkRequest.setImageUri(&quot;oss:&#x2F;&#x2F;onejane-opencv&#x2F;DSC02804_img_encode.JPG&quot;); decodeBlindWatermarkRequest.setImageUri(&quot;oss:&#x2F;&#x2F;onejane-opencv&#x2F;DSC02804_encode.JPG&quot;); decodeBlindWatermarkRequest.setOriginalImageUri(&quot;oss:&#x2F;&#x2F;onejane-opencv&#x2F;DSC02804.JPG&quot;); decodeBlindWatermarkRequest.setProject(&quot;onejane&quot;);&#x2F;&#x2F; decodeBlindWatermarkRequest.setTargetUri(&quot;oss:&#x2F;&#x2F;onejane-opencv&#x2F;DSC02804_img_decode.JPG&quot;); decodeBlindWatermarkRequest.setTargetUri(&quot;oss:&#x2F;&#x2F;onejane-opencv&#x2F;DSC02804_decode.JPG&quot;); DecodeBlindWatermarkResponse decodeBlindWatermarkResponse &#x3D; Imgclient.decodeBlindWatermark(decodeBlindWatermarkRequest); System.out.println(JSON.toJSONString(decodeBlindWatermarkResponse)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"http://onejane.github.io/tags/opencv/"}]},{"title":"HttpURLConnection&OK3&Retrofit自吐通杀","slug":"HttpURLConnection&OK3&Retrofit自吐通杀","date":"2021-03-01T17:28:26.000Z","updated":"2021-12-12T03:09:39.224Z","comments":true,"path":"2021/03/02/HttpURLConnection&OK3&Retrofit自吐通杀/","link":"","permalink":"http://onejane.github.io/2021/03/02/HttpURLConnection&OK3&Retrofit%E8%87%AA%E5%90%90%E9%80%9A%E6%9D%80/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 HttpURLConnectionadb install -r -t network-debug.apk 启动frida 12adb shell .&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64 内存漫游 123456pyenv local 3.8.0objection -g com.example.network explore -P ~&#x2F;.objection&#x2F;pluginsandroid hooking list classes 查看所有可hook的类android hooking search classes URLandroid hooking watch class java.net.URL 由于hookURL类遗漏构造函数需要手动hook $initandroid hooking watch class_method java.net.URL.$init --dump-args --dump-backtrace --dump-return hook构造函数并打印 点击HTTP图片获取按钮，实现自吐第一步，并拿到上层实现类HttpURLConnectionImpl 123android hooking search classes HttpURLConnectionImplandroid hooking watch class com.android.okhttp.internal.huc.HttpURLConnectionImpl hook类所有方法并打印方法android hooking watch class_method com.android.okhttp.internal.huc.HttpURLConnectionImpl.setRequestProperty --dump-args --dump-backtrace --dump-return hook类指定方法并打印出入参及调用栈 点击HTTP图片获取按钮，实现自吐第二步 plugin wallbreaker objectsearch com.android.okhttp.internal.huc.HttpURLConnectionImpl 存在多个实例说明每次点击生成新的对象且不释放 plugin wallbreaker objectdump –fullname 0x2972 打印其中一个对象在内存中的结构 android heap search instances com.android.okhttp.internal.huc.HttpURLConnectionImpl 获取内存中的实例地址 android heap execute 0x21e6 defaultUserAgent 手动调用defaultUserAgent 自吐frida -U -f com.cz.babySister -l hook_HttpUrlConnection.js --no-pause 12345678910111213141516171819202122232425262728function hook_HttpUrlConnection()&#123; Java.perform(function()&#123; &#x2F;&#x2F; java.net.URL.URL ($init) (得到URL) Java.use(&quot;java.net.URL&quot;).$init.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (str)&#123; var result &#x3D; this.$init(str) console.log(&quot;result , str &#x3D;&gt; &quot;,result,str); return result; &#125; &#x2F;&#x2F;HttpURLConnection setRequestProperty 得到各种请求头、属性等，不能hook抽象类HttpURLConnection，只能hook抽象类的实现类HttpURLConnectionImpl Java.use(&quot;com.android.okhttp.internal.huc.HttpURLConnectionImpl&quot;).setRequestProperty.implementation &#x3D; function(str1,str2)&#123; var result &#x3D; this.setRequestProperty(str1,str2); console.log(&quot;.setRequestProperty result,str1,str2-&gt;&quot;,result,str1,str2); return result; &#125; Java.use(&quot;com.android.okhttp.internal.huc.HttpURLConnectionImpl&quot;).setRequestMethod.implementation &#x3D; function(str1)&#123; var result &#x3D; this.setRequestMethod(str1); console.log(&quot;.setRequestMethod result,str1,str2-&gt;&quot;,result,str1); return result; &#125; &#125;)&#125;setImmediate(hook_HttpUrlConnection) OkHttp3搭建抓包环境默认创建Okhttp框架帮我们默认所有配置，因此无法自定义添加用户拦截器。 as新建Ok3Demo项目，创建页面button布局 12345678910111213141516171819&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot; android:gravity&#x3D;&quot;center|center_horizontal|center_vertical&quot; tools:context&#x3D;&quot;.MainActivity&quot;&gt; &lt;Button android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:gravity&#x3D;&quot;center|center_horizontal|center_vertical&quot; android:id&#x3D;&quot;@+id&#x2F;mybtn&quot; android:text&#x3D;&quot;发送请求&quot; android:textSize&#x3D;&quot;45sp&quot;&gt; &lt;&#x2F;Button&gt;&lt;&#x2F;LinearLayout&gt; build.gradle引入ok3依赖 12&#x2F;&#x2F; 增加对Okhttp3的依赖implementation(&quot;com.squareup.okhttp3:okhttp:3.12.0&quot;) AndroidManifest.xml配置网络权限 12&lt;!-- 申请网络请求权限 --&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt; 创建异步请求线程，在RealCall.newRealCall()中，创建了一个新的RealCall对象，RealCall对象是Okhttp3.Call接口的一个实现，也是Okhttp3中Call的唯一实现。它表示一个等待执行的请求，它只能被执行一次，但实际上，到这一步，请求依然可以被取消。因此只有Hook 了execute()和enqueue(new Callback())才能真正保证每个从Okhttp出去的请求都能被Hook到 1234567891011121314151617181920212223242526272829303132public class example &#123; &#x2F;&#x2F; TAG即为日志打印时的标签 private static String TAG &#x3D; &quot;learnokhttp&quot;; &#x2F;&#x2F; 新建一个Okhttp客户端 OkHttpClient client &#x3D; new OkHttpClient(); void run(String url) throws IOException &#123; &#x2F;&#x2F; 构造request Request request &#x3D; new Request.Builder() .url(url) .build(); &#x2F;&#x2F; 发起异步请求 client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; call.cancel(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#x2F;&#x2F;打印输出 Log.d(TAG, response.body().string()); &#125; &#125; ); &#125;&#125; MainActivity中调用网络请求线程 12345678910111213141516171819202122232425262728public class MainActivity extends AppCompatActivity &#123; private static String TAG &#x3D; &quot;learnokhttp&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#x2F;&#x2F; 定位发送请求按钮 Button btn &#x3D; findViewById(R.id.mybtn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#x2F;&#x2F; 访问百度首页 String requestUrl &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;; example myexample &#x3D; new example(); try &#123; myexample.run(requestUrl); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 建造者(Builder)模式新建LoggingInterceptor类，实现Interceptor接口，这代表它是一个拦截器，接下来实现intercept方法，我们的拦截器会打印URL和请求headers 123456789101112131415class LoggingInterceptor implements Interceptor &#123; &#x2F;&#x2F; TAG即为日志打印时的标签 private static String TAG &#x3D; &quot;learnokhttp&quot;; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Request request &#x3D; chain.request(); Log.i(TAG, &quot;请求URL：&quot;+String.valueOf(request.url())+&quot;\\n&quot;); Log.i(TAG, &quot;请求headers：&quot;+&quot;\\n&quot;+String.valueOf(request.headers())+&quot;\\n&quot;); Response response &#x3D; chain.proceed(request); return response; &#125;&#125; 拦截器是Okhttp中重要的一个概念，Okhttp通过Interceptor来完成监控管理、重写和重试请求。Okhttp本身存在五大拦截器，每个网络请求，不管是GET还是PUT/POST或者其他，都必须经过这五大拦截器。拦截器可以对request做出一定修改，同时对返回的Response做出一定修改，因此Interceptor是一个绝佳的Hook点，可以同时打印输出请求和相应。 自定义配置所有参数 1234567&#x2F;&#x2F; 此为原先的clientOkHttpClient client &#x3D; new OkHttpClient();&#x2F;&#x2F; 基于原先的client创建新的clientOkHttpClient newClient &#x3D; client.newBuilder() .addNetworkInterceptor(new LoggingInterceptor()) .build(); 将example中代码转移到MainActivity中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MainActivity extends AppCompatActivity &#123; private static String TAG &#x3D; &quot;learnokhttp&quot;; public static final String requestUrl &#x3D; &quot;http:&#x2F;&#x2F;www.kuaidi100.com&#x2F;query?type&#x3D;yuantong&amp;postid&#x3D;11111111111&quot;; &#x2F;&#x2F; 全局只使用这一个拦截器 public static final OkHttpClient client &#x3D; new OkHttpClient.Builder() .addNetworkInterceptor(new LoggingInterceptor()) .build(); Request request &#x3D; new Request.Builder() .url(requestUrl) .build(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#x2F;&#x2F; 定位发送请求按钮 Button btn &#x3D; findViewById(R.id.mybtn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#x2F;&#x2F; 发起异步请求 client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; call.cancel(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#x2F;&#x2F;打印输出 Log.d(TAG, response.body().string()); &#125; &#125; ); &#125; &#125;); &#125;&#125; hookadb shell &amp;&amp; ./data/local/tmp/fs128arm64 启动frida pyenv local 3.8.0 切换python环境 objection -g com.onejane.ok3demo explore -P ~/.objection/plugins 加载所有插件，点击发送请求并开启内存漫游 12345plugin wallbreaker classsearch OkHttpClient 内存搜索OkHttpClient类plugin wallbreaker classdump --fullname okhttp3.OkHttpClient 打印该类结构plugin wallbreaker objectsearch okhttp3.OkHttpClient 获取该类的内存地址plugin wallbreaker objectdump --fullname 0x2592 打印内存中该地址的类结构plugin wallbreaker objectsearch okhttp3.OkHttpClient 内存中存在多个OkHttpClient,默认不回收对象实例 okhttp3Logging新增okhttp3Logging类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171public final class okhttp3Logging implements Interceptor &#123; private static final String TAG &#x3D; &quot;okhttpGET&quot;; private static final Charset UTF8 &#x3D; Charset.forName(&quot;UTF-8&quot;); @Override public Response intercept(Chain chain) throws IOException &#123; Request request &#x3D; chain.request(); RequestBody requestBody &#x3D; request.body(); boolean hasRequestBody &#x3D; requestBody !&#x3D; null; Connection connection &#x3D; chain.connection(); String requestStartMessage &#x3D; &quot;--&gt; &quot; + request.method() + &#39; &#39; + request.url(); Log.e(TAG, requestStartMessage); if (hasRequestBody) &#123; &#x2F;&#x2F; Request body headers are only present when installed as a network interceptor. Force &#x2F;&#x2F; them to be included (when available) so there values are known. if (requestBody.contentType() !&#x3D; null) &#123; Log.e(TAG, &quot;Content-Type: &quot; + requestBody.contentType()); &#125; if (requestBody.contentLength() !&#x3D; -1) &#123; Log.e(TAG, &quot;Content-Length: &quot; + requestBody.contentLength()); &#125; &#125; Headers headers &#x3D; request.headers(); for (int i &#x3D; 0, count &#x3D; headers.size(); i &lt; count; i++) &#123; String name &#x3D; headers.name(i); &#x2F;&#x2F; Skip headers from the request body as they are explicitly logged above. if (!&quot;Content-Type&quot;.equalsIgnoreCase(name) &amp;&amp; !&quot;Content-Length&quot;.equalsIgnoreCase(name)) &#123; Log.e(TAG, name + &quot;: &quot; + headers.value(i)); &#125; &#125; if (!hasRequestBody) &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method()); &#125; else if (bodyHasUnknownEncoding(request.headers())) &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (encoded body omitted)&quot;); &#125; else &#123; Buffer buffer &#x3D; new Buffer(); requestBody.writeTo(buffer); Charset charset &#x3D; UTF8; MediaType contentType &#x3D; requestBody.contentType(); if (contentType !&#x3D; null) &#123; charset &#x3D; contentType.charset(UTF8); &#125; Log.e(TAG, &quot;&quot;); if (isPlaintext(buffer)) &#123; Log.e(TAG, buffer.readString(charset)); Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (&quot; + requestBody.contentLength() + &quot;-byte body)&quot;); &#125; else &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (binary &quot; + requestBody.contentLength() + &quot;-byte body omitted)&quot;); &#125; &#125; long startNs &#x3D; System.nanoTime(); Response response; try &#123; response &#x3D; chain.proceed(request); &#125; catch (Exception e) &#123; Log.e(TAG, &quot;&lt;-- HTTP FAILED: &quot; + e); throw e; &#125; long tookMs &#x3D; TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs); ResponseBody responseBody &#x3D; response.body(); long contentLength &#x3D; responseBody.contentLength(); String bodySize &#x3D; contentLength !&#x3D; -1 ? contentLength + &quot;-byte&quot; : &quot;unknown-length&quot;; Log.e(TAG, &quot;&lt;-- &quot; + response.code() + (response.message().isEmpty() ? &quot;&quot; : &#39; &#39; + response.message()) + &#39; &#39; + response.request().url() + &quot; (&quot; + tookMs + &quot;ms&quot; + (&quot;, &quot; + bodySize + &quot; body:&quot; + &quot;&quot;) + &#39;)&#39;); Headers myheaders &#x3D; response.headers(); for (int i &#x3D; 0, count &#x3D; myheaders.size(); i &lt; count; i++) &#123; Log.e(TAG, myheaders.name(i) + &quot;: &quot; + myheaders.value(i)); &#125; if (!HttpHeaders.hasBody(response)) &#123; Log.e(TAG, &quot;&lt;-- END HTTP&quot;); &#125; else if (bodyHasUnknownEncoding(response.headers())) &#123; Log.e(TAG, &quot;&lt;-- END HTTP (encoded body omitted)&quot;); &#125; else &#123; BufferedSource source &#x3D; responseBody.source(); source.request(Long.MAX_VALUE); &#x2F;&#x2F; Buffer the entire body. Buffer buffer &#x3D; source.buffer(); Long gzippedLength &#x3D; null; if (&quot;gzip&quot;.equalsIgnoreCase(myheaders.get(&quot;Content-Encoding&quot;))) &#123; gzippedLength &#x3D; buffer.size(); GzipSource gzippedResponseBody &#x3D; null; try &#123; gzippedResponseBody &#x3D; new GzipSource(buffer.clone()); buffer &#x3D; new Buffer(); buffer.writeAll(gzippedResponseBody); &#125; finally &#123; if (gzippedResponseBody !&#x3D; null) &#123; gzippedResponseBody.close(); &#125; &#125; &#125; Charset charset &#x3D; UTF8; MediaType contentType &#x3D; responseBody.contentType(); if (contentType !&#x3D; null) &#123; charset &#x3D; contentType.charset(UTF8); &#125; if (!isPlaintext(buffer)) &#123; Log.e(TAG, &quot;&quot;); Log.e(TAG, &quot;&lt;-- END HTTP (binary &quot; + buffer.size() + &quot;-byte body omitted)&quot;); return response; &#125; if (contentLength !&#x3D; 0) &#123; Log.e(TAG, &quot;&quot;); Log.e(TAG, buffer.clone().readString(charset)); &#125; if (gzippedLength !&#x3D; null) &#123; Log.e(TAG, &quot;&lt;-- END HTTP (&quot; + buffer.size() + &quot;-byte, &quot; + gzippedLength + &quot;-gzipped-byte body)&quot;); &#125; else &#123; Log.e(TAG, &quot;&lt;-- END HTTP (&quot; + buffer.size() + &quot;-byte body)&quot;); &#125; &#125; return response; &#125; &#x2F;** * Returns true if the body in question probably contains human readable text. Uses a small sample * of code points to detect unicode control characters commonly used in binary file signatures. *&#x2F; static boolean isPlaintext(Buffer buffer) &#123; try &#123; Buffer prefix &#x3D; new Buffer(); long byteCount &#x3D; buffer.size() &lt; 64 ? buffer.size() : 64; buffer.copyTo(prefix, 0, byteCount); for (int i &#x3D; 0; i &lt; 16; i++) &#123; if (prefix.exhausted()) &#123; break; &#125; int codePoint &#x3D; prefix.readUtf8CodePoint(); if (Character.isISOControl(codePoint) &amp;&amp; !Character.isWhitespace(codePoint)) &#123; return false; &#125; &#125; return true; &#125; catch (EOFException e) &#123; return false; &#x2F;&#x2F; Truncated UTF-8 sequence. &#125; &#125; private boolean bodyHasUnknownEncoding(Headers myheaders) &#123; String contentEncoding &#x3D; myheaders.get(&quot;Content-Encoding&quot;); return contentEncoding !&#x3D; null &amp;&amp; !contentEncoding.equalsIgnoreCase(&quot;identity&quot;) &amp;&amp; !contentEncoding.equalsIgnoreCase(&quot;gzip&quot;); &#125;&#125; 打包编译后取出dex改名为okhttp3logging.dex，push到/data/locol/tmp目录下 编写frida进行hook,frida -U -f com.onejane.ok3demo -l hookOkhttp3.js --no-pause并通过adb logcat 查看系统log 123456789101112131415161718function hook_okhttp3_logging() &#123; &#x2F;&#x2F; 1. frida Hook java层的代码必须包裹在Java.perform中，Java.perform会将Hook Java相关API准备就绪。 Java.perform(function () &#123; Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;okhttp3logging.dex&quot;).load(); &#x2F;&#x2F; 只修改了这一句，换句话说，只是使用不同的拦截器对象。 var MyInterceptor &#x3D; Java.use(&quot;com.onejane.ok3demo.okhttp3Logging&quot;); var MyInterceptorObj &#x3D; MyInterceptor.$new(); var Builder &#x3D; Java.use(&quot;okhttp3.OkHttpClient$Builder&quot;); console.log(Builder); Builder.build.implementation &#x3D; function () &#123; this.networkInterceptors().add(MyInterceptorObj); return this.build(); &#125;; console.log(&quot;hook_okhttp3...&quot;); &#125;);&#125; Retrofitgit clone https://github.com/peiniwan/Ganhuo.git 编译源码编译安装apk 修改build.gradle,buildscript.repositories和allprojects.repositories添加google() 1classpath &#39;com.android.tools.build:gradle:3.5.3&#39; frida -U -f ganhuo.ly.com.ganhuo -l hookOkhttp3.js --no-pause 调用hook_okhttp3_logging()通过adb logcat查看后台log git clone https://github.com/siyujie/OkHttpLogger-Frida.git 获取Frida 实现拦截okhttp的脚本，首先将 okhttpfind.dex 拷贝到 /data/local/tmp/ 目录下，执行命令启动frida -UF -l okhttp_poker.js -f ganhuo.ly.com.ganhuo --no-pause 可追加 -o [output filepath]保存到文件 原理： 由于所有使用的okhttp框架的App发出的请求都是通过RealCall.java发出的，那么我们可以hook此类拿到request和response, 也可以缓存下来每一个请求的call对象，进行再次请求，所以选择了此处进行hook。 find前新增check，根据特征类寻找是否使用了okhttp3库，如果没有特征类，则说明没有使用okhttp; 找到特征类，说明使用了okhttp的库，并打印出是否被混淆。 12345&#96;find()&#96; 要等完全启动并执行过网络请求后再进行调用,检查是否使用了Okhttp &amp; 是否可能被混淆 &amp; 寻找okhttp3关键类及函数 &#96;switchLoader(\\&quot;okhttp3.OkHttpClient\\&quot;)&#96; 参数：静态分析到的okhttpclient类名&#96;hold()&#96; 要等完全启动再进行调用,开启HOOK拦截&#96;history()&#96; 打印可重新发送的请求&#96;resend(index)&#96; 重新发送请求 baseUrl自吐 Hook RetrofitUtils 中的new Retrofit.Builder().baseUrl(baseurl)的baseUrl 12345objection -g ganhuo.ly.com.ganhuo exploreandroid hooking search classes retrofitandroid hooking list class_methods retrofit2.Retrofitandroid hooking list class_methods retrofit2.Retrofit$Builder 发现只有baseUrl()无参构造，可能在app启动时就执行了baseUrl(baseurl)objection -g ganhuo.ly.com.ganhuo explore --startup-command &quot;android hooking list class_methods retrofit2.Retrofit$Builder&quot; 没有反应 通过编写frida脚本实现hook有参构造baseUrl 12345678910111213141516function hookbaseurl()&#123; Java.perform(function()&#123; Java.use(&quot;retrofit2.Retrofit$Builder&quot;).baseUrl.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(str)&#123; var result &#x3D; this.baseUrl(str) console.log(&quot;result1,str&#x3D;&gt;&quot;,result,str) return result &#125; Java.use(&quot;retrofit2.Retrofit$Builder&quot;).baseUrl.overload(&#39;okhttp3.HttpUrl&#39;).implementation &#x3D; function(str)&#123; var result &#x3D; this.baseUrl(str) console.log(&quot;result2,str&#x3D;&gt;&quot;,result,str) return result &#125; &#125;)&#125;setImmediate(hookbaseurl) var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"okhttp3","slug":"okhttp3","permalink":"http://onejane.github.io/tags/okhttp3/"},{"name":"HttpURLConnection","slug":"HttpURLConnection","permalink":"http://onejane.github.io/tags/HttpURLConnection/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://onejane.github.io/tags/Retrofit/"}]},{"title":"强大的脚本","slug":"强大的脚本","date":"2021-02-22T07:48:20.000Z","updated":"2021-12-12T03:09:39.293Z","comments":true,"path":"2021/02/22/强大的脚本/","link":"","permalink":"http://onejane.github.io/2021/02/22/%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%84%9A%E6%9C%AC/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 Python合并多dex1234567891011121314151617181920import os, sys# python3.7 merge_dex.py .&#x2F;file&#x2F; livedex 反编译成java文件if __name__ &#x3D;&#x3D; &quot;__main__&quot;: if len(sys.argv) &lt; 3 : print(&quot;start error&quot;) sys.exit() print(sys.argv[1], sys.argv[2]) path &#x3D; sys.argv[1] #文件夹目录files&#x3D; os.listdir(path) #得到文件夹下的所有文件名称s &#x3D; []for file in files: #遍历文件夹 if file.find(&quot;dex&quot;) &gt; 0: ## 查找dex 文件 sh &#x3D; &#39;jadx -j 1 -r -d &#39; + sys.argv[2] + &quot; &quot; + path + file print(sh) os.system(sh) 集合排列组合12345678910111213141516171819productType = [1, 2, 3]goodType = [4, 5]energyType = [6, 7]productGoodEnergyType = [[1,2,3],[4,5],[6, 7]]# 多个集合随机有序排列,同itertools.product(*productGoodEnergyType)for newValue in itertools.product(productType,goodType,energyType): print(newValue)# 按组合个数进行无序组合print(list(itertools.permutations(productType))) for productTypeIndex in range(1, len(productType) + 1): # 单个集合按指定个数随机有序排列 productTypeTter1 = itertools.combinations(productType, productTypeIndex) print(list(productTypeTter1)) # 单个集合按指定个数随机无序组合 productTypeTter2 = itertools.permutations(productType, productTypeIndex) print(list(productTypeTter2)) 多集合组合 拿到集合的组合 根据这些组合进行分组笛卡尔积 1234567891011121314151617181920212223242526272829def combine(big_dict): # Cn1+Cn2+...+Cnn # Cmn&#x3D;m!&#x2F;n!*(m-n)! keys &#x3D; list(big_dict.keys()) # 获取keyList combine_key_list &#x3D; [] # key值 排列组合 valueList &#x3D; [] # 将key替换为值 for i in range(1, len(keys) + 1): iter &#x3D; itertools.combinations(keys, i) # [(&#39;a&#39;,), (&#39;b&#39;,), (&#39;c&#39;,), (&#39;a&#39;, &#39;b&#39;), (&#39;a&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)] combine_key_list.extend(list(iter)) # key的所有组合 以list形式加入列表 for m in combine_key_list: # [[[1, 2, 3]], [[4, 5]], [[6, 7, 8, 9]], [[1, 2, 3], [4, 5]], [[1, 2, 3], [6, 7, 8, 9]], [[4, 5], [6, 7, 8, 9]], [[1, 2, 3], [4, 5], [6, 7, 8, 9]]] valueList.append([big_dict.get(n) for n in m if n in keys]) # key所有组合转value组合 以object形式加入列表 param_list &#x3D; [] for index, value in enumerate(valueList): # list转为索引序列 search_type_key &#x3D; list(combine_key_list[index]) # 根据当前值对应key for item in itertools.product(*value): # 集合中n个集合n组笛卡尔积 params &#x3D; dict(zip(search_type_key, list(item))) param_list.append(urlencode(params)) print(param_list)d &#x3D; &#123; &#39;a&#39;: [1,2,3], &#39;b&#39;: [4,5], &#39;c&#39;: [6,7,8,9],&#125;combine(d) 格式转换转str 1234t &#x3D; (1,2)l &#x3D; [3,4]print(&#39;,&#39;.join(map(str, t)) if isinstance(t,tuple) else t)print(&#39;,&#39;.join(map(str, l)) if isinstance(l,list) else l) 转dict 1print(dict(zip(productType,goodType))) 转list 12def flatten(li): return sum(([x] if not isinstance(x, list) else flatten(x) for x in li), []) 字典key替换 1param_dict[&#39;area&#39;] &#x3D; param_dict.pop(&#39;ownerProvince&#39;)+&#39;-&#39;+param_dict.pop(&#39;ownerCity&#39;) Mongo123456import pymongoclient &#x3D; pymongo.MongoClient(settings.get(&#39;MONGO_URI&#39;))[settings.get(&#39;MONGO_DB&#39;)]client[&#39;MUsedCar&#39;].create_index([(&quot;url&quot;, 1)], unique&#x3D;True)client[&#39;MUsedCar&#39;].insert(dict(&#123;&#39;url&#39;:used_car_url+urlencode(param_dict)&#125;))for doc in client[&#39;MUsedCarParams&#39;].find(): print(doc[&#39;params&#39;]) 爬虫url12param_dict &#x3D; dict(parse.parse_qsl(parse.unquote(doc[&#39;params&#39;]))) url解码并转为字典urlencode(param_dict) 字典转url编码 Javaidea生成注释文档File =&gt; setting =&gt; editor =&gt; File and Code Templates 12345&quot;&quot;&quot;@author: onejane@time: $&#123;DATE&#125; $&#123;TIME&#125;@desc:&quot;&quot;&quot; File =&gt; Setting=&gt; Editor=&gt; Live Templates 输入onejane代码提示直接回车即可 Tools-Generate JavaDoc 12zh_CN-tag ProjectDetails:a:&quot;项目详情:&quot; -tag update:a:&quot;项目更改:&quot; -tag CreateDate:a:&quot;创建时间:&quot; -encoding UTF-8 -charset UTF-8 lambda多个分组多列求和1234567Function&lt;MotoEssayShowDailyContextInfoDTO, List&lt;Object&gt;&gt; keyExtractor &#x3D; wr -&gt; Arrays.&lt;Object&gt;asList(wr.getBusinessDate(), wr.getContext());List&lt;MotoEssayShowDailyContextInfoDTO&gt; showDailyContextInfoDTOS &#x3D; infoByCondition.stream().collect(Collectors.groupingBy(keyExtractor, Collectors.reducing((sum, s) -&gt; new MotoEssayShowDailyContextInfoDTO(s.getBusinessDate(), s.getContext(), sum.getExposureArticleNum() + s.getExposureArticleNum(), sum.getExposureNum() + s.getExposureNum(), sum.getClickNum() + s.getClickNum(), sum.getDetailClickNum() + s.getDetailClickNum(), sum.getDuration() + s.getDuration(), sum.getFinish() + s.getFinish())))).entrySet().stream().map(c -&gt; c.getValue().get()).collect(Collectors.toList()); 分组排序1showDailyContextInfoDTOS.stream().collect(Collectors.groupingBy(o -&gt; o.getBusinessDate(), TreeMap::new,Collectors.toList())); Git多仓库12git remote set-url --add origin git@github.com:OneJane&#x2F;CrawlerBase.gitgit push origin --all git remote add origin &#103;&#105;&#116;&#64;&#103;&#105;&#116;&#101;&#x65;&#46;&#x63;&#x6f;&#109;:OneJane/picture.git 初始化后建立git库 版本回退12git refloggit reset --hard 版本号 大仓库提交1git config http.postBuffer 524288000 不行就使用git替代https地址 合并不同提交历史1git pull origin master --allow-unrelated-histories 恢复被删分支12git refloggit branch f&#x2F;wj-0419-5924 bcd2e64 Mongo更新批量将字段更新成字符串 1234db.getCollection(&#39;alimama&#39;).find(&#123;&#125;).forEach(function(x)&#123; db.getCollection(&#39;alimama&#39;).updateOne( &#123;_id: x._id&#125;, &#123;$set:&#123;income_rate: String(x.income_rate)&#125;&#125;)&#125;) 批量新增字段 1db.getCollection(&#39;taobao&#39;).update(&#123;&#125;, &#123;$set: &#123;&#39;name&#39;:&quot;taobao&quot;&#125;&#125;, &#123;multi: true&#125;); 批量修改字段名 1db.getCollection(&#39;long_link&#39;).update(&#123;&#125;, &#123;&quot;$rename&quot;:&#123;&quot;long_link&quot;:&quot;orientPlanLinkUrl&quot;&#125;&#125;, false, true) 查询返回指定字段id 1db.getCollection(&#39;alimama&#39;).find(&#123;&#125;,&#123;_id:0,id:1&#125;) 按照url分组查询并倒序 1db.getCollection(&#39;conditions&#39;).aggregate([&#123;$group : &#123;_id : &quot;$url&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;,&#123; $sort : &#123; num_tutorial: -1 &#125; &#125;]) 模糊查询 1db.getCollection(&#39;conditions&#39;).find(&#123;&#39;url&#39;:&#123;&#39;$regex&#39;:&#39;https:*&#39;&#125;&#125;).count() 导出 sublime 中ctrl+h 进行 {“_id”:.:”(.)”}\\n 替换为 $1\\n 1mongoexport -h 172.20.0.186:27017 -d jddmoto -c mbrand -o mbrand.json --type json -f url Mysqllocate1SELECT GROUP_CONCAT(a.n_id), COUNT(a.&#96;n_id&#96;) FROM &#96;motor_business_essay&#96; a, &#96;motor_business_essay_ext&#96; b where locate(&#39;&quot;img&quot;:&quot;&quot;&#39;,a.c_short_vod_info) Linux删除大文件1234du -h --max-depth&#x3D;1df -hlsof | grep deleted 查询内存中持续删除的进程kill -9 id windows新增复制文件路径.regUTF-8-BOM编码 1234567891011121314151617181920Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\*\\shell\\copypath]@&#x3D;&quot;复制文件路径到剪贴板&quot;[HKEY_CLASSES_ROOT\\*\\shell\\copypath\\command]@&#x3D;&quot;cmd &#x2F;c echo %1 | clip&quot;[HKEY_CLASSES_ROOT\\*\\shell\\copypathwithquote]@&#x3D;&quot;复制文件路径到剪贴板(带引号)&quot;[HKEY_CLASSES_ROOT\\*\\shell\\copypathwithquote\\command]@&#x3D;&quot;cmd &#x2F;c echo \\&quot;%1\\&quot; | clip&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypath]@&#x3D;&quot;复制文件夹路径到剪贴板&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypath\\command]@&#x3D;&quot;cmd &#x2F;c echo %1 | clip&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypathwithquote]@&#x3D;&quot;复制文件夹路径到剪贴板(带引号)&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypathwithquote\\command]@&#x3D;&quot;cmd &#x2F;c echo \\&quot;%1\\&quot; | clip&quot; var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"脚本","slug":"脚本","permalink":"http://onejane.github.io/categories/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"python","slug":"python","permalink":"http://onejane.github.io/tags/python/"}]},{"title":"加壳与脱壳之分类技术","slug":"加壳与脱壳之分类技术","date":"2021-02-21T09:16:27.000Z","updated":"2021-12-12T03:09:39.290Z","comments":true,"path":"2021/02/21/加壳与脱壳之分类技术/","link":"","permalink":"http://onejane.github.io/2021/02/21/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%88%86%E7%B1%BB%E6%8A%80%E6%9C%AF/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 历代加壳技术分类动态加载是用到的时候再去加载，也叫懒加载，是dex加壳，插件化，热更新的基础，避免发布新版本需要用户全量更新app，快速迭代，提升用户体验。比如阿里的AndFix和HotFix，腾讯的tinker，美团的Robust等热修复框架的基础。动态加载的dex不具有生命周期特征，APP中的Activity，Service等组件无法正常工作，只能完成一般函数的调用。需要对ClassLoader进行修正，APP才能够正常运行，有反射替换和反射插入两种修正手段，这是加壳app必然要做的一步。 第一代壳:dex加密 Dex字符串加密 资源加密 对抗反编译 反调试 自定义 DexClass Loader 由于是dex整体保护，在内存中映射是整体连续的，通过定位起始地址将app完整脱下来 第二代壳:dex抽取与加固 对抗第一代壳常见的脱壳法 Dex method代码抽取到外部(通常企业版) Dex动态加载 So加密 首先dex整体保护，其次对关键函数进行抽取(dump内存区域中dex关键类为空)进行so加密，对抗第一代壳常用脱壳法(从关键hook点dump dex) 第三代壳:dex动态解密与混淆 Dex method代码动态解密 So代码膨胀混淆 对抗之前出现的所有脱壳法 对抗第二代壳的一个通用脱壳工具DexHunter(通过遍历dex所有类进行加载初始化，将内存中dex完整恢复),dex中method动态解密，指定函数只有被调用时才执行，dex在内存中始终不是完整的状态 第四代壳:vmp壳目前仍然是smali指令级别的vmp，未来将出现arm指令级别vmp 加壳技术分析dex加固 dex整体加固:文件加载（监控app访问文件的记录）和内存加载（对内存dex的解密直接动态加载） 函数抽取:在函数粒度完成代码的保护：dump下dex的关键函数体置空 VMP和Dex2C:JAVA函数 Native化。vmp-&gt;逆向分析解释器找到取址译码 dex整体加固dex整体加壳是基础防护，所有加壳的app必然都有，关键在于怎么区分函数抽取，vmp以及dex2c甚至多种技术混合的混合型壳。 文件加载:定位解密文件是关键 内存加载:加载时机和内存起始地址是关键 通用方案:dex打开和优化的流程以及产出的odex、dex2oat编译的流程和生成的oat文件等等 函数抽取 类加载和函数执行前的流程解密 函数执行中动态自解密 方案：关注被抽取的函数的执行流程是关键！定位被抽取的函数的恢复时机即可。 获取到保护的dex后,函数体的内容是无效的,注意这里说的是无效,而不是无意义,有的app壳后函数依然是有意义的,但不是我们想要的。f5查看函数体全部为空，则表现为函数抽取。 VMP定位解释器是关键，找到映射关系便可恢复。 获取到保护的dex后,函数的属性由java属性变为 Native,典型的有数字的 onCreate函数 Native化JNI函数。vmp壳的核心就是dalvik虚拟机的解释器原理。 若所有vmp保护的函数都有自己的解释器则so必然很大，所以必然共享一个解释器，vmp化的函数注册地址一致或者函数逻辑相似。 MainActivity动态注册地址在d3dec3f1,TestActivity地址一致，说明vmp保护。 参考vmp加壳方案之ADVMP，vmp对每一种smali指令处理，保护了函数后函数属性发生改变，因为解释器一般是用JNI实现，java易被反编译，故没用java实现，基本由c实现，防止快速定位到解释器的取址译码和执行的流程会加ollvm混淆保护之类。 Dex2c基础是编译原理，进行了等价语义转换，彻底还原难度巨大。 方案：关注JNI相关的api调用是关键，也是分析VMP和dex2c保护的函数的逻辑的关键。 获取到保护的dex后保护的函数属性有java变成native，dcc保护后所有java属性的函数变成jni函数，只能看到类名和参数。核心原理与编译原理相关，传统编译原理是编译器经过词法分析语法分析生成二进制代码，dex2c中生成结果是c、c++文件，经过ndk编译器最终编译为so,每一个函数基本编译成一个c/c++文件，ubuntu中编译最终生成一个so。 dex2c核心对指定java函数进行语义分析生成各个不同的c/c++代码编译为相应so，自然dex2c保护的函数逻辑不一致，自然注册地址不同。 MainActivity的地址在7ba61b17c0，TestActivity地址在7ba61ac604，说明dex2c保护。 dcc_out.apk在lib下编译生成了so文件中,jni函数静态注册都存放于so文件中，使用IDA v7打开libnc.so，搜索java就可以找到所有jni函数。 dcc_out编译于项目LoadDex,新增FirstActivity，SecondActivity MainActivity.java 12345678910111213141516171819202122static&#123; try &#123; System.loadLibrary(&quot;nc&quot;); &#125; catch (UnsatisfiedLinkError e) &#123; e.printStackTrace(); &#125;&#125;setContentView(R.layout.activity_main);Button mybutton01&#x3D;findViewById(R.id.button01);mybutton01.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; context.startActivity(new Intent(context,FirstActivity.class)); &#125;&#125;);Button mybutton02&#x3D;findViewById(R.id.button02);mybutton02.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; context.startActivity(new Intent(context,SecondActivity.class)); &#125;&#125;); AndroidManifest.xml 12&lt;activity android:name&#x3D;&quot;.FirstActivity&quot;&gt;&lt;&#x2F;activity&gt;&lt;activity android:name&#x3D;&quot;.SecondActivity&quot;&gt;&lt;&#x2F;activity&gt; activity_main.xml 12345678910111213141516171819202122232425&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot; android:id&#x3D;&quot;@+id&#x2F;LinearLayout1&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;button01&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center_horizontal&quot; android:text&#x3D;&quot;FirstActivity&quot; &#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;button02&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center_horizontal&quot; android:text&#x3D;&quot;SecondActivity&quot; &#x2F;&gt;&lt;&#x2F;LinearLayout&gt; dcc_ollvm.apk 在dex2c过程中加入了ollvm，在ida中打开so，jni找不到。 参考dex2c加壳方案之dcc 1234git clone https:&#x2F;&#x2F;github.com&#x2F;amimo&#x2F;dcc.gitpyenv local 3.8.5 &amp;&amp; cd dcc &amp;&amp; pip install -r requirements.txtvim filter.txt 添加.*onejane*. 编译函数名含有onejane的函数python dcc.py dcc.apk -o dcc_out.apk 加固app VMP和dex2c是高级防护 VMP:定位解释器是关键,找到映射关系便可恢复 dex2c:基础是编译原理,进行了等价语义转换,彻底还原难度巨大: 通用分类技术:关注JNI相关的ap调用是关键,也是分析VMP和dex2c保护的函数的逻辑的关键。 混合型壳多种加固技术混合使用,比如先将原有smal指令流使用VMP或dex2c保护,构建object数组传递给jni函数进行调用，然后再经过函数抽取进一步保护 区分apk保护技术 是否Native化 函数体无效 函数抽取类壳 否 是 vmp壳 是 native化 Dex2c壳 是 native化 so加固 基于init、 init_array以及JNI_Onload函数的加壳 基于自定义linker的加壳 IDA快捷键 空格键 反汇编窗口切换文本跟图形 ESC 退到上一个操作地址 F5 C伪代码 alt+t 搜索文本 一二三代壳和加壳技术分类识别 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"fart","slug":"fart","permalink":"http://onejane.github.io/tags/fart/"},{"name":"vmp","slug":"vmp","permalink":"http://onejane.github.io/tags/vmp/"},{"name":"dex2c","slug":"dex2c","permalink":"http://onejane.github.io/tags/dex2c/"}]},{"title":"抓包环境与hook","slug":"抓包环境与hook","date":"2021-02-18T15:52:47.000Z","updated":"2022-10-25T13:58:18.199Z","comments":true,"path":"2021/02/18/抓包环境与hook/","link":"","permalink":"http://onejane.github.io/2021/02/18/%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E4%B8%8Ehook/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 1、http://aospxref.com/优点：更新速度快缺点：历史版本较少 2、http://androidxref.com/优点：历史版本较多缺点：更新速度慢 Http抓包基本原理美团点评移动网络优化实践在http套ssl且加密内容成为https 平时我们碰到的http和https都在应用层，socks在会话层，tcp和udp在传输层。ip在网络层。代理都是通过给wifi设置http代理的方式进行抓包，只是在应用层抓包，所以会被很轻易的检测到和绕过的。 很多应用会通过 System.getProperty(“http.proxyHost”); System.getProperty(“http.proxyPort”); 这两个API来查看当前系统是否挂了http代理，会很轻松的让你的抓包失效。 所以我们需要换一种方式来设置代理。就是设置vpn代理，vpn是属于网络层的，设置了vpn后，你的手机上ifconfig后会多一个接口，等于加了一个虚拟网卡，所有的流量都会从这走。应用层和传输层的请求都可以拿到，还不会被上面提及的两个api所检测。 图片视频处于应用层，http协议横跨应用层–表示层–会话层，socks、ssl属于会话层，IP属于网络层,端口属于传输层 应用层Https抓包的根本原理 HTTPS是包裹在SSL协议里的HTTP，APP-Charles客户端校验服务端，Charles-服务器是服务端校验客户端，400 Bad Request,No required SSL certificate was sent 在开始 APP 分析时候我们提到使用 Charles 抓不到包，设置了 SSL 代理也没有用，当我们反编译分析脱壳后的dex找到构造请求的地方时，发现了真相，和 SSL 没有关系，是因 openConnection(Proxy.NO_PROXY)，使用vpn抓包后系统将多一个Interface，设置vpn代理，vpn是属于网络层的，设置了vpn后，你的手机上ifconfig后会多一个接口，等于加了一个虚拟网卡，所有的流量都会从这走。应用层和传输层的请求都可以拿到，还不会被上面提及的两个api所检测。 ip route show table 0|grep default 手机路由表第一条降维打击网络层,任何api都必须经过路由解析http 不过App可以通过判断java.net.NetworkInterface.getName()是否等于“tun0”或“ppp0” 或者 android.net.ConnectivityManager.getNetworkCapabilities来判断是否存在VPN。Bypass也很简单，hook该api使其返回“rmnet_data1”，即可达到过vpn检测目的。 环境搭建tar zxf charles-proxy-4.6.1_amd64.tar.gz &amp;&amp; ./charles 通过注册码注册或生成加权jar包破解，在Proxy中External Proxy Setting配置代理 adb install 0714com.tunnelworkshop.postern_2018-10-07.apk 网络设置 主机连接无线网，虚拟机网络连接修改NAT设置桥接模式即可，不用勾选复制物理网络连接状态，保证手机192.168.0.100和虚拟机192.168.0.109和主机192.168.0.108互相ping通 配置Postern并启动VPN 抓取所有应用层和传输层的包 如需安装https，需要开启SSL Proxying Settings-Enable SSL Proxying,设置规则*.* 配置Burpsuite java -jar burp-loader-keygen.jar - Run - 复制License -EnterLicense Key - Manual Activition - Copy Request 到 Activation Request - 复制Activition Response到Paster response，在User options中设置Socks Proxy实现科学代理。 配置Postern通过代理192.168.0.109:8080并重启VPN openssl x509 -inform DER -in burpder1545.der -out burpder1545.pem 把der转化成pem，然后adb push到/sdcard/Download文件夹下，然后设置→安全性和位置信息→加密与凭据→从存储设备安装，选择pem证书，即可安装到用户用户信任区 Https和Socks5抓包 抓住包出在明文状态的一切时机。种类：Http框架的hook，系统框架hook，中间人抓包。 http+加密+认证+完整性保护=https是身披ssl的http HTTP未加密主要有这些不足 通信使用明文(不加密),内容可能会被窃听 不验证通信方的身份,因此有可能遭遇伪装 DNS劫持-&gt;GFW翻墙 无法证明报文的完整性,所以有可能已遭篡改 运营商劫持-&gt;弹窗广告 cat /etc/resolv.conf 查看主机dns服务器 通信的加密HTTP协议中没有加密机制,但可以通过和SSL( Secure Socket Layer,安全套接层)或TLS( Transport Layer Security,安全层传输协议)的组合使用,加密HTTP的通信内容。用SSL建立安全通信线路之后,就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为Https(HTTP Secure,超文本传输安全协议)或http over ssl。 内容的加密由于HTTP协议中没有加密机制,那么就对HTTP协议传输的内容本身加密。即把HTTP报文里所含的内容进行加密处理在这种情况下,客户端需要对HTTP报文进行加密处理后再发送请求。诚然,为了做到有效的内容加密,前提是要求客户端和服务器同时具备加密和解密机制。主要应用在Web服务中。有一点必须引起注意,由于该方式不同于SSL或TLS将整个通信线路加密处理,所以内容仍有被篡改的风险。 设置-安全性和位置信息-加密与凭据-信任的凭据 查看安装在手机上的信任凭据 1234objection -g com.android.settings explorememory list modulesmemory list exports libssl.somemory list exports libssl.so --json &quot;&#x2F;root&#x2F;libssl.txt&quot; 搜索rsa md5 aes sha非对称加解密 开启https虚拟机启动charles，手机wifi设置代理192.168.0.109:8888，访问chls.pro/ssl安装证书 关闭代理，启动Postern代理192.168.0.109:8888并开启VPN adb install iqiyi_696.apk启动爱奇艺抓包，虽然浏览器能抓到，但是依旧app抓不到，基于android 8.1+Magisk ,需要把个人证书放到系统根目录 12345cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o remount,rw &#x2F;chmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o remount,ro &#x2F; Android将证书放入根目录 12345cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o rw,remount &#x2F;systemchmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o ro,remount &#x2F;system 开启socks5socket本质：收发包的接口，一条跑着RAW DATA的通道，纯binary，wireshark抓包本质上不是中间人抓包，网卡流量的dump转储下来。应用领域SSL+HTTP,SMPT/POP/IMAP,protobuf 一文搞懂TCP与UDP的区别 通过抓包和一点点经验分析携程的协议 安卓应用层抓包通杀脚本 逆向XposedHook模块分析Hook检测过Vpn抓包原理！ 某抢票app逆向续篇之干掉vpn抓包检测 若依旧抓不全包，则使用Postern开启socks5抓包并配置规则开启VPN，charles配置socks抓包,本质在tcp层抓包。 Soul登录抓包adb install soul_channel_soul.apk soul在登录时报错400 No required SSL certificate was sent，缺少证书，需要在charles中安装客户端证书获取服务器信任。 hookfrida两种模式：attach在app启动之后进行hook， spawn未启动时就通过包名启动apk进行hook 123android hooking search classes sslandroid hooking watch class javax.net.ssl.SSLSession 文本中拼上前缀objection -g x.x.x explore -c a.txt 完整实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function hook_socket()&#123; Java.perform(function()&#123; console.log(&quot;hook_socket;&quot;) Java.use(&quot;java.net.SocketOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTP write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; Java.use(&quot;java.net.SocketInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTP read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; &#125;)&#125;function hook_SSLsocketandroid8()&#123; Java.perform(function()&#123; console.log(&quot;hook_SSLsocket&quot;) Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTPS write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTPS read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; &#125;)&#125;function hook_SSLsocket2android10()&#123; Java.perform(function()&#123; console.log(&quot; hook_SSLsocket2&quot;) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_write.implementation &#x3D; function(long,NS,fd,NC,bytearray,int1,int2,int3)&#123; var result &#x3D; this .SSL_write(long,NS,fd,NC,bytearray,int1,int2,int3); console.log(&quot;SSL_write(long,NS,fd,NC,bytearray,int1,int2,int3),result&#x3D;&gt;&quot;,long,NS,fd,NC,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex()); return result; &#125; Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_read.implementation &#x3D; function(long,NS,fd,NC,bytearray,int1,int2,int3)&#123; var result &#x3D; this .SSL_read(long,NS,fd,NC,bytearray,int1,int2,int3); console.log(&quot;SSL_read(long,NS,fd,NC,bytearray,int1,int2,int3),result&#x3D;&gt;&quot;,long,NS,fd,NC,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex()); return result; &#125; &#125;)&#125;function main()&#123; console.log(&quot;Main&quot;) hook_socket(); hook_SSLsocketandroid8(); &#x2F;&#x2F;hook_SSLsocket2android10();&#125;setImmediate(main) ssl.js过自签名证书 123456789101112131415161718192021function hook_KeyStore_load() &#123; Java.perform(function () &#123; var StringClass &#x3D; Java.use(&quot;java.lang.String&quot;); var KeyStore &#x3D; Java.use(&quot;java.security.KeyStore&quot;); KeyStore.load.overload(&#39;java.security.KeyStore$LoadStoreParameter&#39;).implementation &#x3D; function (arg0) &#123; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(&quot;KeyStore.load1:&quot;, arg0); this.load(arg0); &#125;; KeyStore.load.overload(&#39;java.io.InputStream&#39;, &#39;[C&#39;).implementation &#x3D; function (arg0, arg1) &#123; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(&quot;KeyStore.load2:&quot;, arg0, arg1 ? StringClass.$new(arg1) : null); this.load(arg0, arg1); &#125;; console.log(&quot;hook_KeyStore_load...&quot;); &#125;);&#125;setImmediate(hook_KeyStore_load) 开启hook1234567.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64 开启frida-serverpyenv local 3.8.0frida --version 版本一致为12.8.0top 查看soul的包名为cn.soulapp.androidfrida -U -f cn.soulapp.android -l ssl.js 通过attach进行hook公钥加解密的框架层api，打印密码用于解开证书用%resume 重新启动frida -U -f cn.soulapp.android -l ssl.js --no-pause 通过spawn进行hook，证书公钥发送给服务器，从服务器获取session用私钥进行解密的api进行hook，属于自吐，查看terminal中的密码 &#125;%2R+\\OSsjpP!w%X 搜索证书1234567897z x soul_channel_soul.apktree -NCfhl|grep -i p12 找到证书位置tree -NCfhl|grep -i bks或者objection -g cn.soulapp.android explore 如果报错查看frida的客户端和服务端版本是否匹配android hooking watch class_method java.io.File$init --dump-args 如果找不到文件exit并干掉app后objection -g cn.soulapp.android explore --start-command &quot;android hooking watch class_method java.io.File$init --dump-args&quot;du -h assets&#x2F;client.p12file assets&#x2F;client.p12thunar . 在windows上找到后双击导入私钥需要密码即刚才hook到的&#125;%2R+\\OSsjpP!w%X 该证书的内容即可以全部显示 安装证书导入charles - Proxy- SSL Proxying Settings 添加客户端证书 charls将对任意服务器发送该客户端证书 意味着用app访问所有的服务器 测试登录 统一代码查询12345pm -l |grep -i ncs 查看包名frida -U -f com.ninemax.ncsearchnew -l hook_keystore.js --no-pause 证书下载到&#x2F;sdcard&#x2F;Downloadobjection -g com.ninemax.ncsearchnew explore -s &quot;android sslpinning disable&quot;git clone https:&#x2F;&#x2F;github.com&#x2F;WooyunDota&#x2F;DroidSSLUnpinning.git frida -U -f com.ninemax.ncsearchnew -l ObjectionUnpinningPlus&#x2F;hooks.js --no-pause 国外app 访问ip111.cn通过测试 Hook抓包 缺点：不如抓包软件全面 优点：无视证书、基于HOOK直接得到参数、打调用栈得到参数的构成和来源 一般HTTPS：大部分只采用客户端校验服务器 iqiyi双向绑定：很少会有服务器校验客户端 soulSSL Cert Pinning：更少：趣充 adb install movetv.apk 使用Postern和Charles开启socks5即可完整抓到注册登录的请求，部分https无法抓到 安装证书chls.pro/ssl并把把个人证书放到系统根目录，启动ssl抓包，关闭客户端证书的soulapp.cn,否则会误认为请求来自于soul，即可抓到https包。 脱壳123.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64 启动frida-serverobjection -g com.cz.babySister explore -P ~&#x2F;.objection&#x2F;pluginsplugin dexdump dump 批量hook12345678android hooking list classes 列出所有类android hooking list activities 查看所有activitycat ~&#x2F;.objection&#x2F;objection.log|grep -i httpurl cat objection.log|grep -i http 拿到所有关于http相关类，并将前面都加入命令android hooking wathc class存入hooklist.txtobjection -g com.android.settings explore -c &quot;hooklist.txt&quot; 加载命令文件即可批量hookdumpsys activity top|grep baby 在shell中拿到包当前所在activityplugin wallbreaker objectsearch com.cz.babySister.activity.LoginActivity --fullname 搜索类信息地址android heap search instances com.cz.babySister.activity.LoginActivity 查看activity属性信息 Zentracer123456.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs1428arm64 开始frida-servergit clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;ZenTracercd ZenTracer &amp;&amp; pyenv local 3.8.5python -m pip install --upgrade pippip install PyQt5python ZenTracer.py 开始hook设置Match RegEx并开启Start 1android hooking watch class_method java.net.HttpURLConnection.getFollowRedirects --dump-args --dump-backtrace --dump-return hook方法打印调用栈登录定位HTTPURLConnection.getFollowRedirects在com.cz.babySister.c.a.a调用 案例春水堂adb install 春水堂_2.1.0.0强混淆.apk 通过objection -g org.sfjboldyvukzzlpp explore内存漫游后访问视频，cat objection.log|grep -i okhttp3发现根本找不到相关http类信息 通过apktool d 春水堂_2.1.0.0强混淆.apk解包后搜索ok3信息cd 春水堂_2.1.0.0强混淆 &amp;&amp; grep -ril &quot;okhttp3&quot; *找到相关smali 123456.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64 启动 fridapyenv local 3.8.0git clone https:&#x2F;&#x2F;github.com&#x2F;siyujie&#x2F;OkHttpLogger-Frida.gitcd OkHttpLogger-Frida &amp;&amp; adb push okhttpfind.dex &#x2F;data&#x2F;local&#x2F;tmp 将dex文件放入手机并chmod 777frida -U -f org.sfjboldyvukzzlpp -l okhttp_poker.js --no-pausefind() 查看是否使用okhttp并查看混淆结果 将Find Result下的内容复制到okhttp_poker.js开头，替换原有混淆类名 12frida -U -f org.sfjboldyvukzzlpp -l okhttp_poker.js --no-pause 退出后重新frida调用hold() 通杀所有okhttp混淆参数结果 爱奇艺charles证书放到根目录，可以通过magisk的move Certificates安装重启。客户端校验服务器。 hook1234git clone https:&#x2F;&#x2F;github.com&#x2F;BigFaceCat2017&#x2F;frida_ssl_logger.git 框架层的conscrypt本质上是走的native层的ssl抓包logadb install iqiyi_696.apkelectron-ssr &amp;&amp; proxychains pip install hexdump 安装hexdumppython ssl_logger.py -U -f com.qiyi.video &gt;&gt; iqiyi.txt 启动iqiyi并开启hook所有ssl信息保存到文件 ddmsxposed安装XAppDebug模块，开启debug，选中春水堂APP开启调试 ~/Android/Sdk/tools/monitor 启动ddms 使用Trace based profiling，登录后停止方法剖析，搜索HttpURLConnection 趣充adb install -r -t quchong.apk ./charles 启动charles抓包注册获取验证码，设置了no proxy防抓包 服务器校验客户端证书 ： 400 No required SSL certificate was sent 12345678910111213141516function replaceKill()&#123; &#x2F;&#x2F; 替换掉崩掉时的内容，打印崩掉时的参数和pid，不执行崩掉的逻辑，让程序不要崩 console.log(&quot;Preventing from killing ...&quot;) var kill_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;kill&quot;); &#x2F;&#x2F; var kill &#x3D; new NativeFunction(kill_addr,&quot;int&quot;,[&#39;int&#39;,&#39;int&#39;]); Interceptor.replace(kill_addr,new NativeCallback(function(arg0,arg1)&#123; console.log(&quot;arg0&#x3D;&gt; &quot;,arg0) console.log(&quot;arg1&#x3D;&gt; &quot;,arg1) &#125;,&quot;int&quot;,[&#39;int&#39;,&#39;int&#39;]))&#125;function main()&#123; replaceKill()&#125;setImmediate(main); frida -UF -l quchong.js 抓包获取注册验证码 frida -UF -l hookSocket.js -o quchong.txt ps -ef|grep -i quchong 获取包名 123456789objection -g com.whwy.equchong exploreandroid hooking search classes okhttpgit clone https:&#x2F;&#x2F;github.com&#x2F;siyujie&#x2F;OkHttpLogger-Frida.gitadb push okhttpfind.dex &#x2F;data&#x2F;local&#x2F;tmp &amp;&amp; chmod 777 okhttpfind.dexfrida -U -l okhttp_poker.js -f com.whwy.equchong --no-pausefind() 查看是否被混淆后的okhttp的参数拷贝到okhttp_poker.js上面定义参数frida -UF -l okhttp_poker.js -o quchong.txt attach模式操作发送验证码前启动hookfrida -U -l okhttp_poker.js -f com.whwy.equchong --no-pause -o qichong.txt spawn模式hold() 发送验证码抓包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#x2F;&#x2F;过客户端校验服务器function hook_KeyStore_load() &#123; &#x2F;&#x2F; hook证书 自吐证书密码和内容保存在sdcard中 Java.perform(function () &#123; var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); var myArray&#x3D;new Array(1024); var i &#x3D; 0 for (i &#x3D; 0; i myArray.length; i++) &#123; myArray[i]&#x3D; 0x0; &#125; var buffer &#x3D; Java.array(&#39;byte&#39;,myArray); var StringClass &#x3D; Java.use(&quot;java.lang.String&quot;); var KeyStore &#x3D; Java.use(&quot;java.security.KeyStore&quot;); KeyStore.load.overload(&#39;java.security.KeyStore$LoadStoreParameter&#39;).implementation &#x3D; function (arg0) &#123; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(&quot;KeyStore.load1:&quot;, arg0); this.load(arg0); &#125;; KeyStore.load.overload(&#39;java.io.InputStream&#39;, &#39;[C&#39;).implementation &#x3D; function (arg0, arg1) &#123; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); console.log(&quot;KeyStore.load2:&quot;, arg0, arg1 ? StringClass.$new(arg1) : null); if (arg0)&#123; var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(&quot;&#x2F;sdcard&#x2F;Download&quot;+ String(arg0)+&quot;.p12&quot;); var out &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); var r; while( (r &#x3D; arg0.read(buffer)) 0)&#123; out.write(buffer,0,r) &#125; console.log(&quot;save success!&quot;) out.close() &#125; this.load(arg0, arg1); &#125;; console.log(hook_KeyStore_load...); &#125;);&#125;&#x2F;&#x2F;过证书绑定 ssl pinning 对证书在代码中进行额外校验，function hook_ssl() &#123; &#x2F;&#x2F; hook ssl 调用栈 Java.perform(function() &#123; var ClassName &#x3D; &quot;com.android.org.conscrypt.Platform&quot;; var Platform &#x3D; Java.use(ClassName); var targetMethod &#x3D; &quot;checkServerTrusted&quot;; var len &#x3D; Platform[targetMethod].overloads.length; console.log(len); for(var i &#x3D; 0; i len; ++i) &#123; Platform[targetMethod].overloads[i].implementation &#x3D; function () &#123; console.log(&quot;class:&quot;, ClassName, &quot;target:&quot;, targetMethod, &quot;i:&quot;, i, arguments); printStack(ClassName + . + targetMethod); &#125; &#125; &#125;);&#125; frida -U -f com.whwy.equchong -l hook_keystore.js –no-pause -o quchong.txt 证书位置和密钥在KeyStore.load2后的/sdcard/Download 将p12证书拷贝出来，下载kse_5.4.4_all.deb，dpkg -i kse_2.4.4_all.deb，启动keystore explore打开p12证书，输入密码即可查看证书内容 右键-export-export key pair-输入密码 保存为p12，设置密码123456 charles-SSL Proxying Settings-Client Certificate-Import P12-导入导出的p12证书，密码为123456，Host Port配*表示所有发出去的包都用这个证书 启动Postern，配置charles抓包，重新注册获取验证码，依旧拿不到结果是，查看socket后的端口9443，在charles中配置9443端口，即可拿到完整加密请求结果 滴答清单启动charles抓包，发送验证码，查看OverView 证书绑定校验失败：Client closed the connection before a request was made.Possibly the SSL certificate was rejected.You may need to configure your browser or application to trust the Charles Root Certificate.See SSL Proxyinf in the Help menu. Android SSL证书设置和锁定(SSL/TLS Pinning)查看安卓设置-加密与凭据-信任的凭据 frida -U -f cn.ticktick.task -l quchong.js –no-pause 执行hook_ssl() 失败 objection -g cn.ticktick.task explore -s “android sslpinning disable” 失败 git clone https://github.com/WooyunDota/DroidSSLUnpinning.git frida -U -f cn.ticktick.task -l hooks.js –no-pause 失败 1234objection -g cn.ticktick.task explore -s &quot;android hooking watch class_method java.io.File.$init --dump-args --dump-backtrace --dump-return&quot; 打开证书文件就初始化这个文件，hook该类,发送验证码plugin wallbreaker classdump z1.gplugin wallbreaker objectsearch z1.g plugin wallbreaker objectdump --fullname 0x24e6 123cd OkHttpLogger-Frida &amp;&amp; frida -U -f cn.ticktick.task -l okhttp_poker.js %resumefind() 失败则不是ok3混淆,那么就是ok1 https://square.github.io/okhttp/4.x/okhttp/okhttp3/-certificate-pinner/ 1android hooking list class_methods z1.g 其中有z1.g.a,在CertificatePinner中被混淆的 123456789function killCertificatePinner()&#123; Java.perform(function()&#123; console.log(Beginning killCertificatePinner !...) Java.use(z1.g).a.implementation &#x3D; function(str,list)&#123; console.log(called z1.g.a ~) return ; &#125; &#125;)&#125; frida -U -f cn.ticktick.task -l quchong.js –no-pause 发送注册短信过掉z1.g.a的ok1中的证书 抓包总结kali nethunterapt install jnettop nethogs htop 查看请求ip端口 优点：直观、所见即所得缺点：没有内容，粒度太粗，简单看下 wireshark 使用NetHunter-Kex Manager-SETUP LOCAL SERVER 使用USER为root Start SERVER，启动NetHunter Kex的VNC连接界面kali，VNC Viewer也可以通过ip连接,图形化抓包 优点：可以转储内容scp &#x72;&#x6f;&#111;&#x74;&#64;&#x31;&#57;&#50;&#46;&#x31;&#x38;&#x36;&#x2e;&#x30;&#46;&#x32;&#76;/root/a.pcap ./，存下来稍后分析缺点：只能看明文，不能解加密协议 ARM设备武器化指南·破·Kali.Nethunter.2020a.上手实操 termuxadb install termux &amp;&amp; pkg update &amp;&amp; pkg install tcpdump &amp;&amp; ln -s /data/data/com.termux/files/usr/bin/tcpdump /system/bin 并remount 安卓7remount: mount -o rw,remount /system 安卓8remount:mount -o remount,rw /system mount -o remount.rw / 重新挂载，使用tcpdump开启抓包 优点：不需要刷Nethunter缺点：没有界面 hook1234567objection -g com.onejane.httpsocket explore -P ~&#x2F;.objection&#x2F;plugins android hooking search classes socket 将打印的类存入hookSocket.txtsed -i -e &#39;s&#x2F;^&#x2F;android hooking watch class_method &#x2F;&#39; hookSocket.txt 在以上的类前加入android hooking watch class_methodsed -i s&#x2F;$&#x2F;&quot;.\\$init&quot;&#x2F; hookSocket.txt 在以上的类后加入.$initplugin wallbreaker objectsearch java.net.Socket 内存查找类 plugin wallbreaker objectdump --fullname 0x21f2 打印内存中的类plugin wallbreaker classdump --fullname java.net.InetAddress 1objection -g com.onejane.httpsocket explore -c ~&#x2F;root&#x2F;Desktop&#x2F;hookSocket.txt -P ~&#x2F;.objection&#x2F;plugins 批量hook，如有报错就删除报错类 分别使用http和https运行HttpSocket项目，通过frida批量hook以上整理的hookSocket.txt中的类 HTTPjava.net.InetSocketAddress.InetSocketAddress(www.baidu.com/180.101.49.12, 80)java.net.InetSocketAddress$InetSocketAddressHolder.InetSocketAddress$InetSocketAddressHolder((none), www.baidu.com/180.101.49.12, 80, (none))java.net.InetSocketAddress.InetSocketAddress(/192.168.0.2, 43066)java.net.InetSocketAddress$InetSocketAddressHolder.InetSocketAddress$InetSocketAddressHolder((none), /192.168.0.2, 43066, (none))java.net.SocketInputStream.SocketInputStream(Socket[addr=www.baidu.com/180.101.49.12,port=80,localport=43066])java.net.SocketOutputStream.SocketOutputStream(Socket[addr=www.baidu.com/180.101.49.12,port=80,localport=43066])HTTPSjava.net.InetSocketAddress.InetSocketAddress(www.baidu.com/180.101.49.12, 443)java.net.Socket$2.Socket$2(Socket[address=www.baidu.com/180.101.49.12,port=443,localPort=44405])java.net.SocketInputStream.SocketInputStream(Socket[addr=www.baidu.com/180.101.49.12,port=443,localport=44405])java.net.SocketOutputStream.SocketOutputStream(Socket[addr=www.baidu.com/180.101.49.12,port=443,localport=44405])com.android.org.conscrypt.ConscryptFileDescriptorSocket.ConscryptFileDescriptorSocket(Socket[address=www.baidu.com/180.101.49.12,port=443,localPort=44405], www.baidu.com, 443, true, com.android.org.conscrypt.SSLParametersImpl@2ccad02)com.android.org.conscrypt.OpenSSLSocketImpl.OpenSSLSocketImpl(Socket[address=www.baidu.com/180.101.49.12,port=443,localPort=44405], www.baidu.com, 443, true)com.android.org.conscrypt.AbstractConscryptSocket.AbstractConscryptSocket(Socket[address=www.baidu.com/180.101.49.12,port=443,localPort=44405], www.baidu.com, 443, true)com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.ConscryptFileDescriptorSocket$SSLOutputStream(SSL socket over Socket[address=www.baidu.com/180.101.49.12,port=443,localPort=44405])com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.ConscryptFileDescriptorSocket$SSLInputStream(SSL socket over Socket[address=www.baidu.com/180.101.49.12,port=443,localPort=44405]) 123456789101112131415function hook_Address()&#123; Java.perform(function()&#123; Java.use(&quot;java.net.InetSocketAddress&quot;).$init.overload(&#39;java.net.InetAddress&#39;, &#39;int&#39;).implementation &#x3D; function(addr,int)&#123; var result &#x3D; this.$init(addr,int) if(addr.isSiteLocalAddress())&#123; &#x2F;&#x2F; 判断是不是本地地址 console.log(&quot;Local address &#x3D;&gt; &quot;,addr.toString(),&quot; port is &#x3D;&gt; &quot;,int) &#125;else&#123; console.log(&quot;Server address &#x3D;&gt; &quot;,addr.toString(),&quot; port is &#x3D;&gt; &quot;,int) &#125; return result; &#125; &#125;)&#125; frida -U -f com.onejane.httpsocket -l socketAddress.js –no-pause frida -U com.cz.babySister -l socketAddress.js –no-pause -o /root/Desktop/babySisterLogin.txt 使用attach模式抓移动tv登录包http frida -U com.ilulutv.fulao2 -l socketAddress.js –no-pause -o /root/Desktop/fulao2Login.txt 使用attach模式抓fulao2登录包https frida -U com.ilulutv.fulao2 -l hookEvent.js 点击得到所在event的类，点击登录触发AccountActivity 1234567891011android hooking search classes cipher 直接搜索加密相关类，并将所有类加入txt文件进行批量hookobjection -g com.onejane.httpsocket explore -c ~&#x2F;root&#x2F;Desktop&#x2F;hookCipher.txt android hooking watch class_method javax.crypto.Cipher.createCipher hook系统的cipher类android hooking watch class_method net.idik.lib.cipher.so.encrypt.AESEncryptor.decryptandroid hooking watch class_method javax.crypto.Cipher.doFinel 根据堆栈找到登录时触发的app函数android hooking watch class com.ilulutv.fulao2.other.i.b --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method com.ilulutv.fulao2.other.i.b.a --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method com.ilulutv.fulao2.other.i.b.b --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method com.ilulutv.fulao2.other.i.b.c --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method com.ilulutv.fulao2.other.i.b.d --dump-args --dump-backtrace --dump-returnandroid hooking watch class_method com.ilulutv.fulao2.other.i.b.e --dump-args --dump-backtrace --dump-return 手机上抓：优点：无法对抗，全部能抓，没有抓不到的包hook抓包：- 优点1：为所欲为，可以对包的内容进行进一步的更改和定制；- 优点2：抓包全面，直接就是明文，不需要解协议（无需绕过证书绑定,进入ssl之前已经抓到包）- 缺点：可能会不全、可能会漏。hook点是有限的，万一它在用奇葩的框架做网络传输就会漏掉Charles+Postern：协议层抓包：- 优点：全面。已经解好了协议，HTTP、WebSocket直接解好。- 缺点：配置证书稍微麻烦，解不了纯Socket。 抓包通杀git clone https://github.com/BigFaceCat2017/frida_ssl_logger.git 12345python ssl_logger.py -U -v com.iqiyi.video -p iqiyi.pcap 爱奇艺获取验证码抓包plugin wallbreaker objectsearch java.net.SocketOutputStreamplugin wallbreaker objectdump --fullname 0x4c16 看到socket类中地址和ipandroid hooking search classes socket 将相关类拷贝到文件中前面加上android hooking watch classobjection -g com.roysue.httpsocket explore -c tracesocket.txt 哪个类报错干掉哪个类即可 r0capture.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365# Copyright 2017 Google Inc. All Rights Reserved.# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);# you may not use this file except in compliance with the License.# You may obtain a copy of the License at## http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.&quot;&quot;&quot;Decrypts and logs a process&#39;s SSL traffic.Hooks the functions SSL_read() and SSL_write() in a given process and logs thedecrypted data to the console and&#x2F;or to a pcap file. Typical usage example: ssl_log(&quot;wget&quot;, &quot;log.pcap&quot;, True)Dependencies: frida (https:&#x2F;&#x2F;www.frida.re&#x2F;): sudo pip install frida hexdump (https:&#x2F;&#x2F;bitbucket.org&#x2F;techtonik&#x2F;hexdump&#x2F;) if using verbose output: sudo pip install hexdump&quot;&quot;&quot;__author__ &#x3D; &quot;geffner@google.com (Jason Geffner)&quot;__version__ &#x3D; &quot;2.0&quot;&quot;&quot;&quot;# r0captureID: r0ysue 安卓应用层抓包通杀脚本https:&#x2F;&#x2F;github.com&#x2F;r0ysue&#x2F;r0capture## 简介- 仅限安卓平台，测试安卓7、8、9、10 可用 ；- 无视所有证书校验或绑定，无视任何证书；- 通杀TCP&#x2F;IP四层模型中的应用层中的全部协议；- 通杀协议包括：Http,WebSocket,Ftp,Xmpp,Imap,Smtp,Protobuf等等、以及它们的SSL版本；- 通杀所有应用层框架，包括HttpUrlConnection、Okhttp1&#x2F;3&#x2F;4、Retrofit&#x2F;Volley等等；&quot;&quot;&quot;# Windows版本需要安装库：# pip install &#39;win_inet_pton&#39;# pip install hexdumpimport argparseimport osimport platformimport pprintimport randomimport signalimport socketimport structimport timeimport sysimport fridatry: if os.name &#x3D;&#x3D; &#39;nt&#39;: import win_inet_ptonexcept ImportError: # win_inet_pton import error passtry: import hexdump # pylint: disable&#x3D;g-import-not-at-topexcept ImportError: passtry: from shutil import get_terminal_size as get_terminal_sizeexcept: try: from backports.shutil_get_terminal_size import get_terminal_size as get_terminal_size except: passtry: import clickexcept: class click: @staticmethod def secho(message&#x3D;None, **kwargs): print(message) @staticmethod def style(**kwargs): raise Exception(&quot;unsupported style&quot;)banner &#x3D; &quot;&quot;&quot;-------------------------------------------------------------------------------------------- .oooo. . d8P&#39;&#96;Y8b .o8 oooo d8b 888 888 .ooooo. .oooo. oo.ooooo. .o888oo oooo oooo oooo d8b .ooooo. &#96;888&quot;&quot;8P 888 888 d88&#39; &#96;&quot;Y8 &#96;P )88b 888&#39; &#96;88b 888 &#96;888 &#96;888 &#96;888&quot;&quot;8P d88&#39; &#96;88b 888 888 888 888 .oP&quot;888 888 888 888 888 888 888 888ooo888 888 &#96;88b d88&#39; 888 .o8 d8( 888 888 888 888 . 888 888 888 888 .o d888b &#96;Y8bd8P&#39; &#96;Y8bod8P&#39; &#96;Y888&quot;&quot;8o 888bod8P&#39; &quot;888&quot; &#96;V88V&quot;V8P&#39; d888b &#96;Y8bod8P&#39; 888 o888o https:&#x2F;&#x2F;github.com&#x2F;r0ysue&#x2F;r0capture--------------------------------------------------------------------------------------------\\n&quot;&quot;&quot;def show_banner(): colors &#x3D; [&#39;bright_red&#39;, &#39;bright_green&#39;, &#39;bright_blue&#39;, &#39;cyan&#39;, &#39;magenta&#39;] try: click.style(&#39;color test&#39;, fg&#x3D;&#39;bright_red&#39;) except: colors &#x3D; [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;cyan&#39;, &#39;magenta&#39;] try: columns &#x3D; get_terminal_size().columns if columns &gt;&#x3D; len(banner.splitlines()[1]): for line in banner.splitlines(): click.secho(line, fg&#x3D;random.choice(colors)) except: pass# ssl_session[&lt;SSL_SESSION id&gt;] &#x3D; (&lt;bytes sent by client&gt;,# &lt;bytes sent by server&gt;)ssl_sessions &#x3D; &#123;&#125;def ssl_log(process, pcap&#x3D;None, host&#x3D;False, verbose&#x3D;False, isUsb&#x3D;False, ssllib&#x3D;&quot;&quot;, isSpawn&#x3D;True, wait&#x3D;0): &quot;&quot;&quot;Decrypts and logs a process&#39;s SSL traffic. Hooks the functions SSL_read() and SSL_write() in a given process and logs the decrypted data to the console and&#x2F;or to a pcap file. Args: process: The target process&#39;s name (as a string) or process ID (as an int). pcap: The file path to which the pcap file should be written. verbose: If True, log the decrypted traffic to the console. Raises: NotImplementedError: Not running on a Linux or macOS system. &quot;&quot;&quot; # if platform.system() not in (&quot;Darwin&quot;, &quot;Linux&quot;): # raise NotImplementedError(&quot;This function is only implemented for Linux and &quot; # &quot;macOS systems.&quot;) def log_pcap(pcap_file, ssl_session_id, function, src_addr, src_port, dst_addr, dst_port, data): &quot;&quot;&quot;Writes the captured data to a pcap file. Args: pcap_file: The opened pcap file. ssl_session_id: The SSL session ID for the communication. function: The function that was intercepted (&quot;SSL_read&quot; or &quot;SSL_write&quot;). src_addr: The source address of the logged packet. src_port: The source port of the logged packet. dst_addr: The destination address of the logged packet. dst_port: The destination port of the logged packet. data: The decrypted packet data. &quot;&quot;&quot; t &#x3D; time.time() if ssl_session_id not in ssl_sessions: ssl_sessions[ssl_session_id] &#x3D; (random.randint(0, 0xFFFFFFFF), random.randint(0, 0xFFFFFFFF)) client_sent, server_sent &#x3D; ssl_sessions[ssl_session_id] if function &#x3D;&#x3D; &quot;SSL_read&quot;: seq, ack &#x3D; (server_sent, client_sent) else: seq, ack &#x3D; (client_sent, server_sent) for writes in ( # PCAP record (packet) header (&quot;&#x3D;I&quot;, int(t)), # Timestamp seconds (&quot;&#x3D;I&quot;, int((t * 1000000) % 1000000)), # Timestamp microseconds (&quot;&#x3D;I&quot;, 40 + len(data)), # Number of octets saved (&quot;&#x3D;i&quot;, 40 + len(data)), # Actual length of packet # IPv4 header (&quot;&gt;B&quot;, 0x45), # Version and Header Length (&quot;&gt;B&quot;, 0), # Type of Service (&quot;&gt;H&quot;, 40 + len(data)), # Total Length (&quot;&gt;H&quot;, 0), # Identification (&quot;&gt;H&quot;, 0x4000), # Flags and Fragment Offset (&quot;&gt;B&quot;, 0xFF), # Time to Live (&quot;&gt;B&quot;, 6), # Protocol (&quot;&gt;H&quot;, 0), # Header Checksum (&quot;&gt;I&quot;, src_addr), # Source Address (&quot;&gt;I&quot;, dst_addr), # Destination Address # TCP header (&quot;&gt;H&quot;, src_port), # Source Port (&quot;&gt;H&quot;, dst_port), # Destination Port (&quot;&gt;I&quot;, seq), # Sequence Number (&quot;&gt;I&quot;, ack), # Acknowledgment Number (&quot;&gt;H&quot;, 0x5018), # Header Length and Flags (&quot;&gt;H&quot;, 0xFFFF), # Window Size (&quot;&gt;H&quot;, 0), # Checksum (&quot;&gt;H&quot;, 0)): # Urgent Pointer pcap_file.write(struct.pack(writes[0], writes[1])) pcap_file.write(data) if function &#x3D;&#x3D; &quot;SSL_read&quot;: server_sent +&#x3D; len(data) else: client_sent +&#x3D; len(data) ssl_sessions[ssl_session_id] &#x3D; (client_sent, server_sent) def on_message(message, data): &quot;&quot;&quot;Callback for errors and messages sent from Frida-injected JavaScript. Logs captured packet data received from JavaScript to the console and&#x2F;or a pcap file. See https:&#x2F;&#x2F;www.frida.re&#x2F;docs&#x2F;messages&#x2F; for more detail on Frida&#39;s messages. Args: message: A dictionary containing the message &quot;type&quot; and other fields dependent on message type. data: The string of captured decrypted data. &quot;&quot;&quot; if message[&quot;type&quot;] &#x3D;&#x3D; &quot;error&quot;: pprint.pprint(message) os.kill(os.getpid(), signal.SIGTERM) return if len(data) &#x3D;&#x3D; 1: print(message[&quot;payload&quot;][&quot;function&quot;]) print(message[&quot;payload&quot;][&quot;stack&quot;]) return p &#x3D; message[&quot;payload&quot;] if verbose: src_addr &#x3D; socket.inet_ntop(socket.AF_INET, struct.pack(&quot;&gt;I&quot;, p[&quot;src_addr&quot;])) dst_addr &#x3D; socket.inet_ntop(socket.AF_INET, struct.pack(&quot;&gt;I&quot;, p[&quot;dst_addr&quot;])) print(&quot;SSL Session: &quot; + p[&quot;ssl_session_id&quot;]) print(&quot;[%s] %s:%d --&gt; %s:%d&quot; % ( p[&quot;function&quot;], src_addr, p[&quot;src_port&quot;], dst_addr, p[&quot;dst_port&quot;])) hexdump.hexdump(data) print(p[&quot;stack&quot;]) if pcap: log_pcap(pcap_file, p[&quot;ssl_session_id&quot;], p[&quot;function&quot;], p[&quot;src_addr&quot;], p[&quot;src_port&quot;], p[&quot;dst_addr&quot;], p[&quot;dst_port&quot;], data) if isUsb: try: device &#x3D; frida.get_usb_device() except: device &#x3D; frida.get_remote_device() else: if host: manager &#x3D; frida.get_device_manager() device &#x3D; manager.add_remote_device(host) else: device &#x3D; frida.get_local_device() if isSpawn: pid &#x3D; device.spawn([process]) time.sleep(1) session &#x3D; device.attach(pid) time.sleep(1) device.resume(pid) else: print(&quot;attach&quot;) session &#x3D; device.attach(process) if wait &gt; 0: print(&quot;wait for &#123;&#125; seconds&quot;.format(wait)) time.sleep(wait) # session &#x3D; frida.attach(process) # pid &#x3D; device.spawn([process]) # pid &#x3D; process # session &#x3D; device.attach(pid) # device.resume(pid) if pcap: pcap_file &#x3D; open(pcap, &quot;wb&quot;, 0) for writes in ( (&quot;&#x3D;I&quot;, 0xa1b2c3d4), # Magic number (&quot;&#x3D;H&quot;, 2), # Major version number (&quot;&#x3D;H&quot;, 4), # Minor version number (&quot;&#x3D;i&quot;, time.timezone), # GMT to local correction (&quot;&#x3D;I&quot;, 0), # Accuracy of timestamps (&quot;&#x3D;I&quot;, 65535), # Max length of captured packets (&quot;&#x3D;I&quot;, 228)): # Data link type (LINKTYPE_IPV4) pcap_file.write(struct.pack(writes[0], writes[1])) with open(&quot;.&#x2F;script.js&quot;, encoding&#x3D;&quot;utf-8&quot;) as f: _FRIDA_SCRIPT &#x3D; f.read() # _FRIDA_SCRIPT &#x3D; session.create_script(content) # print(_FRIDA_SCRIPT) script &#x3D; session.create_script(_FRIDA_SCRIPT) script.on(&quot;message&quot;, on_message) script.load() if ssllib !&#x3D; &quot;&quot;: script.exports.setssllib(ssllib) print(&quot;Press Ctrl+C to stop logging.&quot;) def stoplog(signum, frame): print(&#39;You have stoped logging.&#39;) session.detach() if pcap: pcap_file.flush() pcap_file.close() exit() signal.signal(signal.SIGINT, stoplog) signal.signal(signal.SIGTERM, stoplog) sys.stdin.read()if __name__ &#x3D;&#x3D; &quot;__main__&quot;: show_banner() class ArgParser(argparse.ArgumentParser): def error(self, message): print(&quot;ssl_logger v&quot; + __version__) print(&quot;by &quot; + __author__) print(&quot;Modified by BigFaceCat&quot;) print(&quot;Error: &quot; + message) print() print(self.format_help().replace(&quot;usage:&quot;, &quot;Usage:&quot;)) self.exit(0) parser &#x3D; ArgParser( add_help&#x3D;False, description&#x3D;&quot;Decrypts and logs a process&#39;s SSL traffic.&quot;, formatter_class&#x3D;argparse.RawDescriptionHelpFormatter, epilog&#x3D;r&quot;&quot;&quot;Examples: %(prog)s -pcap ssl.pcap openssl %(prog)s -verbose 31337 %(prog)s -pcap log.pcap -verbose wget %(prog)s -pcap log.pcap -ssl &quot;*libssl.so*&quot; com.bigfacecat.testdemo&quot;&quot;&quot;) args &#x3D; parser.add_argument_group(&quot;Arguments&quot;) args.add_argument(&quot;-pcap&quot;, &#39;-p&#39;, metavar&#x3D;&quot;&lt;path&gt;&quot;, required&#x3D;False, help&#x3D;&quot;Name of PCAP file to write&quot;) args.add_argument(&quot;-host&quot;, &#39;-H&#39;, metavar&#x3D;&quot;&lt;192.168.1.1:27042&gt;&quot;, required&#x3D;False, help&#x3D;&quot;connect to remote frida-server on HOST&quot;) args.add_argument(&quot;-verbose&quot;,&quot;-v&quot;, required&#x3D;False, action&#x3D;&quot;store_const&quot;, default&#x3D;True, const&#x3D;True, help&#x3D;&quot;Show verbose output&quot;) args.add_argument(&quot;process&quot;, metavar&#x3D;&quot;&lt;process name | process id&gt;&quot;, help&#x3D;&quot;Process whose SSL calls to log&quot;) args.add_argument(&quot;-ssl&quot;, default&#x3D;&quot;&quot;, metavar&#x3D;&quot;&lt;lib&gt;&quot;, help&#x3D;&quot;SSL library to hook&quot;) args.add_argument(&quot;--isUsb&quot;, &quot;-U&quot;, default&#x3D;False, action&#x3D;&quot;store_true&quot;, help&#x3D;&quot;connect to USB device&quot;) args.add_argument(&quot;--isSpawn&quot;, &quot;-f&quot;, default&#x3D;False, action&#x3D;&quot;store_true&quot;, help&#x3D;&quot;if spawned app&quot;) args.add_argument(&quot;-wait&quot;, &quot;-w&quot;, type&#x3D;int, metavar&#x3D;&quot;&lt;seconds&gt;&quot;, default&#x3D;0, help&#x3D;&quot;Time to wait for the process&quot;) parsed &#x3D; parser.parse_args() ssl_log( int(parsed.process) if parsed.process.isdigit() else parsed.process, parsed.pcap, parsed.host, parsed.verbose, isUsb&#x3D;parsed.isUsb, isSpawn&#x3D;parsed.isSpawn, ssllib&#x3D;parsed.ssl, wait&#x3D;parsed.wait ) script.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339&#x2F;** * Initializes &#39;addresses&#39; dictionary and NativeFunctions. *&#x2F;&quot;use strict&quot;;rpc.exports &#x3D; &#123; setssllib: function (name) &#123; console.log(&quot;setSSLLib &#x3D;&gt; &quot; + name); libname &#x3D; name; initializeGlobals(); return; &#125;&#125;;var addresses &#x3D; &#123;&#125;;var SSL_get_fd &#x3D; null;var SSL_get_session &#x3D; null;var SSL_SESSION_get_id &#x3D; null;var getpeername &#x3D; null;var getsockname &#x3D; null;var ntohs &#x3D; null;var ntohl &#x3D; null;var SSLstackwrite &#x3D; null;var SSLstackread &#x3D; null;var libname &#x3D; &quot;*libssl*&quot;;function uuid(len, radix) &#123; var chars &#x3D; &#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#39;.split(&#39;&#39;); var uuid &#x3D; [], i; radix &#x3D; radix || chars.length; if (len) &#123; &#x2F;&#x2F; Compact form for (i &#x3D; 0; i &lt; len; i++) uuid[i] &#x3D; chars[0 | Math.random() * radix]; &#125; else &#123; &#x2F;&#x2F; rfc4122, version 4 form var r; &#x2F;&#x2F; rfc4122 requires these characters uuid[8] &#x3D; uuid[13] &#x3D; uuid[18] &#x3D; uuid[23] &#x3D; &#39;-&#39;; uuid[14] &#x3D; &#39;4&#39;; &#x2F;&#x2F; Fill in random data. At i&#x3D;&#x3D;19 set the high bits of clock sequence as &#x2F;&#x2F; per rfc4122, sec. 4.1.5 for (i &#x3D; 0; i &lt; 36; i++) &#123; if (!uuid[i]) &#123; r &#x3D; 0 | Math.random() * 16; uuid[i] &#x3D; chars[(i &#x3D;&#x3D; 19) ? (r &amp; 0x3) | 0x8 : r]; &#125; &#125; &#125; return uuid.join(&#39;&#39;);&#125;function return_zero(args) &#123; return 0;&#125;function initializeGlobals() &#123; var resolver &#x3D; new ApiResolver(&quot;module&quot;); var exps &#x3D; [ [Process.platform &#x3D;&#x3D; &quot;darwin&quot; ? &quot;*libboringssl*&quot; : &quot;*libssl*&quot;, [&quot;SSL_read&quot;, &quot;SSL_write&quot;, &quot;SSL_get_fd&quot;, &quot;SSL_get_session&quot;, &quot;SSL_SESSION_get_id&quot;]], &#x2F;&#x2F; for ios and Android [Process.platform &#x3D;&#x3D; &quot;darwin&quot; ? &quot;*libsystem*&quot; : &quot;*libc*&quot;, [&quot;getpeername&quot;, &quot;getsockname&quot;, &quot;ntohs&quot;, &quot;ntohl&quot;]] ]; &#x2F;&#x2F; console.log(exps) for (var i &#x3D; 0; i &lt; exps.length; i++) &#123; var lib &#x3D; exps[i][0]; var names &#x3D; exps[i][1]; for (var j &#x3D; 0; j &lt; names.length; j++) &#123; var name &#x3D; names[j]; &#x2F;&#x2F; console.log(&quot;exports:&quot; + lib + &quot;!&quot; + name) var matches &#x3D; resolver.enumerateMatchesSync(&quot;exports:&quot; + lib + &quot;!&quot; + name); if (matches.length &#x3D;&#x3D; 0) &#123; if (name &#x3D;&#x3D; &quot;SSL_get_fd&quot;) &#123; addresses[&quot;SSL_get_fd&quot;] &#x3D; 0; continue; &#125; throw &quot;Could not find &quot; + lib + &quot;!&quot; + name; &#125; else if (matches.length !&#x3D; 1) &#123; &#x2F;&#x2F; Sometimes Frida returns duplicates. var address &#x3D; 0; var s &#x3D; &quot;&quot;; var duplicates_only &#x3D; true; for (var k &#x3D; 0; k &lt; matches.length; k++) &#123; if (s.length !&#x3D; 0) &#123; s +&#x3D; &quot;, &quot;; &#125; s +&#x3D; matches[k].name + &quot;@&quot; + matches[k].address; if (address &#x3D;&#x3D; 0) &#123; address &#x3D; matches[k].address; &#125; else if (!address.equals(matches[k].address)) &#123; duplicates_only &#x3D; false; &#125; &#125; if (!duplicates_only) &#123; throw &quot;More than one match found for &quot; + lib + &quot;!&quot; + name + &quot;: &quot; + s; &#125; &#125; addresses[name] &#x3D; matches[0].address; &#125; &#125; if (addresses[&quot;SSL_get_fd&quot;] &#x3D;&#x3D; 0) &#123; SSL_get_fd &#x3D; return_zero; &#125; else &#123; SSL_get_fd &#x3D; new NativeFunction(addresses[&quot;SSL_get_fd&quot;], &quot;int&quot;, [&quot;pointer&quot;]); &#125; SSL_get_session &#x3D; new NativeFunction(addresses[&quot;SSL_get_session&quot;], &quot;pointer&quot;, [&quot;pointer&quot;]); SSL_SESSION_get_id &#x3D; new NativeFunction(addresses[&quot;SSL_SESSION_get_id&quot;], &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]); getpeername &#x3D; new NativeFunction(addresses[&quot;getpeername&quot;], &quot;int&quot;, [&quot;int&quot;, &quot;pointer&quot;, &quot;pointer&quot;]); getsockname &#x3D; new NativeFunction(addresses[&quot;getsockname&quot;], &quot;int&quot;, [&quot;int&quot;, &quot;pointer&quot;, &quot;pointer&quot;]); ntohs &#x3D; new NativeFunction(addresses[&quot;ntohs&quot;], &quot;uint16&quot;, [&quot;uint16&quot;]); ntohl &#x3D; new NativeFunction(addresses[&quot;ntohl&quot;], &quot;uint32&quot;, [&quot;uint32&quot;]);&#125;initializeGlobals();function ipToNumber(ip) &#123; var num &#x3D; 0; if (ip &#x3D;&#x3D; &quot;&quot;) &#123; return num; &#125; var aNum &#x3D; ip.split(&quot;.&quot;); if (aNum.length !&#x3D; 4) &#123; return num; &#125; num +&#x3D; parseInt(aNum[0]) &lt;&lt; 0; num +&#x3D; parseInt(aNum[1]) &lt;&lt; 8; num +&#x3D; parseInt(aNum[2]) &lt;&lt; 16; num +&#x3D; parseInt(aNum[3]) &lt;&lt; 24; num &#x3D; num &gt;&gt;&gt; 0;&#x2F;&#x2F;这个很关键，不然可能会出现负数的情况 return num;&#125;&#x2F;** * Returns a dictionary of a sockfd&#39;s &quot;src_addr&quot;, &quot;src_port&quot;, &quot;dst_addr&quot;, and * &quot;dst_port&quot;. * @param &#123;int&#125; sockfd The file descriptor of the socket to inspect. * @param &#123;boolean&#125; isRead If true, the context is an SSL_read call. If * false, the context is an SSL_write call. * @return &#123;dict&#125; Dictionary of sockfd&#39;s &quot;src_addr&quot;, &quot;src_port&quot;, &quot;dst_addr&quot;, * and &quot;dst_port&quot;. *&#x2F;function getPortsAndAddresses(sockfd, isRead) &#123; var message &#x3D; &#123;&#125;; var src_dst &#x3D; [&quot;src&quot;, &quot;dst&quot;]; for (var i &#x3D; 0; i &lt; src_dst.length; i++) &#123; if ((src_dst[i] &#x3D;&#x3D; &quot;src&quot;) ^ isRead) &#123; var sockAddr &#x3D; Socket.localAddress(sockfd) &#125; else &#123; var sockAddr &#x3D; Socket.peerAddress(sockfd) &#125; if (sockAddr &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 网络超时or其他原因可能导致socket被关闭 message[src_dst[i] + &quot;_port&quot;] &#x3D; 0 message[src_dst[i] + &quot;_addr&quot;] &#x3D; 0 &#125; else &#123; message[src_dst[i] + &quot;_port&quot;] &#x3D; (sockAddr.port &amp; 0xFFFF) message[src_dst[i] + &quot;_addr&quot;] &#x3D; ntohl(ipToNumber(sockAddr.ip.split(&quot;:&quot;).pop())) &#125; &#125; return message;&#125;&#x2F;** * Get the session_id of SSL object and return it as a hex string. * @param &#123;!NativePointer&#125; ssl A pointer to an SSL object. * @return &#123;dict&#125; A string representing the session_id of the SSL object&#39;s * SSL_SESSION. For example, * &quot;59FD71B7B90202F359D89E66AE4E61247954E28431F6C6AC46625D472FF76336&quot;. *&#x2F;function getSslSessionId(ssl) &#123; var session &#x3D; SSL_get_session(ssl); if (session &#x3D;&#x3D; 0) &#123; return 0; &#125; var len &#x3D; Memory.alloc(4); var p &#x3D; SSL_SESSION_get_id(session, len); len &#x3D; Memory.readU32(len); var session_id &#x3D; &quot;&quot;; for (var i &#x3D; 0; i &lt; len; i++) &#123; &#x2F;&#x2F; Read a byte, convert it to a hex string (0xAB &#x3D;&#x3D;&gt; &quot;AB&quot;), and append &#x2F;&#x2F; it to session_id. session_id +&#x3D; (&quot;0&quot; + Memory.readU8(p.add(i)).toString(16).toUpperCase()).substr(-2); &#125; return session_id;&#125;Interceptor.attach(addresses[&quot;SSL_read&quot;], &#123; onEnter: function (args) &#123; var message &#x3D; getPortsAndAddresses(SSL_get_fd(args[0]), true); message[&quot;ssl_session_id&quot;] &#x3D; getSslSessionId(args[0]); message[&quot;function&quot;] &#x3D; &quot;SSL_read&quot;; message[&quot;stack&quot;] &#x3D; SSLstackread; this.message &#x3D; message; this.buf &#x3D; args[1]; &#125;, onLeave: function (retval) &#123; retval |&#x3D; 0; &#x2F;&#x2F; Cast retval to 32-bit integer. if (retval &lt;&#x3D; 0) &#123; return; &#125; send(this.message, Memory.readByteArray(this.buf, retval)); &#125; &#125;);Interceptor.attach(addresses[&quot;SSL_write&quot;], &#123; onEnter: function (args) &#123; var message &#x3D; getPortsAndAddresses(SSL_get_fd(args[0]), false); message[&quot;ssl_session_id&quot;] &#x3D; getSslSessionId(args[0]); message[&quot;function&quot;] &#x3D; &quot;SSL_write&quot;; message[&quot;stack&quot;] &#x3D; SSLstackwrite; send(message, Memory.readByteArray(args[1], parseInt(args[2]))); &#125;, onLeave: function (retval) &#123; &#125; &#125;);if (Java.available) &#123; Java.perform(function () &#123; function storeP12(pri, p7, p12Path, p12Password) &#123; var X509Certificate &#x3D; Java.use(&quot;java.security.cert.X509Certificate&quot;) var p7X509 &#x3D; Java.cast(p7, X509Certificate); var chain &#x3D; Java.array(&quot;java.security.cert.X509Certificate&quot;, [p7X509]) var ks &#x3D; Java.use(&quot;java.security.KeyStore&quot;).getInstance(&quot;PKCS12&quot;, &quot;BC&quot;); ks.load(null, null); ks.setKeyEntry(&quot;client&quot;, pri, Java.use(&#39;java.lang.String&#39;).$new(p12Password).toCharArray(), chain); try &#123; var out &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(p12Path); ks.store(out, Java.use(&#39;java.lang.String&#39;).$new(p12Password).toCharArray()) &#125; catch (exp) &#123; console.log(exp) &#125; &#125; &#x2F;&#x2F;在服务器校验客户端的情形下，帮助dump客户端证书，并保存为p12的格式，证书密码为r0ysue Java.use(&quot;java.security.KeyStore$PrivateKeyEntry&quot;).getPrivateKey.implementation &#x3D; function () &#123; var result &#x3D; this.getPrivateKey() var packageName &#x3D; Java.use(&quot;android.app.ActivityThread&quot;).currentApplication().getApplicationContext().getPackageName(); storeP12(this.getPrivateKey(), this.getCertificate(), &#39;&#x2F;sdcard&#x2F;Download&#x2F;&#39; + packageName + uuid(10, 16) + &#39;.p12&#39;, &#39;r0ysue&#39;); var message &#x3D; &#123;&#125;; message[&quot;function&quot;] &#x3D; &quot;dumpClinetCertificate&#x3D;&gt;&quot; + &#39;&#x2F;sdcard&#x2F;Download&#x2F;&#39; + packageName + uuid(10, 16) + &#39;.p12&#39; + &#39; pwd: r0ysue&#39;; message[&quot;stack&quot;] &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()); var data &#x3D; Memory.alloc(1); send(message, Memory.readByteArray(data, 1)) return result; &#125; Java.use(&quot;java.security.KeyStore$PrivateKeyEntry&quot;).getCertificateChain.implementation &#x3D; function () &#123; var result &#x3D; this.getCertificateChain() var packageName &#x3D; Java.use(&quot;android.app.ActivityThread&quot;).currentApplication().getApplicationContext().getPackageName(); storeP12(this.getPrivateKey(), this.getCertificate(), &#39;&#x2F;sdcard&#x2F;Download&#x2F;&#39; + packageName + uuid(10, 16) + &#39;.p12&#39;, &#39;r0ysue&#39;); var message &#x3D; &#123;&#125;; message[&quot;function&quot;] &#x3D; &quot;dumpClinetCertificate&#x3D;&gt;&quot; + &#39;&#x2F;sdcard&#x2F;Download&#x2F;&#39; + packageName + uuid(10, 16) + &#39;.p12&#39; + &#39; pwd: r0ysue&#39;; message[&quot;stack&quot;] &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()); var data &#x3D; Memory.alloc(1); send(message, Memory.readByteArray(data, 1)) return result; &#125; &#x2F;&#x2F;SSLpinning helper 帮助定位证书绑定的关键代码 Java.use(&quot;java.io.File&quot;).$init.overload(&#39;java.io.File&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function (file, cert) &#123; var result &#x3D; this.$init(file, cert) var stack &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()); if (file.getPath().indexOf(&quot;cacert&quot;) &gt;&#x3D; 0 &amp;&amp; stack.indexOf(&quot;X509TrustManagerExtensions.checkServerTrusted&quot;) &gt;&#x3D; 0) &#123; var message &#x3D; &#123;&#125;; message[&quot;function&quot;] &#x3D; &quot;SSLpinning position locator &#x3D;&gt; &quot; + file.getPath() + &quot; &quot; + cert; message[&quot;stack&quot;] &#x3D; stack; var data &#x3D; Memory.alloc(1); send(message, Memory.readByteArray(data, 1)) &#125; return result; &#125; Java.use(&quot;java.net.SocketOutputStream&quot;).socketWrite0.overload(&#39;java.io.FileDescriptor&#39;, &#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (fd, bytearry, offset, byteCount) &#123; var result &#x3D; this.socketWrite0(fd, bytearry, offset, byteCount); var message &#x3D; &#123;&#125;; message[&quot;function&quot;] &#x3D; &quot;HTTP_send&quot;; message[&quot;ssl_session_id&quot;] &#x3D; &quot;&quot;; message[&quot;src_addr&quot;] &#x3D; ntohl(ipToNumber((this.socket.value.getLocalAddress().toString().split(&quot;:&quot;)[0]).split(&quot;&#x2F;&quot;).pop())); message[&quot;src_port&quot;] &#x3D; parseInt(this.socket.value.getLocalPort().toString()); message[&quot;dst_addr&quot;] &#x3D; ntohl(ipToNumber((this.socket.value.getRemoteSocketAddress().toString().split(&quot;:&quot;)[0]).split(&quot;&#x2F;&quot;).pop())); message[&quot;dst_port&quot;] &#x3D; parseInt(this.socket.value.getRemoteSocketAddress().toString().split(&quot;:&quot;).pop()); message[&quot;stack&quot;] &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()).toString(); var ptr &#x3D; Memory.alloc(byteCount); for (var i &#x3D; 0; i &lt; byteCount; ++i) Memory.writeS8(ptr.add(i), bytearry[offset + i]); send(message, Memory.readByteArray(ptr, byteCount)) return result; &#125; Java.use(&quot;java.net.SocketInputStream&quot;).socketRead0.overload(&#39;java.io.FileDescriptor&#39;, &#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (fd, bytearry, offset, byteCount, timeout) &#123; var result &#x3D; this.socketRead0(fd, bytearry, offset, byteCount, timeout); var message &#x3D; &#123;&#125;; message[&quot;function&quot;] &#x3D; &quot;HTTP_recv&quot;; message[&quot;ssl_session_id&quot;] &#x3D; &quot;&quot;; message[&quot;src_addr&quot;] &#x3D; ntohl(ipToNumber((this.socket.value.getRemoteSocketAddress().toString().split(&quot;:&quot;)[0]).split(&quot;&#x2F;&quot;).pop())); message[&quot;src_port&quot;] &#x3D; parseInt(this.socket.value.getRemoteSocketAddress().toString().split(&quot;:&quot;).pop()); message[&quot;dst_addr&quot;] &#x3D; ntohl(ipToNumber((this.socket.value.getLocalAddress().toString().split(&quot;:&quot;)[0]).split(&quot;&#x2F;&quot;).pop())); message[&quot;dst_port&quot;] &#x3D; parseInt(this.socket.value.getLocalPort()); message[&quot;stack&quot;] &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()).toString(); if (result &gt; 0) &#123; var ptr &#x3D; Memory.alloc(result); for (var i &#x3D; 0; i &lt; result; ++i) Memory.writeS8(ptr.add(i), bytearry[offset + i]); send(message, Memory.readByteArray(ptr, result)) &#125; return result; &#125; if (parseFloat(Java.androidVersion) &gt; 8) &#123; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (bytearry, int1, int2) &#123; var result &#x3D; this.write(bytearry, int1, int2); SSLstackwrite &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()).toString(); return result; &#125; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (bytearry, int1, int2) &#123; var result &#x3D; this.read(bytearry, int1, int2); SSLstackread &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()).toString(); return result; &#125; &#125; else &#123; Java.use(&quot;com.android.org.conscrypt.OpenSSLSocketImpl$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (bytearry, int1, int2) &#123; var result &#x3D; this.write(bytearry, int1, int2); SSLstackwrite &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()).toString(); return result; &#125; Java.use(&quot;com.android.org.conscrypt.OpenSSLSocketImpl$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function (bytearry, int1, int2) &#123; var result &#x3D; this.read(bytearry, int1, int2); SSLstackread &#x3D; Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()).toString(); return result; &#125; &#125; &#125; )&#125; python r0capture.py -U -f com.qiyi.video -p iqiyi.pcap 某抢票app逆向续篇之干掉vpn抓包检测 Android 开发之避免被第三方使用代理抓包 【SO壳】17种安卓native反调试收集 Android JNI(一)——NDK与JNI基础 网络通讯协议分析Java层socket抓包okhttp2.6项目启动tcp服务器 1tcpdump -i any -s 0 -w &#x2F;sdcard&#x2F;1.pcap 抓tcp包 java.net.Socket类构造函数：new Socket(ip,port)-&gt;Socket(InetAddress[] addresses, int port, SocketAddress localAddr, boolean stream) ​ -&gt;impl java.net.SocksSocketImpl 建立连接：connect(SocketAddress endpoint) 接收数据：java,net.SocketInputStream.read(byte[])-&gt;read(b,0,b.length)-&gt;read(b,off,length,impl.getTimeout())-&gt;socketRead(fd,b,off,length,timeout)-&gt;socketRead0(fd,b,off,length,timeout)(jni函数) 发送数据：java.net.SocketOutputStream.write(byte[])-&gt;socketWrite(b,0,b.length)-&gt;socketWrite0(fd,b,off,len)-&gt;private native void socketWrite0(FileDescriptor fd,byte[] b,int off,int len) throws IOException frida -UF -l hooktcp.js –no-pause frida -U -f com.example.okhttp -l hooktcp.js –no-pause -o tcp.log 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596function LogPrint(log) &#123; var theDate &#x3D; new Date(); var hour &#x3D; theDate.getHours(); var minute &#x3D; theDate.getMinutes(); var second &#x3D; theDate.getSeconds(); var mSecond &#x3D; theDate.getMilliseconds(); hour &lt; 10 ? hour &#x3D; &quot;0&quot; + hour : hour; minute &lt; 10 ? minute &#x3D; &quot;0&quot; + minute : minute; second &lt; 10 ? second &#x3D; &quot;0&quot; + second : second; mSecond &lt; 10 ? mSecond &#x3D; &quot;00&quot; + mSecond : mSecond &lt; 100 ? mSecond &#x3D; &quot;0&quot; + mSecond : mSecond; var time &#x3D; hour + &quot;:&quot; + minute + &quot;:&quot; + second + &quot;:&quot; + mSecond; var threadid &#x3D; Process.getCurrentThreadId(); console.log(&quot;[&quot; + time + &quot;]&quot; + &quot;-&gt;threadid:&quot; + threadid + &quot;--&quot; + log);&#125;function printJavaStack(name) &#123; Java.perform(function () &#123; var Exception &#x3D; Java.use(&quot;java.lang.Exception&quot;); var ins &#x3D; Exception.$new(&quot;Exception&quot;); var straces &#x3D; ins.getStackTrace(); if (straces !&#x3D; undefined &amp;&amp; straces !&#x3D; null) &#123; var strace &#x3D; straces.toString(); var replaceStr &#x3D; strace.replace(&#x2F;,&#x2F;g, &quot; \\n &quot;); LogPrint(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + name + &quot; Stack strat&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); LogPrint(replaceStr); LogPrint(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + name + &quot; Stack end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; \\n &quot;); Exception.$dispose(); &#125; &#125;);&#125;&#x2F;&#x2F; 可以打印ascii码 function isprintable(value) &#123; if (value &gt;&#x3D; 32 &amp;&amp; value &lt;&#x3D; 126) &#123; return true; &#125; return false;&#125;function hooktcp() &#123; Java.perform(function () &#123; var SocketClass &#x3D; Java.use(&#39;java.net.Socket&#39;); SocketClass.$init.overload(&#39;java.lang.String&#39;, &#39;int&#39;).implementation &#x3D; function (arg0, arg1) &#123; console.log(&quot;[&quot; + Process.getCurrentThreadId() + &quot;]new Socket connection:&quot; + arg0 + &quot;,port:&quot; + arg1); printJavaStack(&#39;tcp connect...&#39;) return this.$init(arg0, arg1); &#125; var SocketInputStreamClass &#x3D; Java.use(&#39;java.net.SocketInputStream&#39;); &#x2F;&#x2F;socketRead0 SocketInputStreamClass.socketRead0.implementation &#x3D; function (arg0, arg1, arg2, arg3, arg4) &#123; var size &#x3D; this.socketRead0(arg0, arg1, arg2, arg3, arg4); &#x2F;&#x2F;console.log(&quot;[&quot; + Process.getCurrentThreadId() + &quot;]socketRead0:size:&quot; + size + &quot;,content:&quot; + JSON.stringify(arg1)); var bytearray &#x3D; Java.array(&#39;byte&#39;, arg1); var content &#x3D; &#39;&#39;; for (var i &#x3D; 0; i &lt; size; i++) &#123; if (isprintable(bytearray[i])) &#123; content &#x3D; content + String.fromCharCode(bytearray[i]); &#125; &#125; var socketimpl &#x3D; this.impl.value; var address &#x3D; socketimpl.address.value; var port &#x3D; socketimpl.port.value; console.log(&quot;\\naddress:&quot; + address + &quot;,port&quot; + port + &quot;\\n&quot; + JSON.stringify(this.socket.value) + &quot;\\n[&quot; + Process.getCurrentThreadId() + &quot;]receive:&quot; + content); printJavaStack(&#39;socketRead0&#39;) return size; &#125; var SocketOutPutStreamClass &#x3D; Java.use(&#39;java.net.SocketOutputStream&#39;); SocketOutPutStreamClass.socketWrite0.implementation &#x3D; function (arg0, arg1, arg2, arg3) &#123; var result &#x3D; this.socketWrite0(arg0, arg1, arg2, arg3); &#x2F;&#x2F;console.log(&quot;[&quot; + Process.getCurrentThreadId() + &quot;]socketWrite0:len:&quot; + arg3 + &quot;--content:&quot; + JSON.stringify(arg1)); var bytearray &#x3D; Java.array(&#39;byte&#39;, arg1); var content &#x3D; &#39;&#39;; for (var i &#x3D; 0; i &lt; arg3; i++) &#123; if (isprintable(bytearray[i])) &#123; content &#x3D; content + String.fromCharCode(bytearray[i]); &#125; &#125; var socketimpl &#x3D; this.impl.value; var address &#x3D; socketimpl.address.value; var port &#x3D; socketimpl.port.value; console.log(&quot;send address:&quot; + address + &quot;,port&quot; + port + &quot;[&quot; + Process.getCurrentThreadId() + &quot;]send:&quot; + content); console.log(&quot;\\n&quot; + JSON.stringify(this.socket.value) + &quot;\\n[&quot; + Process.getCurrentThreadId() + &quot;]send:&quot; + content); printJavaStack(&#39;socketWrite0&#39;) return result; &#125; &#125;)&#125;function main() &#123; hooktcp();&#125;setImmediate(main) okhttp2.6项目启动udp服务器 java.net.DatagramSocket-&gt;receive ​ -&gt; PlainDatagramSocketImpl 发送数据：PlainDatagramSocketImpl-&gt;send IoBridge.sendto(fd, p.getData(), p.getOffset(), p.getLength(), 0, address, port libcore/io/BlockGuardOs.sendto 123456789101112294 @Override public int sendto(FileDescriptor fd, ByteBuffer buffer, int flags, InetAddress inetAddress, int port) throws ErrnoException, SocketException &#123;295 BlockGuard.getThreadPolicy().onNetwork();296 return os.sendto(fd, buffer, flags, inetAddress, port);297 &#125;298299 @Override public int sendto(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount, int flags, InetAddress inetAddress, int port) throws ErrnoException, SocketException &#123;300 &#x2F;&#x2F; We permit datagrams without hostname lookups.301 if (inetAddress !&#x3D; null) &#123;302 BlockGuard.getThreadPolicy().onNetwork();303 &#125;304 return os.sendto(fd, bytes, byteOffset, byteCount, flags, inetAddress, port);305 &#125; libcore/io/Linux.java.sendto 12345678910111213212 public int sendto(FileDescriptor fd, ByteBuffer buffer, int flags, InetAddress inetAddress, int port) throws ErrnoException, SocketException &#123;213 final int bytesSent;214 final int position &#x3D; buffer.position();215216 if (buffer.isDirect()) &#123;217 bytesSent &#x3D; sendtoBytes(fd, buffer, position, buffer.remaining(), flags, inetAddress, port);218 &#125; else &#123;219 bytesSent &#x3D; sendtoBytes(fd, NioUtils.unsafeArray(buffer), NioUtils.unsafeArrayOffset(buffer) + position, buffer.remaining(), flags, inetAddress, port);220 &#125;221222 maybeUpdateBufferPosition(buffer, position, bytesSent);223 return bytesSent;224 &#125; 12232 private native int sendtoBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetAddress inetAddress, int port) throws ErrnoException, SocketException;233 private native int sendtoBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, SocketAddress address) throws ErrnoException, SocketException; 接受udp数据 libcore/io/Linux.java.read 123456789101112131415169 public int read(FileDescriptor fd, ByteBuffer buffer) throws ErrnoException, InterruptedIOException &#123;170 final int bytesRead;171 final int position &#x3D; buffer.position();172173 if (buffer.isDirect()) &#123;174 bytesRead &#x3D; readBytes(fd, buffer, position, buffer.remaining());175 &#125; else &#123;176 bytesRead &#x3D; readBytes(fd, NioUtils.unsafeArray(buffer), NioUtils.unsafeArrayOffset(buffer) + position, buffer.remaining());177 &#125;178179 maybeUpdateBufferPosition(buffer, position, bytesRead);180 return bytesRead;181 &#125;186 private native int readBytes(FileDescriptor fd, Object buffer, int offset, int byteCount) throws ErrnoException, InterruptedIOException;207 private native int recvfromBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetSocketAddress srcAddress) throws ErrnoException, SocketException; frida -U -f com.example.okhttp -l hookudp.js –no-pause -o udp.log 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788function LogPrint(log) &#123; var theDate &#x3D; new Date(); var hour &#x3D; theDate.getHours(); var minute &#x3D; theDate.getMinutes(); var second &#x3D; theDate.getSeconds(); var mSecond &#x3D; theDate.getMilliseconds(); hour &lt; 10 ? hour &#x3D; &quot;0&quot; + hour : hour; minute &lt; 10 ? minute &#x3D; &quot;0&quot; + minute : minute; second &lt; 10 ? second &#x3D; &quot;0&quot; + second : second; mSecond &lt; 10 ? mSecond &#x3D; &quot;00&quot; + mSecond : mSecond &lt; 100 ? mSecond &#x3D; &quot;0&quot; + mSecond : mSecond; var time &#x3D; hour + &quot;:&quot; + minute + &quot;:&quot; + second + &quot;:&quot; + mSecond; var threadid &#x3D; Process.getCurrentThreadId(); console.log(&quot;[&quot; + time + &quot;]&quot; + &quot;-&gt;threadid:&quot; + threadid + &quot;--&quot; + log);&#125;function printJavaStack(name) &#123; Java.perform(function () &#123; var Exception &#x3D; Java.use(&quot;java.lang.Exception&quot;); var ins &#x3D; Exception.$new(&quot;Exception&quot;); var straces &#x3D; ins.getStackTrace(); if (straces !&#x3D; undefined &amp;&amp; straces !&#x3D; null) &#123; var strace &#x3D; straces.toString(); var replaceStr &#x3D; strace.replace(&#x2F;,&#x2F;g, &quot; \\n &quot;); LogPrint(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + name + &quot; Stack strat&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); LogPrint(replaceStr); LogPrint(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + name + &quot; Stack end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; \\n &quot;); Exception.$dispose(); &#125; &#125;);&#125;function isprintable(value) &#123; if (value &gt;&#x3D; 32 &amp;&amp; value &lt;&#x3D; 126) &#123; return true; &#125; return false;&#125;function hookudp() &#123; Java.perform(function () &#123; var LinuxClass &#x3D; Java.use(&#39;libcore.io.Linux&#39;); &#x2F;&#x2F; private native int recvfromBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetSocketAddress srcAddress) throws ErrnoException, SocketException; LinuxClass.recvfromBytes.implementation &#x3D; function (arg0, arg1, arg2, arg3, arg4, arg5) &#123; var size &#x3D; this.recvfromBytes(arg0, arg1, arg2, arg3, arg4, arg5); var bytearray &#x3D; Java.array(&#39;byte&#39;,arg1); var content &#x3D; &quot;&quot;; for(var i&#x3D;0;i&lt;size;i++) &#123; content&#x3D;content+String.fromCharCode(bytearray[i]) &#125; console.log(&quot;address:&quot;+arg5+[&quot; + Process.getCurrentThreadId() + &quot;]recvfromBytes:size:&quot; + size + &quot;,content:&quot; + JSON.stringify(arg1)+&quot;--content:&quot;+content); printJavaStack(&#39;recvfromBytes&#39;) return size; &#125; LinuxClass.sendtoBytes.overload(&#39;java.io.FileDescriptor&#39;,&#39;java.lang.Object&#39;,&#39;int&#39;,&#39;int&#39;,&#39;int&#39;,&#39;java.net.SocketAddress&#39;,&#39;int&#39;).implementation &#x3D; function (arg0, arg1, arg2, arg3, arg4, arg5, arg6) &#123; var size &#x3D; this.sendtoBytes(arg0, arg1, arg2, arg3, arg4, arg5, arg6); var bytearray &#x3D; Java.array(&#39;byte&#39;,arg1); var content &#x3D; &quot;&quot;; for(var i&#x3D;0;i&lt;size;i++) &#123; content&#x3D;content+String.fromCharCode(bytearray[i]) &#125; console.log(&quot;address:&quot;+arg5+&quot;port:&quot;+arg6+[&quot; + Process.getCurrentThreadId() + &quot;]sendtoBytes1:len:&quot; + size + &quot;--content:&quot; + JSON.stringify(arg1)+&quot;--content:&quot;+content); printJavaStack(&#39;sendtoBytes1&#39;) return size; &#125; LinuxClass.sendtoBytes.overload(&#39;java.io.FileDescriptor&#39;,&#39;java.lang.Object&#39;,&#39;int&#39;,&#39;int&#39;,&#39;int&#39;,&#39;java.net.SocketAddress&#39;).implementation &#x3D; function (arg0, arg1, arg2, arg3, arg4, arg5) &#123; var size &#x3D; this.sendtoBytes(arg0, arg1, arg2, arg3, arg4, arg5, arg6); var bytearray &#x3D; Java.array(&#39;byte&#39;,arg1); var content &#x3D; &quot;&quot;; for(var i&#x3D;0;i&lt;size;i++) &#123; content&#x3D;content+String.fromCharCode(bytearray[i]) &#125; console.log(&quot;address:&quot;+arg5+&quot;[&quot; + Process.getCurrentThreadId() + &quot;]sendtoBytes2:len:&quot; + size + &quot;--content:&quot; + JSON.stringify(arg1)+&quot;--content:&quot;+content); printJavaStack(&#39;sendtoBytes2&#39;) return size; &#125; &#125;)&#125;function main() &#123; hookudp();&#125;setImmediate(main) ssl抓包sslSocket-&gt;com.android.org.conscrypt.OpenSSLSocketImplWrapper 发送数据:com.android.org.conscrypt.OpenSSLSocketImpl$SSLOutputStream ​ public void write(int oneByte) ​ public void write(byte[] buf, int offset, int byteCount) 12807 NativeCrypto.SSL_write(sslNativePointer, Platform.getFileDescriptor(socket),808 OpenSSLSocketImpl.this, buf, offset, byteCount, writeTimeoutMilliseconds); 12341039 public static native void SSL_write(long sslNativePointer,1040 FileDescriptor fd,1041 SSLHandshakeCallbacks shc,1042 byte[] b, int off, int len, int writeTimeoutMillis) 接收数据:com.android.org.conscrypt.OpenSSLSocketImpl$SSLInputStream ​ public int read() ​ public int read(byte[] buf, int offset, int byteCount) 12341030 public static native int SSL_read(long sslNativePointer,1031 FileDescriptor fd,1032 SSLHandshakeCallbacks shc,1033 byte[] b, int off, int len, int readTimeoutMillis) frida -UF -l hook.js –no-pause 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function hookssl() &#123; Java.perform(function () &#123; var NativeCrypto &#x3D; Java.use(&#39;com.android.org.conscrypt.NativeCrypto&#39;); NativeCrypto.SSL_read.implementation &#x3D; function (arg0, arg1, arg2, arg3, arg4, arg5, arg6) &#123; var size &#x3D; this.SSL_read(arg0, arg1, arg2, arg3, arg4, arg5, arg6); var bytearray &#x3D; Java.array(&#39;byte&#39;,arg3); var content &#x3D; &quot;&quot;; for(var i&#x3D;0;i&lt;size;i++) &#123; content&#x3D;content+String.fromCharCode(bytearray[i]) &#125; console.log(&quot;\\n[&quot; + Process.getCurrentThreadId() +&quot;]ssl receive content:&quot;+content); printJavaStack(&#39;NativeCrypto.read&#39;) return size; &#125; NativeCrypto.SSL_write.implementation &#x3D; function (arg0, arg1, arg2, arg3, arg4, arg5, arg6) &#123; var result &#x3D; this.SSL_write(arg0, arg1, arg2, arg3, arg4, arg5, arg6); var bytearray &#x3D; Java.array(&#39;byte&#39;, arg3); var content &#x3D; &#39;&#39;; for (var i &#x3D; 0; i &lt; arg5; i++) &#123; if (isprintable(bytearray[i])) &#123; content &#x3D; content + String.fromCharCode(bytearray[i]); &#125; &#125; console.log( &quot;\\n[&quot; + Process.getCurrentThreadId() + &quot;]send:&quot; + content); printJavaStack(&#39;SSL_write&#39;) return result; &#125; &#125;)&#125;function enumerate() &#123; Java.perform(function()&#123; Java.enumerateLoadedClassesSync().forEach(function(classname)&#123; if(classname.indexof(&quot;NativeCrypto&quot;) &gt;&#x3D;0) &#123; console.log(classname) &#125; &#125; &#125;)&#125;function main() &#123; enumerate(); hookssl();&#125;setImmediate(main) 不过确实对端的ip和端口，根据调用栈向上追溯一层到SSLOutputStream frida -U -p 12345 -l hookssl2.js –no-pause -o log.txt 多进程hook 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function hookssl2() &#123; Java.perform(function () &#123; var SSLInputStreamClass &#x3D; Java.use(&#39;com.android.org.conscrypt.OpenSSLSocketImpl$SSLInputStream&#39;); SSLInputStreamClass.read.overload(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;).implementation &#x3D; function (arg0, arg1, arg2) &#123; &#x2F;&#x2F; 获取内部类 var SSLInputStreamObj&#x3D;this; var OpenSSLSocketImplobj &#x3D; this.this.$0.value; var socketobj &#x3D; OpenSSLSocketImplobj.socket.value; var size &#x3D; this.SSL_read(arg0, arg1, arg2); var bytearray &#x3D; Java.array(&#39;byte&#39;,arg0); var content &#x3D; &quot;&quot;; for(var i&#x3D;0;i&lt;size;i++) &#123; content&#x3D;content+String.fromCharCode(bytearray[i]) &#125; console.log(&quot;\\naddress:&quot;+&quot;socketobj&quot;+&quot;-----[&quot; + Process.getCurrentThreadId() +&quot;]SSLInputStreamClass receive content:&quot;+content); printJavaStack(&#39;SSLInputStreamClass.read&#39;) return size; &#125; var SSLOutputStreamClass &#x3D; Java.use(&#39;com.android.org.conscrypt.OpenSSLSocketImpl$SSLOutputStream&#39;); SSLOutputStreamClass.write.overload(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;).implementation &#x3D; function (arg0, arg1, arg2) &#123; var SSLOutputStreamObj&#x3D;this; var OpenSSLSocketImplobj &#x3D; this.this.$0.value; var socketobj &#x3D; OpenSSLSocketImplobj.socket.value; var result &#x3D; this.write(arg0, arg1, arg2); var bytearray &#x3D; Java.array(&#39;byte&#39;, arg0); var content &#x3D; &#39;&#39;; for (var i &#x3D; 0; i &lt; arg2; i++) &#123; if (isprintable(bytearray[i])) &#123; content &#x3D; content + String.fromCharCode(bytearray[i]); &#125; &#125; console.log(&quot;\\naddress:&quot;+&quot;socketobj&quot;+&quot;-----[&quot; + Process.getCurrentThreadId() + &quot;]SSLOutputStreamClass send:&quot; + content); printJavaStack(&#39;SSLOutputStreamClass.write&#39;) return result; &#125; &#125;)&#125;function enumerate() &#123; Java.perform(function()&#123; Java.enumerateLoadedClassesSync().forEach(function(classname)&#123; if(classname.indexof(&quot;OpenSSLSocketImpl&quot;) &gt;&#x3D;0) &#123; console.log(classname) &#125; &#125; &#125;)&#125;function main() &#123; enumerate(); hookssl();&#125;setImmediate(main) jni层如果没有使用java层的安卓系统函数将无法抓到，但是wireshark却可以抓到，可以深入jni层抓包 socket抓包tcp native层 SocketOutputStream_socketWrite0动态注册jni函数 12345678910111213141516171819202122adb pull &#x2F;system&#x2F;lib&#x2F;libopenjdk.soadb pull &#x2F;system&#x2F;lib64&#x2F;libopenjdk.so libopenjdk64.so libopenjdk.so - socketRead0 | NET_Read | libc.so - recvfrom | 系统调用(可以在自己的so中实现recvfrom，然后调用系统调用号) | 内核libopenjdk.so - socketWrite0 | NET_Send | libc.so - sendto | 系统调用 | 内核 将这两个so用ida打开搜索JNI_OnLoad，搜索导出函数中SocketInputStream 12socketRead0-&gt;NET_Read-&gt;libc.so系统调用ssize_t recvfrom(int fd, void *buf, size_ n, int flags, struct sockaddr *addr, socklen_t *addr_len);socketWrite0-&gt;NET_Send-&gt;libc.so系统调用ssize_t sendto(int fd, void *buf, size_ n, int flags,const struct sockaddr *addr, socklen_t *addr_len); frida -U -f com.example.okhttp -l hooklibc.js –no-pause 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123function LogPrint(log) &#123; var theDate &#x3D; new Date(); var hour &#x3D; theDate.getHours(); var minute &#x3D; theDate.getMinutes(); var second &#x3D; theDate.getSeconds(); var mSecond &#x3D; theDate.getMilliseconds(); hour &lt; 10 ? hour &#x3D; &quot;0&quot; + hour : hour; minute &lt; 10 ? minute &#x3D; &quot;0&quot; + minute : minute; second &lt; 10 ? second &#x3D; &quot;0&quot; + second : second; mSecond &lt; 10 ? mSecond &#x3D; &quot;00&quot; + mSecond : mSecond &lt; 100 ? mSecond &#x3D; &quot;0&quot; + mSecond : mSecond; var time &#x3D; hour + &quot;:&quot; + minute + &quot;:&quot; + second + &quot;:&quot; + mSecond; var threadid &#x3D; Process.getCurrentThreadId(); console.log(&quot;[&quot; + time + &quot;]&quot; + &quot;-&gt;threadid:&quot; + threadid + &quot;--&quot; + log);&#125;function printNativeStack(context, name) &#123; &#x2F;&#x2F;Debug. var array &#x3D; Thread.backtrace(context, Backtracer.ACCURATE); var first &#x3D; DebugSymbol.fromAddress(array[0]); if (first.toString().indexOf(&#39;libopenjdk.so!NET_Send&#39;) &lt; 0) &#123; var trace &#x3D; Thread.backtrace(context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&quot;\\n&quot;); LogPrint(&quot;-----------start:&quot; + name + &quot;--------------&quot;); LogPrint(trace); LogPrint(&quot;-----------end:&quot; + name + &quot;--------------&quot;); &#125;&#125;function printJavaStack(name) &#123; Java.perform(function () &#123; var Exception &#x3D; Java.use(&quot;java.lang.Exception&quot;); var ins &#x3D; Exception.$new(&quot;Exception&quot;); var straces &#x3D; ins.getStackTrace(); if (straces !&#x3D; undefined &amp;&amp; straces !&#x3D; null) &#123; var strace &#x3D; straces.toString(); var replaceStr &#x3D; strace.replace(&#x2F;,&#x2F;g, &quot; \\n &quot;); LogPrint(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + name + &quot; Stack strat&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); LogPrint(replaceStr); LogPrint(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + name + &quot; Stack end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; \\n &quot;); Exception.$dispose(); &#125; &#125;);&#125;function isprintable(value) &#123; if (value &gt;&#x3D; 32 &amp;&amp; value &lt;&#x3D; 126) &#123; return true; &#125; return false;&#125;function getsocketdetail(fd) &#123; var result &#x3D; &quot;&quot;; var type &#x3D; Socket.type(fd); if (type !&#x3D; null) &#123; result &#x3D; result + &quot;type:&quot; + type; var peer &#x3D; Socket.peerAddress(fd); var local &#x3D; Socket.localAddress(fd); result &#x3D; result + &quot;,address:&quot; + JSON.stringify(peer) + &quot;,local:&quot; + JSON.stringify(local); &#125; else &#123; result &#x3D; &quot;unknown&quot;; &#125; return result;&#125;function hooklibc() &#123; var libcmodule &#x3D; Process.getModuleByName(&quot;libc.so&quot;); var recvfrom_addr &#x3D; libcmodule.getExportByName(&quot;recvfrom&quot;); var sendto_addr &#x3D; libcmodule.getExportByName(&quot;sendto&quot;); console.log(recvfrom_addr + &quot;---&quot; + sendto_addr); &#x2F;&#x2F;ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len) Interceptor.attach(recvfrom_addr, &#123; onEnter: function (args) &#123; this.arg0 &#x3D; args[0]; this.arg1 &#x3D; args[1]; this.arg2 &#x3D; args[2]; LogPrint(&quot;go into libc.so-&gt;recvfom&quot;); printNativeStack(this.context, &quot;recvfom&quot;); &#125;, onLeave(retval) &#123; var size &#x3D; retval.toInt32(); if (size &gt; 0) &#123; var result &#x3D; getsocketdetail(this.arg0.toInt32()); console.log(result + &quot;---libc.so-&gt;recvfrom:&quot; + hexdump(this.arg1, &#123; length: size &#125;)); &#125; LogPrint(&quot;leave libc.so-&gt;recvfom&quot;); &#125; &#125;); &#x2F;&#x2F;ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len) Interceptor.attach(sendto_addr, &#123; onEnter: function (args) &#123; this.arg0 &#x3D; args[0]; this.arg1 &#x3D; args[1]; this.arg2 &#x3D; args[2]; LogPrint(&quot;go into libc.so-&gt;sendto&quot;); printNativeStack(this.context, &quot;sendto&quot;); &#125;, onLeave(retval) &#123; var size &#x3D; ptr(this.arg2).toInt32(); if (size &gt; 0) &#123; var result &#x3D; getsocketdetail(this.arg0.toInt32()); console.log(result + &quot;---libc.so-&gt;sendto:&quot; + hexdump(this.arg1, &#123; length: size &#125;)); &#125; LogPrint(&quot;leave libc.so-&gt;sendto&quot;); &#125; &#125;);&#125;function main() &#123; hooklibc(); hooktcp();&#125;setImmediate(main); udp native层 1234567libcore.io.Linux.sendtoBytes (jni) | libc.so - sendtolibcore.io.Linux.recvfromBytes (jni) | libc.so - recvfrom frida -U -f com.example.okhttp -l hooklibc.js –no-pause 解析数据结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167function LogPrint(log) &#123; var theDate &#x3D; new Date(); var hour &#x3D; theDate.getHours(); var minute &#x3D; theDate.getMinutes(); var second &#x3D; theDate.getSeconds(); var mSecond &#x3D; theDate.getMilliseconds(); hour &lt; 10 ? hour &#x3D; &quot;0&quot; + hour : hour; minute &lt; 10 ? minute &#x3D; &quot;0&quot; + minute : minute; second &lt; 10 ? second &#x3D; &quot;0&quot; + second : second; mSecond &lt; 10 ? mSecond &#x3D; &quot;00&quot; + mSecond : mSecond &lt; 100 ? mSecond &#x3D; &quot;0&quot; + mSecond : mSecond; var time &#x3D; hour + &quot;:&quot; + minute + &quot;:&quot; + second + &quot;:&quot; + mSecond; var threadid &#x3D; Process.getCurrentThreadId(); console.log(&quot;[&quot; + time + &quot;]&quot; + &quot;-&gt;threadid:&quot; + threadid + &quot;--&quot; + log);&#125;function printNativeStack(context, name) &#123; &#x2F;&#x2F;Debug. var array &#x3D; Thread.backtrace(context, Backtracer.ACCURATE); var first &#x3D; DebugSymbol.fromAddress(array[0]); if (first.toString().indexOf(&#39;libopenjdk.so!NET_Send&#39;) &lt; 0) &#123; var trace &#x3D; Thread.backtrace(context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&quot;\\n&quot;);&#x2F;&#x2F; Backtracer.FUZZY LogPrint(&quot;-----------start:&quot; + name + &quot;--------------&quot;); LogPrint(trace); LogPrint(&quot;-----------end:&quot; + name + &quot;--------------&quot;); &#125;&#125;function printJavaStack(name) &#123; Java.perform(function () &#123; var Exception &#x3D; Java.use(&quot;java.lang.Exception&quot;); var ins &#x3D; Exception.$new(&quot;Exception&quot;); var straces &#x3D; ins.getStackTrace(); if (straces !&#x3D; undefined &amp;&amp; straces !&#x3D; null) &#123; var strace &#x3D; straces.toString(); var replaceStr &#x3D; strace.replace(&#x2F;,&#x2F;g, &quot; \\n &quot;); LogPrint(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + name + &quot; Stack strat&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); LogPrint(replaceStr); LogPrint(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + name + &quot; Stack end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; \\n &quot;); Exception.$dispose(); &#125; &#125;);&#125;function isprintable(value) &#123; if (value &gt;&#x3D; 32 &amp;&amp; value &lt;&#x3D; 126) &#123; return true; &#125; return false;&#125;function getsocketdetail(fd) &#123; var result &#x3D; &quot;&quot;; var type &#x3D; Socket.type(fd); if (type !&#x3D; null) &#123; result &#x3D; result + &quot;type:&quot; + type; var peer &#x3D; Socket.peerAddress(fd); var local &#x3D; Socket.localAddress(fd); result &#x3D; result + &quot;,address:&quot; + JSON.stringify(peer) + &quot;,local:&quot; + JSON.stringify(local); &#125; else &#123; result &#x3D; &quot;unknown&quot;; &#125; return result;&#125;function getip(ip_ptr) &#123; var result &#x3D; ptr(ip_ptr).readU8() + &quot;.&quot; + ptr(ip_ptr.add(1)).readU8() + &quot;.&quot; + ptr(ip_ptr.add(2)).readU8() + &quot;.&quot; + ptr(ip_ptr.add(3)).readU8() return result;&#125;function getudpaddr(addrptr) &#123; var port_ptr &#x3D; addrptr.add(2); var port &#x3D; ptr(port_ptr).readU8() * 256 + ptr(port_ptr.add(1)).readU8(); var ip_ptr &#x3D; addrptr.add(4); var ip_addr &#x3D; getip(ip_ptr); return &quot;peer:&quot;+ip_addr+&quot;--port:&quot;+port;&#125;function hooklibc() &#123; var libcmodule &#x3D; Process.getModuleByName(&quot;libc.so&quot;); var recvfrom_addr &#x3D; libcmodule.getExportByName(&quot;recvfrom&quot;); var sendto_addr &#x3D; libcmodule.getExportByName(&quot;sendto&quot;); console.log(recvfrom_addr + &quot;---&quot; + sendto_addr); &#x2F;&#x2F;ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len) Interceptor.attach(recvfrom_addr, &#123; onEnter: function (args) &#123; this.arg0 &#x3D; args[0]; this.arg1 &#x3D; args[1]; this.arg2 &#x3D; args[2]; this.arg3 &#x3D; args[3]; this.arg4 &#x3D; args[4]; this.arg5 &#x3D; args[5]; LogPrint(&quot;go into libc.so-&gt;recvfom&quot;); printNativeStack(this.context, &quot;recvfom&quot;); &#125;, onLeave(retval) &#123; var size &#x3D; retval.toInt32(); if (size &gt; 0) &#123; var result &#x3D; getsocketdetail(this.arg0.toInt32()); if (result.indexOf(&#39;udp&#39;) &gt;&#x3D; 0) &#123; &#x2F;*75struct sockaddr_in &#123; 76 short sin_family; 77 u_short sin_port; 78 struct in_addr sin_addr; 79 char sin_zero[8]; 80&#125;;*&#x2F; var sockaddr_in_ptr &#x3D; this.arg4; var sizeofsockaddr_in &#x3D; this.arg5; &#x2F;&#x2F;02 00 22 b8 c0 a8 05 96 00 00 00 00 00 00 00 00 console.log(&quot;this is a recvfrom udp!-&gt;&quot; + getudpaddr(sockaddr_in_ptr) + &quot;---&quot; + sizeofsockaddr_in); &#125; console.log(Process.getCurrentThreadId()+result + &quot;---libc.so-&gt;recvfrom:&quot; + hexdump(this.arg1, &#123; length: size &#125;)); &#125; LogPrint(&quot;leave libc.so-&gt;recvfom&quot;); &#125; &#125;); &#x2F;&#x2F;ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len) Interceptor.attach(sendto_addr, &#123; onEnter: function (args) &#123; this.arg0 &#x3D; args[0]; this.arg1 &#x3D; args[1]; this.arg2 &#x3D; args[2]; this.arg3 &#x3D; args[3]; this.arg4 &#x3D; args[4]; this.arg5 &#x3D; args[5]; LogPrint(&quot;go into libc.so-&gt;sendto&quot;); printNativeStack(this.context, &quot;sendto&quot;); &#125;, onLeave(retval) &#123; var size &#x3D; ptr(this.arg2).toInt32(); if (size &gt; 0) &#123; var result &#x3D; getsocketdetail(this.arg0.toInt32()); if (result.indexOf(&#39;udp&#39;) &gt;&#x3D; 0) &#123; &#x2F;*75struct sockaddr_in &#123; 76 short sin_family; 77 u_short sin_port; 78 struct in_addr sin_addr; 79 char sin_zero[8]; 80&#125;;*&#x2F; var sockaddr_in_ptr &#x3D; this.arg4; var sizeofsockaddr_in &#x3D; this.arg5; &#x2F;&#x2F;02 00 22 b8 c0 a8 05 96 00 00 00 00 00 00 00 00 console.log(&quot;this is a sendto udp!-&gt;&quot; + getudpaddr(sockaddr_in_ptr) + &quot;---&quot; + sizeofsockaddr_in); &#125; console.log(Process.getCurrentThreadId()+&quot;---&quot;+result + &quot;---libc.so-&gt;sendto:&quot; + hexdump(this.arg1, &#123; length: size &#125;)); &#125; LogPrint(&quot;leave libc.so-&gt;sendto&quot;); &#125; &#125;);&#125;function main() &#123; hooklibc(); hookudp();&#125;setImmediate(main); frida -U -f com.tencent.news -l hooklibc.js –no-pause -o log.txt ssl抓包发送：com.android.org.conscrypt.OpenSSLSocketImpl$SSLOutputStream.write-&gt;jni函数 123456789101112131415161718192021222324252627287543 static void NativeCrypto_SSL_write(JNIEnv* env, jclass, jlong ssl_address, jobject fdObject,7544 jobject shc, jbyteArray b, jint offset, jint len,7545 jint write_timeout_millis) &#123;com.android.org.conscrypt.NativeCrypto.SSL_write （jni) | sslWrite | boringssl -&gt; ssl_lib.c -&gt; SSL_write | ssl3_write_app_data | do_ssl3_write （此时还是明文，之后被加密了） | ssl_write_pending | ssl_write_buffer_flush | dtls_write_buffer_flush&#x2F;tls_write_buffer_flush | BIO_write openssl并没有使用sendto及send发送加密数据，而是使用write,接受没用recvfrom而是read | bio_io | libc.so - writecom.android.org.conscrypt.NativeCrypto.SSL_read (jni) | libc.so - read frida -U -f com.tencent.news -l hookopenssl.js –no-pause -o log.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171function hooklibc() &#123; var libcmodule &#x3D; Process.getModuleByName(&quot;libc.so&quot;); var read_addr &#x3D; libcmodule.getExportByName(&quot;read&quot;); var write_addr &#x3D; libcmodule.getExportByName(&quot;write&quot;); console.log(read_addr + &quot;---&quot; + write_addr); Interceptor.attach(read_addr, &#123; onEnter: function (args) &#123; this.arg0 &#x3D; args[0]; this.arg1 &#x3D; args[1]; this.arg2 &#x3D; args[2]; this.socketinfo &#x3D; getsocketdetail(this.arg0.toInt32()); LogPrint(&quot;go into libc.so-&gt;read_addr&quot; + &quot;---&quot; + this.socketinfo); this.flag &#x3D; false; if (this.socketinfo.indexOf(&quot;tcp&quot;) &gt;&#x3D; 0) &#123; this.flag &#x3D; true; &#125; if (this.flag) &#123; printNativeStack(this.context, Process.getCurrentThreadId() + &quot;read&quot;); &#125; &#125;, onLeave(retval) &#123; if (this.flag) &#123; var size &#x3D; retval.toInt32(); if (size &gt; 0) &#123; console.log(Process.getCurrentThreadId() + &quot;---libc.so-&gt;read:&quot; + hexdump(this.arg1, &#123; length: size &#125;)); &#125; &#125; LogPrint(&quot;leave libc.so-&gt;read&quot;); &#125; &#125;); Interceptor.attach(write_addr, &#123; onEnter: function (args) &#123; this.arg0 &#x3D; args[0]; this.arg1 &#x3D; args[1]; this.arg2 &#x3D; args[2]; this.socketinfo &#x3D; getsocketdetail(this.arg0.toInt32()); LogPrint(&quot;go into libc.so-&gt;write&quot; + &quot;---&quot; + this.socketinfo); this.flag &#x3D; false; if (this.socketinfo.indexOf(&quot;tcp&quot;) &gt;&#x3D; 0) &#123; this.flag &#x3D; true; &#125; if (this.flag) &#123; printNativeStack(this.context, Process.getCurrentThreadId() + &quot;write&quot;); var size &#x3D; ptr(this.arg2).toInt32(); if (size &gt; 0) &#123; console.log(Process.getCurrentThreadId() + &quot;---libc.so-&gt;write:&quot; + hexdump(this.arg1, &#123; length: size &#125;)); &#125; &#125; &#125;, onLeave(retval) &#123; LogPrint(&quot;leave libc.so-&gt;write&quot;); &#125; &#125;);&#125;&#x2F;&#x2F; 明文 打印ip portfunction hookssl() &#123; var libcmodule &#x3D; Process.getModuleByName(&quot;libssl.so&quot;); var read_addr &#x3D; libcmodule.getExportByName(&quot;SSL_read&quot;); var write_addr &#x3D; libcmodule.getExportByName(&quot;SSL_write&quot;); var bio_read_addr &#x3D; libcmodule.getExportByName(&quot;BIO_read&quot;); var bio_write_addr &#x3D; libcmodule.getExportByName(&quot;BIO_write&quot;); var SSL_get_rfd_ptr &#x3D; libsslmodule.getExportByName(&#39;SSL_get_rfd&#39;); var SSL_get_rfd &#x3D; new NativeFunction(SSL_get_rfd_ptr, &#39;int&#39;, [&#39;pointer&#39;]); console.log(read_addr + &quot;---&quot; + write_addr); Interceptor.attach(read_addr, &#123; onEnter: function (args) &#123; this.arg0 &#x3D; args[0]; this.arg1 &#x3D; args[1]; this.arg2 &#x3D; args[2]; LogPrint(&quot;go into libssl.so-&gt;SSL_read&quot;); printNativeStack(this.context, Process.getCurrentThreadId() + &quot;SSL_read&quot;); &#125;, onLeave(retval) &#123; var size &#x3D; retval.toInt32(); if (size &gt; 0) &#123; var sockfd &#x3D; SSL_get_rfd(this.arg0); var socketdetail &#x3D; getsocketdetail(sockfd); console.log(socketdetail+&quot;----&quot;+Process.getCurrentThreadId() + &quot;---libssl.so-&gt;SSL_read:&quot; + hexdump(this.arg1, &#123; length: size &#125;)); &#125; LogPrint(&quot;leave libc.so-&gt;SSL_read&quot;); &#125; &#125;); Interceptor.attach(write_addr, &#123; onEnter: function (args) &#123; this.arg0 &#x3D; args[0]; this.arg1 &#x3D; args[1]; this.arg2 &#x3D; args[2]; LogPrint(&quot;go into libc.so-&gt;SSL_write&quot;); printNativeStack(this.context, Process.getCurrentThreadId() + &quot;SSL_write&quot;); var size &#x3D; ptr(this.arg2).toInt32(); if (size &gt; 0) &#123; var sockfd &#x3D; SSL_get_rfd(this.arg0); var socketdetail &#x3D; getsocketdetail(sockfd); console.log(socketdetail+&quot;----&quot;+Process.getCurrentThreadId() + &quot;---libssl.so-&gt;SSL_write:&quot; + hexdump(this.arg1, &#123; length: size &#125;)); &#125; &#125;, onLeave(retval) &#123; LogPrint(&quot;libssl.so-&gt;SSL_write&quot;); &#125; &#125;); Interceptor.attach(bio_read_addr, &#123; onEnter: function (args) &#123; this.arg0 &#x3D; args[0]; this.arg1 &#x3D; args[1]; this.arg2 &#x3D; args[2]; LogPrint(&quot;go into libssl.so-&gt;bio_read&quot;); printNativeStack(this.context, Process.getCurrentThreadId() + &quot;bio_read&quot;); &#125;, onLeave(retval) &#123; var size &#x3D; retval.toInt32(); if (size &gt; 0) &#123; var sockfd &#x3D; SSL_get_rfd(this.arg0); var socketdetail &#x3D; getsocketdetail(sockfd); console.log(socketdetail+&quot;----&quot;+Process.getCurrentThreadId() + &quot;---libssl.so-&gt;bio_read:&quot; + hexdump(this.arg1, &#123; length: size &#125;)); &#125; LogPrint(&quot;leave libc.so-&gt;bio_read&quot;); &#125; &#125;); Interceptor.attach(bio_write_addr, &#123; onEnter: function (args) &#123; this.arg0 &#x3D; args[0]; this.arg1 &#x3D; args[1]; this.arg2 &#x3D; args[2]; LogPrint(&quot;go into libc.so-&gt;bio_write&quot;); printNativeStack(this.context, Process.getCurrentThreadId() + &quot;bio_write&quot;); var size &#x3D; ptr(this.arg2).toInt32(); if (size &gt; 0) &#123; var sockfd &#x3D; SSL_get_rfd(this.arg0); var socketdetail &#x3D; getsocketdetail(sockfd); console.log(socketdetail+&quot;----&quot;+Process.getCurrentThreadId() + &quot;---libssl.so-&gt;bio_write:&quot; + hexdump(this.arg1, &#123; length: size &#125;)); &#125; &#125;, onLeave(retval) &#123; LogPrint(&quot;libssl.so-&gt;bio_write&quot;); &#125; &#125;);&#125;function main() &#123; hooklibc(); hookssl();&#125; 自编译openssl库抓包溯源hook 自编译 ssl so中的所有导出函数（有符号）,so中的符号被抹掉时：通过hook libc.so中的write，read进行堆栈回溯 1234567891011121314151617181920212223242526272829303132333435363738function hookallssl() &#123; var libsslmodule &#x3D; Process.getModuleByName(&quot;libssl.so&quot;); var SSL_get_rfd_ptr &#x3D; libsslmodule.getExportByName(&#39;SSL_get_rfd&#39;); &#x2F;&#x2F; 导出函数 获取socket的id var SSL_get_rfd &#x3D; new NativeFunction(SSL_get_rfd_ptr, &#39;int&#39;, [&#39;pointer&#39;]); Process.enumerateModules().forEach(function (module) &#123; module.enumerateExports().forEach(function (symbol) &#123; var name &#x3D; symbol.name; if (name &#x3D;&#x3D; &#39;SSL_read&#39;) &#123; LogPrint(JSON.stringify(module) + JSON.stringify(symbol)); &#125; if (name &#x3D;&#x3D; &#39;SSL_write&#39;) &#123; LogPrint(JSON.stringify(module) + JSON.stringify(symbol)); Interceptor.attach(symbol.address, &#123; onEnter: function (args) &#123; this.arg0 &#x3D; args[0]; this.arg1 &#x3D; args[1]; this.arg2 &#x3D; args[2]; LogPrint(&quot;go into &quot; + Process.getCurrentThreadId() + &quot;---&quot; + JSON.stringify(module) + &quot;---&quot; + JSON.stringify(symbol)); printNativeStack(this.context, Process.getCurrentThreadId() + &quot;---&quot; + JSON.stringify(module) + &quot;---&quot; + JSON.stringify(symbol)); var size &#x3D; ptr(this.arg2).toInt32(); if (size &gt; 0) &#123; var sockfd &#x3D; SSL_get_rfd(this.arg0); var socketdetail &#x3D; getsocketdetail(sockfd); console.log(socketdetail + &quot;---&quot; + Process.getCurrentThreadId() + &quot;---&quot; + JSON.stringify(module) + &quot;---&quot; + JSON.stringify(symbol) + hexdump(this.arg1, &#123; length: size &#125;)); &#125; &#125;, onLeave(retval) &#123; LogPrint(&quot;leave &quot; + Process.getCurrentThreadId() + &quot;---&quot; + JSON.stringify(module) + &quot;---&quot; + JSON.stringify(symbol)); &#125; &#125;); &#125; &#125;) &#125;)&#125; 实战脱壳 12345678910111213141516171819202122232425262728293031&#x2F;&#x2F; 只适用于存在getDex和getBytes api的android版本,手动dump脱壳指定类的dexfunction dumpdex()&#123; &#x2F;&#x2F; com.example.socket.MainActivity &#x2F;&#x2F; a.a.a.a$a Java.perform(function()&#123; var File &#x3D; Java.use(&#39;java.io.File&#39;); var FileOutputStream &#x3D; Java.use(&#39;java.io.FileOutputStream&#39;); Java.enumerateClassLoadersSync().forEach(function(loader)&#123; console.log(loader+&quot;\\n&quot;); try&#123; var aclass &#x3D; loader.loaderClass(&quot;a.a.a.a$a&quot;) console.log(aclass); var dexobj &#x3D; aclass.getDex(); console.loader(dexobj); var dexbytes &#x3D; dexobj.getBytes(); var dexsavepath &#x3D; &quot;&#x2F;data&#x2F;data&#x2F;com.example.socket&#x2F;dump.dex&quot;; var dexfile &#x3D; File.$new(dexsavepath); if(!dexfile.exists())&#123; dexfile.createNewFile(); &#125; var fileOutputStream &#x3D; FileOutputStream.$new(dexfile); fileOutputStream.write(dexbytes); fileOutputStream.fluse(); fileOutputStream.close(); console.log(&quot;save dex success&quot;); &#125; catch(e) &#123; &#125; &#125;) &#125;)&#125; hook 12345678910111213141516171819202122232425&#x2F;&#x2F; 只适用于存在getDex和getBytes api的android版本,手动dump脱壳指定类的dexfunction hook()&#123; &#x2F;&#x2F; com.example.socket.MainActivity &#x2F;&#x2F; a.a.a.a$a Java.perform(function()&#123; var File &#x3D; Java.use(&#39;java.io.File&#39;); var FileOutputStream &#x3D; Java.use(&#39;java.io.FileOutputStream&#39;); Java.enumerateClassLoadersSync().forEach(function(loader)&#123; console.log(loader+&quot;\\n&quot;); try&#123; var aclass &#x3D; loader.loaderClass(&quot;a.a.a.a$a&quot;) Java.classFactory.loader&#x3D;loader; var HelloKitty &#x3D; Java.use(&#39;com.example.socket.HelloKitty&#39;); HelloKitty.hello.implementation &#x3D; function(arg) &#123; console.log(&quot;Hellokitty.hello is called,arg:&quot;+arg); var result &#x3D; this.hello(arg); console.log(&quot;Hellokitty.hello called over!,result:&quot;+result); return result; &#125; &#125; catch(e) &#123; &#125; &#125;) &#125;)&#125; var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"postern","slug":"postern","permalink":"http://onejane.github.io/tags/postern/"},{"name":"charles","slug":"charles","permalink":"http://onejane.github.io/tags/charles/"},{"name":"burpsuite","slug":"burpsuite","permalink":"http://onejane.github.io/tags/burpsuite/"}]},{"title":"主动调用java及native层","slug":"主动调用java及native层","date":"2021-02-16T15:27:08.000Z","updated":"2022-10-16T04:52:49.812Z","comments":true,"path":"2021/02/16/主动调用java及native层/","link":"","permalink":"http://onejane.github.io/2021/02/16/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8java%E5%8F%8Anative%E5%B1%82/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 examplefrida-server-linuxfrida-python修改examples中rpc.py 12345678910111213141516171819# -*- coding: utf-8 -*-from __future__ import print_functionimport fridaimport timesession &#x3D; frida.attach(&quot;mousepad&quot;)script &#x3D; session.create_script(&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; hello: function () &#123; return &#39;Hello&#39;; &#125;, failPlease: function () &#123; return &#39;oops&#39;; &#125;&#125;;&quot;&quot;&quot;)script.load()api &#x3D; script.exportsprint(&quot;api.hello() &#x3D;&gt;&quot;, api.hello())print(&quot;api.fail_please() &#x3D;&gt;&quot;,api.fail_please()) 7z x frida-server-14.2.12-linux-x86_64.xz &amp;&amp; chmod 777 frida-server-14.2.12-linux-x86_64 &amp;&amp; ./frida-server-14.2.12-linux-x86_64 启动linux的frida server 通过netstat -tuulp可以查询被frida-server listen的27042端口 echo 123&gt;1.txt &amp;&amp; mousepad 1.txt 记事本打开1.txt,ps aux|grep -i mousepad查看该进程 python rpc.py 查看rpc attach mousepad引用打印结果 python-binding里连接frida-server的非标准端口: ./fs1428arm64 -l 0.0.0.0:6666import fridadevice = frida.get_device_manager().add_remote_device(‘192.168.1.101:6666’)print(device.name,devie.type,device.id) frida-python修改examples中bytecode.py 1234567891011121314system_session &#x3D; frida.attach(0)bytecode &#x3D; system_session.compile_script(name&#x3D;&quot;bytecode-example&quot;, source&#x3D;&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; listThreads: function () &#123; return Process.enumerateThreadsSync(); &#125;&#125;;&quot;&quot;&quot;)session &#x3D; frida.attach(&quot;mousepad&quot;)script &#x3D; session.create_script_from_bytes(bytecode)script.load()api &#x3D; script.exportsprint(&quot;api.list_threads() &#x3D;&gt;&quot;, api.list_threads()) python bytecode.py 查看rpc 编译生成的thread列表 frida-server-androidfrida-python修改examples中rpc.py 1234567891011121314151617181920device &#x3D; frida.get_usb_device()#device &#x3D; frida.get_device_manager.add_remote_device(&quot;192.168.0.2:8888&quot;) # 基于远程ip的集群pid &#x3D; device.spawn([&quot;com.android.settings&quot;])device.resume(pid)time.sleep(1)session &#x3D; device.attach(pid)script &#x3D; session.create_script(&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; hello: function () &#123; return &#39;Hello&#39;; &#125;, failPlease: function () &#123; return &#39;oops&#39;; &#125;&#125;;&quot;&quot;&quot;)script.load()api &#x3D; script.exportsprint(&quot;api.hello() &#x3D;&gt;&quot;, api.hello())print(&quot;api.fail_please() &#x3D;&gt;&quot;,api.fail_please()) ./fs1428arm64 pyenv local 3.8.5 &amp;&amp; python rpc.py 自启动进程查看rpc attach pid引用打印结果 frida-python修改examples中detached.py 1234567891011121314151617181920def on_detached(): print(&quot;on_detached&quot;)def on_detached_with_reason(reason): print(&quot;on_detached_with_reason:&quot;, reason)def on_detached_with_varargs(*args): print(&quot;on_detached_with_varargs:&quot;, args)device &#x3D; frida.get_usb_device()#device &#x3D; frida.get_device_manager.add_remote_device(&quot;192.168.0.2:8888&quot;) # 基于远程ip的集群pid &#x3D; device.spawn([&quot;com.android.settings&quot;])device.resume(pid)time.sleep(1)session &#x3D; device.attach(pid)print(&quot;attached&quot;)session.on(&#39;detached&#39;, on_detached)session.on(&#39;detached&#39;, on_detached_with_reason)session.on(&#39;detached&#39;, on_detached_with_varargs)sys.stdin.read() ./fs1428arm64 pyenv local 3.8.5 &amp;&amp; python detached.py 自启动进程detach进程后捕获进程退出打印log frida-python修改examples中crash_reporting.py 123456789101112131415def on_process_crashed(crash): print(&quot;on_process_crashed&quot;) print(&quot;\\tcrash:&quot;, crash)def on_detached(reason, crash): print(&quot;on_detached()&quot;) print(&quot;\\treason:&quot;, reason) print(&quot;\\tcrash:&quot;, crash)device &#x3D; frida.get_usb_device()device.on(&#39;process-crashed&#39;, on_process_crashed)session &#x3D; device.attach(&quot;com.android.settings&quot;)session.on(&#39;detached&#39;, on_detached)print(&quot;[*] Ready&quot;)sys.stdin.read() ./fs1428arm64 pyenv local 3.8.5 &amp;&amp; python crash_reporting.py 进程运行中detach进程后捕获进程退出打印log 当需要hook一个app的子进程时，调用child_gating.py在子进程创建时创建脚本打印内容。 argv = [“/bin/sh”, “-c”, “cat /etc/hosts”] # 在bullhead中/system/bin/sh frida-python修改examples中bytecode.py 1234567891011121314151617181920device &#x3D; frida.get_usb_device()#device &#x3D; frida.get_device_manager.add_remote_device(&quot;192.168.0.2:8888&quot;) # 基于远程ip的集群pid &#x3D; device.spawn([&quot;com.hd.zhibo&quot;])device.resume(pid)time.sleep(1)system_session &#x3D; device.attach(0)bytecode &#x3D; system_session.compile_script(name&#x3D;&quot;bytecode-example&quot;, source&#x3D;&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; listThreads: function () &#123; return Process.enumerateThreadsSync(); &#125;&#125;;&quot;&quot;&quot;)session &#x3D; device.attach(pid)script &#x3D; session.create_script_from_bytes(bytecode)script.load()api &#x3D; script.exportsprint(&quot;api.list_threads() &#x3D;&gt;&quot;, api.list_threads()) python bytecode.py 查看rpc 编译生成的thread列表 DEXDump:js暴露3个export api(memorydump,switchmode,scandex)，在py层调用三个api进行交互 Zentracer:使用替换js中字符串(MATCHREGEX,BLACKREGEX)将黑白名单传输给js文件，将js文件直接加载通过send将信息传输给py端 java层主动调用pyenv 升级123456789pyenv versionsgit clone https:&#x2F;&#x2F;github.com&#x2F;pyenv&#x2F;pyenv-update.git $(pyenv root)&#x2F;plugins&#x2F;pyenv-updatepyenv updatepyenv install 3.8.6pip install objection 安装最新版objection和fridafrida -UF Frida 查看版本Frida.heapSizeScript 查看运行环境使用的是QJS 项目Httpsocketlibssl库的抓包导出表与符号表 1234567objection -g com.roysue.httpsocket.explorememory list modules 搜索libssl.somemory list exports libssl.so --json &#x2F;root&#x2F;Desktop&#x2F;libssl.so.json 通过json文件查看导出函数表memory list exports libcrypto.so --json &#x2F;root&#x2F;Desktop&#x2F;libcrypto.so.json frida-trace -UF -I libssl.so 指定模块trace自动化导出表查看经过了哪里frida-trace -U -f com.roysue.Httpsocket -I libssl.so 容易崩frida-trace -U -f com.roysue.Httpsocket -I libcrypto.so 自动生成的hook在当前目录的__handlers__下 尝试通过frida实现hook所有so的导出表和符号表frida -U -f com.roysue.httpsocket -l traceNative.js --no-pause 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109function writeSomething(path, contents) &#123; var fopen_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fopen&quot;); var fputs_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fputs&quot;); var fclose_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fclose&quot;); &#x2F;&#x2F;console.log(&quot;fopen&#x3D;&gt;&quot;,fopen_addr,&quot; fputs&#x3D;&gt;&quot;,fputs_addr,&quot; fclose&#x3D;&gt;&quot;,fclose_addr); var fopen &#x3D; new NativeFunction(fopen_addr, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]) var fputs &#x3D; new NativeFunction(fputs_addr, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]) var fclose &#x3D; new NativeFunction(fclose_addr, &quot;int&quot;, [&quot;pointer&quot;]) &#x2F;&#x2F;console.log(path,contents) var fileName &#x3D; Memory.allocUtf8String(path); var mode &#x3D; Memory.allocUtf8String(&quot;a+&quot;); var fp &#x3D; fopen(fileName, mode); var contentHello &#x3D; Memory.allocUtf8String(contents); var ret &#x3D; fputs(contentHello, fp) fclose(fp);&#125;&#x2F;&#x2F; 枚举出所有导出函数和内部符号，找到关键函数存在的so，动态注册无效，名称和native可以完全不一样function traceNativeExport()&#123; var modules &#x3D; Process.enumerateModules(); for(var i &#x3D; 0;i&lt;modules.length;i++)&#123; var module &#x3D; modules[i]; if(module.name.indexOf(&quot;libssl.so&quot;)&lt;0)&#123; continue; &#125; &#x2F;&#x2F; 枚举so所有导出表 var exports &#x3D; module.enumerateExports(); for(var j &#x3D; 0;j&lt;exports.length;j++)&#123; &#x2F;&#x2F;console.log(&quot;module name is &#x3D;&gt;&quot;,module.name,&quot; symbol name is &#x3D;&gt;&quot;,exports[j].name) &#x2F;&#x2F;var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;so&#x2F;&quot;+module.name+&quot;.txt&quot; &#x2F;&#x2F; 通过objection -g com.roysue.httpsocket explore 中env拿到的filesDirectory地址 &#x2F;&#x2F;var path &#x3D; &quot;&#x2F;data&#x2F;data&#x2F;com.roysue.d0so2&#x2F;cache&#x2F;&quot;+module.name+&quot;.txt&quot; &#x2F;&#x2F;writeSomething(path,&quot;type: &quot;+exports[j].type+&quot; function name :&quot;+exports[j].name+&quot; address : &quot;+exports[j].address+&quot; offset &#x3D;&gt; 0x&quot;+(exports[j].address - module[i].address)+&quot;\\n&quot;) &#x2F;&#x2F; 把所有包含SSL_write的函数全部hook上 if(exports[j].name.indexOf(&quot;SSL_write&quot;)&gt;&#x3D;0)&#123; attach(exports[j].name,exports[j].address); &#125; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;set&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;send&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;recv&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#125; &#125;&#125;function attach(name,address)&#123; console.log(&quot;attaching &quot;,name); Interceptor.attach(address,&#123; onEnter:function(args)&#123; console.log(&quot;Entering &#x3D;&gt; &quot; ,name) console.log(&quot;args[0] &#x3D;&gt; &quot;,hexdump(args[0]) ) &#x2F;&#x2F; console.log(&quot;args[1] &#x3D;&gt; &quot;,args[1].readCString()) &#x2F;&#x2F; console.log(&quot;args[2] &#x3D;&gt; &quot;,args[2]) &#125;,onLeave:function(retval)&#123; &#x2F;&#x2F;console.log(&quot;retval is &#x3D;&gt; &quot;,retval) &#125; &#125;)&#125;&#x2F;&#x2F; 枚举符号表function traceNativeSymbol()&#123; var modules &#x3D; Process.enumerateModules(); for(var i &#x3D; 0;i&lt;modules.length;i++)&#123; var module &#x3D; modules[i]; &#x2F;&#x2F; console.log(JSON.stringify(modules)) if(module.name.indexOf(&quot;linker64&quot;)&lt;0)&#123; continue; &#125; var exports &#x3D; module.enumerateSymbols(); console.log(JSON.stringify(exports)) for(var j &#x3D; 0;j&lt;exports.length;j++)&#123; if(exports[j] &#x3D;&#x3D; null)&#123; continue; &#125; console.log(&quot;module name is &#x3D;&gt;&quot;,module.name,&quot; symbol name is &#x3D;&gt;&quot;,exports[j].name) var path &#x3D; &quot;&#x2F;data&#x2F;data&#x2F;com.roysue.d0so2&#x2F;cache&#x2F;&quot;+module.name+&quot;Symbol.txt&quot; writeSomething(path,&quot;type: &quot;+exports[j].type+&quot; function name :&quot;+exports[j].name+&quot; address : &quot;+exports[j].address+&quot; offset &#x3D;&gt; 0x&quot;+(exports[j].address - module[i].address)+&quot;\\n&quot;) &#125; &#125;&#125;function main()&#123; console.log(&quot;Entering main&quot;) traceNativeExport(); &#x2F;&#x2F;traceNativeSymbol();&#125;setImmediate(main) git clone https://github.com/BigFaceCat2017/frida_ssl_logger.git python ssl_logger.py -U -f com.roysue.httpsocket -p capture.pcap 抓包ssl保存到pcap中使用wireshark查看 libc去除httpSocket.js中traceNativeExport对libssl.so的过滤，frida -UF -l traceNative.js,trace后的结果到/data/data/com.roysue.d0so2/cache中cat libs.so.txt|grep open frida -UF -l traceNativelibc.js -o trace.txt frida -U -f com.ss.android.auto -l traceNativelibc.js -o trace.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126function writeSomething(path, contents) &#123; var fopen_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fopen&quot;); var fputs_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fputs&quot;); var fclose_addr &#x3D; Module.findExportByName(&quot;libc.so&quot;, &quot;fclose&quot;); &#x2F;&#x2F;console.log(&quot;fopen&#x3D;&gt;&quot;,fopen_addr,&quot; fputs&#x3D;&gt;&quot;,fputs_addr,&quot; fclose&#x3D;&gt;&quot;,fclose_addr); var fopen &#x3D; new NativeFunction(fopen_addr, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]) var fputs &#x3D; new NativeFunction(fputs_addr, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]) var fclose &#x3D; new NativeFunction(fclose_addr, &quot;int&quot;, [&quot;pointer&quot;]) &#x2F;&#x2F;console.log(path,contents) var fileName &#x3D; Memory.allocUtf8String(path); var mode &#x3D; Memory.allocUtf8String(&quot;a+&quot;); var fp &#x3D; fopen(fileName, mode); var contentHello &#x3D; Memory.allocUtf8String(contents); var ret &#x3D; fputs(contentHello, fp) fclose(fp);&#125;function traceNativeExport()&#123; var modules &#x3D; Process.enumerateModules(); for(var i &#x3D; 0;i&lt;modules.length;i++)&#123; var module &#x3D; modules[i]; if(module.name.indexOf(&quot;libc.so&quot;)&lt;0)&#123; continue; &#125; var exports &#x3D; module.enumerateExports(); for(var j &#x3D; 0;j&lt;exports.length;j++)&#123; &#x2F;&#x2F;console.log(&quot;module name is &#x3D;&gt;&quot;,module.name,&quot; symbol name is &#x3D;&gt;&quot;,exports[j].name) &#x2F;&#x2F;var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;so&#x2F;&quot;+module.name+&quot;.txt&quot; &#x2F;&#x2F; var path &#x3D; &quot;&#x2F;data&#x2F;data&#x2F;com.roysue.d0so2&#x2F;cache&#x2F;&quot;+module.name+&quot;.txt&quot; &#x2F;&#x2F; writeSomething(path,&quot;type: &quot;+exports[j].type+&quot; function name :&quot;+exports[j].name+&quot; address : &quot;+exports[j].address+&quot; offset &#x3D;&gt; 0x&quot;+ ( exports[j].address.sub(modules[i].base) )+&quot;\\n&quot;) &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;strto&quot;)&gt;&#x3D;0)continue; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;strco&quot;)&gt;&#x3D;0)continue; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;_l&quot;)&gt;&#x3D;0)continue; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;pthread&quot;)&gt;&#x3D;0)continue; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;socket&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; fopen fputs fputc fclose &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#x2F;&#x2F; 过反调试,一般反调试都有单独创建线程 if(exports[j].name.indexOf(&quot;pthread_create&quot;)&gt;&#x3D;0)&#123; attach(exports[j].name,exports[j].address); &#125; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;read&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; man read &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;write&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;send&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(exports[j].name.indexOf(&quot;recv&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F; attach(exports[j].name,exports[j].address); &#x2F;&#x2F; &#125; &#125; &#125;&#125;function attach(name,address)&#123; console.log(&quot;attaching &quot;,name); Interceptor.attach(address,&#123; onEnter:function(args)&#123; console.log(&quot;Entering &#x3D;&gt; &quot; ,name) &#x2F;&#x2F; console.log(&quot;args[0] &#x3D;&gt; &quot;,args[0].readCString() ) &#x2F;&#x2F; console.log(&quot;args[1] &#x3D;&gt; &quot;,args[1].readCString()) &#x2F;&#x2F; console.log( hexdump(args[1])) console.log(&quot;args[2] &#x3D;&gt; &quot;,args[2]) &#x2F;&#x2F; 打印调用栈 &#x2F;&#x2F; console.log(&#39;R0YSUE called from:\\n&#39; +Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&#39;\\n&#39;) + &#39;\\n&#39;); &#125;,onLeave:function(retval)&#123; console.log(&quot;exit &#x3D;&gt; &quot;,name) &#x2F;&#x2F; console.log(&quot;retval is &#x3D;&gt; &quot;,retval.readCString()) &#125; &#125;)&#125;function traceNativeSymbol()&#123; var modules &#x3D; Process.enumerateModules(); &#x2F;&#x2F; console.log(JSON.stringify(modules)) for(var i &#x3D; 0;i&lt;modules.length;i++)&#123; var module &#x3D; modules[i]; &#x2F;&#x2F; console.log(JSON.stringify(modules)) &#x2F;&#x2F; if(module.name.indexOf(&quot;linker64&quot;)&lt;0)&#123; &#x2F;&#x2F; continue; &#x2F;&#x2F; &#125; var exports &#x3D; module.enumerateSymbols(); &#x2F;&#x2F; console.log(JSON.stringify(exports)) for(var j &#x3D; 0;j&lt;exports.length;j++)&#123; &#x2F;&#x2F; console.log(&quot;module name is &#x3D;&gt;&quot;,module.name,&quot; symbol name is &#x3D;&gt;&quot;,exports[j].name) var path &#x3D; &quot;&#x2F;data&#x2F;data&#x2F;com.roysue.d0so2&#x2F;cache&#x2F;&quot;+module.name+&quot;Symbol.txt&quot; writeSomething(path,&quot;type: &quot;+exports[j].type+&quot; function name :&quot;+exports[j].name+&quot; address : &quot;+exports[j].address+&quot; offset &#x3D;&gt; 0x&quot;+ ( exports[j].address.sub(modules[i].base) )+&quot;\\n&quot;) &#125; &#125;&#125;function main()&#123; console.log(&quot;Entering main&quot;) traceNativeExport(); &#x2F;&#x2F; traceNativeSymbol();&#125;setImmediate(main) Unicorn 在 Android 的应用 项目d0so2123objection -g com.roysue.d0so2 explore -s &quot;android hooking watch class_method com.roysue.d0so2.MainActivity.sI3 --dump-args --dump-backtrace --dump-return&quot;memory list modules 查找native-lib为libnative-lib.somemory list exports libnative-lib.so 只能找到静态注册的stringFromJNI1，stringFromJNI1，但是找不到动态注册的sI3 git clone https://github.com/lasting-yang/frida_hook_libart.githttps://github.com/lasting-yang/frida_hook_libart.git 1frida -U --no-pause -f com.roysue.d0so2 -l hook_RegisterNatives.js 找到动态注册的类和原名 其中0x7612a10454绝对地址减去0x7612a01000模块地址，得到0xf454函数地址 1memory list exports libnative-lib.so 搜索0x7612a10454 将函数名复制到http://demangler.com/ 进行解码得到原函数名 1android hooking watch class_method com.rosyue.d0so2.MainActivity.sI3() --dump-args --dump-backtrace --dump-return frida实现hook动态注册函数，frida -UF -l hookNative.js 12345678910111213141516171819202122232425262728function hook_native()&#123; var libnative_addr &#x3D; Module.findBaseAddress(&#39;libnative-lib.so&#39;); console.log(&quot;libnative_addr is &#x3D;&gt; &quot;,libnative_addr) var stringfromJNI3 &#x3D; libnative_addr.add(0xf454); console.log(&quot;stringfromJNI3 address is &#x3D;&gt;&quot;,stringfromJNI3); var stringfromJNI3_2 &#x3D; Module.findExportByName(&#39;libnative-lib.so&#39;, &quot;_Z14stringFromJNI3P7_JNIEnvP7_jclassP8_jstring&quot;) console.log(&quot;stringfromJNI3_2 address is &#x3D;&gt;&quot;,stringfromJNI3_2); Interceptor.attach(stringfromJNI3_2,&#123; onEnter:function(args)&#123; console.log(&quot;jnienv pointer &#x3D;&gt;&quot;,args[0]) console.log(&quot;jobj pointer &#x3D;&gt;&quot;,args[1]) console.log(&quot;jstring pointer&#x3D;&gt;&quot;,Java.vm.getEnv().getStringUtfChars(args[2], null).readCString() ) &#125;,onLeave:function(retval)&#123; console.log(&quot;retval is &#x3D;&gt;&quot;,Java.vm.getEnv().getStringUtfChars(retval, null).readCString()) console.log(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;) &#125; &#125;)&#125;function main()&#123; hook_native()&#125;setImmediate(main) 项目 demoso1Android JNI(一)——NDK与JNI基础 Android逆向新手答疑解惑篇——JNI与动态注册 pyenv 3.8.0 123456objection -g com.example.demoso1 exploreandroid hooking search classes com.example.demoso1 打印包名下所有的类android hooking list class_methods com.example.demoso1.MainActivity 打印类下所有方法android hooking watch class com.example.demoso1.MainActivityandroid hooking watch class_method com.example.demoso1.MainActivity.method02 --dump-args --dump-backtrace --dump-return objection -N -h 192.168.0.105 -p 8888 -g com.example.demoso1 explore method01在native层的静态方法，method02是native层的动态方法 123456789101112131415161718192021222324252627282930313233343536var MainActivityHandle &#x3D; null; &#x2F;&#x2F; 实例调用的性能优化(将instance缓存起来反复调用)Java.perform(function()&#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) Java.choose(&quot;com.example.demoso1.MainActivity&quot;,&#123; onMatch:function(instance)&#123; MainActivityHandle &#x3D; instance; &#125;,onComplete()&#123;&#125; &#125;) console.log(&quot;MainActivityHandle is &#x3D;&gt; &quot;,MainActivityHandle)&#125;) function fridamethod01(plaintext)&#123; var result; &#x2F;&#x2F; method01 是 静态方法，使用Java.use Java.perform(function()&#123; var MainActivity &#x3D; Java.use(&quot;com.example.demoso1.MainActivity&quot;); var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) result &#x3D; MainActivity.method01(javaString.$new(plaintext)) &#125;) return result;&#125;function fridamethod02(ciphertext)&#123; var result; Java.perform(function()&#123; &#x2F;&#x2F; method02 是 动态方法，使用Java.choose var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) &#x2F;&#x2F; Java.choose(&quot;com.example.demoso1.MainActivity&quot;,&#123; &#x2F;&#x2F; onMatch:function(instance)&#123; &#x2F;&#x2F; MainActivityHandle &#x3D; instance.method02(javaString.$new(ciphertext)); &#x2F;&#x2F; &#125;,onComplete()&#123;&#125; &#x2F;&#x2F; &#125;) result &#x3D; MainActivityHandle.method02(javaString.$new(ciphertext)) &#125;) return result;&#125; hook主机中 ./fs128arm64 -l 0.0.0.0:8888frida -H 192.168.0.105:8888 -F -l hookandinvoke.js 手机ipobjection -N -h 192.168.0.105 -p 8888 -g com.example.demoso1 explore 远程objection连接 123456HTTP 每次都是新连接 速度慢RPC 是 TCP流，速度快rpc.exports&#x3D;&#123; fridamethod01:fridamethod01, fridamethod02:fridamethod02,&#125; rpc调用curl -s -X POST “http://127.0.0.1:5000/encrypt&quot; -H “Content-Type: application/json” -d ‘{“data”: “roysue”}’ curl -s -X POST “http://127.0.0.1:5000/decrypt&quot; -H “Content-Type: application/json” -d ‘{“data”: “47fcda3822cd10a8e2f667fa49da783f”}’ 123456789101112131415device &#x3D; frida.get_device_manager().add_remote_device(&quot;192.168.0.105:8888&quot;)# 启动&#96;demo01&#96;这个apppid &#x3D; device.spawn([&quot;com.example.demoso1&quot;])device.resume(pid)time.sleep(1)session &#x3D; device.attach(pid)# 加载脚本with open(&quot;hookandinvoke.js&quot;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot; , my_message_handler) #调用错误处理script.load()print(script.exports.fridamethod01(&quot;roysue&quot;))print(script.exports.fridamethod02(&quot;47fcda3822cd10a8e2f667fa49da783f&quot;)) python hookandinvoke.py 压测http并发性能https://github.com/JoeDog/siege 压测 apt install siege https://www.jianshu.com/p/74c465ff136f 1siege -c5 -r10 \"http://127.0.0.1:5000/encrypt POST &lt;./iloveroysue.json \" nps 内网穿透客户端：linux_arm64_client.tar.gz 因为n5x是kali nethunter系统，chmod 777 * &amp;&amp; ./npc，启动npc 服务端：https://ehang-io.github.io/nps/#/run 添加隧道，端口映射 add_remote_device 修改远程地址，将手机ip和kali主机ip暴露公网调用，通过siege压测 device = frida.get_device_manager().add_remote_device(“192.168.0.105:8888”) 手机ip linux_arm64_client.tar.gz device = frida.get_device_manager().add_remote_device(“118.126.66.193:58888”) npc和frida都在手机上，新增客户端，启动npc，手机ip公网映射添加隧道58888目标8888 siege -c5 -r10 “http://127.0.0.1:5000/encrypt POST &lt;./iloveroysue.json “ 启动py脚本 linux_amd64_client.tar.gz device = frida.get_device_manager().add_remote_device(“118.126.66.193:48888”) npc在kali上，新增客户端，启动npc，配置隧道服务端口55000目标5000端口，手机ip公网映射48888目标192.168.0.105:8888 siege -c5 -r10 “http://118.126.66.193:55000/encrypt POST &lt;./iloveroysue.json “ 启动py脚本 Native层主动调用demoso1基于https://www.jianshu.com/p/0390f598c34c 12objection -g com.example.demoso1 explorememory list exports libnative-lib.so 查看导出函数，静态函数直接搜索 _Z8method01P7_JNIEnvP7_jclassP8_jstring 通过搜索http://demangler.com/ 拿到原函数名 或者通过https://github.com/lasting-yang/frida_hook_libart.git frida -U -f com.example.demoso1 -l hook_RegisterNatives.js –no-pause 查看原始方法名 修改hook_RegisterNatives，添加hookMethod01和invokemethod02 123456789101112131415161718192021222324252627282930313233343536373839在hook_RegisterNatives方法中添加 if(name.indexOf(&quot;method01&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F;hookmethod(fnPtr_ptr); &#x2F;&#x2F;replacehook(fnPtr_ptr); method01addr &#x3D; fnPtr_ptr; &#125;else if (name.indexOf(&quot;method02&quot;)&gt;&#x3D;0)&#123; method02addr &#x3D; fnPtr_ptr; method02 &#x3D; new NativeFunction(method02addr,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;pointer&#39;,&#39;pointer&#39;]); &#125;else&#123; continue; &#125;新增invokemethod01function invokemethod01(contents)&#123; console.log(&quot;ENV&#x3D;&gt;&quot;,ENV) console.log(&quot;JCLZ&#x3D;&gt;&quot;,JCLZ); console.log(&quot;method01_addr is &#x3D;&gt;&quot;,method01addr) var method01 &#x3D; new NativeFunction(method01addr,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;pointer&#39;,&#39;pointer&#39;]); var NewStringUTF &#x3D; new NativeFunction(addrNewStringUTF,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;pointer&#39;]) var result &#x3D; null; Java.perform(function()&#123; console.log(&quot;Java.vm.getEnv()&quot;,Java.vm.getEnv()) var JSTRING &#x3D; NewStringUTF(Java.vm.getEnv(),Memory.allocUtf8String(contents)) result &#x3D; method01(Java.vm.getEnv(),JSTRING,JSTRING); console.log(&quot;result is &#x3D;&gt;&quot;,result) console.log(&quot;result is &quot;,Java.vm.getEnv().getStringUtfChars(result, null).readCString()) result &#x3D; Java.vm.getEnv().getStringUtfChars(result, null).readCString(); &#125;) return result;&#125;新增invokemethod02function invokemethod02(contents)&#123; var result &#x3D; null; Java.perform(function()&#123; var JSTRING &#x3D; NewStringUTF(Java.vm.getEnv(),Memory.allocUtf8String(contents)) result &#x3D; method02(Java.vm.getEnv(),JSTRING,JSTRING); result &#x3D; Java.vm.getEnv().getStringUtfChars(result, null).readCString(); &#125;) return result;&#125; jni 获取类(jclass)的方式 1.需要new 一个对象时需要jclass.2.需要调用这个对象的方法或者属性时需要jclass.3.jclass 不需要释放. 12345获取对象类jclass GetObjectClass_(JNIEnv* jni, jobject object) &#123; jclass c = jni-&gt;GetObjectClass(object); return c;&#125; 12直接找到类名jclass long_cls &#x3D; env-&gt;FindClass(&quot;java&#x2F;lang&#x2F;Long&quot;); rpc1234rpc.exports &#x3D; &#123; invoke1:invokemethod01, &#x2F;&#x2F; 导出名不可以有大写字母或者下划线 invoke2:invokemethod02&#125;; init.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import timeimport fridafrom flask import Flask, jsonify, requestimport jsondef my_message_handler(message , payload): #定义错误处理 print(message) print(payload)# 连接安卓机上的frida-server#device &#x3D; frida.get_device_manager().add_remote_device(&quot;192.168.0.3:8888&quot;)#device &#x3D; frida.get_device_manager().add_remote_device(&quot;118.126.66.193:58888&quot;)device &#x3D; frida.get_device_manager().add_remote_device(&quot;192.168.0.105:8888&quot;)#device &#x3D; frida.get_usb_device()# 启动&#96;demo01&#96;这个apppid &#x3D; device.spawn([&quot;com.example.demoso1&quot;])session &#x3D; device.attach(pid)# 加载脚本with open(&quot;hook_RegisterNatives.js&quot;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot; , my_message_handler) #调用错误处理script.load()time.sleep(3)device.resume(pid)time.sleep(3)print(script.exports.invoke1(&quot;onejane&quot;))print(script.exports.invoke2(&quot;c6138f96658ce0cb845bdab0f9616273&quot;))# 脚本会持续运行等待输入#input()app &#x3D; Flask(__name__)@app.route(&#39;&#x2F;encrypt&#39;, methods&#x3D;[&#39;POST&#39;])#url加密def encrypt_class(): data &#x3D; request.get_data() json_data &#x3D; json.loads(data.decode(&quot;utf-8&quot;)) postdata &#x3D; json_data.get(&quot;data&quot;) #print(postdata) res &#x3D; script.exports.invoke1(postdata) return res @app.route(&#39;&#x2F;decrypt&#39;, methods&#x3D;[&#39;POST&#39;])#data解密def decrypt_class(): data &#x3D; request.get_data() json_data &#x3D; json.loads(data.decode(&quot;utf-8&quot;)) postdata &#x3D; json_data.get(&quot;data&quot;) res &#x3D; script.exports.invoke2(postdata) return res if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.run() 端口usb连接，主机连接adb, ./fs128arm64 -l 0.0.0.0:8888 启动frida server 脱离apk7z x demoso1/app/build/outputs/apk/debug/app-debug.apk cp lib/arm64-v8a/libnative-lib.so 到 /data/app/libnative-lib.so 并赋予最高权限 adb push libnative-lib.so /data/app 12345678910frida -U -f com.android.settings -l hook_RegisterNatives.js --no-pauseobjection -g com.android.settings explore memory list modules 可以看到libnative-lib.so已经被加载memory list exports libnative-lib.so 找到两个函数名_Z8method01P7_JNIEnvP7_jclassP8_jstring，_Z8method02P7_JNIEnvP8_jobjectP8_jstringvar modulelibnative &#x3D; Module.load(&quot;&#x2F;data&#x2F;app&#x2F;libnative-lib.so&quot;) &#x2F;&#x2F; 加载somethod01addr &#x3D; modulelibnative.findExportByName(&quot;_Z8method01P7_JNIEnvP7_jclassP8_jstring&quot;)method02addr &#x3D; modulelibnative.findExportByName(&quot;_Z8method02P7_JNIEnvP8_jobjectP8_jstring&quot;)修改init.py中pid &#x3D; device.spawn([&quot;com.android.settings&quot;]) RPC（TCP） 远快于 HTTP,手机暴露frida-server，它是一个TCP，效率很高 自吐算法摘要adb install HookTestDemo.apk jadx-gui HookTestDemo.apk frida -UF -l hookEvent.js 所有点击事件hook，发现所有触发类都是MainActivity 普通方法123456789101112131415161718case R.id.putong &#x2F;*&#123;ENCODED_INT: 2131165291&#125;*&#x2F;: toastPrint(Utils.getCalc(2000, 2000) + BuildConfig.FLAVOR); toastPrint(new Money.innerClass(&quot;资源吧&quot;, 666).outPrint()); return;static class innerClass &#123; private String name; private int num; public innerClass(String name2, int num2) &#123; this.name &#x3D; name2; this.num &#x3D; num2; &#125; public String outPrint() &#123; return &quot;内部类被调用&quot; + this.name + &quot;: &quot; + this.num; &#125;&#125; objection探索一波，枚举不准的话，延迟加载，每个按钮都点一次触发类 1234567objection -g com.xiaojianbang.app explore -P ~&#x2F;.objection&#x2F;plugins android hooking search classes com.xiaojianbang.app 找不到Money类android hooking list classes cat ~&#x2F;.objection&#x2F;objection.log | grep -i &quot;com.xiaojianbang.app&quot;plugin wallbreaker classdump --fullname com.xiaojianbang.app.Moneyandroid heap search instances com.xiaojianbang.app.MainActivity.&#x2F;fs1426arm64 hook主动调用内部类 12345678910111213141516171819202122232425262728293031323334var MainActivity &#x3D; null;Java.perform(function () &#123; Java.choose(&quot;com.xiaojianbang.app.MainActivity&quot;, &#123; onMatch: function (instanse) &#123; MainActivity &#x3D; instanse; console.log(&quot;found instance &#x3D;&gt; &quot;, MainActivity); &#125;, onComplete: function () &#123; console.log(&quot;search completed!&quot;) &#125; &#125;)&#125;)function showToast(string) &#123; Java.perform(function () &#123; &#x2F;&#x2F; UI thread 注入 var Toast &#x3D; Java.use(&#39;android.widget.Toast&#39;); var currentApplication &#x3D; Java.use(&#39;android.app.ActivityThread&#39;).currentApplication(); var context &#x3D; currentApplication.getApplicationContext(); &#x2F;&#x2F; 在线程上运行指定的函数 Java.scheduleOnMainThread(function () &#123; Toast.makeText(context, string, Toast.LENGTH_LONG.value).show(); &#125;) &#125;)&#125;function invokeNormal() &#123; Java.perform(function () &#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) &#x2F;&#x2F; 静态内部函数 var MoneyInnerClass &#x3D; Java.use(&quot;com.xiaojianbang.app.Money$innerClass&quot;).$new(javaString.$new(&quot;J&quot;), 666).outPrint(); console.log(&quot;result &#x3D;&gt;&quot;, MoneyInnerClass) showToast(javaString.$new(MoneyInnerClass)) &#125;)&#125; frida -UF -l hookxjb.js [Pixel::HookTestDemo]-&gt; result =&gt; 内部类被调用J: 666 构造实例方法1234567891011case R.id.gouzao &#x2F;*&#123;ENCODED_INT: 2131165257&#125;*&#x2F;: if (money &#x3D;&#x3D; null) &#123; money &#x3D; new Money(&quot;美元&quot;, 1000); &#125; toastPrint(&quot;money: &quot; + money.getInfo()); toastPrint(Utils.getMoney().getInfo()); toastPrint(new Money().name()); public String name() &#123; return &quot;my name is xiaojianbang&quot;;&#125; frida -UF -l hookxjb.js invokeInit() 1234567function invokeInit() &#123; Java.perform(function () &#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) var MoneyName &#x3D; Java.use(&quot;com.xiaojianbang.app.Money&quot;).$new().name(); showToast(javaString.$new(MoneyName)) &#125;)&#125; 重载方法1234567891011121314151617case R.id.chongzai &#x2F;*&#123;ENCODED_INT: 2131165233&#125;*&#x2F;: toastPrint(Utils.test(666)); toastPrint(Utils.test()); toastPrint(Utils.test(new Money(&quot;港币&quot;, 7000))); toastPrint(new Money() &#123; &#x2F;* class com.xiaojianbang.app.MainActivity.AnonymousClass1 *&#x2F; @Override &#x2F;&#x2F; com.xiaojianbang.app.Money public String getInfo() &#123; return &quot;匿名类被调用&quot;; &#125; &#125;.getInfo()); return;public static String test(int num) &#123; return &quot;www.zygx8.com &quot; + num;&#125; android hooking list class_methods com.xiaojianbang.app.Utils 1234567function invokeOverload() &#123; Java.perform(function () &#123; &#x2F;&#x2F; 静态重载方法 var result &#x3D; Java.use(&quot;com.xiaojianbang.app.Utils&quot;).test(666); console.log(&quot;invoke overload result is &#x3D;&gt; &quot;, result); &#125;)&#125; frida -UF -l hookxjb.js invokeOverload() 对象参数123456789101112131415case R.id.duixiang &#x2F;*&#123;ENCODED_INT: 2131165247&#125;*&#x2F;: toastPrint(Utils.test(new Money(&quot;美元&quot;, 200))); toastPrint(new Utils().myPrint(new String[]&#123;&quot;资源共享吧&quot;, &quot;官网&quot;, &quot;:&quot;, &quot;www.zygx8.com&quot;&#125;)); return;public static String test(Money money) &#123; return money.getInfo();&#125;public String myPrint(String[] strArr) &#123; StringBuilder sb &#x3D; new StringBuilder(); for (String str : strArr) &#123; sb.append(str); &#125; return sb.toString();&#125; frida -UF -l hookxjb.js invokeOverload() 1234567891011121314function invokeObject() &#123; Java.perform(function () &#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) var newMoney &#x3D; Java.use(&quot;com.xiaojianbang.app.Money&quot;).$new(javaString.$new(&quot;dollar&quot;), 200); var result &#x3D; Java.use(&quot;com.xiaojianbang.app.Utils&quot;).test(newMoney); showToast(javaString.$new(result)) var StringArray &#x3D; Java.array(&quot;java.lang.String&quot;, [javaString.$new(&quot;J &quot;), javaString.$new(&quot;you are the &quot;), javaString.$new(&quot;best &quot;)]) var result &#x3D; Java.use(&quot;com.xiaojianbang.app.Utils&quot;).$new().myPrint(StringArray); showToast(javaString.$new(result)) &#125;)&#125; Native12345678case R.id.helloFromC &#x2F;*&#123;ENCODED_INT: 2131165260&#125;*&#x2F;: toastPrint(NativeHelper.helloFromC()); return;case R.id.add &#x2F;*&#123;ENCODED_INT: 2131165218&#125;*&#x2F;: toastPrint(NativeHelper.add(5, 6, 7) + BuildConfig.FLAVOR); return; public static native String helloFromC(); public static native int add(int i, int i2, int i3); frida -UF -l hookxjb.js invokeNative() 123456789101112function invokeNative() &#123; Java.perform(function () &#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) var result &#x3D; Java.use(&quot;com.xiaojianbang.app.NativeHelper&quot;).helloFromC(); showToast(javaString.$new(result)); result &#x3D; Java.use(&quot;com.xiaojianbang.app.NativeHelper&quot;).add(100, 200, 300); showToast(javaString.$new(String(result))); &#125;)&#125; MD512345678case R.id.JavaMD5 &#x2F;*&#123;ENCODED_INT: 2131165191&#125;*&#x2F;: toastPrint(MD5.md5_1(&quot;xiaojianbang&quot;)); return;public static String md5_1(String args) throws Exception &#123; MessageDigest md &#x3D; MessageDigest.getInstance(&quot;MD5&quot;, &quot;BC&quot;); md.update(args.getBytes()); return Utils.byteToHexString(md.digest());&#125; hook类java.security.MessageDigest中所有的方法包括md5 12345678910111213141516171819202122232425262728function hookMD5() &#123; Java.perform(function () &#123; var targetClassMethod &#x3D; &quot;java.security.MessageDigest.getInstance&quot; var delim &#x3D; targetClassMethod.lastIndexOf(&quot;.&quot;); if (delim &#x3D;&#x3D;&#x3D; -1) return; var targetClass &#x3D; targetClassMethod.slice(0, delim) var targetMethod &#x3D; targetClassMethod.slice(delim + 1, targetClassMethod.length) var hook &#x3D; Java.use(targetClass); var overloadCount &#x3D; hook[targetMethod].overloads.length; var overloadCount &#x3D; hook[targetMethod].overloads.length; for (var i &#x3D; 0; i &lt; overloadCount; i++) &#123; hook[targetMethod].overloads[i].implementation &#x3D; function () &#123; console.warn(&quot;\\n*** entered &quot; + targetClassMethod); &#x2F;&#x2F; print args if (arguments.length &gt;&#x3D; 0) &#123; for (var j &#x3D; 0; j &lt; arguments.length; j++) &#123; console.log(&quot;arg[&quot; + j + &quot;]: &quot; + arguments[j]); &#125; &#125; var retval &#x3D; this[targetMethod].apply(this, arguments); console.log(&quot;\\nretval: &quot; + retval); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return retval; &#125; &#125; &#125;)&#125; IDA从入门到理解 某加固系统运行信息获取frida 脚本 unidbg学习笔记 浅谈渗透江湖之细水柔情 领悟Frida的精髓_0512newCodeAndProject.zip var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"rpc","slug":"rpc","permalink":"http://onejane.github.io/tags/rpc/"},{"name":"so","slug":"so","permalink":"http://onejane.github.io/tags/so/"}]},{"title":"基于内存漫游定位分析","slug":"基于内存漫游定位分析","date":"2021-02-12T13:54:40.000Z","updated":"2021-12-12T03:09:39.292Z","comments":true,"path":"2021/02/12/基于内存漫游定位分析/","link":"","permalink":"http://onejane.github.io/2021/02/12/%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E6%BC%AB%E6%B8%B8%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 三板斧： 先hook、看参数和返回值，利用命令行定位 再利用命令行/写代码构造参数、主动调用 最后规模化利用PYTHON配RPC导出结果 基于内存漫游定位案例一adb install -r -t movetv.apk 移动tv onejane/123456,-r强制升级，-t允许装debug版本 jadx打开发现com.tecent.StubShell加壳，找不到MainActivity 123456pyenv local 3.8.0adb shell.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64objection -g com.cz.babySister exploreandroid hooking search classes com.wrapper.proxyapplicationandroid hooking watch class com.wrapper.proxyapplication.WrapperProxyApplication 该类在启动则被调用，attach将无法hook Frida附加app的两种模式： SPAWN：创建进程时就hook，有壳的话就不行 ATTACH：应用运行过程中hook，有壳也是ok 分析123android hooking list activitiesandroid intent launch_activity com.cz.babySister.activity.LoginActivity 指定启动Activityps -ef|grep baby 进程一直自动启动 objection -d -g com.cz.babySister explore --startup-command &quot;android hooking watch class com.wrapper.proxyapplication.WrapperProxyApplication&quot; 开启debug -d 由于该app会自动后台启动 需要在前台启动时立即使用objection漫游 批量hookandroid hooking search classes com.wrapper.proxyapplication 枚举包中所有类 12345com.wrapper.proxyapplication.CustomerClassLoadercom.wrapper.proxyapplication.MultiDexcom.wrapper.proxyapplication.MultiDex$V19com.wrapper.proxyapplication.Utilcom.wrapper.proxyapplication.WrapperProxyApplication 如何使用objection去批量hook和trace？ 把~/.objection/objection.log删掉； 到objection界面中运行android hooking list classes，列出所有的类； 对新生成的~/.objection/objection.log文件进行过滤，比如只关心http相关的。cat objection.log|grep -i http 将输出结果保存到一个excel列中，前面补全android hooking watch class xxxxx，另存为文本文件 加载这个文件：objection -g com.android.settings explore -c “2.txt” ，这样一下子就hook上了几千个相关类的所有方法及其所有重载。 如果trace感兴趣的方法也是同理，android hooking search methods * ，会打印出所有的方法。 vim hooklist.txt 12345android hooking watch class com.wrapper.proxyapplication.CustomerClassLoaderandroid hooking watch class com.wrapper.proxyapplication.MultiDexandroid hooking watch class com.wrapper.proxyapplication.MultiDex$V19android hooking watch class com.wrapper.proxyapplication.Utilandroid hooking watch class com.wrapper.proxyapplication.WrapperProxyApplication objection -g com.cz.babySister explore -c “hooklist.txt” 批量hook android hooking list class_methods com.wrapper.proxyapplication.Util 枚举类中所有方法 Zentraceradb shell &amp;&amp; top 根据负载查看包名 java.net.HttpUrlConnection 1234objection -g com.cz.babySister explore --startup-command &quot;android hooking watch class java.net.HttpURLConnection&quot;jobs listjobs kill idandroid hooking watch class_method java.net.HttpURLConnection.getFollowRedirects --dump-args 登录发现堆栈来自于com.cz.babySister.c.a.a 通过jadx搜索com.cz.babySister.c.a.a所在类，通过android hooking watch class com.cz.babySister.c.a进行trace类 通过android hooking watch class_method com.cz.babySister.c.a.a --dump-args --dump-backtrace --dump-return 进行trace方法 什么叫trace？hook多了就成了trace 系统框架是不可能被混淆的，基于枚举的内存漫游定位思路的含义是：怀疑你使用了什么框架API、怀疑你经过了哪个包哪处地方、就去那里埋伏起来，等待经过。 针对混淆后的okhttp3,通过Frida实现的拦截okhttp脚本 ./data/local/tmp/fs1428arm64 cd ZenTracer &amp;&amp; proxychains pip install PyQt5 &amp;&amp; python ZenTracer.py 报错：Could not load the Qt platform plugin “xcb” in “” even though it was found 1export QT_DEBUG_PLUGINS&#x3D;1 python ZenTracer.py ldd libqxcb.so 查看具体哪个so文件为not found apt install libxcb-util1 libxcb-xinerama0 Action-Match RegEx Action-Start 启动trace,登录trace保存为json thunar . 打开当前目录 查看babySister查看json 极端情况：Match RegEx 填写com.cz.babySister主包名，trace所有的方法 1234objection -g com.cz.babySister exploreandroid hooking search classes com.cz.babySistercat ~&#x2F;.objection&#x2F;objection.log|grep com.cz.babySister 拿到所有的类 在前面添加命令 android hooking watch class保存到classes.txt中objection -g com.cz.babySister explore -c classes.txt 实现批量hook 案例二adb install xes.apk 123456objection -g com.xes.jazhanghui.activity explore -P ~&#x2F;.objection&#x2F;plugins 启动objection加载所有插件android hooking search classes okhttp3android hooking list class_methods okhttp3.OkHttpClientandroid heap search instances okhttp3.OkHttpClient 找到对象实例plugin wallbreaker objectsearch okhttp3.OkHttpClient 拿到ok3对象的地址，如混淆在jadx中找到ok3的类注释中的renameplugin wallbreaker objectdump --fullname 0x37d2 分析adb push okhttplogging.dex /data/local/tmp adb push myok2curl.dex /data/local/tmp cd ~/Desktop/frida-agent-example &amp;&amp; npm run watch frida -UF -l hookOkhttp3.js 通过adb logcat | grep “okhttpGet”查看log 原生：离解释器更近：安卓原生就是dex被libart.so来解释、linux原生就是CPU直接解释的机器码 123ps -e |grep -i chromeobjection -g com.android.chrome explorememory list modules 发现dex被libart.so加载解析执行 脱壳frida_fart 12cd frida_fart &amp;&amp; adb push lib&#x2F;* &#x2F;data&#x2F;local&#x2F;tmpcd &#x2F;data&#x2F;local&#x2F;tmp&#x2F; &amp;&amp; cp fart* &#x2F;data&#x2F;app &amp;&amp; cd &#x2F;data&#x2F;app &amp;&amp; chmod 777 fart* 加权限 修改源码dex保存路径：var savepath = “/sdcard/com.cz.babySister.activity/“; 1234mkdir &#x2F;sdcard&#x2F;com.cz.babySister.activity&#x2F; frida -U -f com.cz.babySister -l frida_fart_reflection.js --no-pausefrida -UF -l frida_fart_reflection.jsfrida -U -f com.cz.babySister -l frida_fart_hook.js --no-pause 基于安卓8，生成dex frida-dexdump 核心原理：进程级别的内存漫游 cd ~/.objection/plugins/dexdump &amp;&amp; python main.py 自动脱壳(前台运行的学而思app) cd com.xes.jazhanghui.activity &amp;&amp; grep -ril “okhttp3.OkHttpClient” * du -h * 查看文件最大的dex使用jadx打开 objection -g com.xes.jazhanghui.activity explore -P ~/.objection/plugins android hooking list activities 在jadx中查找到dex包含com.xes.jazhanghui.activity.mvp.live.activity.LiveMainActivity 同理：脱壳移动TV，grep -ril “MainActivity” *,grep -ril “LoginActivity” *,找到唯一入口dex 案例三adb install 免费电影院v2.1.0_210.apk 分析静态：通过jadx搜索OkHttpClient,或者apktool d 免费电影院v2.1.0_210.apk &amp;&amp; grep -ril &quot;OkHttpClient&quot; * 动态： 12345cat smali&#x2F;فمضﺝ&#x2F;ﻙﺫتك$ﺯﺵتﻝ.smali拿到.class public Lفمضﺝ&#x2F;ﻙﺫتك;类名objection -g com.singleman.freevideo explore -P &#x2F;root&#x2F;.objection&#x2F;plugins 点击登录调用ok3plugin wallbreaker objectsearch فمضﺝ.ﻙﺫتكplugin wallbreaker objectdump --fullname 0x2452 查看该类是否ok3Client，获取其中List&lt;Interceptor&gt;地址，用wallbreaker dump下来class为Collections$UnmodifiableRandomAccessList 即为OkHttpClient类 在hookOkhttp3.js中实现hook 12345678910111213141516171819202122Java.choose(&quot;فمضﺝ.ﻙﺫتك&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;1. found instance:&quot;,instance) &#x2F;&#x2F;console.log(&quot;2. instance.interceptors():&quot;,instance.interceptors().$className) console.log(&quot;3. instance._interceptors:&quot;,instance.ﻭﻍﺫﻉ.value.$className) &#x2F;&#x2F;console.log(&quot;4. interceptors:&quot;,gson2.$new().toJson(instance.interceptors())) console.log(&quot;5. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(instance.ﻭﻍﺫﻉ.value.toArray())) &#x2F;* var newInter &#x3D; Java.use(&quot;java.util.ArrayList&quot;).$new(); newInter.addAll(instance.interceptors()); console.log(&quot;6. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(newInter.toArray())); console.log(&quot;7. interceptors:&quot;,newInter.$className); newInter.add(MyInterceptorObj); newInter.add(curlInter); instance._interceptors.value &#x3D; newInter; *&#x2F; &#125;,onComplete:function()&#123; console.log(&quot;Search complete!&quot;) &#125;&#125;) 案例四1234567adb install 中国移动7.0.0.apkadb shell 打开app前台运行，top查看包名ps -ef|grep greenpm -l | grep green 查看包名pyenv local 3.9.0.&#x2F;fs14216arm64objection -g com.greenpoint.android.mc10086.activity explore 该样本是多进程 1234cat &#x2F;proc&#x2F;11929&#x2F;status 发现该进程被子进程进行attach了，TracerPid: 11958frida -U -f com.greenpoint.android.mc10086.activity 因为frida比子进程快，attch后没有释放父进程%resume 会直接挂掉Process terminatedfrida -UF 报双进程错unable to access process with pid 13250 due to system restrictions; wget hluda-server-14.2.16-android-arm64 12345.&#x2F;hluda14216arm64frida -U -f com.greenpoint.android.mc10086.activity%resumeproxychains git clone https:&#x2F;&#x2F;github.com&#x2F;r0ysue&#x2F;r0tracer.gitfrida -U -f com.greenpoint.android.mc10086.activity -l r0tracer.js -o cmcc.txt frida是app进程启动时spawn注入比任何程序都快，注入成功就dettach掉，trace id为父进程，子进程就可以回头调试主进程。frida server和脚本是进程间通信，即socket通信。 用objection不管是spawn还是attach都失败的双进程，frida命令的话可以先不加--no-pause，然后手动%resume就可以使用hluda进行hook上了。 基于Frida的Hook案例一adb install -r -t junior.apk 开启远程调用frida -UF -l demo.js 像素显示dip2px123456789101112131415161718objection -g com.example.junior explore -P ~&#x2F;.objection&#x2F;plugins 加载所有插件android hooking list activities 查看用于展示的界面android intent launch_activity com.example.junior.CalculatorActivity 启动计算器界面cat objection.log | grep com.example.junior.util.Utilsandroid hooking list class_methods com.example.junior.util.Utils 打印来中所有可hook的函数android hooking watch class_method com.example.junior.util.Utils.dip2px --dump-args --dump-return --dump-backtrace hook方法并打印像素显示出入参与调用栈function main() &#123; Java.perform(function () &#123;&#x2F;&#x2F;只要是java的代码都要跑在Java.perform里面 console.log(&quot;Entering Hook!&quot;) Java.use(&quot;com.example.junior.util.Utils&quot;).dip2px.implementation &#x3D; function (context, float) &#123; &#x2F;&#x2F;return null; var result &#x3D; this.dip2px(context, 100) console.log(&quot;context,float,result &#x3D;&#x3D;&gt; &quot;, context, float, result); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return 26; &#125; &#125;)&#125; 分辨率显示setTexthook用不上Java.choose的，hook函数时不分动静态 123456789101112131415161718192021222324252627282930android intent launch_activity com.example.junior.ScreenActivity cat objection.log|grep -i android.widget.TextViewandroid hooking list class_methods android.widget.TextView 打印来中所有可hook的函数android hooking watch class_method android.widget.TextView.setText --dump-args --dump-backtrace --dump-return hook公共方法setTextandroid heap search instances com.example.junior.ScreenActivity 搜索activity类内存地址android heap execute 0x6f72 showScreenInfo 主动调用该类的指定方法，frida端hook自动执行function Screen() &#123; Java.perform(function () &#123; &#x2F;&#x2F; 重载 Java.use(&quot;android.widget.TextView&quot;).setText.overload(&#39;java.lang.CharSequence&#39;).implementation &#x3D; function (text) &#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;); var newString &#x3D; javaString.$new(&quot;onejane&quot;) var result &#x3D; null; var realText &#x3D; String(text); console.log(&quot;real text is &#x3D;&#x3D;&gt; &quot;,realText); if (realText.indexOf(&quot;junior&quot;) &gt;&#x3D; 0) &#123; var result &#x3D; this.setText(newString); console.log(&quot;text,result &#x3D;&#x3D;&gt; &quot;, newString, result); &#125; else &#123; var result &#x3D; this.setText(text); console.log(&quot;text,result &#x3D;&#x3D;&gt; &quot;, text, result); &#125; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return result; &#125; &#125;)&#125; 计算器123456789101112131415161718192021222324cat objection.log|grep -i com.example.junior.util.Arithandroid hooking list class_methods com.example.junior.util.Arith 查看Arith类有哪些hook的方法android hooking watch class_method com.example.junior.util.Arith.sub --dump-args --dump-backtrace --dump-return hook静态方法subfunction Equals()&#123; Java.perform(function()&#123; Java.use(&quot;java.lang.String&quot;).equals.implementation &#x3D; function(obj)&#123; var result &#x3D; this.equals(obj); console.log(&quot;obj,result &#x3D;&#x3D;&gt; &quot;,obj,result); return result; &#125; &#125;)&#125;function sub()&#123; Java.perform(function()&#123; Java.use(&quot;com.example.junior.util.Arith&quot;).sub.overload(&#39;java.lang.String&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function(str1,str2)&#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) var result &#x3D; this.sub(str1,javaString.$new(&quot;2&quot;)); &#x2F;&#x2F; 本质上属于主动调用构造函数 console.log(&quot;str1,str2,result&#x3D;&#x3D;&gt;&quot;,str1,str2,result) return javaString.$new(&quot;10&quot;); &#125; &#125;)&#125; 静态变量运行junior的计算器 12plugin wallbreaker classsearch Arith 内存漫游搜索Arith类plugin wallbreaker classdump --fullname com.example.junior.util.Arith 将Arith类dump发现有静态变量 通过frida获取静态变量DEF_DIV_SCALE并修改值为20，内存中的静态变量DEF_DIV_SCALE即变为20 123456789function staticField()&#123; Java.perform(function()&#123; var divscale &#x3D; Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value; console.log(&quot;divscale1 is &#x3D;&gt;&quot;,divscale); Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value&#x3D;20; divscale &#x3D; Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value; console.log(&quot;divscale2 is &#x3D;&gt;&quot;,divscale); &#125;)&#125; 静态主动调用frida -UF -l demo.js主动调用Arith.add方法 123456function operate()&#123; Java.perform(function()&#123; var Arith &#x3D; Java.use(&quot;com.example.junior.util.Arith&quot;); console.log(&quot;addResult is &#x3D;&gt;&quot;,Arith.add(&quot;1&quot;,&quot;1&quot;)); &#125;)&#125; plugin wallbreaker classsearch Build 搜索含有Build的类 plugin wallbreaker classdump --fullname android.os.Build 将Build类dump下来 123456789function fingerPrint()&#123; Java.perform(function()&#123; var Build &#x3D; Java.use(&quot;android.os.Build&quot;); console.log(Build.DEVICE.value,Build.ID.value,Build.MODEL.value,Build.SERIAL.value); Build.SERIAL.value &#x3D; &#39;F123456&#39;; console.log(Build.SERIAL.value,Build.getSerial()); &#x2F;&#x2F; 若app无权限getSerial()，换设置重新主动调用 console.log(&#39;sdk is &#39;,Build.getString(&quot;ro.build.version.sdk&quot;)); &#125;)&#125; 动态变量plugin wallbreaker objectsearch com.example.junior.CalculatorActivity 获取该类地址 plugin wallbreaker objectdump 0x1eea 计算1+2=3后查看该类的动态变量 寻找CalculatorActivity实例，通过frida动态hook，通过修改showText值时内存中变量变为123 12345678910111213function dynamicField()&#123; Java.perform(function()&#123; Java.choose(&quot;com.example.junior.CalculatorActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance &#x3D;&gt;&quot;,instance); console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.showText.value) instance.showText.value &#x3D; &quot;123&quot; &#125;,onComplete:function()&#123; console.log(&#39;Search complete&#39;) &#125; &#125;) &#125;)&#125; 动态主动调用动态调用有参函数，计算机显示666，打印666 12345678910111213function dynamic()&#123; Java.perform(function()&#123; Java.choose(&quot;com.example.junior.CalculatorActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance &#x3D;&gt;&quot;,instance); console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.clear(&quot;666&quot;)) console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.showText.value) &#125;,onComplete:function()&#123; console.log(&#39;Search complete&#39;) &#125; &#125;) &#125;)&#125; RPC调用12345678910111213141516171819import frida# device&#x3D;frida.get_device_manager().add_remote_device(&#39;192.168.0.100:5555&#39;) 远程连接.&#x2F;fs128arm64 -l 0.0.0.0:5555,可定义多个device实现批量自动化群控device &#x3D; frida.get_usb_device()### attachpid&#x3D;device.get_frontmost_application().pid # 若双进程保护，指定pid进行hooksession &#x3D; device.attach(pid)### spawn #pid &#x3D; device.spawn([&quot;com.example.junior&quot;])#device.resume(pid)#time.sleep(1)#session &#x3D; device.attach(pid)with open(&quot;demo.js&quot;) as f: script &#x3D; session.create_script(f.read())script.load()input() 键盘操作input keyevent 4 表示后退 1234567function subcommand()&#123; Java.perform(function()&#123; &#x2F;&#x2F; adb input api var process &#x3D; Java.use(&#39;java.lang.Runtime&#39;).getRuntime().exec(&#39;input keyevent 4&#39;); console.log(&#39;subcommand success process is &#39;, process) &#125;)&#125; 循环调用 demo.js中导出指定方法 123rpc.exports &#x3D; &#123; subcommand: subcommand&#125; demo.py中开启循环 1234567command &#x3D; &quot;&quot;while 1 &#x3D;&#x3D; 1: command &#x3D; input(&quot;Enter command:\\n1: Exit\\n2: Call secret function\\nchoice:&quot;) if command &#x3D;&#x3D; &quot;1&quot;: break elif command &#x3D;&#x3D; &quot;2&quot;: # 在这里调用，可以设置多个条件判断 script.exports.subcommand() 输入2对当前进程持续后退 案例二利用nps实现启动了frida-server和nps-client的device的内网穿透，真正意义上实现批量自动化群控 案例三利用ssr通过nps内网穿透实现4G作为出口ip代理供request/scrapy调用 objection和frida不可同时hook一个函数, hook Non-ASCII 对于有些混淆后不可见或乱码的函数名，可以先编码打印出来, 再用编码后的字符串去 hook. 123456789101112131415161718192021Java.perform( function x() &#123; var targetClass &#x3D; &quot;com.example.hooktest.MainActivity&quot;; var hookCls &#x3D; Java.use(targetClass); var methods &#x3D; hookCls.class.getDeclaredMethods(); for (var i in methods) &#123; console.log(methods[i].toString()); console.log(encodeURIComponent(methods[i].toString().replace(&#x2F;^.*?\\.([^\\s\\.\\(\\)]+)\\(.*?$&#x2F;, &quot;$1&quot;))); &#125; hookCls[decodeURIComponent(&quot;%D6%8F&quot;)] .implementation &#x3D; function (x) &#123; console.log(&quot;original call: fun(&quot; + x + &quot;)&quot;); var result &#x3D; this[decodeURIComponent(&quot;%D6%8F&quot;)](900); return result; &#125; &#125;) hook Intent MainActivity中Intent intent2 = new Intent(this, Class.forName(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;));我们通过frida打印Intent 参考资料： Android App 保护那些事儿 （一） Android App 保护那些事儿 (二) frida dexclassloader 从三道题目入手入门frida Frida 入门小练习 举杯邀Frida，对影成三题 Null混淆 Android 字符串及字典混淆开源实现 资源压缩 Android微信逆向–实现发朋友圈动态 微信朋友圈分析 实用FRIDA进阶：脱壳、自动化、高频问题 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"}]},{"title":"动静态分析之去弹窗重打包","slug":"动静态分析之去弹窗重打包","date":"2021-02-09T02:38:07.000Z","updated":"2021-12-12T03:09:39.291Z","comments":true,"path":"2021/02/09/动静态分析之去弹窗重打包/","link":"","permalink":"http://onejane.github.io/2021/02/09/%E5%8A%A8%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8E%BB%E5%BC%B9%E7%AA%97%E9%87%8D%E6%89%93%E5%8C%85/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 重打包带壳应用重打包失败，需要先脱壳 objection的patchapk需要aapt、adb、jarsigner、apktool，其中apktool需要官网下载下，其他前仨在android-studio中就有，注意AndroidStudio版本号： tree -NCfhl|grep aapt 全局搜索aapt tree -NCfhl|grep jarsigner 全局搜索 jarsigner apktool下载jar和编译文件后mv apktool* /usr/local/bin &amp;&amp; chmod 777 /usr/local/bin/apktool* 12345ln -s /root/Desktop/android-studio/jre/bin/jarsigner /usr/binln -s /root/Android/Sdk/build-tools/30.0.3/aapt /usr/binln -s /root/Android/Sdk/build-tools/30.0.3/aapt2 /usr/binln -s /root/Android/Sdk/platform-tools/adb /usr/bin ln -s /root/Android/Sdk/build-tools/30.0.3/zipalign /usr/bin 获取到重打包Fulao2_2021-02-09.objection.apk，卸载fulao2后重新安装adb install -r Fulao2_2021-02-09.objection.apk 123pyenv local 3.8.5apt install aapt zipalignproxychains objection patchapk --architecture armeabi-v7a --source Fulao2_2021-02-09.apk 虚拟机中没有native层无法安装 内存信息搜索与执行 12345cd /data/local/tmp &amp;&amp; ./fs1428arm64 启动frida serverobjection -g com.ilulutv.fulao2 explorememory list modules 查看app加载的so模块memory list exports libcipher-lib.so --json /root/Desktop/fulao.libcipher.json 导出库所有函数android heap search instances android.graphics.Bitmap 获取内存中图片对象 1234android heap execute 257601546 getHeight --return-string 数字串是HashCode,获取图片高度android heap execute 257601546 getWidth --return-string android heap evaluate 257601546 打印带参数的方法返回值console.log(clazz.getPixel(10,20)) 在控制台中输入js脚本，调用有参函数 启动activity或service 1234567891011android hooking list activities 查看当前可用的activitiesandroid intent launch_activity com.ilulutv.fulao2.me.news.NewsActivity 启动指定Activityandroid hooking list receivers 查看当前可用广播android hooking list services android hooking watch class android.graphics.Bitmap hook图片所有方法jobs list 查看hook了116个函数,ID为oj90asdcjobs kill oj90asdc 取消hookandroid hooking watch class_method android.graphics.Bitmap.nativeRowBytes --dump-args --dump-backtrace --dump-return hook指定方法android hooking watch class android.graphics.BitmapFactory hook图片所有函数android hooking watch class_method android.graphics.BitmapFactory.decodeByteArray --dump-args --dump-backtrace --dump-return 直接得到图片数据流android hooking watch class_method android.graphics.BitmapFactory.decodeByteArray --dump-backtrace 获取显示图片前解密的函数，去jadx中查看该方法逻辑 objection自带集成flask api，可以通过rpc跑预置的命令，也可以自己传脚本到手机上跑 123456objection -g com.ilulutv.fulao2 explore --enable-apicurl -s \"http://127.0.0.1:8888/rpc/invoke/androidFileCwd\"curl -s \"http://127.0.0.1:8888/rpc/invoke/androidHookingListActivities\"curl -s \"http://127.0.0.1:8888/rpc/invoke/androidHookingGetClasses\" url -s -X POST \"http://127.0.0.1:8888/rpc/invoke/androidHookingGetClassMethods\" -H \"Content-Type: application/json\" -d '&#123;\"clazz\": \"android.graphics.BitmapFactory\"&#125;' curl -s -X POST \"http://127.0.0.1:8888/rpc/invoke/androidHookingWatchClass\" -H \"Content-Type: application/json\" -d '&#123;\"clazz\": \"android.graphics.BitmapFactory\"&#125;' 启动hook BitmapFactory，job lisk可以查看hook 脱壳objection patchapk –architecture arm64-v8a –source movetv.apk 重打包出错，加壳(腾讯)应用无法objection patchapk objection -g com.cz.babySister explore -P ~/.objection/plugins/dexdump/frida_dexdump 1234567891011pyenv local 3.8.5proxychains git clone https://github.com/hluwa/FRIDA-DEXDump ~/Downloads/FRIDA-DEXDumpmv ~/Downloads/FRIDA-DEXDump/frida_dexdump ~/.objection/plugins/dexdumpadb install movetv.apkobjection -g com.cz.babySister explore -P ~/.objection/plugins 加载全部插件启动app多运行一会plugin dexdump dump 脱壳cd com.cz.babySister/grep -ril \"MainActivity\" * 查看主入口dexobjection -g com.cz.babySister exploreandroid hooking list activitiesandroid intent launch_activity com.cz.babySister.activity.MainActivity 不登录进Activity，判断是否越权bug 无壳去更新重打包环境/root/Android/Sdk/build-tools/30.0.3/d8 MainActivity 直接生成dex文件，老版的是d8-&gt;dx adb install zhibo.apk 安装apk,启动新版本更新弹窗 分析123456789pyenv local 3.8.5cd /data/local/tmp/ &amp;&amp; ./fs1428arm64objection -g com.hd.zhibo exploreandroid hooking list activities 只有一个主界面com.zhibo.media.channel_main，在AndroidManifest.xml中只有一个activityandroid heap search instances android.app.AlertDialog 获取弹窗实例hashcode,在弹窗出现前hookplugin load /root/.objection/plugins/Wallbreakerplugin wallbreaker objectsearch android.app.AlertDialog 找到实例的地址plugin wallbreaker objectdump 0x2956 打印类结构，其中AlertController 指向地址是0x2b26plugin wallbreaker objectdump 0x2b26 拿出该类中的具体信息 重新hook 类AlertDialog，并打印出调用栈 12345adb shellps -e| grep zhibo kill 18149 干掉进程objection -g com.hd.zhibo explore 启动超级直播android hooking watch class android.app.AlertDialog 在弹窗弹出之前开始hook android hooking watch class_method android.app.AlertDialog.onCreate --dump-args --dump-backtrace --dump-return 再次在弹窗弹出前hook OnCreate方法 通过jadx搜索com.zhibo.media.channel_receiver.onReceive和com.zhibo.media.channel_main.update_show定位到核心弹窗判断逻辑 12345public void update_show(Bundle bundle) &#123; if (bundle != null &amp;&amp; bundle.containsKey(\"ver\") &amp;&amp; bundle.containsKey(\"info\") &amp;&amp; bundle.containsKey(\"path\")) &#123; new AlertDialog.Builder(this).setTitle(\"发现新版本 \" + bundle.getString(\"ver\") + \" 是否升级\").setMessage(bundle.getString(\"info\")).setPositiveButton(\"立刻升级\", new o(this, bundle)).show(); &#125;&#125; 或者objection -g com.hd.zhibo explore --startup-command &quot;android hooking watch class_method android.app.AlertDialog.onCreate --dump-args --dump-backtrace --dump-return&quot; 启动时则运行命令即可避免在弹窗前跟不上执行hook 去弹窗apktool d zhibo.apk &amp;&amp; vim zhibo/smali/com/zhibo/media/channel_main.smali 解包并搜索info，修改if-eqz改为if-nez 12345678apktool b zhibo/ 重打包cd zhibo/dist &amp;&amp; keytool -genkey -alias abc.keystore -keyalg RSA -validity 20000 -keystore abc.keystoreIs CN=Unknown, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown correct? [no]: yesjarsigner -verbose -keystore abc.keystore -signedjar textx.apk zhibo.apk abc.keystorepm uninstall com.hd.zhibo 卸载包adb install textx.apk 安装包am start-activity com.hd.zhibo 启动包 加壳去更新重打包adb install 青青草视频.apk 启动弹窗是强制升级 jadx打开包,com.SecShell.SecShell 梆梆加固 环境12345678pyenv local 3.8.0 &amp;&amp; ./data/local/tmp/fs128arm64top 查看进程最高是com.hello.qqc┌──(root💀kali)-[~/Desktop]└─# frida-ps -U|grep hello 双线程 23169 com.hello.qqc23190 com.hello.qqc23247 com.hello.qqc:pushcore23277 com.hello.qqc:pushcore 脱壳 objection plugin 12objection -g com.hello.qqc explore -P ~/.objection/plugins 加载所有插件，关闭所有qqc进程，使用objection启动hookplugin dexdump dump 多进程的话，用objection先占用一个，再frida dexdump python main.py 通过cd ~/.objection/plugins/dexdump &amp;&amp; python main.py 由于双进程，需要用objection先占住启动进程，再判断前台进程进行脱壳 frida-dexdump pip install frida-dexdump 通过直接运行frida-dexdump进行脱壳 越权12android hooking list activitiesandroid intent launch_activity cn.net.tokyo.ccg.ui.activity.AboutActivity 进入关于我们页面，绕过弹窗，再进入其他页面发现依旧存在升级弹窗 弹窗分析基于objection进程动态hook弹窗 Window查看类是否可以hook 123android hooking list classes cat ~&#x2F;.objection&#x2F;objection.log |grep -i window 如果有则可以hookobjection -g com.hello.qqc explore --startup-command &quot;android hooking watch class android.view.Window&quot; 对所有该Window类进行hook 点击立即升级，objection显示新增agent如下 Dialog12cat ~&#x2F;.objection&#x2F;objection.log |grep -i dialogobjection -g com.hello.qqc explore --startup-command &quot;android hooking watch class android.app.Dialog&quot; 点击立即升级，objection显示新增agent如下 点击弹窗也有agentlog打印出调用Dialog方法 PopupWindow&amp;AlertDialog12345objection -g com.hello.qqc explore --startup-command &quot;android hooking watch class android.widget.PopupWindow&quot;或者objection -g com.hello.qqc exploreandroid hooking watch class android.widget.PopupWindowandroid hooking watch class android.app.AlertDialog 点击立即升级发现无新agentlog新增 主要可能是Dialog弹窗嫌疑最大，其中agent的log(agent) [5384329357348] Called android.app.Dialog.setCancelable(boolean) 1android hooking watch class_method android.app.Dialog.setCancelable --dump-args --dump-backtrace --dump-return 通过jadx搜索脱壳下的dex文件cn.net.tokyo.ccg.ui.fragment.dialog.UpdateDialogFragment的onCreateDialog方法 12345678910111213141516171819202122public Dialog onCreateDialog(@Nullable Bundle bundle) &#123; FragmentActivity activity &#x3D; getActivity(); activity.getClass(); Dialog dialog &#x3D; new Dialog(activity, 2131755208); dialog.requestWindowFeature(1); dialog.setContentView(2131427414); VersionBean.Version version &#x3D; this.f2134a; if (version !&#x3D; null) &#123; dialog.setCanceledOnTouchOutside(!WakedResultReceiver.CONTEXT_KEY.equals(version.status)); dialog.setCancelable(true ^ WakedResultReceiver.CONTEXT_KEY.equals(this.f2134a.status)); Window window &#x3D; dialog.getWindow(); if (window !&#x3D; null) &#123; window.setBackgroundDrawable(new ColorDrawable(0)); WindowManager.LayoutParams attributes &#x3D; window.getAttributes(); attributes.width &#x3D; -1; attributes.height &#x3D; -1; window.setAttributes(attributes); &#125; a(dialog); &#125; return dialog;&#125; 调用了a(dialog); 12345678910111213141516171819202122232425private void a(Dialog dialog) &#123; Button button &#x3D; (Button) dialog.findViewById(b.btn_force_update); Button button2 &#x3D; (Button) dialog.findViewById(b.btn_update); Button button3 &#x3D; (Button) dialog.findViewById(b.btn_cancel); TextView textView &#x3D; (TextView) dialog.findViewById(b.tv_file_size); LinearLayout linearLayout &#x3D; (LinearLayout) dialog.findViewById(b.ll_button); ((TextView) dialog.findViewById(b.tv_version)).setText(String.format(Locale.getDefault(), &quot;版本号：%s&quot;, this.f2134a.version)); ((TextView) dialog.findViewById(b.tv_content)).setText(this.f2134a.desc); if (!TextUtils.isEmpty(this.f2134a.filesize)) &#123; textView.setText(String.format(Locale.getDefault(), &quot;文件大小: %s&quot;, this.f2134a.filesize)); &#125; ImageView imageView &#x3D; (ImageView) dialog.findViewById(b.im_close); if (WakedResultReceiver.CONTEXT_KEY.equals(this.f2134a.status)) &#123; linearLayout.setVisibility(8); button.setVisibility(0); button.setOnClickListener(new f(this)); return; &#125; linearLayout.setVisibility(0); button.setVisibility(8); button3.setOnClickListener(new g(this)); imageView.setVisibility(0); imageView.setOnClickListener(new d(this)); button2.setOnClickListener(new e(this));&#125; 中文搜索，可能被字符串混淆加密，Android 字符串及字典混淆开源实现,或通过wallbreak查看类结构，避免字符串加密。 plugin wallbreaker objectsearch cn.net.tokyo.ccg.ui.fragment.dialog.UpdateDialogFragment 搜索类地址 plugin wallbreaker objectdump –fullname 0x2452 打印类结构 通过点击立即升级按钮，打印调用栈如下，jadx搜索cn.net.tokyo.ccg.ui.activity.MainActivity.a @Override // b.a.a.a.d.b.z public void a(VersionBean.Version version, boolean z) { this.f1696a = version.url; if (version != null) { UpdateDialogFragment.b(version, z).show(getSupportFragmentManager(), UpdateDialogFragment.class.getSimpleName()); } } 去壳123apktool -s d 青青草视频.apk &amp;&amp; cd 青青草视频&#x2F; 解包指定不反编译源码并保留dex，并扔掉壳cp ~&#x2F;Desktop&#x2F;com.hello.qqc&#x2F;*.dex . 将之前去壳后的dex放入解包文件夹thunar . 打开所在文件夹，ctrl+2以详细信息查看文件，根据大小进行重命名dex，classes.dex,classes2.dex... 在jadx中搜索extends Application 找到主入口文件cn.net.tokyo.ccg.base.App,vim AndroidManifest.xml 搜索application标签，修改android:name=&quot;com.SecShell.SecShell.ApplicationWrapper&quot; 为android:name=&quot;cn.net.tokyo.ccg.base.App&quot;修改加壳入口点为原app的入口点。 12345apktool b 青青草视频 回编译cd 青青草视频&#x2F;dist 编译完成的apkkeytool -genkey -alias abc.keystore -keyalg RSA -validity 20000 -keystore abc.keystorejarsigner -verbose -keystore abc.keystore -signedjar qqc_signed.apk 青青草视频.apk abc.keystore 签名adb install -r qqc_signed.apk 重新安装编译后的apk，即脱壳后的重打包dex 去弹窗12345678910apktool d 青青草视频.apkcd 青青草视频&#x2F;tree -NCfhl | grep MainActivityvim .&#x2F;青青草视频&#x2F;smali&#x2F;cn&#x2F;net&#x2F;tokyo&#x2F;ccg&#x2F;ui&#x2F;activity&#x2F;MainActivity.smali 搜索UpdateDialogFragment修改if-eqz p1, :cond_0为if-nez p1, :cond_0apktool b 青青草视频&#x2F; 回编译cd 青青草视频&#x2F;dist 编译完成的apkkeytool -genkey -alias abc.keystore -keyalg RSA -validity 20000 -keystore abc.keystorejarsigner -verbose -keystore abc.keystore -signedjar qqc2_signed.apk 青青草视频.apk abc.keystore 重签名adb install -r qqc2_signed.apk 重新安装编译后的apk var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"}]},{"title":"动静态分析之锁机病毒","slug":"动静态分析之锁机病毒","date":"2021-02-05T09:22:07.000Z","updated":"2021-12-12T03:09:39.291Z","comments":true,"path":"2021/02/05/动静态分析之锁机病毒/","link":"","permalink":"http://onejane.github.io/2021/02/05/%E5%8A%A8%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E4%B9%8B%E9%94%81%E6%9C%BA%E7%97%85%E6%AF%92/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 小试牛刀创建demoAndroid Studio新建demo项目 MainActivity 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity &#123; EditText username_et; EditText password_et; TextView message_tv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); password_et = (EditText) this.findViewById(R.id.editText2); username_et = (EditText) this.findViewById(R.id.editText); message_tv = ((TextView) findViewById(R.id.textView)); this.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (username_et.getText().toString().compareTo(\"admin\") == 0) &#123; message_tv.setText(\"You cannot login as admin\"); return; &#125; //hook target message_tv.setText(\"Sending to the server :\" + Base64.encodeToString((username_et.getText().toString() + \":\" + password_et.getText().toString()).getBytes(), Base64.DEFAULT)); for(int i=0;i&lt;100;i++)&#123; Log.i(\"onejane\",\"now i is\"+Integer.valueOf(i)); &#125; &#125; &#125;); &#125;&#125; activity_main.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"请输入纯数字\" tools:layout_editor_absoluteX=\"159dp\" tools:layout_editor_absoluteY=\"120dp\" /&gt; &lt;EditText android:id=\"@+id/editText\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:ems=\"10\" android:inputType=\"textPersonName\" android:hint=\"name\" tools:layout_editor_absoluteX=\"98dp\" tools:layout_editor_absoluteY=\"196dp\" /&gt; &lt;EditText android:id=\"@+id/editText2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:ems=\"10\" android:inputType=\"textPersonName\" android:hint=\"password\" tools:layout_editor_absoluteX=\"98dp\" tools:layout_editor_absoluteY=\"313dp\" /&gt; &lt;Button android:id=\"@+id/button\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Button\" tools:layout_editor_absoluteX=\"171dp\" tools:layout_editor_absoluteY=\"428dp\" /&gt; &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; debug启动，点击BUTTON打断点动态调试。 动态调试查看包名 :dumpsys activity top|grep demo debug启动应用:adb shell am start -D -n com.example.demo/.MainActivity 使用jeb tab进入smali，ctrl+b附加断点，关闭as，ddms等占用adb应用，jeb开启debug,修改变量类型为string查看变量内容 内存漫游启动frida:./fs1428arm64 启动app：pm list packages|grep demo 内存漫游:objection -g com.example.demo explore -P /root/.objection/plugins 通过hook关键Base64函数:android hooking watch class_method android.util.Base64.encodeToString --dump-args --dump-backtrace --dump-return 输入username和password点击button操作，抓取内存中android.util.Base64.encodeToString入参及返回 1234567plugin wallbreaker objectsearch com.example.demo.MainActivity 拿到进程地址plugin wallbreaker objectdump --fullname 0x22d6 动态查看对象属性plugin wallbreaker classdump --fullname com.example.demo.MainActivity 动态查看内存中的MainActivityplugin wallbreaker classdump --fullname androidx.appcompat.app.AppCompatActivityapktool d demo.apk 解包thunar demo/smali/com/example/demo/MainActivity.smali 查看smalimousepad demo/smali/com/example/demo/MainActivity.smali AndroidManifest.xml debuggable属性，意为“可调试”，有true和false两种模式。android:debuggable=”true”，不可调试应用可通过xdebuggable模块实现jeb无源码调试smali。 如果打包的是debug版本的apk文件，那么这个debuggable属性就自动设置为true，反之，如果打包的是release版本的apk文件，那么这个debuggable属性就自动设置为false 使用jeb打开zhibo.apk，jeb开启debug attach com.hd.zhibo 12dumpsys activity top|grep zhibo adb shell am start -D -n com.hd.zhibo&#x2F;com.zhibo.media.channel_main 使用debug启动应用 Kali Linux里的as4的DDMS启动失败，原因是要用as自带的jre来启动，直接./monitor用的是Kali系统的jdk，版本太高了 12ln -s &#x2F;root&#x2F;Desktop&#x2F;android-studio&#x2F;jre&#x2F; &#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;tools&#x2F;lib&#x2F;monitor-x86_64&#x2F;cd &#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;tools&#x2F;lib&#x2F;monitor-x86_64&#x2F; &amp;&amp; .&#x2F;monitor 点击Dump View Hierarchy for UI Automator,定位到元素所属类 Open Perspective 打开Hierarchy View中的View 可以快速定位到AdView,拿到子类zzbbq即可hook该方法，使用jeb定位搜索zzbbq，干掉广告组件。 锁机病毒换不锈钢脸盆adb install yry-1.0.apk 启动app后，场面异常血腥，不忍直视。 背景图片和背景音乐极其不健康 音量被调到最大，循环播放，且无法关闭 屏幕被锁定，无法进行任何操作 usb断开 开机自动启动 手机持续震动 通过移动安全威胁数据平台检测得知app开启了以下权限 不解释连招打开源码分析，好家伙吗，我直接好家伙！！！充满了对家人的亲切问候，名字挺好听，人干的事一点都不沾边。 气的我又买了个手机，重新装上该app，上去就是frida+objection+jeb+jadx动静态分析一套不解释组合连招直接带走。 静态分析通过jadx反编译AndroidManifest.xml中看到大片的uses-permission申请权限，以及对广播的receiver中申请的action，用于监听广播自启动调用action，妙啊，后续一系列的病毒实现广播监听就是罪魁祸首。 不同反编译软件要结合着看，同一个软件不同版本可能结果都不一样，比如jeb3中将解锁加密逻辑判断为 if(颜如玉QQ2693533893.getSaltMD5(MyServiceOne.颜如玉(v2.substring(0, 3))) + v2.substring(3, v2.length()).equals(&quot;9DDEB743E935CE399F1DFAF080775366&quot; + v3_1)) 不能说逻辑严密吧，可以说是狗屁不通,字符串+布尔值居然还能放到if条件里，giao！！！ FloatViewUtil UI工具类 MainActivity 入口 MyBroadcast 继承自BroadcastReceiver实现启动时调用onReceive MyServiceOne 加解密服务类 UsbLock 锁死usb接口 动态分析1.如何做到adb找不到设备，直接断开连接，无法hook动态分析，也没法DDMS？ UsbLock继承自TimerTask，在重新run方法中执行一句话命令Process exec = Runtime.getRuntime().exec(&quot;setprop persist.sys.usb.config none&quot;); 方案一:apktool解包后修改smali源码注释掉这行smali指令并编译重打包，keytool制作秘钥库，apksigner重签名安装。 123456apktool d yry-1.0.apk 解包cd yry-1.0&#x2F;smali&#x2F;com&#x2F;shimeng&#x2F;诗梦 &amp;&amp; vim USBLock.smali 干掉这一行const-string v10, &quot;setprop persist.sys.usb.config none&quot;apktool b yry-1.0 回编译cd yry-1.0&#x2F;dist &amp;&amp; keytool -genkey -alias abc.keystore -keyalg RSA -validity 20000 -keystore abc.keystore 制作秘钥jarsigner -verbose -keystore abc.keystore -signedjar new_yry.apk yry-1.0.apk abc.keystore 重签名安装new_yry.apk 方案二:实现安装上termux，启动好frida即可 1234567adb push frida-server-14.2.8-android-x86 &#x2F;data&#x2F;local&#x2F;tmp 赋予最高权限 adb install com.termux_92.apk cd &#x2F;data&#x2F;local&#x2F;tmp &amp;&amp; chmod 777 * &amp;&amp; .&#x2F;frida-server-14.2.8-android-x86 -l 0.0.0.0:8888 启动fridapyenv local 3.8.5 切换py版本,保证objection frida版本对应frida-ps -H 192.168.0.104:8888 | grep shimeng 查找病毒进程确实存在objection -N -h 192.168.0.104 -p 8888 -g com.shimeng.qq2693533893 explore 开启内存分析android hooking list classes 2.如何做到无法关闭音量，循环播放富强民主文明和谐的音乐？ 12android hooking list services 拿到可hook的方法android hooking list receivers 12plugin wallbreaker classdump com.shimeng.qq2693533893.MyServiceOne --fullname 内存漫游可视化这两个类的源码结构plugin wallbreaker classdump com.shimeng.qq2693533893.MyBroadcast --fullname android hooking watch class com.shimeng.qq2693533893.MyServiceOne 通过hook类MyServiceOne 发现MyServiceOne.access$L1000018一直被反复调用 android hooking watch class_method com.shimeng.qq2693533893.MyServiceOne.access$L1000018 --dump-backtrace 我们开始hook该内部类并打印调用栈，发现调用栈上层反复调用com.shimeng.qq2693533893.MyServiceOne.access$100000007.run，想必这就是为什么循环播放的原因了，瞄一波反编译源码，soga，该线程获取到系统audio服务后setStreamVolume调高最大音量，vibrator持续震动。 123456789101112131415161718192021222324class 100000007 implements Runnable &#123; private final MyServiceOne this$0; static MyServiceOne access$0(100000007 arg4) &#123; return MyServiceOne.this; &#125; @Override public void run() &#123; MyServiceOne.this.hand2.postDelayed(this, 1800L); AudioManager v1 = (AudioManager)MyServiceOne.this.getSystemService(\"audio\"); v1.setStreamVolume(3, v1.getStreamMaxVolume(3), 4); v1.getStreamMaxVolume(0); v1.getStreamVolume(0); v1.getStreamVolume(0); Vibrator v4 = (Vibrator)MyServiceOne.this.getApplication().getSystemService(\"vibrator\"); long[] v5 = new long[4]; new long[4][0] = 100L; v5[1] = 1500L; v5[2] = 100L; v5[3] = 1500L; v4.vibrate(v5, -1); &#125;&#125; 3.如何做到锁屏无法退出？ 之前初步分析到疑似UI工具类FloatViewUtil ，在MyServiceOne的m2() sm() sm2()中反复调用，使用frida主动调用FloatViewUtil.removeView() 去掉了锁屏界面，留下空白界面，那么这个空白界面才是真正的activity。 在createfloatview中调用了this.wm.addView(this.v, this.w);，原来是借助WindowManager显示一个全屏置顶的浮窗锁定了屏幕，public void addView(View view, ViewGroup.LayoutParams params);用this.w封装参数flags判断是否取消悬浮窗，每次触摸屏幕调用OnTouchListener后更新this.this$0.wm.updateViewLayout(view2, this.this$0.w);，保持原样，所以锁屏无法操作，除了调用系统库WindowManager.removeView()别无他法。 4.如何做到开机启动并关闭也能复活？ 之前分析AndroidManifest.xml时发现MyBroadcast继承BroadcastReceiver监听了BOOT_COMPLETED启动方法实现onReceive。其中通过if (intent2.getAction() != null) {实现context4.startService(intent5),通过if (Intent.ACTION_SCREEN_ON.equals(intent2.getAction()) &amp;&amp; intent2.getAction() != null) {实现context5.startActivity(intent7)，startService启动的service进程用户不可见，且不会被杀死，除非系统内存不足一保持前台进程和可视进程，这也太tm适合做自启服务了！！！当主动调用拿掉app的强制悬浮时，看到后台依旧有一个MyServiceOne服务偷偷运行，强制kill该进程后，果然不会再次复活了。哦！原来这就是惊喜啊！ KO这个病毒已经被我们开膛破肚了，但是好像从开发角度分析没有太多成就感，那么就硬肛吧！！！伤害高而且侮辱性极强！！！ 之前hook MyServiceOne打印出了内存中所有的类名，由于输入密码需要点击那么就需要onClick，搜索jeb2中发现100000002，100000003，100000006三个匿名内部类中实现了View$OnClickListener的onClick方法，那么先从100000002开肛吧！ 一层解锁12345678910111213141516171819202122232425262728@Override public void onClick(View arg15) &#123; 100000002 v0 &#x3D; this; String v2 &#x3D; v0.val$editText.getText().toString(); if(v2.length() &gt;&#x3D; 3) &#123; String v3 &#x3D; MyServiceOne.颜如玉(颜如玉QQ2693533893.getSaltMD5(new StringBuffer().append(&quot;&quot;).append(v0.val$诗梦).toString())).replaceAll(&quot;\\\\D+&quot;, &quot;&quot;); if(v3.length() &gt; 9 &amp;&amp; v3.length() &gt; 3) &#123; if(new StringBuffer().append(颜如玉QQ2693533893.getSaltMD5(MyServiceOne.颜如玉(v2.substring(0, 3)))).append(v2.substring(3, v2.length())).toString().equals(new StringBuffer().append(&quot;9DDEB743E935CE399F1DFAF080775366&quot;).append(v3.substring(0, 9)).toString())) &#123; v0.this$0.util.removeView(); v0.this$0.sm2(); &#125; else &#123; --v0.this$0.L; ++v0.this$0.B; v0.val$lpo.setText(new StringBuffer().append(new StringBuffer().append(new StringBuffer().append(new StringBuffer().append(new StringBuffer().append(&quot;很抱歉！密码错误解锁请加QQ群:437732815联系管理员购买正确的密码解锁...密码以错&quot;).append(v0.this$0.B).toString()).append(&quot;次！&quot;).toString()).append(&quot;还剩&quot;).toString()).append(v0.this$0.L).toString()).append(&quot;次输入错误密码的机会&quot;).toString()); if(v0.this$0.L &lt;&#x3D; 0) &#123; v0.val$lpo.setText(&quot;本次输入密码错误次数累计以达10次,请重启手机后获取输入密码机会！&quot;); v0.val$button.setVisibility(8); v0.val$textView2.setVisibility(8); v0.val$editText.setVisibility(8); v0.val$a00.setVisibility(8); v0.val$b00.setVisibility(8); v0.val$c00.setVisibility(8); v0.val$d00.setVisibility(8); &#125; &#125; &#125; &#125;&#125; 使用jeb2反编译拿到100000002中解锁的逻辑，那么v2必定是我们输入的字符串，当长度大于3时调用MyServiceOne.颜如玉方法，那么就hook这个颜如玉 android hooking watch class_method com.shimeng.qq2693533893.MyServiceOne.颜如玉 --dump-args --dump-backtrace --dump-return 打印调用栈果然调用了onClick方法，页面弹出很抱歉！密码错误解锁等恰好是onClick中解锁失败返回的信息 在sm()方法中拿到生成识别码的逻辑，跟进去原来是随机四位数做了火星文对应，在100000002构造函数中this.val$诗梦 = arg17;就是随机四位数v11 ^ 1288，，所以才显示在前台页面是火星文，那么我们首先通过hook颜如玉QQ2693533893.get()拿到四位数对应的该火星文。 123int v11 &#x3D; ((int)(Math.random() * (((double)9876))));v4.setText(new StringBuffer().append(&quot;你的识别码&#x3D;&quot;).append(颜如玉QQ2693533893.get(new StringBuffer().append(&quot;&quot;).append(v11).toString())).toString());v3.setOnClickListener(new 100000002(this, v5, v11 ^ 1288, v6, v3, v4, v7, v8, v9, v10)); 接着分析onClick方法可知随机四位数被作为参数给了getSaltMD5,那么我们可以通过反射和四位数拿到v3的值。 12345String v3 &#x3D; MyServiceOne.颜如玉(颜如玉QQ2693533893.getSaltMD5(new StringBuffer().append(&quot;&quot;).append(v0.val$诗梦).toString())).replaceAll(&quot;\\\\D+&quot;, &quot;&quot;);if(new StringBuffer().append(颜如玉QQ2693533893.getSaltMD5(MyServiceOne.颜如玉(v2.substring(0, 3)))).append(v2.substring(3, v2.length())).toString().equals(new StringBuffer().append(&quot;9DDEB743E935CE399F1DFAF080775366&quot;).append(v3.substring(0, 9)).toString())) &#123; v0.this$0.util.removeView(); v0.this$0.sm2();&#125; frida脚本编写如下： 123456789101112131415161718function stage1()&#123; Java.perform(function()&#123; var javaString &#x3D; Java.use(&#39;java.lang.String&#39;) for(var i&#x3D;999;i&lt;10000;i++)&#123; var i_str &#x3D; javaString.$new(String(i)); var recogCode &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).get(i_str); var final_last9 &#x3D; Java.use(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;).颜如玉(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).getSaltMD5((javaString.$new(String(i^1288))))); var final_final_last9 &#x3D; javaString.$new(final_last9).replaceAll(&quot;\\\\D+&quot;, &quot;&quot;); console.log(&quot;i_str,recogCode,final_final_last9:&quot;,i_str,recogCode,final_final_last9); if (recogCode &#x3D;&#x3D; &quot;©©&#x2F;÷&quot;)&#123; &#x2F;&#x2F; 5147 break; &#125; &#125; &#125;)&#125; frida -H 192.168.0.104:8888 -f com.shimeng.qq2693533893 -l yry.js 并运行stage1()拿到四位数,火星文,加密串对应关系 1234567891011i_str,recogCode,final_final_last9: 5582 ©©※÷ 95207171906204966108845772i_str,recogCode,final_final_last9: 5583 ©©※∷ 39716345426943642188517i_str,recogCode,final_final_last9: 5584 ©©※● 5796073015486055711181i_str,recogCode,final_final_last9: 5585 ©©※© 4182232792980711126331187i_str,recogCode,final_final_last9: 5586 ©©※额 99099593856461775560719982i_str,recogCode,final_final_last9: 5587 ©©※★ 19863461630870460433322044i_str,recogCode,final_final_last9: 5588 ©©※※ 9011175927236532778650i_str,recogCode,final_final_last9: 5589 ©©※&#x2F; 132271537343570495458138i_str,recogCode,final_final_last9: 5590 ©©&#x2F;嘻 7083188607268447436716i_str,recogCode,final_final_last9: 5591 ©©&#x2F;❥ 61563069152823766973923722i_str,recogCode,final_final_last9: 5592 ©©&#x2F;÷ 50084396538178613588090863 接着分析这个equals大长串,很明显前面字符串md5(颜如玉(输入串(0,3)))+输入串(3,).equals(“9DDEB743E935CE399F1DFAF080775366”+加密串前9位) 众所周知，MD5是128位二进制位，一位16进制数=4位二进制数，以16进制显示为32位字符串，那么md5(颜如玉(输入串(0,3))) === “9DDEB743E935CE399F1DFAF080775366”，且输入串(3,)=加密串前9位。 通过剥离反编译后的算法，拿到输入串前3位为358，加上输入串(3,)即加密串前9位500843965===》输入串v2=358500843965 一giao我里giaogiao 二层解锁 giao中计了 耐心分析，原来只是故技重施，雕虫小技而已，随机数从四位变成了五位，加密方法修改了下而已。 12345String v3 &#x3D; 颜如玉QQ2693533893.hex_sha1(MyServiceOne.破解死妈.getTwiceMD5ofString(new StringBuffer().append(&quot;&quot;).append(v0.val$u2).toString())).replaceAll(&quot;\\\\D+&quot;, &quot;&quot;);if(v3.length() &gt; 9 &amp;&amp; v3.length() &gt; 3 &amp;&amp; (new StringBuffer().append(MyServiceOne.破解死妈.getTwiceMD5ofString(颜如玉QQ2693533893.hex_sha1(v2.substring(0, 3)))).append(v2.substring(3, v2.length())).toString().equals(new StringBuffer().append(&quot;8D4FF507DCDA63C201EB8B99D4170900&quot;).append(v3.substring(0, 9)).toString()))) &#123; v0.this$0.util.removeView(); v0.this$0.诗梦();&#125; 同样的方式，修改frida脚本如下： 123456789101112131415161718192021222324252627function stage2()&#123; Java.perform(function()&#123; var QQinstance &#x3D; null; Java.choose(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance :&quot;,instance); QQinstance &#x3D; instance; &#125;,onComplete:function()&#123;console.log(&quot;search Competed!&quot;)&#125; &#125;) console.log(&quot;QQinstance is :&quot;,QQinstance) var javaString &#x3D; Java.use(&#39;java.lang.String&#39;) for (var i &#x3D; 9999;i&lt;100000;i++)&#123; var i_str &#x3D; javaString.$new(String(i)); var recogCode &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).get(i_str); var final_right9 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).hex_sha1(QQinstance.getTwiceMD5ofString(i_str)); var finalFinalright9 &#x3D; javaString.$new(final_right9).replaceAll(&quot;\\\\D+&quot;, &quot;&quot;); console.log(&quot;i_str,recogCode,finalFinalright9&quot;,i_str,recogCode,finalFinalright9) if (recogCode &#x3D;&#x3D; &quot;※嘻额❥&#x2F;&quot;)&#123; &#x2F;&#x2F; 98074 break; &#125; &#125; &#125;)&#125; frida -H 192.168.0.104:8888 -f com.shimeng.qq2693533893 -l yry.js 并运行stage2()拿到四位数,火星文,加密串对应关系 123456i_str,recogCode,finalFinalright9 80614 ※嘻额❥● 387001687403591151857740i_str,recogCode,finalFinalright9 80615 ※嘻额❥© 82202783102877783960515732i_str,recogCode,finalFinalright9 80616 ※嘻额❥额 20062102770068853202687179i_str,recogCode,finalFinalright9 80617 ※嘻额❥★ 13702574120572139433375947i_str,recogCode,finalFinalright9 80618 ※嘻额❥※ 681123636848227458618110944i_str,recogCode,finalFinalright9 80619 ※嘻额❥&#x2F; 93184320701127896024850 拿到输入串v2=694931843207 一giao我里giaogiao 三层解锁 giao又双叒叕中计了 耐心分析，jeb2反编译发现这次不是故技重施，而是要放大招了 12345678910111213141516@Override public void onClick(View arg12) &#123; 100000006 v0 &#x3D; this; new Thread(new 100000004(v0)).start(); if(颜如玉QQ2693533893.hex_sha1(&quot;破解死妈&quot;).equals(v0.this$0.坐等前往世界的尽头的小船)) &#123; v0.this$0.util.removeView(); new Timer().schedule(new 100000005(v0), ((long)1500)); &#125; else if(颜如玉QQ2693533893.hex_sha1(v0.val$fuck.getText().toString()).equals(v0.this$0.坐等前往世界的尽头的小船)) &#123; v0.this$0.util.removeView(); &#125; else &#123; v0.this$0.解锁.setVisibility(0); v0.this$0.解锁.setText(new StringBuffer().append(new StringBuffer().append(&quot;密码错误，手机恢复正常失败&quot;).append(&quot;&#x2F;n&quot;).toString()).append(&quot;Manifest-Version: 1.0Created-By: 1.0 (Android SignApk)&quot;).toString()); v0.this$0.hand3.postDelayed(v0.this$0.runn3, ((long)2000)); &#125;&#125; 这次输入的值经过hex_sha1后要和变量v0.this$0.坐等前往世界的尽头的小船一致才行，通过smali插桩打印log重打包或者通过hook String的equals方法得知这个变量居然为空，也就是无论如何也不可能解开了，这局又是逆风局。 smali插桩： 通过Android逆向助手反编译apk中的dex，找到指定方法所在的smali文件，打印变量处添加log，将crack.smali放到com同级目录下，log打印使用方式 12345678输出byteinvoke-static &#123;v*&#125;, Lcrack;-&gt;convertByteArrayToString([B)Ljava&#x2F;lang&#x2F;String;输出stringinvoke-static &#123;v*&#125;, Lcrack;-&gt;log(Ljava&#x2F;lang&#x2F;String;)V输出tag&#x3D;&#x3D;Debug-Info&#x3D;&#x3D; 将classes目录通过Android逆向助手重打包dex，不解压原apk并生成的dex直接替换原apk中的classes.dex并安装改过的apk 全局搜索坐等前往世界的尽头的小船发现这是个全局变量，在内部类100000006的内部类100000004中存在赋值 123456789101112131415@Override public void run() &#123; 100000001 v0 &#x3D; this; 100000001 v4 &#x3D; v0; try &#123; String v1 &#x3D; v4.this$0.独自走在孤独的雨中(&quot;https:&#x2F;&#x2F;www.lanzous.com&#x2F;b897189&quot;); String v2 &#x3D; v1.substring(v1.indexOf(&quot;【&quot;), v1.indexOf(&quot;】&quot;)).replace(&quot;【&quot;, &quot;&quot;); if(&quot;&quot;.equals(v2)) &#123; return; &#125; v0.this$0.smsOpera(v2); &#125; catch(Exception v4_1) &#123; &#125;&#125; 独自走在孤独的雨中是一个http请求工具类，返回请求结果，那么打开这个地址需要输入密码，看起来应该是作者会给到倒霉蛋的密码，然后输入即可拿到子串，请求不听的向该地址发送，知道拿到子串后smsOpera发送短信，即可给内存中变量v0.this$0.坐等前往世界的尽头的小船赋值，那么新机词挖一此莫bai禾多此！ 12345678910111213function stage3()&#123; Java.perform(function()&#123; var javaString &#x3D; Java.use(&#39;java.lang.String&#39;) var ikey &#x3D; javaString.$new(String(123456)) var ikeySign &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).hex_sha1(ikey) Java.choose(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance&quot;,instance) instance.坐等前往世界的尽头的小船.value &#x3D; ikeySign; &#125;,onComplete()&#123;console.log(&quot;search completed!&quot;)&#125; &#125;) &#125;)&#125; frida -H 192.168.0.104:8888 -f com.shimeng.qq2693533893 -l yry.js 并运行stage3()利用frida在内存中给坐等前往世界的尽头的小船进行赋值，再输入123456，终于解锁。 我是J，一个让你沉迷于技术的讲述者。 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"kali","slug":"kali","permalink":"http://onejane.github.io/tags/kali/"}]},{"title":"加壳与脱壳之基本原理","slug":"加壳与脱壳之基本原理","date":"2021-02-04T02:39:05.000Z","updated":"2021-12-12T03:09:39.290Z","comments":true,"path":"2021/02/04/加壳与脱壳之基本原理/","link":"","permalink":"http://onejane.github.io/2021/02/04/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 逆向基本流程 使用自动化检测工具检测apk是否加壳，或者借助一些反编译工具依靠经验推断是否加壳 GDA3.85 或者 常见so文件 《娜迦》企业版本加固 libedog.so 《娜迦》免费版本加固 libddog.so 《梆梆》企业版本加固 libDexHelper.so 《梆梆》免费版本加固 libsecexe.so 《爱加密》企业版本加固 ijiami.ajm 《爱加密》免费版本加固 libexec.so 《通付盾》加固 libegis.so 《360》加固 libprotectClass.so，libjiagu.so 《百度》加固 libbaiduprotect.so 《阿里》加固 libmobisec.so 《腾讯》加固 libtup.so 《盛大》加固 libapssec.so 《瑞星》加固 librsprotect.so 《网秦》加固 nqdata 《国信灵通》加固 libnqshield.so 《apkprotect》加固 apkprotect 《几维安全》加固 libkwscmm.so，libkwscr.so，libkwslinker.so 《UU安全》加固 libuusafe.jar.so，libuusafe.so，libuusafeempty.so 几维安全 lib/armeabi-v7a/libkwscmm.so，lib/armeabi-v7a/libkwscr.so，lib/armeabi-v7a/libkwslinker.so UU安全 assets/libuusafe.jar.so，assets/libuusafe.so，lib/armeabi/libuusafeempty.so 如果apk加壳，则需要首先对apk进行脱壳 使用jeb，jadx，apktool等反编译工具对apk进行反编译 如果反编译工具打不开，使用010Editor把文件魔术字修复前8个字节 64 65 78 0A 30 33 35 00 dex.035. 再使用jadx反编译 grep -ril “MainAcitvity” ./*.txt 找到对应dex前缀名 先依据静态分析中得到的关键字字符串，关键api调用等方法快速定位需要分析的关键函数和流程 如果依据简单的字符串，关键api无法快速定位，则apk可能使用了字符串加密，反射调用等手段，此时可以结合hook，动态调试等 定位到关键函数后，再根据是java实现还是jni实现进一步分析 类加载基本原理JVM类加载器 Bootstrap ClassLoader（引导类加载器） C/C++代码实现的加载器,用于加载指定的JDK的核心类库,比如java. lang、java.utI等这些系统类。Java虚拟机的启动就是通过 Bootstrap,该 Classloader在java里无法获取,负责加载/lib下的类。 Extensions Classloader(拓展类加载器) Java中的实现类为 Extclassloader,提供了除了系统类之外的额外功能,可以在java里获取,负责加载/lib/ext下的类 Application ClassLoader(应用程序类加载器) Java中的实现类为 AppClassLoader,是与我们接触对多的类加载器,开发人员写的代码默认就是由它来加载, ClassLoader.getSystemClassLoader返回的就是它。 可以自定义类加载器，只需要通过java.lang.ClassLoader来实现自己的类加载器。 加载顺序：Bootstrap ClassLoader-&gt;Extensions Classloader-&gt;Application ClassLoader 双亲委派 如果一个类加载器收到了类加载请求,它并不会自己先去加载,而是把这个请求委托给父类的加载器去执行,如果父类加载器还存在其父类加载器,则进一步向上委托,依次递归,请求最终将到达顶层的启动类加载器,如果父类加载器可以完成类加载任务,就成功返回,倘若父类加载器无法完成此加载任务,子加载器才会尝试自己去加载。 1)避免重复加载,如果已经加载过一次class,可以直接读取已经加载的class 2)更加安全,无法自定义类来替代系统的类,可以防止核心API库被随意篡改 Android类加载器加载时机： 隐式加载：创建类的实例，访问类的静态变量，或者为静态变量赋值，调用类的静态方法，使用反射方式来强制创建某个类或接口对应的java.lang.Class对象，初始化某个类的子类 显式加载：使用LoadClass()加载，使用forName()加载 加载过程： 装载：查找和导入Class文件 链接：其中解析步骤是可以选择的（a）检查：检查载入的class文件数据的正确性（b）准备：给类的静态变量分配存储空间（c）解析：将符号引用转成直接引用 初始化：即调用&lt;clinit&gt;函数，对静态变量，静态代码块执行初始化工作 ClassLoader继承关系 ClassLoader:抽象类；BootClassLoader:预加载常用类，单例模式。与Java中的BootClassLoader不同，它并不是由C/C++代码实现，而是由Java实现的；BaseDexClassLoader是PathClassLoader、DexClassLoader、InMemoryDexClassLoader的父类，类加载的主要逻辑都是在BaseDexClassLoader完成的。SecureClassLoader继承了抽象类ClassLoader，拓展了ClassLoader类加入了权限方面的功能，加强了安全性，其子类URLClassLoader是用URL路径从jar文件中加载类和资源。其中重点关注的是PathClassLoader和DexClassLoader。PathClassLoader是Android默认使用的类加载器，一个apk中的Activity等类便是在其中加载。DexClassLoader可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更灵活，是实现插件化、热修复以及dex加壳的重点。 DexClassLoader方法参数 dexPath:目标所在的apk或者jar文件的路径，装载器将从路径中寻找指定的目标类。dexOutputDir:由于dex 文件在APK或者 jar文件中，所以在装载前面前先要从里面解压出dex文件，这个路径就是dex文件存放的路径，在 android系统中，一个应用程序对应一个linux用户id ,应用程序只对自己的数据目录有写的权限，所以我们存放在这个路径中。libPath :目标类中使用的C/C++库。parent：该装载器的父装载器，一般为当前执行类的装载器。 Android8.0新引入InMemoryDexClassLoader，用于直接从内存中加载dex。 http://androidxref.com/8.0.0_r4/ 搜索位于libcore中的Definition的DexClassLoader 、PathClassLoader、 InmemoryDexClassLoader查看源码。 ClassLoaderTest新建项目ClassLoaderTest验证类加载器的加载顺序 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); testClassLoader(); &#125; /** * I/kanxue: thisClassLoader:dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/base.apk\"],nativeLibraryDirectories=[/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/lib/x86, /system/lib, /system/product/lib]]] * I/kanxue: this:dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/base.apk\"],nativeLibraryDirectories=[/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/lib/x86, /system/lib, /system/product/lib]]]===java.lang.BootClassLoader@232d58a * I/kanxue: root:java.lang.BootClassLoader@232d58a * */ public void testClassLoader()&#123; ClassLoader thisClassLoader=MainActivity.class.getClassLoader(); Log.i(\"kanxue\",\"thisClassLoader:\"+thisClassLoader); ClassLoader tmpClassLoader = null; ClassLoader parentClassLoader=thisClassLoader.getParent(); while (parentClassLoader!=null)&#123; Log.i(\"kanxue\",\"this:\"+thisClassLoader+\"===\"+parentClassLoader); tmpClassLoader=parentClassLoader.getParent(); thisClassLoader=parentClassLoader; parentClassLoader=tmpClassLoader; &#125; Log.i(\"kanxue\",\"root:\"+thisClassLoader); &#125;&#125; LoadDex通过DexClassLoader实现一个动态加载的dex插件 在ClassLoaderTest项目中打印log 12345public class TestDexClass &#123; public void testFunc()&#123; Log.i(\"kanxue\",\"I'm from com.onejane.classloadertest.TestDexClass.testFunc\"); &#125;&#125; 通过build生成ClassLoaderTest\\app\\build\\outputs\\apk\\debug\\app-debug.apk, apktool d -s app-debug.apk保留并抽取出classes.dex adb push classes.dex /sdcard 创建LoadDex空白Android项目，加载调用位于dex下com.onejane.classloadertest.TestDexClass 在AndroidManifest.xml中添加读写权限 12&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt; 新增application配置android:requestLegacyExternalStorage=”true” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context = this.getApplicationContext(); /** * Android 10 sdk30 无法获取sdcard权限，通过获取当前app的cache目录 * if(!getExternalCacheDir().exists()) getExternalCacheDir().mkdirs(); * testDexClassLoader(context,getExternalCacheDir().getAbsolutePath()+\"/classes.dex\"); * 再将TestDexClass所在的adb push classes.dex /sdcard/Android/data/com.onejane.loaddex/cache/ */ // 若sdk30需要sdcard，通过requestMyPermissions动态获取读写权限 testDexClassLoader(context,\"/sdcard/classes.dex\"); &#125; private void requestMyPermissions() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; //没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(\"kanxue\", \"requestMyPermissions: 有写SD权限\"); &#125; if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; //没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(\"kanxue\", \"requestMyPermissions: 有读SD权限\"); &#125; &#125; // 可应对app热更新bug修复 public void testDexClassLoader(Context context, String dexfilepath)&#123; // 存放dex文件 File optFile = context.getDir(\"opt_dex\",0); // 存放依赖的so文件 File libFile = context.getDir(\"lib_path\",0); ClassLoader parentClassLoader=MainActivity.class.getClassLoader(); Log.i(\"kanxue\",parentClassLoader.toString()); //PathClassLoader ClassLoader tmpClassLoader=context.getClassLoader(); Log.i(\"kanxue\",tmpClassLoader.toString()); // PathClassLoader requestMyPermissions(); DexClassLoader dexClassLoader = new DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity.class.getClassLoader()); Class&lt;?&gt; clazz=null; try&#123; clazz=dexClassLoader.loadClass(\"com.onejane.classloadertest.TestDexClass\"); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; if(clazz!=null)&#123; try &#123; Method testFuncMethod=clazz.getDeclaredMethod(\"testFunc\"); Object obj = clazz.newInstance(); testFuncMethod.invoke(obj); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 利用外部dex下发热修复bug，用户无感知更新。 APP启动流程由发起进程通过binder进程间通信告知system_server进程启动指定的app，system_server通过socket方式与安卓孵化器进程进行通信，告诉孵化器进程启动指定app，由进程fork产生新的进程真正进入ActivityThread.main()，在此之前一直处于安卓的framework中。 ActivityThread是单例模式，在app整个进程的生命周期中，只存在一个实例，http://androidxref.com/8.0.0_r4/ 搜索位于frameworks中的ActivityThread 调用静态函数currentActivityThread获取当前进程中的ActivityThread实例，进而可以获取ActivityThread的重要变量,如mPackages 1234public static ActivityThread currentActivityThread() &#123; return sCurrentActivityThread;&#125;final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages &#x3D; new ArrayMap&lt;&gt;(); 其中LoadedApk中有加载app组件的PathClassLoader,即mClassLoader 通过反射获取app进程中单例ActivityThread，其中的sCurrentActivityThread静态变量用于全局保存创建的ActivityThread实例，同时还提供了currentActivityThread()静态函数用于获取当前虚拟机创建的ActivityThread实例。 反射拿到ActivityThread中的 mPackages的ArrayMap，通过当前app包名获取LoadedApk。 最后通过LoadedApk获取mClassLoader-&gt;PathClassLoader。 PathClassLoader: app运行过程中用于加载四大组件类的ClassLoader **ActivityThread.main()**函数是java中的入口main函数,这里会启动主消息循环，并创建ActivityThread实例，之后调用thread.attach(false)完成一系列初始化准备工作，并完成全局静态变量sCurrentActivityThread的初始化。之后主线程进入消息循环，等待接收来自系统的消息。当收到系统发送来的bindapplication的进程间调用时，调用函数handleBindApplication来处理该请求。 12345678910111213141516171819202122private void handleBindApplication(AppBindData data) &#123; &#x2F;&#x2F;step 1: 创建LoadedApk对象 data.info &#x3D; getPackageInfoNoCheck(data.appInfo, data.compatInfo); ... &#x2F;&#x2F;step 2: 创建ContextImpl对象; final ContextImpl appContext &#x3D; ContextImpl.createAppContext(this, data.info); &#x2F;&#x2F;step 3: 创建Instrumentation mInstrumentation &#x3D; new Instrumentation(); &#x2F;&#x2F;step 4: 创建Application对象;在makeApplication函数中调用了newApplication，真正执行app代码。在该函数中又调用了app.attach(context)，在attach函数中调用了Application.attachBaseContext函数 Application app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication &#x3D; app; &#x2F;&#x2F;step 5: 安装providers List&lt;ProviderInfo&gt; providers &#x3D; data.providers; installContentProviders(app, providers); &#x2F;&#x2F;step 6: 执行Application.Create回调 mInstrumentation.callApplicationOnCreate(app); ...&#125; 在 handleBindApplication函数中第一次进入了app的代码世界，该函数功能是启动一个application，并把系统收集的apk组件等相关信息绑定到application里，在创建完application对象后，接着调用了application的attachBaseContext方法，之后调用了application的onCreate函数。由此可以发现，app的Application类中的attachBaseContext和onCreate这两个函数是最先获取执行权进行代码执行的。这也是为什么各家的加固工具的主要逻辑都是通过替换app入口Application，并自实现这两个函数，在这两个函数中进行加密dex释放以及执行权交付的原因。 APP运行流程 无壳：PathClassLoader加载自身app自身dex，包括app声明的Application及所有其他类信息 加壳：PathClassLoader只加载壳自身代码，不包含app自身真正代码。首先进入壳的application的attachBaseContext，解密原始dex，再完成执行权的交付。 DexClassLoader加载的类是没有组件生命周期的，也就是说即使DexClassLoader通过对APK的动态加载完成了对组件类的加载，当系统启动该组件时，依然会出现加载类失败的异常，因为插件没有组件相关的类，如一些activity或service，若只用DexClassLoader进行动态加载，系统PathClassLoader无法找到相关组件信息，app将直接崩溃。所以如何解决动态加载dex中的生命周期成为加壳厂商首先需要解决的问题！！！ 在项目ClassLoaderTest中新建TestActivity ，并将build的apk中的classes.dex取出，adb push classes.dex /sdcard 12345678public class TestActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#x2F;&#x2F; adb push classes.dex &#x2F;sdcard Log.i(&quot;kanxue&quot;,&quot;I&#39;m from TestActivity.onCreate&quot;); &#125;&#125; 在项目LoadDex中，配置AndroidManifest.xml&lt;activity android:name=&quot;com.onejane.classloadertest.TestActivity&quot;&gt;&lt;/activity&gt;,在MainActivity中新增方法，并启动运行 123456789101112131415161718192021222324252627protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context &#x3D; this.getApplicationContext(); startTestActivity(context,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;);&#125;public void startTestActivity(Context context,String dexfilepath)&#123; &#x2F;&#x2F; 存放dex文件 File optFile &#x3D; context.getDir(&quot;opt_dex&quot;,0); &#x2F;&#x2F; 存放依赖的so文件 File libFile &#x3D; context.getDir(&quot;lib_path&quot;,0); ClassLoader parentClassLoader&#x3D;MainActivity.class.getClassLoader(); Log.i(&quot;kanxue&quot;,parentClassLoader.toString()); &#x2F;&#x2F;PathClassLoader ClassLoader tmpClassLoader&#x3D;context.getClassLoader(); Log.i(&quot;kanxue&quot;,tmpClassLoader.toString()); &#x2F;&#x2F; PathClassLoader requestMyPermissions(); DexClassLoader dexClassLoader &#x3D; new DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity.class.getClassLoader()); Class&lt;?&gt; clazz&#x3D;null; try&#123; clazz&#x3D;dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; if(clazz!&#x3D;null)&#123; context.startActivity(new Intent(context,clazz)); &#125;&#125; 启动app将报错ClassNotFoundException: Didn’t find class “com.onejane.classloadertest.TestActivity” 说明组件相关的Activity由mClassLoader-&gt;PathClassLoader加载了，虽然获取到非空TestActivity，却无法找到启动的目标Activity。 方案一反射替换，替换系统组件类加载器mClassLoader为我们的DexClassLoader，同时设置DexClassLoader的parent为系统组件类加载器PathClassLoader； 修改LoadDex项目的MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context &#x3D; this.getApplicationContext(); startTestActivityReplaceMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;); &#125; private void requestMyPermissions() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有写SD权限&quot;); &#125; if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有读SD权限&quot;); &#125; &#125; public void replaceClassloader(ClassLoader classloader)&#123; try &#123; Class&lt;?&gt; ActivityThreadClazz&#x3D;classloader.loadClass(&quot;android.app.ActivityThread&quot;); &#x2F;&#x2F; 获取静态函数currentActivityThread Method currentActivityThreadMethod&#x3D; ActivityThreadClazz.getDeclaredMethod(&quot;currentActivityThread&quot;); currentActivityThreadMethod.setAccessible(true); Object activityThreadObj&#x3D;currentActivityThreadMethod.invoke(null); &#x2F;&#x2F; 获取ActivityThread对象 &#x2F;&#x2F;final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages &#x3D; new ArrayMap&lt;&gt;(); Field mPackagesField&#x3D;ActivityThreadClazz.getDeclaredField(&quot;mPackages&quot;); &#x2F;&#x2F; 获取ActivityThread对象的ArrayMap的Field mPackagesField.setAccessible(true); ArrayMap mPackagesObj&#x3D; (ArrayMap) mPackagesField.get(activityThreadObj); &#x2F;&#x2F; 通过Field获取mPackages实例 WeakReference wr&#x3D; (WeakReference) mPackagesObj.get(this.getPackageName()); &#x2F;&#x2F; 从ArrayMap中获取LoadApk Object loadedApkObj&#x3D;wr.get(); Class LoadedApkClazz&#x3D;classloader.loadClass(&quot;android.app.LoadedApk&quot;); &#x2F;&#x2F;private ClassLoader mClassLoader; Field mClassLoaderField&#x3D;LoadedApkClazz.getDeclaredField(&quot;mClassLoader&quot;); mClassLoaderField.setAccessible(true); mClassLoaderField.set(loadedApkObj,classloader); &#x2F;&#x2F; 将LoadApk(mClassLoader)替换为我们的DexClassLoader &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; &#125; public void startTestActivityReplaceMethod(Context context,String dexfilepath)&#123; &#x2F;&#x2F; 存放dex文件 File optFile &#x3D; context.getDir(&quot;opt_dex&quot;,0); &#x2F;&#x2F; 存放依赖的so文件 File libFile &#x3D; context.getDir(&quot;lib_path&quot;,0); requestMyPermissions(); DexClassLoader dexClassLoader &#x3D; new DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity.class.getClassLoader()); replaceClassloader(dexClassLoader); Class&lt;?&gt; clazz&#x3D;null; try&#123; clazz&#x3D;dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; if(clazz!&#x3D;null)&#123; context.startActivity(new Intent(context,clazz)); &#125; &#125;&#125; 方案二打破原有的双亲关系，在系统组件类加载器和BootClassLoader的中间插入我们自己的DexClassLoader即可 修改ClassLoaderTest中的TestActivity类继承自Activity 123456789public class TestActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState);&#x2F;&#x2F; setContentView(R.layout.activity_main); &#x2F;&#x2F; adb push classes.dex &#x2F;sdcard Log.i(&quot;kanxue&quot;,&quot;I&#39;m from TestActivity.onCreate&quot;); &#125;&#125; 修改LoadDex中的MainActivity继承Activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context &#x3D; this.getApplicationContext(); &#x2F;&#x2F; 若sdk30需要sdcard，通过requestMyPermissions动态获取读写权限&#x2F;&#x2F; testDexClassLoader(context,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;);&#x2F;&#x2F; startTestActivityReplaceMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;); startTestActivityInsertMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;); &#125; private void requestMyPermissions() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有写SD权限&quot;); &#125; if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有读SD权限&quot;); &#125; &#125; public void startTestActivityInsertMethod(Context context,String dexfilepath)&#123; File optfile&#x3D;context.getDir(&quot;opt_dex&quot;,0); File libfile&#x3D;context.getDir(&quot;lib_path&quot;,0); requestMyPermissions(); ClassLoader pathClassloader&#x3D;MainActivity.class.getClassLoader(); ClassLoader bootClassloader&#x3D;MainActivity.class.getClassLoader().getParent(); &#x2F;&#x2F; 设置自定义dexClassLoader父ClassLoader为bootClassloader DexClassLoader dexClassLoader&#x3D;new DexClassLoader(dexfilepath,optfile.getAbsolutePath(),libfile.getAbsolutePath(),bootClassloader); try &#123; Field parentField&#x3D;ClassLoader.class.getDeclaredField(&quot;parent&quot;); parentField.setAccessible(true); &#x2F;&#x2F; 设置pathClassLoader父ClassLoader为自定义dexClassLoader parentField.set(pathClassloader,dexClassLoader); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; ClassLoader tmpClassloader&#x3D;pathClassloader; ClassLoader parentClassloader&#x3D;pathClassloader.getParent(); while(parentClassloader!&#x3D;null)&#123; Log.i(&quot;kanxue&quot;,&quot;this:&quot;+tmpClassloader+&quot;--parent:&quot;+parentClassloader); tmpClassloader&#x3D;parentClassloader; parentClassloader&#x3D;parentClassloader.getParent(); &#125; Log.i(&quot;kanxue&quot;,&quot;root:&quot;+tmpClassloader); Class&lt;?&gt; clazz&#x3D;null; try &#123; clazz &#x3D; dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; context.startActivity(new Intent(context,clazz)); &#125;&#125; 以上都是基于文件形式的外部加载，Android 8.0引入InMemoryDexClassLoader实现从内存中直接加载字节流，更加安全，不能通过文件监控形式达到脱壳目的，需要从进程内存中扣出这块完整的dex实现脱壳。 部分app在AndroidManifest.xml中没有声明application，加固厂商只需要添加一个application，在自己的application中完成classloader的替换。 部分app在AndroidManifest.xml中已经声明application，加固需要一个代理的application，壳的application不仅需要完成解密dex以及classloader相关修复，还需要完成解密dex后原app的application的attachBaseContext和onCreate函数调用。 逆向分析和脱壳的意义 ClassLoader和动态加载 加壳APP运行流程和ClassLoader修正 var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"classloader","slug":"classloader","permalink":"http://onejane.github.io/tags/classloader/"}]},{"title":"猿人学之访问逻辑罗生门","slug":"猿人学之访问逻辑罗生门","date":"2021-02-03T05:25:34.000Z","updated":"2021-12-12T03:09:39.336Z","comments":true,"path":"2021/02/03/猿人学之访问逻辑罗生门/","link":"","permalink":"http://onejane.github.io/2021/02/03/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8B%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91%E7%BD%97%E7%94%9F%E9%97%A8/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 题目http://match.yuanrenxue.com/match/3 抓取下列5页商标的数据，并将出现频率最高的申请号填入答案中 抓包 分析http://match.yuanrenxue.com/match/3 请求原始网页后请求一堆js/css,并没有携带cookie和特殊的返回 http://match.yuanrenxue.com/logo 每次请求页数的时候都会先请求logo并set了一个cookie，说明cookie是从服务器返回的 http://match.yuanrenxue.com/api/match/3 请求返回页面json数据，携带logo返回的cookie 没有带cookie不能访问http://match.yuanrenxue.com/api/match/3 使用请求头加引号.py 将fiddler的请求头包上 请求头加引号.py 123456789101112131415161718import reold_headers ='''Connection: keep-aliveAccept: application/json, text/javascript, */*; q=0.01X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36Referer: http://match.yuanrenxue.com/match/3Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: sessionid=7ly07o9fclh1llfsposkhh9jqvujxkth'''pattern = '^(.*?):[\\s]*(.*?)$'headers = \"\"for line in old_headers.splitlines(): headers += (re.sub(pattern,'\\'\\\\1\\': \\'\\\\2\\',',line)) + '\\n'print(headers[:-2]) 加上cookie使用python请求抓取返回一堆js代码，因为cookie是由服务器生成的，所以这一段返回的js没有意义 12345678910111213headers = &#123; 'Connection': 'keep-alive', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'X-Requested-With': 'XMLHttpRequest', 'User-Agent': 'yuanrenxue.project', 'Referer': 'http://match.yuanrenxue.com/match/3', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Cookie': 'sessionid=7ly07o9fclh1llfsposkhh9jqvujxkth'&#125;url = 'http://match.yuanrenxue.com/api/match/3'res = requests.get(url=url, headers=headers)print(res.text) 爬虫规律：请求完logo后再请求api则正常返回，同理请求第二页 1234567891011121314151617session = requests.session()headers = &#123; 'Connection': 'keep-alive', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'X-Requested-With': 'XMLHttpRequest', 'User-Agent': 'yuanrenxue.project', 'Referer': 'http://match.yuanrenxue.com/match/3', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9'&#125;session.headers = headersurl_logo = 'http://match.yuanrenxue.com/logo'res = session.post(url_logo)print(res, res.cookies)url = 'http://match.yuanrenxue.com/api/match/3?page=1'res = session.get(url=url)print(res.text) var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"猿人学之js混淆动态cookie","slug":"猿人学之js混淆动态cookie","date":"2021-02-03T02:19:32.000Z","updated":"2022-11-19T03:00:28.998Z","comments":true,"path":"2021/02/03/猿人学之js混淆动态cookie/","link":"","permalink":"http://onejane.github.io/2021/02/03/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8Bjs%E6%B7%B7%E6%B7%86%E5%8A%A8%E6%80%81cookie/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 题目http://match.yuanrenxue.com/match/2 提取全部5页发布日热度的值，计算所有值的加和,并提交答案 抓包chrome无痕模式通过抓包获取所有请求 第一个match/2不携带cookie并返回一串js代码 第二个match/2最早携带cookie并返回html页面，且并没有在请求头set-cookie,说明cookie是本地生成，而非服务器生成带到前端的，那么第一个match/2返回的js很可能就会生成cookie 1Cookie m&#x3D;dd5572e825610043a17c791d1eadc601|1607590427000 第三个api/match/2携带cookie返回页面请求json数据 对于动态cookie应该重放攻击后进行AutoResponse替换为静态处理。hook生成cookie的位置，追踪堆栈 12345Object.defineProperty(document,&#39;cookie&#39;,&#123; set:function(val)&#123; debugger; &#125;&#125;) 分析ob-decrypt12git clone https:&#x2F;&#x2F;github.com&#x2F;DingZaiHub&#x2F;ob-decrypt.git 原js在source.js，解密后的js在code.jsnode ob-decrypt.js 如果报错TypeError: Cannot read property ‘split’ of undefined if (arrName == id.name &amp;&amp; init.callee.object.value != undefined) { // 数组节点 console.log(typeof init.callee.object.value) arr = init.callee.object.value.split(&#39;|&#39;); pre_path.remove() } 当搜索document的时候，恰好找到了存cookie的位置 12document[&quot;coo&quot; + &quot;kie&quot;] &#x3D; _0x2c1923[&quot;ley&quot; + &quot;Wl&quot;](_0x2c1923[&quot;sJt&quot; + &quot;Xw&quot;](_0x2c1923[&quot;sJt&quot; + &quot;Xw&quot;](_0x2c1923[&quot;sJt&quot; + &quot;Xw&quot;](_0x2c1923[&quot;BwY&quot; + &quot;uN&quot;](_0x2c1923[&quot;BwY&quot; + &quot;uN&quot;](&quot;m&quot;, _0x2c1923[&quot;UET&quot; + &quot;ZQ&quot;](_0x10cbb5)), &quot;&#x3D;&quot;), _0x2c1923[&quot;zel&quot; + &quot;pz&quot;](_0x40ee99, _0x476429)), &quot;|&quot;), _0x476429), _0x2c1923[&quot;GYP&quot; + &quot;En&quot;]);location[&quot;rel&quot; + &quot;oad&quot;](); 类似以上的套娃混淆a(b(c(d,e),f),g(h,i))，从表达式中间的逗号开始处理对应的函数 123456789_0x2c1923[&quot;ley&quot; + &quot;Wl&quot;] &#x3D; function (_0x53c832, _0x599c90) &#123; return _0x53c832 + _0x599c90;&#125;;_0x2c1923[&quot;sJt&quot; + &quot;Xw&quot;] &#x3D; function (_0x28b4c2, _0x43d6c8) &#123; return _0x28b4c2 + _0x43d6c8;&#125;;_0x2c1923[&quot;BwY&quot; + &quot;uN&quot;] &#x3D; function (_0x4bea8f, _0x478a42) &#123; return _0x4bea8f + _0x478a42;&#125;; 比如_0x2c1923[&quot;BwY&quot; + &quot;uN&quot;](&quot;m&quot;, _0x2c1923[&quot;UET&quot; + &quot;ZQ&quot;](_0x10cbb5))改成&quot;m&quot;+ _0x2c1923[&quot;UET&quot; + &quot;ZQ&quot;](_0x10cbb5),以此类推，以上套娃混淆改成了 1cookie &#x3D; &quot;m&quot;+ _0x10cbb5()+ &quot;&#x3D;&quot;+ _0x40ee99(_0x59d742)+ &quot;|&quot;+ _0x59d742+ &quot;; p&quot; + &quot;ath&quot; + &quot;&#x3D;&#x2F;&quot; 与生成的cookie对比m=之间应该是空字符串，不过_0x10cbb5()还是有可能通过eval执行其他操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240function _0x10cbb5(_0x5f13ed, _0x478af7) &#123; var _0x676db2 &#x3D; &#123;&#125;; _0x676db2[&quot;zmh&quot; + &quot;zz&quot;] &#x3D; _0x2c1923[&quot;kBz&quot; + &quot;Ka&quot;]; _0x676db2[&quot;Gbk&quot; + &quot;oY&quot;] &#x3D; function (_0x1081d2, _0x4d51d1) &#123; return _0x2c1923[&quot;Dkz&quot; + &quot;qh&quot;](_0x1081d2, _0x4d51d1); &#125;; _0x676db2[&quot;pvW&quot; + &quot;KS&quot;] &#x3D; _0x2c1923[&quot;MNm&quot; + &quot;hh&quot;]; _0x676db2[&quot;YYF&quot; + &quot;qH&quot;] &#x3D; _0x2c1923[&quot;Mty&quot; + &quot;HN&quot;]; _0x676db2[&quot;Sfa&quot; + &quot;kl&quot;] &#x3D; _0x2c1923[&quot;ecZ&quot; + &quot;Qk&quot;]; _0x676db2[&quot;gUm&quot; + &quot;VG&quot;] &#x3D; function (_0x3f6b12, _0x2d619d) &#123; return _0x2c1923[&quot;BhS&quot; + &quot;oX&quot;](_0x3f6b12, _0x2d619d); &#125;; _0x676db2[&quot;OPB&quot; + &quot;pQ&quot;] &#x3D; function (_0x3ff6e7, _0x3bef5f) &#123; return _0x2c1923[&quot;JAx&quot; + &quot;OR&quot;](_0x3ff6e7, _0x3bef5f); &#125;; _0x676db2[&quot;BjH&quot; + &quot;Sb&quot;] &#x3D; _0x2c1923[&quot;Klw&quot; + &quot;fb&quot;]; _0x676db2[&quot;PTQ&quot; + &quot;Ui&quot;] &#x3D; function (_0x1b44b4) &#123; return _0x2c1923[&quot;fha&quot; + &quot;Jp&quot;](_0x1b44b4); &#125;; _0x676db2[&quot;kTD&quot; + &quot;PO&quot;] &#x3D; function (_0xfb99e4, _0x40cf5b) &#123; return _0x2c1923[&quot;BhS&quot; + &quot;oX&quot;](_0xfb99e4, _0x40cf5b); &#125;; _0x676db2[&quot;YEP&quot; + &quot;pq&quot;] &#x3D; function (_0x1bda72, _0x47daba) &#123; return _0x2c1923[&quot;qgy&quot; + &quot;zh&quot;](_0x1bda72, _0x47daba); &#125;; _0x676db2[&quot;KLK&quot; + &quot;fL&quot;] &#x3D; function (_0x416106, _0x55357b) &#123; return _0x2c1923[&quot;JAx&quot; + &quot;OR&quot;](_0x416106, _0x55357b); &#125;; _0x676db2[&quot;ISp&quot; + &quot;bk&quot;] &#x3D; _0x2c1923[&quot;mcW&quot; + &quot;Jc&quot;]; _0x676db2[&quot;tWb&quot; + &quot;gg&quot;] &#x3D; _0x2c1923[&quot;OBQ&quot; + &quot;iX&quot;]; _0x676db2[&quot;lKc&quot; + &quot;bf&quot;] &#x3D; _0x2c1923[&quot;puu&quot; + &quot;fA&quot;]; _0x676db2[&quot;XMC&quot; + &quot;Ur&quot;] &#x3D; _0x2c1923[&quot;cte&quot; + &quot;DM&quot;]; _0x676db2[&quot;dfK&quot; + &quot;OC&quot;] &#x3D; _0x2c1923[&quot;Jng&quot; + &quot;FV&quot;]; _0x676db2[&quot;egT&quot; + &quot;Fi&quot;] &#x3D; function (_0x21631f, _0x4bfcdf) &#123; return _0x2c1923[&quot;mdY&quot; + &quot;ma&quot;](_0x21631f, _0x4bfcdf); &#125;; _0x676db2[&quot;UpF&quot; + &quot;Fn&quot;] &#x3D; _0x2c1923[&quot;RoK&quot; + &quot;bA&quot;]; _0x676db2[&quot;Xqa&quot; + &quot;uV&quot;] &#x3D; function (_0x51abee, _0x5ab76f) &#123; return _0x2c1923[&quot;UfH&quot; + &quot;Ee&quot;](_0x51abee, _0x5ab76f); &#125;; _0x676db2[&quot;iiW&quot; + &quot;bz&quot;] &#x3D; _0x2c1923[&quot;wZN&quot; + &quot;LZ&quot;]; _0x676db2[&quot;Teo&quot; + &quot;Zg&quot;] &#x3D; _0x2c1923[&quot;fND&quot; + &quot;Sz&quot;]; _0x676db2[&quot;gZh&quot; + &quot;Wd&quot;] &#x3D; function (_0x10719b, _0x56e20a) &#123; return _0x2c1923[&quot;pkn&quot; + &quot;vA&quot;](_0x10719b, _0x56e20a); &#125;; _0x676db2[&quot;YmC&quot; + &quot;AF&quot;] &#x3D; _0x2c1923[&quot;uLh&quot; + &quot;Sz&quot;]; _0x676db2[&quot;NJQ&quot; + &quot;wb&quot;] &#x3D; function (_0x38e4cb) &#123; return _0x2c1923[&quot;fha&quot; + &quot;Jp&quot;](_0x38e4cb); &#125;; _0x676db2[&quot;IxU&quot; + &quot;UW&quot;] &#x3D; _0x2c1923[&quot;xwp&quot; + &quot;cD&quot;]; _0x676db2[&quot;VaY&quot; + &quot;Gr&quot;] &#x3D; function (_0x1b36ae, _0x3c24be, _0x3d336b) &#123; return _0x2c1923[&quot;XGh&quot; + &quot;hn&quot;](_0x1b36ae, _0x3c24be, _0x3d336b); &#125;; _0x676db2[&quot;qKV&quot; + &quot;mx&quot;] &#x3D; _0x2c1923[&quot;DfB&quot; + &quot;tS&quot;]; _0x676db2[&quot;smj&quot; + &quot;kw&quot;] &#x3D; _0x2c1923[&quot;JsK&quot; + &quot;bk&quot;]; _0x676db2[&quot;cqw&quot; + &quot;Qh&quot;] &#x3D; function (_0x50db75) &#123; return _0x2c1923[&quot;fha&quot; + &quot;Jp&quot;](_0x50db75); &#125;; _0x676db2[&quot;MRA&quot; + &quot;zw&quot;] &#x3D; function (_0x16b21f, _0x33fd9f, _0x4b394b) &#123; return _0x2c1923[&quot;Yxf&quot; + &quot;pg&quot;](_0x16b21f, _0x33fd9f, _0x4b394b); &#125;; _0x676db2[&quot;VLC&quot; + &quot;OW&quot;] &#x3D; function (_0x5bcbd5, _0x2d0cee, _0x3e387d) &#123; return _0x2c1923[&quot;KWs&quot; + &quot;dR&quot;](_0x5bcbd5, _0x2d0cee, _0x3e387d); &#125;; _0x676db2[&quot;SYr&quot; + &quot;hB&quot;] &#x3D; function (_0x3c4717, _0x496a53) &#123; return _0x2c1923[&quot;Gqh&quot; + &quot;Ur&quot;](_0x3c4717, _0x496a53); &#125;; if (_0x2c1923[&quot;JAx&quot; + &quot;OR&quot;](_0x2c1923[&quot;COQ&quot; + &quot;Wa&quot;], _0x2c1923[&quot;COQ&quot; + &quot;Wa&quot;])) &#123; var _0x6ee9d8 &#x3D; _0x2c1923[&quot;rfJ&quot; + &quot;MM&quot;](_0x35cbe4, this, function () &#123; var _0x2f0878 &#x3D; &#123;&#125;; _0x2f0878[&quot;nQU&quot; + &quot;fV&quot;] &#x3D; _0x676db2[&quot;zmh&quot; + &quot;zz&quot;]; _0x2f0878[&quot;zPo&quot; + &quot;jC&quot;] &#x3D; function (_0x2f55d1, _0x100e5a) &#123; return _0x676db2[&quot;Gbk&quot; + &quot;oY&quot;](_0x2f55d1, _0x100e5a); &#125;; _0x2f0878[&quot;jQt&quot; + &quot;lW&quot;] &#x3D; _0x676db2[&quot;pvW&quot; + &quot;KS&quot;]; _0x2f0878[&quot;ZTr&quot; + &quot;YJ&quot;] &#x3D; _0x676db2[&quot;YYF&quot; + &quot;qH&quot;]; _0x2f0878[&quot;ngu&quot; + &quot;BX&quot;] &#x3D; _0x676db2[&quot;Sfa&quot; + &quot;kl&quot;]; _0x2f0878[&quot;zVE&quot; + &quot;nH&quot;] &#x3D; function (_0x52ff30, _0x37e1a1) &#123; return _0x676db2[&quot;gUm&quot; + &quot;VG&quot;](_0x52ff30, _0x37e1a1); &#125;; if (_0x676db2[&quot;OPB&quot; + &quot;pQ&quot;](_0x676db2[&quot;BjH&quot; + &quot;Sb&quot;], _0x676db2[&quot;BjH&quot; + &quot;Sb&quot;])) &#123; var _0x1cf61c &#x3D; function () &#123; if (_0x2f0878[&quot;zPo&quot; + &quot;jC&quot;](_0x2f0878[&quot;jQt&quot; + &quot;lW&quot;], _0x2f0878[&quot;jQt&quot; + &quot;lW&quot;])) &#123; while (1) &#123; console[&quot;log&quot;](_0x2f0878[&quot;nQU&quot; + &quot;fV&quot;]); debugger; &#125; &#125; else &#123; var _0x27e4dc &#x3D; _0x1cf61c[&quot;con&quot; + &quot;str&quot; + &quot;uct&quot; + &quot;or&quot;](_0x2f0878[&quot;ZTr&quot; + &quot;YJ&quot;])()[&quot;com&quot; + &quot;pil&quot; + &quot;e&quot;](_0x2f0878[&quot;ngu&quot; + &quot;BX&quot;]); return !_0x27e4dc[&quot;tes&quot; + &quot;t&quot;](_0x6ee9d8); &#125; &#125;; return _0x676db2[&quot;PTQ&quot; + &quot;Ui&quot;](_0x1cf61c); &#125; else &#123; tVQxMC[&quot;zVE&quot; + &quot;nH&quot;](result, &quot;0&quot;); &#125; &#125;); _0x2c1923[&quot;fha&quot; + &quot;Jp&quot;](_0x6ee9d8); (function () &#123; var _0x389680 &#x3D; &#123;&#125;; _0x389680[&quot;AOX&quot; + &quot;GX&quot;] &#x3D; _0x676db2[&quot;YYF&quot; + &quot;qH&quot;]; _0x389680[&quot;VzQ&quot; + &quot;tD&quot;] &#x3D; _0x676db2[&quot;Sfa&quot; + &quot;kl&quot;]; _0x389680[&quot;Iet&quot; + &quot;SJ&quot;] &#x3D; function (_0x35b105, _0x49691e) &#123; return _0x676db2[&quot;kTD&quot; + &quot;PO&quot;](_0x35b105, _0x49691e); &#125;; _0x389680[&quot;vne&quot; + &quot;Zn&quot;] &#x3D; function (_0x4645ab, _0x1fe59e) &#123; return _0x676db2[&quot;YEP&quot; + &quot;pq&quot;](_0x4645ab, _0x1fe59e); &#125;; _0x389680[&quot;aAC&quot; + &quot;QE&quot;] &#x3D; function (_0x39bf1f, _0x1e7a33) &#123; return _0x676db2[&quot;KLK&quot; + &quot;fL&quot;](_0x39bf1f, _0x1e7a33); &#125;; _0x389680[&quot;wIa&quot; + &quot;VK&quot;] &#x3D; _0x676db2[&quot;ISp&quot; + &quot;bk&quot;]; _0x389680[&quot;cIl&quot; + &quot;vA&quot;] &#x3D; _0x676db2[&quot;tWb&quot; + &quot;gg&quot;]; _0x389680[&quot;hJS&quot; + &quot;Up&quot;] &#x3D; _0x676db2[&quot;lKc&quot; + &quot;bf&quot;]; _0x389680[&quot;Xie&quot; + &quot;LS&quot;] &#x3D; _0x676db2[&quot;XMC&quot; + &quot;Ur&quot;]; _0x389680[&quot;fxT&quot; + &quot;ZL&quot;] &#x3D; function (_0x345d86, _0x51eceb) &#123; return _0x676db2[&quot;YEP&quot; + &quot;pq&quot;](_0x345d86, _0x51eceb); &#125;; _0x389680[&quot;wtX&quot; + &quot;zc&quot;] &#x3D; _0x676db2[&quot;dfK&quot; + &quot;OC&quot;]; _0x389680[&quot;zEr&quot; + &quot;ej&quot;] &#x3D; function (_0x210ca1, _0x5abe82) &#123; return _0x676db2[&quot;egT&quot; + &quot;Fi&quot;](_0x210ca1, _0x5abe82); &#125;; _0x389680[&quot;HEu&quot; + &quot;mW&quot;] &#x3D; _0x676db2[&quot;UpF&quot; + &quot;Fn&quot;]; _0x389680[&quot;Yma&quot; + &quot;PV&quot;] &#x3D; function (_0x4285c1, _0x268f50) &#123; return _0x676db2[&quot;Xqa&quot; + &quot;uV&quot;](_0x4285c1, _0x268f50); &#125;; _0x389680[&quot;xhS&quot; + &quot;Ho&quot;] &#x3D; _0x676db2[&quot;iiW&quot; + &quot;bz&quot;]; _0x389680[&quot;vWk&quot; + &quot;MG&quot;] &#x3D; _0x676db2[&quot;Teo&quot; + &quot;Zg&quot;]; _0x389680[&quot;kmc&quot; + &quot;dm&quot;] &#x3D; function (_0x5ba947, _0x533ea6) &#123; return _0x676db2[&quot;YEP&quot; + &quot;pq&quot;](_0x5ba947, _0x533ea6); &#125;; _0x389680[&quot;UUP&quot; + &quot;CN&quot;] &#x3D; function (_0x575e79, _0x497b6c) &#123; return _0x676db2[&quot;gZh&quot; + &quot;Wd&quot;](_0x575e79, _0x497b6c); &#125;; _0x389680[&quot;tAf&quot; + &quot;jG&quot;] &#x3D; _0x676db2[&quot;YmC&quot; + &quot;AF&quot;]; _0x389680[&quot;awM&quot; + &quot;Du&quot;] &#x3D; function (_0x12d63a) &#123; return _0x676db2[&quot;NJQ&quot; + &quot;wb&quot;](_0x12d63a); &#125;; if (_0x676db2[&quot;gZh&quot; + &quot;Wd&quot;](_0x676db2[&quot;IxU&quot; + &quot;UW&quot;], _0x676db2[&quot;IxU&quot; + &quot;UW&quot;])) &#123; var _0x46c9da &#x3D; test[&quot;con&quot; + &quot;str&quot; + &quot;uct&quot; + &quot;or&quot;](QaQCGf[&quot;AOX&quot; + &quot;GX&quot;])()[&quot;com&quot; + &quot;pil&quot; + &quot;e&quot;](QaQCGf[&quot;VzQ&quot; + &quot;tD&quot;]); return !_0x46c9da[&quot;tes&quot; + &quot;t&quot;](_0xb4a243); &#125; else &#123; _0x676db2[&quot;VaY&quot; + &quot;Gr&quot;](_0x3be8cd, this, function () &#123; var _0x3b4193 &#x3D; &#123;&#125;; _0x3b4193[&quot;IzZ&quot; + &quot;kU&quot;] &#x3D; function (_0x35a2d1, _0x5103da) &#123; return _0x389680[&quot;Iet&quot; + &quot;SJ&quot;](_0x35a2d1, _0x5103da); &#125;; _0x3b4193[&quot;pIC&quot; + &quot;da&quot;] &#x3D; function (_0x2041c6, _0x55cf4b) &#123; return _0x389680[&quot;Iet&quot; + &quot;SJ&quot;](_0x2041c6, _0x55cf4b); &#125;; _0x3b4193[&quot;iAb&quot; + &quot;GP&quot;] &#x3D; function (_0x93c757, _0x5c5049) &#123; return _0x389680[&quot;vne&quot; + &quot;Zn&quot;](_0x93c757, _0x5c5049); &#125;; if (_0x389680[&quot;aAC&quot; + &quot;QE&quot;](_0x389680[&quot;wIa&quot; + &quot;VK&quot;], _0x389680[&quot;cIl&quot; + &quot;vA&quot;])) &#123; return _0x3b4193[&quot;IzZ&quot; + &quot;kU&quot;](_0x539398, _0x3b4193[&quot;pIC&quot; + &quot;da&quot;](_0x34aebb, _0x5f13ed)); &#125; else &#123; var _0x372fe3 &#x3D; new RegExp(_0x389680[&quot;hJS&quot; + &quot;Up&quot;]); var _0x21e399 &#x3D; new RegExp(_0x389680[&quot;Xie&quot; + &quot;LS&quot;], &quot;i&quot;); var _0x36d1ec &#x3D; _0x389680[&quot;fxT&quot; + &quot;ZL&quot;]($dbsm_0x598564, _0x389680[&quot;wtX&quot; + &quot;zc&quot;]); if (!_0x372fe3[&quot;tes&quot; + &quot;t&quot;](_0x389680[&quot;zEr&quot; + &quot;ej&quot;](_0x36d1ec, _0x389680[&quot;HEu&quot; + &quot;mW&quot;])) || !_0x21e399[&quot;tes&quot; + &quot;t&quot;](_0x389680[&quot;Yma&quot; + &quot;PV&quot;](_0x36d1ec, _0x389680[&quot;xhS&quot; + &quot;Ho&quot;]))) &#123; if (_0x389680[&quot;aAC&quot; + &quot;QE&quot;](_0x389680[&quot;vWk&quot; + &quot;MG&quot;], _0x389680[&quot;vWk&quot; + &quot;MG&quot;])) &#123; _0x389680[&quot;kmc&quot; + &quot;dm&quot;](_0x36d1ec, &quot;0&quot;); &#125; else &#123; if (ret) &#123; return debuggerProtection; &#125; else &#123; itNjFl[&quot;iAb&quot; + &quot;GP&quot;](debuggerProtection, 0); &#125; &#125; &#125; else &#123; if (_0x389680[&quot;UUP&quot; + &quot;CN&quot;](_0x389680[&quot;tAf&quot; + &quot;jG&quot;], _0x389680[&quot;tAf&quot; + &quot;jG&quot;])) &#123; var _0x54f102, _0x2d235e, _0x4141b3, _0x15cf75, _0x3979a1, _0x1b2486 &#x3D; 0, _0x32b74e &#x3D; -0, _0x13f848 &#x3D; -0, _0x117ded &#x3D; 0; &#125; else &#123; _0x389680[&quot;awM&quot; + &quot;Du&quot;]($dbsm_0x598564); &#125; &#125; &#125; &#125;)(); &#125; &#125;)(); _0x2c1923[&quot;fha&quot; + &quot;Jp&quot;](_0x2e765b); qz &#x3D; [10, 99, 111, 110, 115, 111, 108, 101, 32, 61, 32, 110, 101, 119, 32, 79, 98, 106, 101, 99, 116, 40, 41, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 115, 41, 32, 123, 10, 32, 32, 32, 32, 119, 104, 105, 108, 101, 32, 40, 49, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 40, 105, 61, 48, 59, 105, 60, 49, 49, 48, 48, 48, 48, 48, 59, 105, 43, 43, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 104, 105, 115, 116, 111, 114, 121, 46, 112, 117, 115, 104, 83, 116, 97, 116, 101, 40, 48, 44, 48, 44, 105, 41, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 10, 125, 10, 99, 111, 110, 115, 111, 108, 101, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 91, 111, 98, 106, 101, 99, 116, 32, 79, 98, 106, 101, 99, 116, 93, 39, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 402, 32, 116, 111, 83, 116, 114, 105, 110, 103, 40, 41, 32, 123, 32, 91, 110, 97, 116, 105, 118, 101, 32, 99, 111, 100, 101, 93, 32, 125, 39, 10]; _0x2c1923[&quot;Gqh&quot; + &quot;Ur&quot;](eval, _0x2c1923[&quot;Gqh&quot; + &quot;Ur&quot;](_0x479444, qz)); try &#123; if (_0x2c1923[&quot;pkn&quot; + &quot;vA&quot;](_0x2c1923[&quot;vib&quot; + &quot;ZR&quot;], _0x2c1923[&quot;vib&quot; + &quot;ZR&quot;])) &#123; return function (_0x19e254) &#123; &#125;[&quot;con&quot; + &quot;str&quot; + &quot;uct&quot; + &quot;or&quot;](qagLji[&quot;qKV&quot; + &quot;mx&quot;])[&quot;app&quot; + &quot;ly&quot;](qagLji[&quot;smj&quot; + &quot;kw&quot;]); &#125; else &#123; if (global) &#123; if (_0x2c1923[&quot;sMz&quot; + &quot;OI&quot;](_0x2c1923[&quot;Czp&quot; + &quot;mr&quot;], _0x2c1923[&quot;jXI&quot; + &quot;QF&quot;])) &#123; return _0x2c1923[&quot;ltM&quot; + &quot;vm&quot;](_0x2c1923[&quot;Fut&quot; + &quot;Nn&quot;](_0x5f13ed, _0x52cae0), _0x2c1923[&quot;ytp&quot; + &quot;Jc&quot;](_0x5f13ed, _0x2c1923[&quot;cnC&quot; + &quot;ig&quot;](32, _0x52cae0))); &#125; else &#123; console[&quot;log&quot;](_0x2c1923[&quot;kBz&quot; + &quot;Ka&quot;]); &#125; &#125; else &#123; if (_0x2c1923[&quot;osL&quot; + &quot;ze&quot;](_0x2c1923[&quot;sPt&quot; + &quot;gu&quot;], _0x2c1923[&quot;Zkz&quot; + &quot;LF&quot;])) &#123; var _0x176277, _0x1aa798 &#x3D; &quot;&quot;, _0x14ae63 &#x3D; _0x2c1923[&quot;tui&quot; + &quot;zA&quot;](32, _0x5f13ed[&quot;len&quot; + &quot;gth&quot;]); for (_0x176277 &#x3D; 0; _0x2c1923[&quot;fST&quot; + &quot;ws&quot;](_0x176277, _0x14ae63); _0x176277 +&#x3D; 8) _0x1aa798 +&#x3D; String[&quot;fro&quot; + &quot;mCh&quot; + &quot;arC&quot; + &quot;ode&quot;](_0x2c1923[&quot;mPE&quot; + &quot;nw&quot;](_0x2c1923[&quot;YcE&quot; + &quot;yA&quot;](_0x5f13ed[_0x2c1923[&quot;auH&quot; + &quot;KH&quot;](_0x176277, 5)], _0x2c1923[&quot;uBC&quot; + &quot;tw&quot;](_0x176277, 32)), 255)); return _0x1aa798; &#125; else &#123; while (1) &#123; if (_0x2c1923[&quot;xso&quot; + &quot;nc&quot;](_0x2c1923[&quot;QAx&quot; + &quot;NH&quot;], _0x2c1923[&quot;ZsR&quot; + &quot;Il&quot;])) &#123; _0x676db2[&quot;cqw&quot; + &quot;Qh&quot;](_0x10cbb5); return _0x52cae0 ? _0x4d6ae5 ? _0x676db2[&quot;MRA&quot; + &quot;zw&quot;](_0x1196c7, _0x52cae0, _0x5f13ed) : _0x676db2[&quot;VLC&quot; + &quot;OW&quot;](y, _0x52cae0, _0x5f13ed) : _0x4d6ae5 ? _0x676db2[&quot;YEP&quot; + &quot;pq&quot;](_0x5c4a33, _0x5f13ed) : _0x676db2[&quot;SYr&quot; + &quot;hB&quot;](_0x1a412b, _0x5f13ed); &#125; else &#123; console[&quot;log&quot;](_0x2c1923[&quot;kBz&quot; + &quot;Ka&quot;]); debugger; &#125; &#125; &#125; &#125; &#125; &#125; catch (_0x4cd00c) &#123; if (_0x2c1923[&quot;pkn&quot; + &quot;vA&quot;](_0x2c1923[&quot;yKg&quot; + &quot;SK&quot;], _0x2c1923[&quot;RJU&quot; + &quot;Xr&quot;])) &#123; return navigator[&quot;ven&quot; + &quot;dor&quot; + &quot;Sub&quot;]; &#125; else &#123; PJTCmw[&quot;fha&quot; + &quot;Jp&quot;]($dbsm_0x598564); &#125; &#125; &#125; else &#123; var _0x316c04 &#x3D; firstCall ? function () &#123; if (fn) &#123; var _0xc8cc17 &#x3D; fn[&quot;app&quot; + &quot;ly&quot;](context, arguments); fn &#x3D; null; return _0xc8cc17; &#125; &#125; : function () &#123; &#125;; firstCall &#x3D; ![]; return _0x316c04; &#125;&#125; 通过分析_0x10cbb5函数逻辑，首先定义对象_0x676db2，并对应定义对象中的函数，通过在函数开头加上debugger，断点调试发现进入_0x2c1923[&quot;fha&quot; + &quot;Jp&quot;](_0x6ee9d8)时卡死，可能是触发定时器循环调用了。 123_0x2c1923[&quot;fha&quot; + &quot;Jp&quot;] &#x3D; function (_0x5ec0e7) &#123; return _0x5ec0e7();&#125;; 所以在调用_0x6ee9d8()时卡死，在该方法中加入debugger重新调用_0x10cbb5()进入return _0x676db2[&quot;PTQ&quot; + &quot;Ui&quot;](_0x1cf61c)后卡死，由于_0x676db2[&quot;PTQ&quot; + &quot;Ui&quot;](_0x1cf61c)即_0x2c1923[&quot;fha&quot; + &quot;Jp&quot;](_0x1cf61c)即_0x1cf61c()，在_0x1cf61c方法中加上debugger重新跟踪 由于上面的if表达式返回false，所以总是会进入return !_0x27e4dc[&quot;tes&quot; + &quot;t&quot;](_0x6ee9d8)，而_0x27e4dc中的_0x1cf61c函数不接受参数，该逻辑对cookie加密没有任何影响，未传参 未改变全局变量 无返回。同理分析_0x2c1923[&quot;fha&quot; + &quot;Jp&quot;](_0x2e765b);未传参 未改变全局变量 无返回，唯一出现eval的位置就是_0x2c1923[&quot;Gqh&quot; + &quot;Ur&quot;](eval, _0x2c1923[&quot;Gqh&quot; + &quot;Ur&quot;](_0x479444, qz));，即eval(_0x479444(qz))的出来一串字符串罢了。所以_0x10cbb5()即返回空。 接下来分析cookie = &quot;m&quot;+ _0x10cbb5()+ &quot;=&quot;+ _0x40ee99(_0x59d742)+ &quot;|&quot;+ _0x59d742+ &quot;; p&quot; + &quot;ath&quot; + &quot;=/&quot;中的 _0x40ee99(_0x59d742)和_0x59d742，根据抓包结果m=dd5572e825610043a17c791d1eadc601|1607590427000，_0x59d742在function _0x94ebae(_0x59d742, _0x426e6a)中没有发现定义，只能获取该方法的引用位置，_0x2c1923[&quot;duF&quot; + &quot;Bq&quot;](_0x94ebae, _0x2c1923[&quot;gvf&quot; + &quot;Ex&quot;](_0x4bd99c)),即_0x94ebae(_0x4bd99c()),而_0x4bd99c函数中返回了Date[&quot;par&quot; + &quot;se&quot;](new Date()),所以_0x59d742为时间戳。 12345678910111213141516// 第一个参数为时间戳，其他都为nullfunction _0x40ee99(_0x37e3fa, _0x29817b, _0x399d9b) &#123; if (_0x2c1923[\"Xig\" + \"eA\"](_0x2c1923[\"Ezx\" + \"AN\"], _0x2c1923[\"nav\" + \"HD\"])) &#123; _0x2c1923[\"vry\" + \"dI\"](_0x10cbb5); return _0x29817b ? _0x399d9b ? _0x2c1923[\"OXT\" + \"ft\"](_0x1196c7, _0x29817b, _0x37e3fa) : _0x2c1923[\"wIK\" + \"US\"](y, _0x29817b, _0x37e3fa) : _0x399d9b ? _0x2c1923[\"jJy\" + \"be\"](_0x5c4a33, _0x37e3fa) : _0x2c1923[\"yqw\" + \"db\"](_0x1a412b, _0x37e3fa); &#125; else &#123; if (global) &#123; console[\"log\"](_0x2c1923[\"kBz\" + \"Ka\"]); &#125; else &#123; while (1) &#123; console[\"log\"](_0x2c1923[\"kBz\" + \"Ka\"]); debugger; &#125; &#125; &#125;&#125; 通过分析大三元表达式得_0x2c1923[&quot;yqw&quot; + &quot;db&quot;](_0x1a412b, _0x37e3fa)即_0x1a412b(_0x37e3fa)，继续分析扣取_0x1a412b函数，过程省略。 123456789101112&#x2F;&#x2F; 获取时间戳function _0x59d742(_0x53a223, _0xc9f38e) &#123; return Date[&quot;parse&quot;](new Date()); &#125;&#x2F;&#x2F; 这是取到加密值function _0x83032f(_0x37e3fa, _0x281a82) &#123; return &quot;m&quot;+ _0x10cbb5()+ &quot;&#x3D;&quot;+ _0x1a412b(_0x37e3fa)+ &quot;|&quot;+ _0x37e3fa+ &quot;; p&quot; + &quot;ath&quot; + &quot;&#x3D;&#x2F;&quot;;&#125;&#x2F;&#x2F; 使用函数去调用代码function get_m_value()&#123; return _0x83032f(_0x59d742()); &#125; ob混淆专解测试版V0.1使用ob混淆专解测试版V0.1反混淆第一个match/2返回的js代码去掉script标签 将解析完的js放到notepad++中进行js format，查找eval，setInterval，document等函数或者cookie等关键字符串。 123456789101112131415161718function V(Y, Z, a0) &#123; // 空参数 M(); return Z ? a0 ? H(Z, Y) : y(Z, Y) : a0 ? T(Y) : U(Y); &#125; // Y=X()时间戳，Z无用 function W(Y, Z) &#123; // 获取cookie document[\"cookie\"] = \"m\" + M() + \"=\" + V(Y) + \"|\" + Y + \"; path=/\"; // 带上cookie重新刷新页面返回真实网页并发送ajax请求获取json数据 location[\"reload\"](); &#125; // 时间戳 function X(Y, Z) &#123; return Date[\"parse\"](new Date()); &#125; // 最先执行js W(X()); 查看W和V中的M(),都没有传参数 1234567891011121314151617181920212223242526272829303132333435function M(Y, Z) &#123; // 只定义函数并无更新值 var a2 = B(this, function () &#123; var a5 = &#123; \"JLTiy\": \"return /\\\" + this + \\\"/\", \"uynWF\": \"^([^ ]+( +[^ ]+)+)+[^ ]&#125;\" &#125;; var a7 = function () &#123; var a8 = a7[\"constructor\"](a5[\"JLTiy\"])()[\"compile\"](a5[\"uynWF\"]); return !a8[\"test\"](a2); &#125;; return a7(); &#125;); // 未传参 未改变全局变量 无返回 a2(); // 未传参 未改变全局变量 无返回 K(); qz = [10, 99, 111, 110, 115, 111, 108, 101, 32, 61, 32, 110, 101, 119, 32, 79, 98, 106, 101, 99, 116, 40, 41, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 115, 41, 32, 123, 10, 32, 32, 32, 32, 119, 104, 105, 108, 101, 32, 40, 49, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 40, 105, 61, 48, 59, 105, 60, 49, 49, 48, 48, 48, 48, 48, 59, 105, 43, 43, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 104, 105, 115, 116, 111, 114, 121, 46, 112, 117, 115, 104, 83, 116, 97, 116, 101, 40, 48, 44, 48, 44, 105, 41, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 10, 125, 10, 99, 111, 110, 115, 111, 108, 101, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 91, 111, 98, 106, 101, 99, 116, 32, 79, 98, 106, 101, 99, 116, 93, 39, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 402, 32, 116, 111, 83, 116, 114, 105, 110, 103, 40, 41, 32, 123, 32, 91, 110, 97, 116, 105, 118, 101, 32, 99, 111, 100, 101, 93, 32, 125, 39, 10]; eval(L(qz)); try &#123; if (global) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); &#125; else &#123; while (1) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); debugger; &#125; &#125; &#125; catch (a5) &#123; return navigator[\"vendorSub\"]; &#125; &#125; 通过WT-JS查看L(qz)，并没有对cookie进行影响 1234567function L(Y, Z) &#123; let a0 = \"\"; for (let a1 = 0; a1 &lt; Y[\"length\"]; a1++) &#123; a0 += String[\"fromCharCode\"](Y[a1]); &#125; return a0;&#125; navigator[&quot;vendorSub&quot;]放到console返回””,得出M()结论不返回或者返回””,也没修改变量参数，去除无用首行(function $c(k) {和尾行})();，去除最先执行W(X());，去除W内的location[&quot;reload&quot;]();，将document[&quot;cookie&quot;] =改为return ，去除无用setInterval(M(), 500);,去除W函数无用Z,M()为null也可以去除，删除无返回js，因为会报test未定义 12345678910111213141516// 无返回 var a2 = B(this, function () &#123; var a5 = &#123; \"JLTiy\": \"return /\\\" + this + \\\"/\", \"uynWF\": \"^([^ ]+( +[^ ]+)+)+[^ ]&#125;\" &#125;; var a7 = function () &#123; var a8 = a7[\"constructor\"](a5[\"JLTiy\"])()[\"compile\"](a5[\"uynWF\"]); return !a8[\"test\"](a2); &#125;; return a7();&#125;);// 未传参 未改变全局变量 无返回a2(); 新增var navigator = {};，使用鬼鬼调试工具，执行W(X());，核心js如下2.js 1234567891011121314151617181920212223242526272829303132333435363738var navigator = &#123;&#125;;function M(Y, Z) &#123; // 未传参 未改变全局变量 无返回 K(); qz = [10, 99, 111, 110, 115, 111, 108, 101, 32, 61, 32, 110, 101, 119, 32, 79, 98, 106, 101, 99, 116, 40, 41, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 115, 41, 32, 123, 10, 32, 32, 32, 32, 119, 104, 105, 108, 101, 32, 40, 49, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 40, 105, 61, 48, 59, 105, 60, 49, 49, 48, 48, 48, 48, 48, 59, 105, 43, 43, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 104, 105, 115, 116, 111, 114, 121, 46, 112, 117, 115, 104, 83, 116, 97, 116, 101, 40, 48, 44, 48, 44, 105, 41, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 10, 125, 10, 99, 111, 110, 115, 111, 108, 101, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 91, 111, 98, 106, 101, 99, 116, 32, 79, 98, 106, 101, 99, 116, 93, 39, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 402, 32, 116, 111, 83, 116, 114, 105, 110, 103, 40, 41, 32, 123, 32, 91, 110, 97, 116, 105, 118, 101, 32, 99, 111, 100, 101, 93, 32, 125, 39, 10]; eval(L(qz)); try &#123; if (global) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); &#125; else &#123; while (1) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); debugger; &#125; &#125; &#125; catch (a5) &#123; return navigator[\"vendorSub\"]; &#125;&#125;function V(Y, Z, a0) &#123; // 空参数 M(); return Z ? a0 ? H(Z, Y) : y(Z, Y) : a0 ? T(Y) : U(Y);&#125;// Y=X()时间戳，Z无用function W(Y) &#123; return \"m\" + \"=\" + V(Y) + \"|\" + Y;&#125;function X(Y, Z) &#123; return Date[\"parse\"](new Date());&#125;function request() &#123; return W(X());&#125; 爬虫123456789101112131415161718192021222324252627282930313233import requestsimport execjsimport timedef get_page(page_num,param): url = \"http://match.yuanrenxue.com/api/match/2?page=&#123;&#125;\".format(page_num) headers = &#123; 'Host': 'match.yuanrenxue.com', 'Referer':'http://match.yuanrenxue.com/match/2', 'User-Agent':'yuanrenxue.project', 'X-Requested-With':'XMLHttpRequest', 'Cookie': param &#125; resonse = requests.get(url=url,headers=headers) return resonse.json()def calculate_m_value(): with open(r'2.js',encoding='utf-8',mode='r') as f: JsData = f.read() psd = execjs.compile(JsData).call('request') psd = psd.replace('丨','%E4%B8%A8') print('this request parameters is :',psd) return psdif __name__ == '__main__': sum_num = 0 for page_num in range(1,6): res = get_page(page_num,calculate_m_value()) data = [__['value'] for __ in res['data']] print(data) sum_num+=sum(data) time.sleep(1) print('the answer is :',sum_num) var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"猿人学之js混淆源码乱码","slug":"猿人学之js混淆源码乱码","date":"2021-02-01T03:18:17.000Z","updated":"2021-12-12T03:09:39.335Z","comments":true,"path":"2021/02/01/猿人学之js混淆源码乱码/","link":"","permalink":"http://onejane.github.io/2021/02/01/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8Bjs%E6%B7%B7%E6%B7%86%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 题目https://match.yuanrenxue.com/match/1 抓取所有（5页）机票的价格，并计算所有机票价格的平均值，填入答案。 抓包打开控制台开始抓包，出现无限debugger循环,可以通过Never pause here或Fiddler过掉。 方案一：在第2行选中右键Never pause here 方案二：通过查看该debug的js名为uzt.js，本地创建uzt.js并修改其中的jsFiddler的AutoResponder下，选中Enable automatic reaponses 和Unmatched requests passthrough 通过翻页获取请求https://match.yuanrenxue.com/api/match/1，参数得其中1607516709为秒时间戳，即time.time() 12page: 2m: 3ddf4f4e72bd84562a0e0104d425a791丨1607657864 分析搜索丨中文竖线，未果，目测做了js混淆加密。添加XHR断点api/match/1跟踪调用栈到request发现被源码被混淆加密。 将该页面js拷贝下来，存到demo.js中，开始反混淆 1234git clone https:&#x2F;&#x2F;gitee.com&#x2F;virjar&#x2F;jsrepair.gitcd jsrepairnpm inode cli.js demo.js 开始反混淆 反混淆结果如下，_0x2268f9为毫秒时间戳 123456789101112window[&#39;url&#39;] &#x3D; &#39;&#x2F;api&#x2F;match&#x2F;1&#39;;request &#x3D; function () &#123; var _0x2268f9 &#x3D; Date[&#39;parse&#39;](new Date()) + (16798545 + -72936737 + 156138192), _0x57feae &#x3D; oo0O0(_0x2268f9[&#39;toString&#39;]()) + window[&#39;f&#39;]; const _0x5d83a3 &#x3D; &#123;&#125;; _0x5d83a3[&#39;page&#39;] &#x3D; window[&#39;page&#39;]; _0x5d83a3[&#39;m&#39;] &#x3D; _0x57feae + &#39;丨&#39; + _0x2268f9 &#x2F; (-1 * 3483 + -9059 + 13542); var _0xb89747 &#x3D; _0x5d83a3; $[&#39;ajax&#39;](&#123; ... &#125;);&#125;;request(); 搜索oo0O0，扣出所在的js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function oo0O0(mw) &#123; window.b &#x3D; &#39;&#39;; for (var i &#x3D; 0, len &#x3D; window.a.length; i &lt; len; i++) &#123; console.log(window.a[i]); window.b +&#x3D; String[document.e + document.g](window.a[i][document.f + document.h]() - i - window.c) &#125; var U &#x3D; [&#39;W5r5W6VdIHZcT8kU&#39;, &#39;WQ8CWRaxWQirAW&#x3D;&#x3D;&#39;]; var J &#x3D; function(o, E) &#123; o &#x3D; o - 0x0; var N &#x3D; U[o]; if (J[&#39;bSSGte&#39;] &#x3D;&#x3D;&#x3D; undefined) &#123; var Y &#x3D; function(w) &#123; var m &#x3D; &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+&#x2F;&#x3D;&#39;, T &#x3D; String(w)[&#39;replace&#39;](&#x2F;&#x3D;+$&#x2F;, &#39;&#39;); var A &#x3D; &#39;&#39;; for (var C &#x3D; 0x0, b, W, l &#x3D; 0x0; W &#x3D; T[&#39;charAt&#39;](l++); ~W &amp;&amp; (b &#x3D; C % 0x4 ? b * 0x40 + W : W, C++ % 0x4) ? A +&#x3D; String[&#39;fromCharCode&#39;](0xff &amp; b &gt;&gt; (-0x2 * C &amp; 0x6)) : 0x0) &#123; W &#x3D; m[&#39;indexOf&#39;](W) &#125; return A &#125;; var t &#x3D; function(w, m) &#123; var T &#x3D; [], A &#x3D; 0x0, C, b &#x3D; &#39;&#39;, W &#x3D; &#39;&#39;; w &#x3D; Y(w); for (var R &#x3D; 0x0, v &#x3D; w[&#39;length&#39;]; R &lt; v; R++) &#123; W +&#x3D; &#39;%&#39; + (&#39;00&#39; + w[&#39;charCodeAt&#39;](R)[&#39;toString&#39;](0x10))[&#39;slice&#39;](-0x2) &#125; w &#x3D; decodeURIComponent(W); var l; for (l &#x3D; 0x0; l &lt; 0x100; l++) &#123; T[l] &#x3D; l &#125; for (l &#x3D; 0x0; l &lt; 0x100; l++) &#123; A &#x3D; (A + T[l] + m[&#39;charCodeAt&#39;](l % m[&#39;length&#39;])) % 0x100, C &#x3D; T[l], T[l] &#x3D; T[A], T[A] &#x3D; C &#125; l &#x3D; 0x0, A &#x3D; 0x0; for (var L &#x3D; 0x0; L &lt; w[&#39;length&#39;]; L++) &#123; l &#x3D; (l + 0x1) % 0x100, A &#x3D; (A + T[l]) % 0x100, C &#x3D; T[l], T[l] &#x3D; T[A], T[A] &#x3D; C, b +&#x3D; String[&#39;fromCharCode&#39;](w[&#39;charCodeAt&#39;](L) ^ T[(T[l] + T[A]) % 0x100]) &#125; return b &#125;; J[&#39;luAabU&#39;] &#x3D; t, J[&#39;qlVPZg&#39;] &#x3D; &#123;&#125;, J[&#39;bSSGte&#39;] &#x3D; !![] &#125; var H &#x3D; J[&#39;qlVPZg&#39;][o]; return H &#x3D;&#x3D;&#x3D; undefined ? (J[&#39;TUDBIJ&#39;] &#x3D;&#x3D;&#x3D; undefined &amp;&amp; (J[&#39;TUDBIJ&#39;] &#x3D; !![]), N &#x3D; J[&#39;luAabU&#39;](N, E), J[&#39;qlVPZg&#39;][o] &#x3D; N) : N &#x3D; H, N &#125;; eval(atob(window[&#39;b&#39;])[J(&#39;0x0&#39;, &#39;]dQW&#39;)](J(&#39;0x1&#39;, &#39;GTu!&#39;), &#39;\\x27&#39; + mw + &#39;\\x27&#39;)); return &#39;&#39;&#125; 由于本js中返回’’，所以只需要关注eval(atob(window[&#39;b&#39;])[J(&#39;0x0&#39;, &#39;]dQW&#39;)](J(&#39;0x1&#39;, &#39;GTu!&#39;), &#39;\\x27&#39; + mw + &#39;\\x27&#39;));中做了什么操作。atob是解码使用 base-64 编码的字符串的函数，通过console中获取atob(window[&#39;b&#39;])。 通过WT-JS加载计算window.f=hex_md5(mwqqppz) 报错未定义，mwqqppz可能是被其他地方替换或者加密来的，eval(atob(window[&#39;b&#39;])[J(&#39;0x0&#39;, &#39;]dQW&#39;)](J(&#39;0x1&#39;, &#39;GTu!&#39;), &#39;\\x27&#39; + mw + &#39;\\x27&#39;));中的J方法在oo0O0中被定义，且J方法中引用了U，在控制台定义J和U方法后，再执行J方法 1234var U &#x3D; [&#39;W5r5W6VdIHZcT8kU&#39;, &#39;WQ8CWRaxWQirAW&#x3D;&#x3D;&#39;];var J &#x3D; function (o, E) &#123; ...&#125; 拼接得到eval(atob(window[&#39;b&#39;])[replace](&#39;mwqqppz&#39;, &#39;\\x27&#39; + mw + &#39;\\x27&#39;));，搜索\\bmw\\b,发现mw为oo0O0的入参，即时间戳 在atob(window[&#39;b&#39;])返回的js后追加get_m_value方法获取m=window.f的值 12345678function get_m_value() &#123; var timestamp &#x3D; Date.parse(new Date()) + 100000000; &#x2F;&#x2F; timestamp &#x3D; &#39;1607657864000&#39; f &#x3D; hex_md5(timestamp+&#39;&#39;) var m &#x3D; f; m &#x3D; m + &#39;丨&#39; + timestamp &#x2F; 1000 return m;&#125; 爬虫123456789101112131415161718192021222324252627282930313233343536import timeimport execjsimport requestsdef get_page(page_num,parameters): url &#x3D; &#39;http:&#x2F;&#x2F;match.yuanrenxue.com&#x2F;api&#x2F;match&#x2F;1?page&#x3D;&#123;&#125;&amp;m&#x3D;&#123;&#125;&#39;.format(page_num,parameters) headers &#x3D; &#123; &#39;Host&#39;: &#39;match.yuanrenxue.com&#39;, &#39;Referer&#39;: &#39;http:&#x2F;&#x2F;match.yuanrenxue.com&#x2F;match&#x2F;1&#39;, &#39;User-Agent&#39;: &#39;yuanrenxue.project&#39;, &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;, &#39;Cookie&#39;: &#39;qpfccr&#x3D;true; Hm_lvt_c99546cf032aaa5a679230de9a95c7db&#x3D;1607556997,1607557857; Hm_lpvt_c99546cf032aaa5a679230de9a95c7db&#x3D;1607557857; no-alert&#x3D;true&#39; &#125; response &#x3D; requests.get(url&#x3D;url,headers&#x3D;headers) return response.json()def calculate_m_value(): with open(r&#39;1.js&#39;,encoding&#x3D;&#39;utf-8&#39;,mode&#x3D;&#39;r&#39;) as f: JsData &#x3D; f.read() psd &#x3D; execjs.compile(JsData).call(&#39;request&#39;) psd &#x3D; psd.replace(&#39;丨&#39;,&#39;%E4%B8%A8&#39;) print(&#39;this request parameters is :&#39;,psd) return psdif __name__ &#x3D;&#x3D; &#39;__main__&#39;: sum_num &#x3D; 0 index_num &#x3D; 0 for page_num in range(1,6): res &#x3D; get_page(page_num,calculate_m_value()) data &#x3D; [__[&#39;value&#39;] for __ in res[&#39;data&#39;]] print(data) sum_num+&#x3D;sum(data) index_num +&#x3D; len(data) time.sleep(1) average &#x3D; sum_num&#x2F;index_num print(&#39;the answer is :&#39;,average) var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"博客搭建","slug":"博客搭建","date":"2021-01-31T14:51:49.000Z","updated":"2021-12-12T03:09:39.292Z","comments":true,"path":"2021/01/31/博客搭建/","link":"","permalink":"http://onejane.github.io/2021/01/31/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 Hexo12345678https://nodejs.org/download/release/v10.15.3/ 安装nodenpm install -g cnpm --registry=https://registry.npm.taobao.orgnpm config set registry https://registry.npm.taobao.org npm install -g hexo@4.1.1npm install -g hexo-cli@1.3.0 hexo init blog cd blog npm install Melody12345678910111213set http_proxy=http://127.0.0.1:1080set https_proxy=https://127.0.0.1:1080git clone -b master https://github.com/Molunerfinn/hexo-theme-melody themes/melodynpm install hexo-renderer-pug hexo-renderer-styluscp themes\\melody\\_config.yml themes\\melody\\melody.yml 通过git pull 即可更新melodynpm i --save hexo-wordcountnpm i hexo-deployer-git --save 使用git bashnpm install --save-dev gulp@3.9.1npm install -g gulp@3.9.1npm install gulp-imagemin@3.1.1 --savenpm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify --save blog\\package.json 12345\"scripts\": &#123; \"build\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d &amp; git add * &amp; git commit -m 'deploy' &amp; git push origin master\", \"test\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo s\", \"dev\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\" &#125; 通过npm run build 即可自动打包上传发布http://onejane.gitee.io/ 新建Onajane公开项目，hexo d后启用服务的Gitee Pages 新建picture公开项目，上传图片后启动服务的Gitee Pages图床服务，http://onejane.gitee.io/picture/avatar.jpg blog_config.yml 1234567891011121314151617title: Jsubtitle: '朝花夕拾'description: '逆向,爬虫'keywords:author: Jlanguage: zh-Hanstimezone: 'Hongkong'url: https://gitee.com/OneJanetheme: melodypost_asset_folder: true # npm install https://github.com/CodeFalling/hexo-asset-image --save 上传图片到博客deploy: type: git repo: gitee: https://gitee.com/OneJane/OneJane.git github: git@github.com:OneJane/OneJane.github.io.git branch: master message: gitee 评论https://leancloud.cn/dashboard/applist.html#/apps 新建应用获取AppID,AppKey 123456789101112valine: enable: true # if you want use valine,please set this value is true appId: cWLsquGr5PNi33OWXNhzerep-gzGzoHsz # leancloud application app id appKey: S35phfCSbm8dAG9LpOc5rjm3 # leancloud application app key notify: false # valine mail notify (true/false) https://github.com/xCss/Valine/wiki verify: false # valine verify code (true/false) recordip: false # whether record commentor's ip (true/false) pageSize: 10 # comment list page size avatar: mm # gravatar style https://valine.js.org/#/avatar lang: zh-cn # i18n: zh-cn/en placeholder: 一起来吹牛逼好吗！ # valine comment input placeholder(like: Please leave your footprints ) guest_info: nick,mail,link #valine comment header inf 分享123sharejs: enable: true disabled_sites: google,facebook 搜索本地 npm install hexo-generator-search –save 12345local_search: enable: true # or false labels: input_placeholder: Search for Posts hits_empty: \"We didn't find any results for the search: $&#123;query&#125;\" # if there are no result 头像1avatar: http://onejane.gitee.io/picture/avatar.jpg # 网站 Logo 导航菜单1234567891011121314151617181920hexo new page tags修改source/tags/index.md---title: 标签date: 2018-01-05 00:00:00type: \"tags\"---hexo new page categories修改source/categories/index.md---title: 分类date: 2018-01-05 00:00:00type: \"categories\"---修改_config.ymlmenu: 主页: / 归档: /archives 标签: /tags 分类: /categories 自动节选123auto_excerpt: enable: true length: 150 顶部图12top_img_height: 80 top_img: http://onejane.gitee.io/picture/hacker.jpg 在_config.yml和文章中使用 打赏1234567QR_code: - itemlist: img: http://onejane.gitee.io/picture/alipay.png text: 支付宝打赏 - itemlist: img: http://onejane.gitee.io/picture/wx.png text: 微信打赏 广告/音乐播放器123adv: enable: true info: &lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"center\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=572547816&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt; Follow1234follow: enable: true url: 'https://gitee.com/OneJane/' text: 'Follow Me' 友链123links_title: 友链 # 配置友链的标题文字links: OneJane: http://onejane.gitee.io/ 目录1234toc: enable: true # or false number: true # or false. 版本v1.5.6新增 在文章头部加入toc_number: true 页脚1footer_custom_text: Hi, welcome to my &lt;a href=http://onejane.gitee.io/\"&gt;blog&lt;/a&gt;! 配置成hitokoto则是随机的谚语 点击特效1fireworks: true 彩带123456canvas_ribbon: enable: true size: 150 alpha: 0.6 zIndex: -1 click_to_change: false 阅读密码npm install –save hexo-blog-encrypt 123文中标题填入password: blogJmessage: 请联系微信：codewj，获取本文密码 分析baiduhttps://tongji.baidu.com/sc-web/10000134724/home/site/index?from=3 新增网站后，获取hm.src = “https://hm.baidu.com/hm.js?***&quot;;作为百度id googlehttps://analytics.google.com/analytics/web/#/a111479568p260655414/admin 创建媒体资源-显示高级选项-创建 Universal Analytics 媒体资源，创建好后进入媒体资源设置获取跟踪ID,UA开头的就是谷歌id 12baidu_analytics: ***google_analytics: *** var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"生活","slug":"生活","permalink":"http://onejane.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://onejane.github.io/tags/hexo/"}]},{"title":"逆向环境搭建","slug":"逆向环境搭建","date":"2021-01-31T03:20:05.000Z","updated":"2022-10-17T15:10:36.472Z","comments":true,"path":"2021/01/31/逆向环境搭建/","link":"","permalink":"http://onejane.github.io/2021/01/31/%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"篇幅有限完整内容及源码关注公众号：ReverseCode，发送 冲 刷机https://developers.google.com/android/images#angler 开机键+音量减 进入recovery PixelES文件浏览器 查看系统文件 玩逆向必备一台真机，那么非谷歌亲儿子莫属，模拟器缺失native/so层，属于精简版系统，故还是真机香呀。 官网下载pixel 8.1.0镜像，建议刷OPM1.171019.011版本安卓8.1.0 12adb reboot bootloader 或 按住音量向下键和开机键 进入fastboot状态cd sailfish-opm4.171019.021.p1-factory-0bcf4315/sailfish-opm4.171019.021.p1 &amp;&amp; flash-all.sh 开始刷机 设置-关于手机-版本号8下点击-进入开发者模式，进入系统-高级-打开开发者选项-USB调试 123456adb push Magisk-v20.4.zip /sdcard adb push magisk-riru-v21.3.zip /sdcard/Download 使用magisk模块安装并重启adb push magisk-EdXposed-SandHook-v0.4.5.1_beta.4463.-release.zip /sdcard/Download 使用magisk模块安装并重启adb install EdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apk 安装xposedadb push MagiskHidePropsConf-v5.3.4.zip /sdcard/Download adb install JustTrustMePlus-debug.apk 用于结合xposed突破SSL Pinning抓包限制 twrp作为第三方刷机工具，刷入Magisk，nethunter等魔改系统。 fastboot flash recovery twrp-3.3.0-0-angler.img 12345678adb reboot bootloaderfastboot boot twrp-3.4.0-0-sailfish.img 进入recovery modeinstall Magisk-v20.4.zipadb install MagiskManager-v7.5.1.apksettings put global captive_portal_http_url https://www.google.cn/generate_204 去除wifi上的×settings put global captive_portal_https_url https://www.google.cn/generate_204settings put global ntp_server 1.hk.pool.ntp.org 修改时区reboot linux下载最新的platform-tools刷机的时候，fastboot会报各种unknow command或接近的错误，把fastboot文件替换成随着aosp一起编译出来的即可,使用自行编译的fastboot即可。 123rm ~&#x2F;Android&#x2F;Sdk&#x2F;platform-tools&#x2F;fastbootcp fastboot810r1 fastbootfastboot --version 通过wifi连接adb可实现群控adb -s 192.168.0.104:5555 install com.ttxapps.wifiadb_2.1.3-810031745_minAPI15(nodpi)_apkmirror.com.apk 安装apk adb connect 192.168.0.104:5555 使用adb连接手机，如果异常“由于目标计算机积极拒绝，无法连接。 (10061) 12345adb root adb remountadb shell setprop service.adb.tcp.port 5555adb tcpip 5555adb connect 192.168.3.88 termux adb -s 192.168.0.104:5555 install com.termux_92.apk adb被禁时在app端使用命令行操作 pkg update &amp;&amp; pkg install htop 在app端安装管理进程的包 xdebuggable &amp;&amp; XAppDebug启动EdXposed,搜索xdebuggable 和XAppDebug模块并安装开启debug apk(需要借助ssr科学上网) ro.debuggable adb push MagiskHidePropsConf-v5.3.4.zip /sdcard/Download 并通过Magisk Manager-模块-下载-安装MagiskHidePropsConf-v5.3.4.zip reboot-adb shell-props 123456789101112131415161718192021222324252627282930313233343536373839404142434445461 - Edit device fingerprint2 - Force BASIC key attestation3 - Device simulation (disabled)4 - Edit MagiskHide props5 - Add&#x2F;edit custom props6 - Delete prop values7 - Script settings8 - Collect logsu - Perform module update checkr - Reset all options&#x2F;settingsb - Reboot devicee - ExitSee the module readme or thesupport thread @ XDA for details.Enter your desired option: 41 - ro.debuggable2 - ro.secure3 - ro.build.type4 - ro.build.tags5 - ro.bootmode6 - ro.boot.modea - Change all propsb - Go back to main menue - ExitPick several options at once byseparating inputs with a comma.Example: 1,3,4See the module readme or thesupport thread @ XDA for details.Enter your desired option: 1You currently have the safe value set.Are you sure you want to change it to 1?Enter y(es), n(o) or e(xit): yDo you want to reboot now (y&#x2F;n)?Enter y(es), n(o) or e(xit): y getprop ro.debuggable 即可查看1,开启全局可调式 Pixel XLlineageos,twrp 12345678910111213141516171819adb reboot bootloader fastboot boot twrp-3.4.0-0-marlin.img 进入twrp「TWRP主界面」-&gt;「Wipe」-&gt;「Format Data」 输入yes「Adavanced Wipe」-&gt; 勾选「Dalvik &#x2F; ART Cache」、「Cache」、「System」、「Data」、「Internal Storage」（切勿勾选到「Vendor」） -&gt; 划过滑动条确认擦除 「TWRP主界面」-&gt;「Advanced」-&gt;「ADB Sideload」（划过滑条即可） 勾选双清adb sideload lineage-17.1-20201028-nightly-marlin-signed.zip 重启设置-关于手机-版本号-8次打开开发者选项设置-系统-高级-开发者选项-Android 调试adb install MagiskManager-v7.5.1.apkadb install EdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apkadb push magisk-riru-v21.3.zip &#x2F;sdcard&#x2F;Downloadadb push MagiskHidePropsConf-v5.3.4.zip &#x2F;sdcard&#x2F;Downloadadb push EdXposed-SandHook-v0.4.6.2.4529.-release.zip &#x2F;sdcard&#x2F;Downloadadb reboot bootloaderfastboot boot twrp-3.4.0-0-marlin.img「TWRP主界面」-&gt;「Advanced」-&gt;「ADB Sideload」（划过滑条即可）adb sideload Magisk-v20.4.zip 重启通过Magisk模块新增选择下载目录，安装riru，MagiskHidePropsConf，EdXposedadb install JustTrustMePlus-debug.apk marlin,SR5-SuperSU-v2.82-SR5-20171001224502.zip,xposed-v89-sdk25-arm64.zip,XposedInstaller_3.1.5 12345678adb reboot bootloader .&#x2F;flash-all.bat设置-关于手机-版本号-8次打开开发者选项设置-系统-高级-开发者选项-Android 调试adb install XposedInstaller_3.1.5.apkfastboot boot twrp-3.4.0-0-marlin.imginstall SR5-SuperSU-v2.82-SR5-20171001224502.zip,xposed-v89-sdk25-arm64.zipadb push timeadjust.sh &#x2F;data&#x2F;local&#x2F;tmp &amp;&amp; sh timeadjust.sh pixel系列安装xposed不可使用xposed-v89-sdk25-arm64.zip，只能ssr后谷歌下载xposed框架安装。 Nexus 6P12345678910111213141516171819adb reboot bootloaderfastboot devicesfastboot erase cache 如出现&lt; waiting for any device &gt;，插拔usbfastboot erase userdatafastboot flashing unlockfastboot flash bootloader .\\bootloader-angler-angler-03.68.imgfastboot reboot-bootloaderfastboot flash radio .\\radio-angler-angler-03.81.imgfastboot reboot-bootloaderfastboot flash vendor .\\image-angler-n2g48c\\vendor.imgfastboot reboot-bootloaderfastboot flash system .\\image-angler-n2g48c\\system.imgfastboot flash boot .\\image-angler-n2g48c\\boot.imgfastboot flash recovery recovery.imgfastboot erase cachefastboot erase userdatafastboot flash cache cache.imgfastboot flash userdata userdata.imgfastboot flashing lock 设置-关于手机-版本号8下点击-进入开发者模式-打开开发者选项 adb push UPDATE-SuperSU-v2.79-20161211114519.zip /sdcard adb push xposed-v89-sdk25-arm64.zip /sdcard rom:https://dl.google.com/dl/android/aosp/angler-n2g48c-factory-6a21e528.zip 解压得到angler-n2g48c-factory-6a21e528\\angler-n2g48c\\image-angler-n2g48c superSu:https://download.chainfire.eu/1016/SuperSU/UPDATE-SuperSU-v2.79-20161211114519.zip xposed安卓7.1对应sdk:https://dl-xda.xposed.info/framework/sdk25/arm64/xposed-v89-sdk25-arm64.zip xposed apk:https://dl.xda-cdn.com/4/3/9/3/0/8/2/XposedInstaller_3.1.5.apk?key=4Rkip9MZy_4KitcodXSxBw&amp;ts=1598862686 twrp:https://dl.twrp.me/angler/twrp-3.4.0-0-angler.img Kali NetHunter12345678910111213141516171819202122232425wget https:&#x2F;&#x2F;dl.google.com&#x2F;dl&#x2F;android&#x2F;aosp&#x2F;angler-opm1.171019.011-factory-39448337.zipadb kill-serveradb start-serveradb reboot bootloader.&#x2F;flash-all.sh 如报错替换fastboot,which fastboot,使用fastboot8.1.0r1,开启开发者选项，打开USB调试 https:&#x2F;&#x2F;www.kali.org&#x2F;kali-nethunter&#x2F;https:&#x2F;&#x2F;www.offensive-security.com&#x2F;kali-linux-nethunter-download&#x2F;Nexus 6P Oreo (ZIP)adb push SR5-SuperSU-v2.82-SR5-20171001224502.zip &#x2F;sdcard&#x2F;adb push nethunter-2021.1-angler-oreo-kalifs-full.zip &#x2F;sdcard&#x2F;adb push timeadjust.sh &#x2F;sdcard&#x2F;adb reboot bootloaderfastboot flash recovery twrp-3.4.0-0-angler.img刷完之后按音量向下键，选择Recovery mode，按电源键进入，进入Recovery之后，选择Install→SR5-SuperSU-v2.82-SR5-20171001224502.zip开始刷机。再次进入recovery，把nethunter-2020.2-pre3-angler-oreo-kalifs-full.zip.torrent刷进去，中间解压Kali rootfs的过程，会至多25分钟连接wifish timeadjust.sh 同步时间，reboot刷机结束后进入系统首次也要先点击Nethunter的应用，申请的所有权限都给，左侧导航进入Kali Chroot Manager，点击START KALI CHROOT，只要初始化这一次，后续无论如何重启都会出现如图所示的Everything is fine and Chroot has been started!。点开Nethunter终端这款App，选择KALI，进入Kali系统apt update升级系统中的软件库信息apt install neofetch htop jnettop点开Nethunter进入标左侧签KeX Manager，点击“SETUP LOCAL SERVER”，会要求输入一个连接密码和显示密码，输入和确认即可，然后点击“START SERVER”开启服务器。点开“Nethunter KeX”这个App，在密码那一栏输入密码之后，点击“Connect”进行连接，即可直接进入Kali Nethunter操作系统的桌面。 搭配QtScrcpy就可以在电脑上观看手机屏幕上的内容，或者通过usb一拖四实现鼠标键盘完全电脑操作。该系统自动集成了java,BurpSuite2020.06,charles,python3,python。 vnc点开Nethunter这个app 切换到Kali Chroot Manager,START KALI CHROOT 切换到Kali Services，将SSH启动并且勾选Start at Boot，这样就拥有了sshd 切换到Kex Manage–SETUP LOCAL SERVER 设置好密码后–取消Localhost Only–START SERVER–OPEN KEX CLIENT 打开VNC Viewer,通过NetHunter 终端查看ip地址，显示器为1，开启VNC登录 通过一拖四的typec转USB，连接键盘鼠标，将Nexus 6p变成一台kali电脑。 Nexus1234567891011121314151617adb reboot bootloaderfastboot oem unlockfastboot erase cache 如出现&lt; waiting for any device &gt;，插拔usbfastboot erase userdatafastboot flash bootloader .\\bootloader-hammerhead-hhz20h.imgfastboot flash radio .\\radio-hammerhead-m8974a-2.0.50.2.30.imgfastboot reboot-bootloadercd .\\image-hammerhead-m4b30z\\fastboot flash recovery recovery.imgfastboot flash boot boot.imgfastboot flash system system.imgfastboot flash userdata userdata.imgfastboot erase cachefastboot erase userdatafastboot flash cache cache.imgfastboot flash userdata userdata.imgfastboot reboot 设置-关于手机-版本号8下点击-进入开发者模式-打开开发者选项 adb push UPDATE-SuperSU-v2.79-20161211114519.zip /sdcard adb push .\\xposed-v89-sdk23-arm.zip /sdcard 1234567adb reboot bootloaderfastboot flash recovery twrp-3.4.0-0-hammerhead.img 然后进入recovery modeadb install .\\XposedInstaller_3.1.5.apk 安装Xposedadb shelladb shell 输入su获取超级用户权限chmod 711 &#x2F;data&#x2F;user&#x2F;0&#x2F;de.robv.android.xposed.installerreboot 安装完毕 小米 Mix 2打开开发者选项-usb调试 -设备解锁状态-绑定账号和设备 adb reboot bootloader 解锁bootloader，执行miflash_unlock.exe EdXposed-SandHook-v0.4.6.2.4529.-release.zip twrp-3.3.1-1-chiron.img 12345678910111213adb reboot bootloaderfastboot flash recovery twrp-3.3.1-1-chiron.imgfastboot boot twrp-3.3.1-1-chiron.imgadb push lineage-17.0-chiron.zip 不能有中文进入twrp后清除Cache，System，Data分区install lineage-17.0-chiron.zipinstall Magisk-v20.4.zipadb install MagiskManager-v7.5.1.apk adb install EdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apk在magisk中安装adb push magisk-riru-v21.3.zip &#x2F;sdcard&#x2F;Downloadadb push MagiskHidePropsConf-v5.3.4.zip &#x2F;sdcard&#x2F;Downloadadb push EdXposed-SandHook-v0.4.6.2.4529.-release.zip &#x2F;sdcard&#x2F;Download 小米6我的设备-全部参数-双击8次MIUI版本-开发者选项 更多设置-开发者选项-usb调试 -设备解锁状态-绑定账号和设备 解锁bootloader，执行miflash_unlock.exe https://download.lineageos.org/sagit lineage-17.1-20201022-nightly-sagit-signed.zip twrp-3.3.1-2-sagit.img fw_sagit_miui_MI6Global_V10.4.1.0.PCAMIXM_38edd1584c_9.0.zip 12345678910111213adb reboot bootloader 重启到引导系统fastboot flash recovery twrp-3.3.1-2-sagit.imgfastboot reboot 执行完命令马上长按音量+ 清除数据fastboot reboot 重启进入 TWRP ，执行完命令马上长按音量+，滑动开始「TWRP主界面」-&gt;「Wipe」-&gt;「Format Data」 输入yes「Adavanced Wipe」-&gt; 勾选「Dalvik &#x2F; ART Cache」、「Cache」、「System」、「Data」、「Internal Storage」（切勿勾选到「Vendor」） -&gt; 划过滑动条确认擦除 「TWRP主界面」-&gt;「Advanced」-&gt;「ADB Sideload」（划过滑条即可）adb sideload fw_sagit_miui_MI6Global_V10.4.1.0.PCAMIXM_38edd1584c_9.0.zip 刷完后手机会自动退出 ADB Sideload「TWRP主界面」-&gt;「Advanced」-&gt;「ADB Sideload」（划过滑条即可）adb sideload lineage-17.1-20201105-nightly-sagit-signed.zip 刷完后手机会自动退出 ADB Sideload重启按住音量+ 进入twrpinstall Magisk-v20.4.zip 重启adb install MagiskManager-v7.5.1.apk 设置-关于手机-版本号-8次打开开发者选项 设置-系统-高级-开发者选项-Android 调试 123456adb install EdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apk在magisk中安装adb push magisk-riru-v21.3.zip &#x2F;sdcard&#x2F;Downloadadb push MagiskHidePropsConf-v5.3.4.zip &#x2F;sdcard&#x2F;Downloadadb push EdXposed-SandHook-v0.4.6.2.4529.-release.zip &#x2F;sdcard&#x2F;Downloadadb install JustTrustMePlus-debug.apk Genymotion安装全程开全局代理，安装nexus 5x 8.0network mode选择Bridge或者在virtualbox中修改网络为桥接，如virtualbox网络连接里没有桥接网卡选择修改D:\\VirtualBox\\drivers\\network\\netlwf\\VBoxNetLwf.infsettings-system-Languages&amp;input-Languages-Add a language-简体中文 adb 无法连接genymotion怎么办？ 修改genymotion的settings，Use custom Android SDK tools为本地android sdk路径adb kill-server + adb start-server 重启adb安装wifiadb后即可，默认可以连接192网段，配置桥接，可adb connect 192.168.0.104:5555 arm桥接 uname -a i686 查看cpu架构为x86 32位 不支持arm，需要安装arm桥，直接将 Genymotion-ARM-Translation_for_8.0.zip拖入nexus 5x 8.0, 进行安装adb reboot 即可安装带有arm的so的apk Kali别用Windows了，鲁迅曾经说过，他在逆向生涯中超过一半的苦难均由Windows赐予。 vmware安装文件 秘钥：YC34H-6WWDK-085MQ-JYPNX-NZRA2 kali-linux-2020.4-vmware-amd64.7z种子，使用vmware打开vmx文件，配置6g内存，80g磁盘存储，网络适配选择桥接到本地网卡(虚拟网络编辑器)，默认账密：kali/kali，sudo passwd root 修改密码123456 重启后使用root登录，android-studio-ide-201.7042882-linux.tar.gz安装包~/.cache/vmware/drag_and_drop 定期删除拷贝的文件缓存 基本配置12345678apt update;apt install htop jnettop tmux iotopdpkg-reconfigure tzdata 选择Asia-Shanghai apt update 更新自动同步时间apt install xfonts-intl-chinese 装中文字体apt-get install ttf-wqy-microhei# nano /etc/ssh/sshd_config 开启sshdPermitRootLogin yes# /etc/init.d/ssh start 常用软件1234567tar zxf android-studio-ide-201.7042882-linux.tar.gzcd ~/Desktop/android-studio/bin &amp;&amp; ./studio.sh 启动android studioctrl+shift+t 当前窗口新建终端vim ~/.zshrcexport PATH=\"/root/Android/Sdk/platform-tools:$PATH\" 加入环境变量exec \"$SHELL\"dpkg -i code_1.52.1-1608136922_amd64.deb 安装vscode as若报错To build this project, accept the SDK license agreements and install the missing components？ 执行/root/Android/Sdk/tools/bin/sdkmanager –licenses Android设备投屏 NodeJs jadx-1.2.0.zip多dex打开，修改jadx-gui中set DEFAULT_JVM_OPTS=&quot;-Xms512M&quot; &quot;-Xmx8g&quot;,加入zshrc的环境变量中export PATH=&quot;/root/Android/Sdk/ndk-bundle:/root/Android/Sdk/platform-tools:${JAVA_HOME}/bin:$PATH:/root/Desktop/charles/bin:/root/Desktop/jadx-1.2.0/bin:$NDK_HOME&quot; 123curl -fsSL https://deb.nodesource.com/setup_14.x | bash -apt-get install -y nodejsnpm install --save @types/frida-gum frida代码提示 jeb-pro-3.19.1.202005071620_pwd_ilbtcdnwiuypbzeo_.7z 运行./jeb_linux.sh，输入密码：ilbtcdnwiuypbzeo，进入界面点击Manual Key Generation中间按钮获取LICENSE DATA，运行jebKeygen.py 获取license key后输入到界面的key中，continue Kali Linux里的as4的DDMS启动失败，原因是要用as自带的jre来启动，直接./monitor用的是Kali系统的jdk，版本太高了ln -s /root/Desktop/android-studio/jre/ /root/Android/Sdk/tools/lib/monitor-x86_64/,然后通过~/Android/Sdk/tools/monitor打开ddms vim ~/.bashrc &amp;&amp; source ~/.bashrc export PATH=$PATH:/root/Android/Sdk/platform-tools jdk1.8 123456789101112apt-get remove openjdk-11-jre-headless:amd64apt-get remove openjdk-11-jre:amd64tar zxf jdk-8u191-linux-x64.tar.gz -C &#x2F;opt&#x2F;jdkvim ~&#x2F;.zshrcexport JAVA_HOME&#x3D;&#x2F;opt&#x2F;jdkexport CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;libexport PATH&#x3D;&quot;&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;ndk-bundle:&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;platform-tools:$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH&quot;source ~&#x2F;.zshrcupdate-alternatives --install &#x2F;usr&#x2F;bin&#x2F;java java &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;java 1update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;javac javac &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;javac 1update-alternatives --set java &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;javaupdate-alternatives --set javac &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;javac nexus 5x 安装流程 twrp-&gt;SuperSu-&gt; nethunter kali nethunter下载nexus 5x nethunter，使用投屏可变成一个迷你的linux渗透系统，通过twrp进行install ，sh userinit.sh 同步时间 tab smali与java代码转换 ctrl+b 下断点（注意这个必须在smali代码界面才有用） esc 回退上一级引用 activity_main.xml中配置的view组件：jeb中以十六进制存在于代码中，利用计算器的程序员模式转为十进制，jadx将该十进制存入resources.arsc，gda有APK入口直接进入MainActivity，同样以十六进制存入代码中。 科学上网dpkg -i electron-ssr-0.2.6.deb 卸载使用-r，查询使用-l ,失败缺少包，经过https://pkgs.org/ 查找所缺的包并安装 123456apt --fix-broken installapt-get install gconf2dpkg -i libdbusmenu-gtk4_18.10.20180917_bzr492+repack1-2_amd64.deb dpkg -i libindicator7_0.5.0-4_amd64.deb dpkg -i libappindicator1_0.4.92-8_amd64.debdpkg -i electron-ssr-0.2.6.deb 启动electron-ssr的pac模式即可vim /etc/proxychains4.conf 通过右键复制SSR服务器订阅代理设置 1http 127.0.0.1 12333 基本命令 getprop ro.product.cpu.abi 判断系统cpu版本 虚拟机一般都是x86 dumpsys meminfo pid 查看进程占用内存映射的信息 cat /proc/pid/maps 进程加载的so cat /proc/pid/maps | grep -i libart.so 所有java代码通过libart.so解析，脱壳机的关键 dumpsys activity top 显示当前的Activity，显示View Hierarchy，看view的类信息 dumpsys package com.soviet.hook4crawler 查看运行包信息 pm list packages 查看所有安装的包 pyenv环境对python不同包(frida,objection…)多版本管理 全套安装最新版本：proxychains pip install objection 3.8.512345678910111213ctrl+alt+t 新建终端git clone https://github.com/pyenv/pyenv.git ~/.pyenv 安装pyenv，python全版本随意切echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' &gt;&gt; ~/.zshrcecho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' &gt;&gt; ~/.zshrcecho -e 'if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\\n eval \"$(pyenv init -)\"\\nfi' &gt;&gt; ~/.zshrcexec \"$SHELL\"apt-get update; apt-get install --no-install-recommends make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-devPYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pyenv install 3.8.5 使用代理访问，不然会报错you can specify \"--disable-ipv6\".pyenv local 3.8.5python -Vpyenv local system 切换原系统pyenvpip install frida-toolsproxychains4 pip install objection==1.9.5 针对指定frida版本的objection，通过pypi中查找frida release日期稍后一点版本的objection即可7x x frida-server-14.2.8-android-arm64.xz 123456adb push frida-server-14.2.8-android-arm64 /data/local/tmpmv frida-server-14.2.8-android-arm64 fs1428arm64 改名fs1428arm64,防止反调试chmod 777 fs1428arm64 加权./fs1428arm64frida-ps -Uandroid hooking list classes 1234567891011121314android sslpinning disable 关闭app的ssl校验android hooking set return_value com.xxx.xxx.methodName false 设置返回值android hooking generate simple com.sf.security.AuthConfig 直接生成hook代码android hooking search classes [search_name] android hooking search methods [search_name] android intent launch_activity [class_activity]android hooking list class_methods com.android.settings.DisplaySettings 查看类全部方法android root disable 关闭app的root检测android heap search instances com.android.settings.DisplaySettings 堆内存中搜索指定类的实例android heap execute 40977078 c 拿到hashcode调用c方法android heap execute 0x2526 getPreferenceScreenResId 直接调用指定实例下的方法plugin wallbreaker classdump --fullname com.sf.security.AuthConfigplugin wallbreaker objectsearch com.sf.security.AuthConfigplugin wallbreaker objectdump --fullname 0x36d6 查看源码 3.8.0123456PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pyenv install 3.8.0 pyenv local 3.8.0 PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pip install frida==12.8.0PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pip install frida-tools==5.3.0PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pip install objection==1.8.4objection -g com.android.settings explore 7z x frida-server-12.8.0-android-arm64 12345adb push frida-server-12.8.0-android-arm64 /data/local/tmpmv frida-server-12.8.0-android-arm64 fs128arm64 改名防止反调试chmod 777 frida-server-12.8.0-android-arm64objection -g com.android.settings exploreandroid hooking list classes 特定版本frida 按照这个顺序，在装objection的时候，就会直接Requirement already satisfied，不会再去下载新的frida来安装了。 123pip install frida&#x3D;&#x3D;12.8.0 pip install frida-tools&#x3D;&#x3D;5.3.0 pip install objection&#x3D;&#x3D;1.8.4 frida开发环境 pyenv local 3.8.0 &amp;&amp; ./fs128arm64 git clone https://github.com/oleavr/frida-agent-example.git cd frida-agent-example/ npm install 使用VSCode等IDE打开此工程，在agent下编写typescript，会有智能提示。 npm run watch会监控代码修改自动编译生成js文件 frida -UF -l demo.js usb连接手机保存将自动调用demo.js 进行hook Java.perform(function(){console.log(&quot;frida hook&quot;)}) frida -UF -l demo.js –runtime=v8 使用v8引擎 Java.perform(()=&gt;{console.log(&quot;Hello World&quot;)}) frida-ps -U 查看所有进程 frida -H 192.168.0.100:5555 -f com.ttxapps.wifiadb -l demo.js –runtime=v8 远程hook,-l指定脚本 frida -Uf com.android.settings -l demo.js –runtime=v8 –no-pause 经过usb主动启动应用调用demo.js,-f是spawn模式,–no-pause直接加载应用，没有的话需要%resume启动主线程 frida -UF –runtime=v8 -e “Java.perform(()=&gt;{console.log(‘Hello World’)})” -o /root/log.txt 直接执行脚本写入文件 远程连接 ./fs128arm64 -v -l 0.0.0.0:8888 指定端口启动frida，默认端口27042 frida-ps -H 192.168.0.8:8888 指定-U表示usb,-H表示主机ip frida -H 192.168.0.8:8888 -F 指定-H表示主机ip，-F表示前台应用，输入frida即可查看Frida信息 cd frida-agent-example/ &amp;&amp; npm install &amp;&amp; npm run watch &amp;&amp; frida -H 192.168.0.8:8888 -F -l agent/demo.js 远程调用js脚本 1234567Java.perform(()&#x3D;&gt;&#123;console.log(&quot;Hello World&quot;)&#125;) function main()&#123; Java.perform(function()&#123; console.log(&quot;hello&quot;) &#125;)&#125;setImmediate(main) 远程调用 12345678910111213import fridadevice &#x3D; frida.get_usb_device() print(device.get_frontmost_application())#pid &#x3D; device.spawn([&quot;com.onejane.demo02&quot;])pid&#x3D;device.get_frontmost_application().pid # 若双进程保护，指定pid进行hook print(device.enumerate_processes()) # 枚举所有进程print(device.enumerate_applications()) # 枚举所有包名# device.resume(pid)# time.sleep(1)session &#x3D; device.attach(pid) with open(&quot;demo.js&quot;) as f: script &#x3D; session.create_script(f.read())script.load() plugins 1234proxychains git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;FRIDA-DEXDump ~&#x2F;Downloads&#x2F;FRIDA-DEXDump 脱壳mv ~&#x2F;Downloads&#x2F;FRIDA-DEXDump&#x2F;frida_dexdump ~&#x2F;.objection&#x2F;plugins&#x2F;dexdump 在plugins子目录插件下必须有__init__.pyproxychains git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;Wallbreaker ~&#x2F;.objection&#x2F;plugins&#x2F;Wallbreaker 内存漫游objection -N -h 192.168.0.8 -p 8888 -g com.android.settings explore -P ~&#x2F;.objection&#x2F;plugins 远程连接批量加载插件 卸载pip uninstall frida pip uninstall frida-tools pip uninstall objection MikRompixel+android10 下载marlin-qp1a.191005.007.a3-factory-bef66533.zip，将aosp10r2_marlin线刷包修改其中android-info.txt压缩为image-marlin-qp1a.191005.007.a3.zip 12345require board&#x3D;marlin|sailfishrequire version-bootloader&#x3D;8996-012001-1908071822require version-baseband&#x3D;8996-130361-1905270421 刷机完成后安装**MikManager**，参考Xposed搭建开发里安装LSPosed，无线网如果有问题，安装captivemgr申请权限如果su冲突关闭magisk中的超级用户访问权限。配置frida-server-15.1.11-android-arm64.xz和frida-server-14.2.18-android-arm64.xz所需要的的环境 1234567891011PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pyenv install 3.8.6pyenv local 3.8.6PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pip install frida&#x3D;&#x3D;14.2.18PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pip install frida-tools&#x3D;&#x3D;9.2.4PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pip install objection&#x3D;&#x3D;1.11.0PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pyenv install 3.8.7pyenv local 3.8.7PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pip install frida&#x3D;&#x3D;15.1.11PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pip install frida-tools&#x3D;&#x3D;10.4.1PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains4 pip install objection&#x3D;&#x3D;1.11.0 辅助-选择脚本，启动后根据logcat查看app启动时log 12345678910function Log(info)&#123; Java.perform(function()&#123; var LogClass &#x3D; Java.use(&quot;android.util.Log&quot;); LogClass.e(&quot;mikrom&quot;,info); &#125;)&#125;function main() &#123; Log(&quot;666&quot;)&#125;setImmediate(main) 辅助-监听，frida attach模式，启动app后再附加 辅助-监听并阻塞，frida spawn模式，启动app后阻塞启动hook var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"25827-1638538754631-918\", \"name\": \"万物皆可逆向\", \"qrcode\": \"https://onejane.github.io/gzh.jpg\", \"keyword\": \"密码\" }); }","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"kali","slug":"kali","permalink":"http://onejane.github.io/tags/kali/"},{"name":"xposed","slug":"xposed","permalink":"http://onejane.github.io/tags/xposed/"}]}],"categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"},{"name":"NDK开发","slug":"安卓逆向/NDK开发","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/NDK%E5%BC%80%E5%8F%91/"},{"name":"开发技巧","slug":"开发技巧","permalink":"http://onejane.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"},{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"},{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"},{"name":"脚本","slug":"脚本","permalink":"http://onejane.github.io/categories/%E8%84%9A%E6%9C%AC/"},{"name":"生活","slug":"生活","permalink":"http://onejane.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"chales","slug":"chales","permalink":"http://onejane.github.io/tags/chales/"},{"name":"ida","slug":"ida","permalink":"http://onejane.github.io/tags/ida/"},{"name":"xposed","slug":"xposed","permalink":"http://onejane.github.io/tags/xposed/"},{"name":"unidbg","slug":"unidbg","permalink":"http://onejane.github.io/tags/unidbg/"},{"name":"frida_hook_libart","slug":"frida-hook-libart","permalink":"http://onejane.github.io/tags/frida-hook-libart/"},{"name":"unidbg-server","slug":"unidbg-server","permalink":"http://onejane.github.io/tags/unidbg-server/"},{"name":"SO","slug":"SO","permalink":"http://onejane.github.io/tags/SO/"},{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"},{"name":"wasm","slug":"wasm","permalink":"http://onejane.github.io/tags/wasm/"},{"name":"ExAndroidNativeEmu","slug":"ExAndroidNativeEmu","permalink":"http://onejane.github.io/tags/ExAndroidNativeEmu/"},{"name":"IDA","slug":"IDA","permalink":"http://onejane.github.io/tags/IDA/"},{"name":"fiddler","slug":"fiddler","permalink":"http://onejane.github.io/tags/fiddler/"},{"name":"rpc","slug":"rpc","permalink":"http://onejane.github.io/tags/rpc/"},{"name":"NDK","slug":"NDK","permalink":"http://onejane.github.io/tags/NDK/"},{"name":"mybatis","slug":"mybatis","permalink":"http://onejane.github.io/tags/mybatis/"},{"name":"FART","slug":"FART","permalink":"http://onejane.github.io/tags/FART/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://onejane.github.io/tags/elasticsearch/"},{"name":"kali","slug":"kali","permalink":"http://onejane.github.io/tags/kali/"},{"name":"redis","slug":"redis","permalink":"http://onejane.github.io/tags/redis/"},{"name":"ssl","slug":"ssl","permalink":"http://onejane.github.io/tags/ssl/"},{"name":"aosp","slug":"aosp","permalink":"http://onejane.github.io/tags/aosp/"},{"name":"scrapy","slug":"scrapy","permalink":"http://onejane.github.io/tags/scrapy/"},{"name":"fart","slug":"fart","permalink":"http://onejane.github.io/tags/fart/"},{"name":"postern","slug":"postern","permalink":"http://onejane.github.io/tags/postern/"},{"name":"charles","slug":"charles","permalink":"http://onejane.github.io/tags/charles/"},{"name":"youpk","slug":"youpk","permalink":"http://onejane.github.io/tags/youpk/"},{"name":"dexdump","slug":"dexdump","permalink":"http://onejane.github.io/tags/dexdump/"},{"name":"selenium","slug":"selenium","permalink":"http://onejane.github.io/tags/selenium/"},{"name":"wallbreaker","slug":"wallbreaker","permalink":"http://onejane.github.io/tags/wallbreaker/"},{"name":"scrapy_redis","slug":"scrapy-redis","permalink":"http://onejane.github.io/tags/scrapy-redis/"},{"name":"mongo","slug":"mongo","permalink":"http://onejane.github.io/tags/mongo/"},{"name":"asyncore","slug":"asyncore","permalink":"http://onejane.github.io/tags/asyncore/"},{"name":"socket","slug":"socket","permalink":"http://onejane.github.io/tags/socket/"},{"name":"asyncio","slug":"asyncio","permalink":"http://onejane.github.io/tags/asyncio/"},{"name":"websocket","slug":"websocket","permalink":"http://onejane.github.io/tags/websocket/"},{"name":"requests","slug":"requests","permalink":"http://onejane.github.io/tags/requests/"},{"name":"pymongo","slug":"pymongo","permalink":"http://onejane.github.io/tags/pymongo/"},{"name":"flask","slug":"flask","permalink":"http://onejane.github.io/tags/flask/"},{"name":"xpath","slug":"xpath","permalink":"http://onejane.github.io/tags/xpath/"},{"name":"css","slug":"css","permalink":"http://onejane.github.io/tags/css/"},{"name":"json","slug":"json","permalink":"http://onejane.github.io/tags/json/"},{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","permalink":"http://onejane.github.io/tags/ThreadPoolExecutor/"},{"name":"BoundedSemaphore","slug":"BoundedSemaphore","permalink":"http://onejane.github.io/tags/BoundedSemaphore/"},{"name":"parsel","slug":"parsel","permalink":"http://onejane.github.io/tags/parsel/"},{"name":"classloader","slug":"classloader","permalink":"http://onejane.github.io/tags/classloader/"},{"name":"Dalvik","slug":"Dalvik","permalink":"http://onejane.github.io/tags/Dalvik/"},{"name":"ART","slug":"ART","permalink":"http://onejane.github.io/tags/ART/"},{"name":"Socket","slug":"Socket","permalink":"http://onejane.github.io/tags/Socket/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://onejane.github.io/tags/WebSocket/"},{"name":"Protobuf","slug":"Protobuf","permalink":"http://onejane.github.io/tags/Protobuf/"},{"name":"XMPP","slug":"XMPP","permalink":"http://onejane.github.io/tags/XMPP/"},{"name":"nacos","slug":"nacos","permalink":"http://onejane.github.io/tags/nacos/"},{"name":"feign","slug":"feign","permalink":"http://onejane.github.io/tags/feign/"},{"name":"gateway","slug":"gateway","permalink":"http://onejane.github.io/tags/gateway/"},{"name":"sentinel","slug":"sentinel","permalink":"http://onejane.github.io/tags/sentinel/"},{"name":"opencv","slug":"opencv","permalink":"http://onejane.github.io/tags/opencv/"},{"name":"okhttp3","slug":"okhttp3","permalink":"http://onejane.github.io/tags/okhttp3/"},{"name":"HttpURLConnection","slug":"HttpURLConnection","permalink":"http://onejane.github.io/tags/HttpURLConnection/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://onejane.github.io/tags/Retrofit/"},{"name":"python","slug":"python","permalink":"http://onejane.github.io/tags/python/"},{"name":"vmp","slug":"vmp","permalink":"http://onejane.github.io/tags/vmp/"},{"name":"dex2c","slug":"dex2c","permalink":"http://onejane.github.io/tags/dex2c/"},{"name":"burpsuite","slug":"burpsuite","permalink":"http://onejane.github.io/tags/burpsuite/"},{"name":"so","slug":"so","permalink":"http://onejane.github.io/tags/so/"},{"name":"hexo","slug":"hexo","permalink":"http://onejane.github.io/tags/hexo/"}]}