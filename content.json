{"meta":{"title":"J","subtitle":"朝花夕拾","description":"逆向,爬虫","author":"J","url":"http://onejane.gitee.io","root":"/"},"pages":[{"title":"404","date":"2021-01-30T10:32:36.000Z","updated":"2021-01-30T10:33:01.911Z","comments":true,"path":"/404.html","permalink":"http://onejane.gitee.io/404.html","excerpt":"","text":""},{"title":"标签","date":"2021-01-30T07:34:05.000Z","updated":"2021-01-30T08:00:59.817Z","comments":true,"path":"tags/index.html","permalink":"http://onejane.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-30T07:34:23.000Z","updated":"2021-01-30T08:30:40.321Z","comments":true,"path":"categories/index.html","permalink":"http://onejane.gitee.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"加壳与脱壳之二代壳函数抽取","slug":"加壳与脱壳之二代壳函数抽取","date":"2021-03-25T00:07:35.000Z","updated":"2021-03-27T00:36:51.346Z","comments":true,"path":"2021/03/25/加壳与脱壳之二代壳函数抽取/","link":"","permalink":"http://onejane.gitee.io/2021/03/25/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E4%BA%8C%E4%BB%A3%E5%A3%B3%E5%87%BD%E6%95%B0%E6%8A%BD%E5%8F%96/","excerpt":"","text":"函数抽取宣告一代壳整体保护的结束，由此进入二代壳的时代。 Dalvik Android中实现「类方法指令抽取方式」加固方案原理解析：对dex结构简单介绍，定位函数指令地址，实现函数抽取壳的demo，对getPwd函数进行指令抽取，类被加载时重填恢复指令。 Android免Root权限通过Hook系统函数修改程序运行时内存指令逻辑：为了修改原有系统对dex加载流程，需要hook系统某些关键函数，自然可以在原有函数逻辑中添加需要自定义的逻辑功能，再添加一些保护函数的填充。 源码分析实现函数抽取壳需要保证对函数恢复的时机肯定早于函数被调用的时机，即当函数被调用时指令流必须已经被修复了，否则app逻辑被破坏导致app崩了。再选择时机，Android中实现「类方法指令抽取方式」加固方案原理解析中选择了dexFindClass函数。。 对于函数来说在被调用之前，首先dex加载(dexclassloader动态加载)，对类加载需要经过装载-链接-初始化，在这些加载过程中有非常多的时机供我们选择，Dalvik源代码编译生成的libdvm.so通过ida打开，搜索文中的dexFindClass函数，获取导出的函数名可实现函数抽取。loadClass加载一个dex中的类的流程:DexClassLoader-&gt;BaseDexClassLoader-&gt;ClassLoader的loadClass,完整体现了双亲委派的特性。 1234567891011121314151617486 protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123; &#x2F;&#x2F; 为了提高加载类效率，如果已经加载直接返回，否则进行双亲委派的父节点加载487 Class&lt;?&gt; clazz &#x3D; findLoadedClass(className);488489 if (clazz &#x3D;&#x3D; null) &#123;490 try &#123;491 clazz &#x3D; parent.loadClass(className, false);492 &#125; catch (ClassNotFoundException e) &#123;493 &#x2F;&#x2F; Don&#39;t want to see this.494 &#125;495496 if (clazz &#x3D;&#x3D; null) &#123;497 clazz &#x3D; findClass(className);498 &#125;499 &#125;500501 return clazz;502 &#125; 对于使用DexClassLoader第一次加载类的parent节点是pathClassLoader或被指定的bootClassLoader,因为类只由当前的classloader加载必然是找不到的，因此进入BaseDexClassLoader的findClass实现中。 12345678910111252 protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;53 List&lt;Throwable&gt; suppressedExceptions &#x3D; new ArrayList&lt;Throwable&gt;();54 Class c &#x3D; pathList.findClass(name, suppressedExceptions);55 if (c &#x3D;&#x3D; null) &#123;56 ClassNotFoundException cnfe &#x3D; new ClassNotFoundException(&quot;Didn&#39;t find class \\&quot;&quot; + name + &quot;\\&quot; on path: &quot; + pathList);57 for (Throwable t : suppressedExceptions) &#123;58 cnfe.addSuppressed(t);59 &#125;60 throw cnfe;61 &#125;62 return c;63 &#125; 紧接着进入pathList.findClass，其中pathList是在BaseDexClassLoader构造函数中实例化化，跟着进入pathList.findClass，调用了dex.loadClassBinaryName查找类 1234567891011121314151617317 public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;318 for (Element element : dexElements) &#123;319 DexFile dex &#x3D; element.dexFile;320321 if (dex !&#x3D; null) &#123; &#x2F;&#x2F; 尝试从每个dex中遍历找到类所在的dex中并返回类所在dex322 Class clazz &#x3D; dex.loadClassBinaryName(name, definingContext, suppressed); 323 if (clazz !&#x3D; null) &#123;324 return clazz;325 &#125;326 &#125;327 &#125;328 if (dexElementsSuppressedExceptions !&#x3D; null) &#123;329 suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));330 &#125;331 return null;332 &#125; 跟着进入loadClassBinaryName,其中调用了native层实现defineClassNative 1234567891011121314151617181920214 public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) &#123;215 return defineClass(name, loader, mCookie, suppressed);216 &#125;217218 private static Class defineClass(String name, ClassLoader loader, int cookie,219 List&lt;Throwable&gt; suppressed) &#123;220 Class result &#x3D; null;221 try &#123;222 result &#x3D; defineClassNative(name, loader, cookie);223 &#125; catch (NoClassDefFoundError e) &#123;224 if (suppressed !&#x3D; null) &#123;225 suppressed.add(e);226 &#125;227 &#125; catch (ClassNotFoundException e) &#123;228 if (suppressed !&#x3D; null) &#123;229 suppressed.add(e);230 &#125;231 &#125;232 return result;233 &#125; dalvik下Full Search搜索defineClassNative，进入/dalvik/vm/native/dalvik_system_DexFile.cpp的Dalvik_dalvik_system_DexFile_defineClassNative方法，如注释中所说从一个dex文件中加载一个类 123456789101112131415161718192021222324252627282930349static void Dalvik_dalvik_system_DexFile_defineClassNative(const u4* args,350 JValue* pResult)351&#123;352 StringObject* nameObj &#x3D; (StringObject*) args[0]; &#x2F;&#x2F; 类名353 Object* loader &#x3D; (Object*) args[1]; &#x2F;&#x2F; classloader354 int cookie &#x3D; args[2]; &#x2F;&#x2F; java层cookie355 ClassObject* clazz &#x3D; NULL;356 DexOrJar* pDexOrJar &#x3D; (DexOrJar*) cookie; &#x2F;&#x2F; 将int型cookie转为DexOrJar指针357 DvmDex* pDvmDex;358 char* name;359 char* descriptor;360361 name &#x3D; dvmCreateCstrFromString(nameObj);362 descriptor &#x3D; dvmDotToDescriptor(name);363 ALOGV(&quot;--- Explicit class load &#39;%s&#39; l&#x3D;%p c&#x3D;0x%08x&quot;,364 descriptor, loader, cookie);365 free(name);366367 if (!validateCookie(cookie))368 RETURN_VOID();369370 if (pDexOrJar-&gt;isDex)371 pDvmDex &#x3D; dvmGetRawDexFileDex(pDexOrJar-&gt;pRawDexFile);372 else373 pDvmDex &#x3D; dvmGetJarFileDex(pDexOrJar-&gt;pJarFile);374375 &#x2F;* once we load something, we can&#39;t unmap the storage *&#x2F;376 pDexOrJar-&gt;okayToFree &#x3D; false;377378 clazz &#x3D; dvmDefineClass(pDvmDex, descriptor, loader); 进入dvmGetRawDexFileDex，只是取出指针中的pDvmDex 12362INLINE DvmDex* dvmGetRawDexFileDex(RawDexFile* pRawDexFile) &#123;63 return pRawDexFile-&gt;pDvmDex;64&#125; 进入dvmDefineClass 12345671413ClassObject* dvmDefineClass(DvmDex* pDvmDex, const char* descriptor,1414 Object* classLoader)1415&#123;1416 assert(pDvmDex !&#x3D; NULL);14171418 return findClassNoInit(descriptor, classLoader, pDvmDex);1419&#125; 进入findClassNoInit，首先调用了clazz = dvmLookupClass(descriptor, loader, true);对当前加载的类名进行计算查询，如没有则返回为空，对于第一次加载必然是没有的，接着进入pClassDef = dexFindClass(pDvmDex-&gt;pDexFile, descriptor);，即Android中实现「类方法指令抽取方式」加固方案原理解析中选择的时机点，并通过hook掉类被加载时的时机，对抽取函数的恢复，实现函数还原，因此必然需要早于函数执行的时机，保证app正常运行。由于有些函数符号没有导出，就不是很容易进行hook，而在libdvm.so中的dexFindClass在IDA中是被导出的，方便hook。以上就是Dalvik下函数抽取壳的简单原理。 ARTArt下实现难点：dex2oat编译流程，dex2oat是可以进行脱壳，对抽取的dex进行编译生成了oat文件，后续的函数运行中，从oat中取出函数编译生成的二进制代码来执行，自然从dex2oat后那么我们动态修改的dex中的smali指令流就不会生效。因此如果希望填充回去smali指令生效要么禁用dex2oat实现阻止编译，这样对加载到内存中的dex文件进行填充始终会保持生效，要么保持dex2oat编译，但是还原代码时机要早于dex2oat就ok了，保证dex2oat再次对dex编译的时候，dex已经是一个完整dex，不会影响我们填充的代码，但是肯定dex文件存在完整的时候，可以利用dex2oat编译的流程进行脱壳，一般都是牺牲掉app一部分的运行效率，干掉dex2oat的过程，因为google本身提倡dex2oat就是为了提升app运行效率。 禁用dex2oat编译回到ART下DexClassLoader动态加载dex的流程，在art下搜索GenerateOatFileNoChecks，该函数完成调用dex2oat进行编译 GenerateOatFileNoChecks中调用Dex2Oat函数 12616OatFileAssistant::ResultOfAttemptToUpdate OatFileAssistant::GenerateOatFileNoChecks(617 OatFileAssistant::OatFileInfo&amp; info, CompilerFilter::Filter filter, std::string* error_msg) &#123; Dex2Oat最终调用return Exec(argv, error_msg);，Exec中调用了int status = ExecAndReturnCode(arg_vector, error_msg);,其中ExecAndReturnCode通过pid_t pid = fork();进行fork一个子进程，在子进程中调用了execve(program, &amp;args[0], envp);完成对dex2oat这个二进制程序的调用。整个流程中任意一个环节被打断，dex2oat将会被干掉，无法继续运行。TurboDex就是干掉dex2oat为了让dex在第一次动态加载时快速加载完成，因为不干掉dex2oat，art虚拟机就会调用dex2oat对当前的dex进行编译，编译过程非常耗时，可以很大地提升dexclassloader加载dex 的效率，该项目就是通过hook了execv方法实现。 众所周知,Android中在Runtime加载一个 未优化的Dex文件 (尤其在 ART 模式)需要花费 很长的时间. 当你在App中使用 插件化框架 的时候, 首次加载插件就需要耗费很长的时间. TurboDex 就是为了解决这一问题而生, 就像是给AndroidVM开启了上帝模式, 在引入TurboDex后, 无论你加载了多大的Dex文件,都可以在毫秒级别内完成. 接下来通过hook execve实现干掉dex2oat，可以通过爱奇艺xhook的GOT进行表hook干掉dex2oat，也可以用inline库hook。 36：00","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"classloader","slug":"classloader","permalink":"http://onejane.gitee.io/tags/classloader/"}]},{"title":"加壳与脱壳之一代壳dex保护","slug":"加壳与脱壳之一代壳dex保护","date":"2021-03-16T12:27:25.000Z","updated":"2021-03-25T00:05:36.462Z","comments":true,"path":"2021/03/16/加壳与脱壳之一代壳dex保护/","link":"","permalink":"http://onejane.gitee.io/2021/03/16/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E4%B8%80%E4%BB%A3%E5%A3%B3dex%E4%BF%9D%E6%8A%A4/","excerpt":"","text":"Dalvik源码分析虽然加壳技术有所不同，第一步依然是dump内存中dex，虽然安卓4.4后Dalvik淡出视野，但是影响深远。Dalvik系统DexClassLoader加载dex具体流程： 搜索DexClassLoader源码只有一个构造函数 dexPath：需要加载的dex路径 optimizedDirectory：dex优化过程中产生的odex的存放路径 libraryPath：当前classloader需要加载so的路径 parent：双亲委派中的当前dexclassloader的父节点设置的classloader 1234public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), libraryPath, parent);&#125; 进入父类BaseDexClassLoader封装大量的函数，真正逻辑存在BaseDexClassLoader的构造函数中实现，调用了父类的构造函数，该类存在与/libcore/libart和/libcore/libdvm，说明在安卓4.4中已经开始引入art相关逻辑。 12345public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(parent); this.pathList &#x3D; new DexPathList(this, dexPath, libraryPath, optimizedDirectory);&#125; 进入Dalvik的ClassLoader的构造函数，将当前的ClassLoader的父节点作为传入的parent。 123456ClassLoader(ClassLoader parentLoader, boolean nullAllowed) &#123; if (parentLoader &#x3D;&#x3D; null &amp;&amp; !nullAllowed) &#123; throw new NullPointerException(&quot;parentLoader &#x3D;&#x3D; null &amp;&amp; !nullAllowed&quot;); &#125; parent &#x3D; parentLoader;&#125; new DexPathList再初始化pathList实例，进入DexPathList构造函数，前面对参数校验，真正起作用this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,suppressedExceptions);,makeDexElements方法调用了loadDexFile返回的dex添加到element数组并返回数组。 loadDexFile中再度调用了DexFile.loadDex(file.getPath(), optimizedPath, 0)，该方法新建了一个DexFile对象，return new DexFile(sourcePathName, outputPathName, flags);，在Dexfile中调用了openDexFile(sourceName, outputName, flags)完成了对dex的处理，openDexFile中调用了openDexFileNative，其中又调用openDexFileNative(new File(sourceName).getCanonicalPath(),(outputName == null) ? null : new File(outputName).getCanonicalPath(),flags);,跟进openDexFileNative发现是一个使用c/c++实现的native函数，native private static int openDexFileNative。该方法处理类/libcore/dalvik/src/main/java/dalvik/system/DexFile.java中，对应的实现文件就是dalvik_system_DexFile查看方法Dalvik_dalvik_system_DexFile_openDexFileNative，其中调用了dvmRawDexFileOpen实现对dex文件的打开。 123456789if (hasDexExtension(sourceName) &amp;&amp; dvmRawDexFileOpen(sourceName, outputName, &amp;pRawDexFile, false) &#x3D;&#x3D; 0) &#123; ALOGV(&quot;Opening DEX file &#39;%s&#39; (DEX)&quot;, sourceName); pDexOrJar &#x3D; (DexOrJar*) malloc(sizeof(DexOrJar)); pDexOrJar-&gt;isDex &#x3D; true; pDexOrJar-&gt;pRawDexFile &#x3D; pRawDexFile; pDexOrJar-&gt;pDexMemory &#x3D; NULL;&#125; 在dvmRawDexFileOpen中dexFd = open(fileName, O_RDONLY);打开dex文件，verifyMagicAndGetAdler32(dexFd, &amp;adler32) &lt; 0对dex魔术字校验，cachedName = dexOptGenerateCacheFileName(fileName, NULL);生成优化后的odex文件路径，dvmOptimizeDexFile(optFd, dexOffset, fileSize,fileName, modTime, adler32, isBootstrap);优化当前的dex，跟进发现存在于DexPrepare.cpp中的dvmOptimizeDexFile(int fd, off_t dexOffset, long dexLength,const char* fileName, u4 modWhen, u4 crc, bool isBootstrap),该方法中pid = fork();新建了子进程用于调用/bin/dexopt对当前dex文件进行优化，结果生成odex文件。bin/dexopt的main方法中传入的文件校验是dex时，调用static int fromDex(int argc, char* const argv[])首先调用dvmPrepForDexOpt对当前优化环境准备，再调用dvmContinueOptimization对当前的fd文件进行优化 123dexLength &lt; (int) sizeof(DexHeader) 字节长度判断mapAddr &#x3D; mmap(NULL, dexOffset + dexLength, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); mmap对当前dex文件的内容进行内存映射rewriteDex(((u1*) mapAddr) + dexOffset, dexLength, doVerify, doOpt, &amp;pClassLookup, NULL); 重写dex 查看static bool rewriteDex(u1* addr, int len, bool doVerify, bool doOpt,DexClassLookup** ppClassLookup, DvmDex** ppDvmDex)方法参数有加载到内存中dex的起始地址，字节数。该方法中暴露出在Dalvik中脱壳点的相关函数，dvmDexFileOpenPartial函数中出现dexFileParse，参数包含起始地址和字节数。 以上即是dexclassloader在动态加载dex时Dalvik实现的逻辑处理，很多时机点都出现了加载的dex的起始地址，就是最好的脱壳时机。很多脱壳方法都是对**dvmDexFileOpenPartial和dexFileParse进行下断点或者进行hook，取出第一个参数(起始地址)和第二个参数(dex长度)，其实在mmap对dex内存映射时包含dex文件，对当前映射区域进行dump也可以脱下从文件形式加载dex，在rewriteDex**时也出现了dex文件加载的起始地址和大小，自然也是可以进行dump等等。通过Cydia、xposed、frida都可以对实现对关键时机的hook，取出前两个参数，拿到起始地址和长度，dump下来内存区域即可实现脱壳。 定制源码脱壳对新的一些加壳厂商的产品依然有效，除非厂商对这些函数进行hook修改，或者参考Dalvik修改实现自己的逻辑。进入Ubuntu 1604x64_4.4的编译环境虚拟机，tom/admin，4.4的源码为hammerhead。通过编译源码的方式实现以下为部分脱壳点： dvmDexFileOpenPartial搜索 dvmDexFileOpenPartial 发现在/dalvik/vm/DvmDex.cpp文件中，使用Geany打开 ~/SourceCode/android-4.4.4_r1/dalvik/vm/DvmDex.cpp，找到dvmDexFileOpenPartial方法，只需要保存起始地址和大小即可。 修改int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex) 123456789101112131415#include &lt;sys&#x2F;stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;&#x2F;&#x2F;新建保存路径用于拼接脱壳app产生的dex路径，对每个脱壳的app的脱下的dex单独起名char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dvmDexFileOpenPartial.dex&quot;,len,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,addr,len); close(fd);&#125; dexFileParse搜索**dexFileParse**发现存在/dalvik/libdex/DexFile.cpp中，使用geany编辑器打开DexFile.cpp 修改DexFile* dexFileParse(const u1* data, size_t length, int flags) 123456789101112131415#include &lt;sys&#x2F;stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;&#x2F;&#x2F;新建保存路径用于拼接脱壳app产生的dex路径，对每个脱壳的app的脱下的dex单独起名char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dvmFileParse.dex&quot;,length,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,data,length); close(fd);&#125; mmap搜索 mmap 存在于/dalvik/vm/analysis/DexPrepare.cpp的中， 修改bool dvmContinueOptimization(int fd, off_t dexOffset, long dexLength, const char* fileName, u4 modWhen, u4 crc, bool isBootstrap) 1234567891011char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dvmContinueOptimization.dex&quot;,dexLength,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,mapAddr,dexOffset + dexLength); close(fd);&#125; 第一次映射到内存中需要将dex通过010Editor修正，删除64 65 78 0A前的字符。 rewriteDex搜索rewriteDex位于/dalvik/vm/analysis/DexPrepare.cpp， 修改static bool rewriteDex(u1* addr, int len, bool doVerify, bool doOpt, DexClassLookup** ppClassLookup, DvmDex** ppDvmDex) 1234567891011char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_rewriteDex.dex&quot;,len,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,addr,len); close(fd);&#125; dexSwapVerify搜索dexSwapVerify存在于/dalvik/libdex/DexSwapVerify.cpp 修改int dexSwapAndVerify(u1* addr, int len) 1234567891011char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dexSwapAndVerify.dex&quot;,len,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,addr,len); close(fd);&#125; 编译1234~&#x2F;SourceCode&#x2F;android-4.4.4_r1$ source build&#x2F;envsetup.sh~&#x2F;SourceCode&#x2F;android-4.4.4_r1$ lunch7 选择aosp_hammerhead-userdebug~&#x2F;SourceCode&#x2F;android-4.4.4_r1$ time make -j4 如果报错直接make单线程编译 生成路径~/SourceCode/android/4.4.4_r1/out/target/product/hammerhead，将boot.img,cache.img,ramdisk.img,system.img,userdata.img拷出来 adb reboot bootloader fastboot flash system system.img 常用的img有boot,cache,ramdisk,system,userdata 安装LoadDex.apk，并把ClassLoaderTest生成的classes.dex放入/sdcard。在Activity启动的时候加载/sdcard的classes.dex的TestActivity并打印I&#39;m from TestActivity.onCreate，这就是一代壳的基本原理。 重启系统后/sdcard中已经出现一些系统中脱下的dex，启动LoadDex，grep -ril &quot;TestActivity&quot; ./*.dex 找到LoadDex中脱下的dex，gda可以看到优化后的odex的TestActivity中onCreate方法 真实案例a.apk 《百度》加固 启动后进入/sdcard , grep -ril “SplashActivity” ./*.dex b.apk 《爱加密》企业版本加固 启动后进入/sdcard , grep -ril “mvp/ui/SplashActivity” ./*.dex，内容都为null，说明用了函数抽取。 ARTInMemoryDexClassLoader源码分析加载内存中的解密字节流过程art的具体流程： 在Android 8.0中libcore搜索InMemoryDexClassLoader两个构造函数，分别加载一个或多个dex。进入父类BaseDexClassLoader.java的构造函数 123456789public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(parent); this.pathList &#x3D; new DexPathList(this, dexPath, librarySearchPath, null); if (reporter !&#x3D; null) &#123; reporter.report(this.pathList.getDexPaths()); &#125;&#125; 跟进public DexPathList(ClassLoader definingContext, ByteBuffer[] dexFiles)，前几步对传参判断，紧接着对传入的so库的处理 123456this.definingContext &#x3D; definingContext;&#x2F;&#x2F; TODO It might be useful to let in-memory dex-paths have native libraries.this.nativeLibraryDirectories &#x3D; Collections.emptyList();this.systemNativeLibraryDirectories &#x3D; splitPaths(System.getProperty(&quot;java.library.path&quot;), true);this.nativeLibraryPathElements &#x3D; makePathElements(this.systemNativeLibraryDirectories); 传入的dex只需要看this.dexElements = makeInMemoryDexElements(dexFiles, suppressedExceptions);摘除核心代码如下： 12345678910private static Element[] makeInMemoryDexElements(ByteBuffer[] dexFiles, List&lt;IOException&gt; suppressedExceptions) &#123; Element[] elements &#x3D; new Element[dexFiles.length]; int elementPos &#x3D; 0; for (ByteBuffer buf : dexFiles) &#123; DexFile dex &#x3D; new DexFile(buf); elements[elementPos++] &#x3D; new Element(dex); &#125; return elements;&#125; 进入DexFile(buf)的构造函数中，发现将buf在内存中打开 12345DexFile(ByteBuffer buf) throws IOException &#123; mCookie &#x3D; openInMemoryDexFile(buf); mInternalCookie &#x3D; mCookie; mFileName &#x3D; null;&#125; 查看openInMemoryDexFile方法，分别根据条件创建了两次cookie 1234567private static Object openInMemoryDexFile(ByteBuffer buf) throws IOException &#123; if (buf.isDirect()) &#123; return createCookieWithDirectBuffer(buf, buf.position(), buf.limit()); &#125; else &#123; return createCookieWithArray(buf.array(), buf.position(), buf.limit()); &#125;&#125; 分别查看createCookieWithDirectBuffer和createCookieWithArray两个方法，发现是两个native函数 12private static native Object createCookieWithDirectBuffer(ByteBuffer buf, int start, int end);private static native Object createCookieWithArray(byte[] buf, int start, int end); 在art模块中Full Search createCookieWithDirectBuffer,进入DexFile_createCookieWithDirectBuffer 12345678910111213141516171819202122static jobject DexFile_createCookieWithDirectBuffer(JNIEnv* env, jclass, &#x2F;&#x2F; 静态函数 第一个是jclass当前类 jobject buffer, &#x2F;&#x2F; 传入内存中的字节流 jint start, jint end) &#123; uint8_t* base_address &#x3D; reinterpret_cast&lt;uint8_t*&gt;(env-&gt;GetDirectBufferAddress(buffer)); if (base_address &#x3D;&#x3D; nullptr) &#123; ScopedObjectAccess soa(env); ThrowWrappedIOException(&quot;dexFileBuffer not direct&quot;); return 0; &#125; std::unique_ptr&lt;MemMap&gt; dex_mem_map(AllocateDexMemoryMap(env, start, end)); if (dex_mem_map &#x3D;&#x3D; nullptr) &#123; DCHECK(Thread::Current()-&gt;IsExceptionPending()); return 0; &#125; size_t length &#x3D; static_cast&lt;size_t&gt;(end - start); memcpy(dex_mem_map-&gt;Begin(), base_address, length); &#x2F;&#x2F; 对当前字节流进行内存拷贝memcpy，传入begin和length就是dex的起始地址，可以进行dump return CreateSingleDexFileCookie(env, std::move(dex_mem_map));&#125; createCookieWithDirectBuffer和createCookieWithArray都进行了CreateSingleDexFileCookie 12345678910static jobject CreateSingleDexFileCookie(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; data) &#123; std::unique_ptr&lt;const DexFile&gt; dex_file(CreateDexFile(env, std::move(data))); &#x2F;&#x2F; 根据传入dex文件在内存中信息创建了DexFile实例 if (dex_file.get() &#x3D;&#x3D; nullptr) &#123; DCHECK(env-&gt;ExceptionCheck()); return nullptr; &#125; std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files; dex_files.push_back(std::move(dex_file)); return ConvertDexFilesToJavaArray(env, nullptr, dex_files); &#x2F;&#x2F; 对该dex_files进行返回&#125; 通过CreateDexFile创建DexFile对象 12345678910111213141516171819202122232425static const DexFile* CreateDexFile(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; dex_mem_map) &#123; &#x2F;&#x2F; 返回dex文件在内存中映射的地址 std::string location &#x3D; StringPrintf(&quot;Anonymous-DexFile@%p-%p&quot;, dex_mem_map-&gt;Begin(), dex_mem_map-&gt;End()); std::string error_message; std::unique_ptr&lt;const DexFile&gt; dex_file(DexFile::Open(location, 0, std::move(dex_mem_map), &#x2F;* verify *&#x2F; true, &#x2F;* verify_location *&#x2F; true, &amp;error_message)); if (dex_file &#x3D;&#x3D; nullptr) &#123; ScopedObjectAccess soa(env); ThrowWrappedIOException(&quot;%s&quot;, error_message.c_str()); return nullptr; &#125; if (!dex_file-&gt;DisableWrite()) &#123; ScopedObjectAccess soa(env); ThrowWrappedIOException(&quot;Failed to make dex file read-only&quot;); return nullptr; &#125; return dex_file.release();&#125; 进入DexFile::Open，其中又调用了OpenCommon函数 1234567891011121314151617181920212223std::unique_ptr&lt;const DexFile&gt; DexFile::Open(const std::string&amp; location, uint32_t location_checksum, std::unique_ptr&lt;MemMap&gt; map, bool verify, bool verify_checksum, std::string* error_msg) &#123; ScopedTrace trace(std::string(&quot;Open dex file from mapped-memory &quot;) + location); CHECK(map.get() !&#x3D; nullptr); if (map-&gt;Size() &lt; sizeof(DexFile::Header)) &#123; *error_msg &#x3D; StringPrintf( &quot;DexFile: failed to open dex file &#39;%s&#39; that is too short to have a header&quot;, location.c_str()); return nullptr; &#125; std::unique_ptr&lt;DexFile&gt; dex_file &#x3D; OpenCommon(map-&gt;Begin(), map-&gt;Size(), location, location_checksum, kNoOatDexFile, verify, verify_checksum, error_msg); 进入OpenCommon函数 1234567891011121314151617std::unique_ptr&lt;DexFile&gt; DexFile::OpenCommon(const uint8_t* base, size_t size, const std::string&amp; location, uint32_t location_checksum, const OatDexFile* oat_dex_file, bool verify, bool verify_checksum, std::string* error_msg, VerifyResult* verify_result) &#123; if (verify_result !&#x3D; nullptr) &#123; *verify_result &#x3D; VerifyResult::kVerifyNotAttempted; &#125; std::unique_ptr&lt;DexFile&gt; dex_file(new DexFile(base, size, location, location_checksum, oat_dex_file)); &#x2F;&#x2F; 创建新的DexFile实例，构造函数也包含起始地址和大小 说明InMemoryDexClassLoader在对内存中bytebuffer的dex信息进行加载流程中涉及很多函数逻辑都包含dex信息的起始地址和大小。InMemoryDexClassLoader并没有对内存中dex信息进行编译生成相应的oat文件，这是与DexClassLoader的不同。 通用脱壳点： CreateSingleDexFileCookie的data参数可以获取起始地址 CreateDexFile DexFile::Open OpenCommon DexFile::DexFile DexClassLoader加载dex源码分析DexClassLoader只有一个构造函数 1234public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), librarySearchPath, parent);&#125; 进入父类BaseDexClassLoader.java的构造函数 123456789public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(parent); this.pathList &#x3D; new DexPathList(this, dexPath, librarySearchPath, null); if (reporter !&#x3D; null) &#123; reporter.report(this.pathList.getDexPaths()); &#125;&#125; 同样的进入DexPathList的核心逻辑this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,suppressedExceptions, definingContext);,调用了makeDexElements，其中加载dex文件loadDexFile(file, optimizedDirectory, loader, elements); 12345678910private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader, Element[] elements) throws IOException &#123; if (optimizedDirectory &#x3D;&#x3D; null) &#123; return new DexFile(file, loader, elements); &#125; else &#123; String optimizedPath &#x3D; optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements); &#125;&#125; DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements)调用了5个参数的loadDex,进入loadDex函数 1234static DexFile loadDex(String sourcePathName, String outputPathName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; return new DexFile(sourcePathName, outputPathName, flags, loader, elements); &#x2F;&#x2F; 创建DexFile实例&#125; 进入DexFile五参数构造函数 123456DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; mCookie &#x3D; openDexFile(fileName, null, 0, loader, elements); mInternalCookie &#x3D; mCookie; mFileName &#x3D; fileName; &#x2F;&#x2F;System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; fileName&#x3D;&quot; + fileName);&#125; 进入openDexFile中调用了native函数private static native Object openDexFileNative(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements); 1234567return openDexFileNative(new File(sourceName).getAbsolutePath(), (outputName &#x3D;&#x3D; null) ? null : new File(outputName).getAbsolutePath(), flags, loader, elements); Full Search搜索art目录下的openDexFileNative， 123456789101112131415161718192021222324252627282930313233343536373839static jobject DexFile_openDexFileNative(JNIEnv* env, jclass, &#x2F;&#x2F; 静态函数 jstring javaSourceName, &#x2F;&#x2F; 加载的dex路径 jstring javaOutputName ATTRIBUTE_UNUSED, jint flags ATTRIBUTE_UNUSED, jobject class_loader, jobjectArray dex_elements) &#123; ScopedUtfChars sourceName(env, javaSourceName); if (sourceName.c_str() &#x3D;&#x3D; nullptr) &#123; return 0; &#125; Runtime* const runtime &#x3D; Runtime::Current(); ClassLinker* linker &#x3D; runtime-&gt;GetClassLinker(); std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files; std::vector&lt;std::string&gt; error_msgs; const OatFile* oat_file &#x3D; nullptr; &#x2F;&#x2F; 出现oat dex_files &#x3D; runtime-&gt;GetOatFileManager().OpenDexFilesFromOat(sourceName.c_str(), class_loader, dex_elements, &#x2F;*out*&#x2F; &amp;oat_file, &#x2F;*out*&#x2F; &amp;error_msgs); &#x2F;&#x2F; 调用OpenDexFilesFromOat编译生成oat流程 if (!dex_files.empty()) &#123; jlongArray array &#x3D; ConvertDexFilesToJavaArray(env, oat_file, dex_files); if (array &#x3D;&#x3D; nullptr) &#123; ScopedObjectAccess soa(env); for (auto&amp; dex_file : dex_files) &#123; if (linker-&gt;IsDexFileRegistered(soa.Self(), *dex_file)) &#123; dex_file.release(); &#125; &#125; &#125; return array; &#125; return nullptr; &#125;&#125; DexClassLoader第一次动态加载解密的dex时必然没有进行编译生成oat，查看OpenDexFilesFromOat,首先OatFileAssistant oat_file_assistant(dex_location,kRuntimeISA,!runtime-&gt;IsAotCompiler());新建了OatFileAssistant 对象，if (!oat_file_assistant.IsUpToDate())由于没有生成oat对象的，进入判断中的MakeUpToDate函数，其中调用了return GenerateOatFileNoChecks(info, target, error_msg);GenerateOatFileNoChecks最终进入调用dex2oat编译生成oat的流程 123456789if (!Dex2Oat(args, error_msg)) &#123; &#x2F;&#x2F; Manually delete the oat and vdex files. This ensures there is no garbage &#x2F;&#x2F; left over if the process unexpectedly died. vdex_file-&gt;Erase(); unlink(vdex_file_name.c_str()); oat_file-&gt;Erase(); unlink(oat_file_name.c_str()); return kUpdateFailed;&#125; 中准备相关二进制程序参数的相关信息，最终调用return Exec(argv, error_msg);实现dex2oat编译的过程，进入Exec中调用了ExecAndReturnCode，首次进行了进程fork，在子进程当中使用execve(program, &amp;args[0], envp);执行dex2oat实际执行流程。 说明我们在整个流程中其中某个函数进行修改或者hook都会导致dex2oat流程结束，强制结束dex2oat流程，可以让我们在DexClassLoader在加载dex时过程变的很有效率，减少dex2oat编译的流程，要想实现art下的函数抽取技术，也是要阻断dex2oat的流程。当我们阻断了dex2oat会导致openDexFileNative中 dex_files 文件无法生成，在调用runtime-&gt;GetOatFileManager().OpenDexFilesFromOat中进入尝试判断原始dex文件oat_file_assistant.HasOriginalDexFiles()并通过DexFile::Open进行加载dex 123456789101112131415161718if (dex_files.empty()) &#123; if (oat_file_assistant.HasOriginalDexFiles()) &#123; if (Runtime::Current()-&gt;IsDexFileFallbackEnabled()) &#123; static constexpr bool kVerifyChecksum &#x3D; true; if (!DexFile::Open( dex_location, dex_location, kVerifyChecksum, &#x2F;*out*&#x2F; &amp;error_msg, &amp;dex_files)) &#123; LOG(WARNING) &lt;&lt; error_msg; error_msgs-&gt;push_back(&quot;Failed to open dex files from &quot; + std::string(dex_location) + &quot; because: &quot; + error_msg); &#125; &#125; else &#123; error_msgs-&gt;push_back(&quot;Fallback mode disabled, skipping dex files.&quot;); &#125; &#125; else &#123; error_msgs-&gt;push_back(&quot;No original dex files found for dex location &quot; + std::string(dex_location)); &#125;&#125; 进入DexFile::Open中可看到File fd = OpenAndReadMagic(filename, &amp;magic, error_msg);到此出现了第一个脱壳点OpenAndReadMagic，此时dex还未加载到内存当中。紧接着开始判断dex魔术头，并进入DexFile::OpenFile函数 12345678910111213if (IsDexMagic(magic)) &#123; std::unique_ptr&lt;const DexFile&gt; dex_file(DexFile::OpenFile(fd.Release(), &#x2F;&#x2F; 文件描述符，可以作为脱壳点 location, &#x2F;* verify *&#x2F; true, verify_checksum, error_msg)); if (dex_file.get() !&#x3D; nullptr) &#123; dex_files-&gt;push_back(std::move(dex_file)); return true; &#125; else &#123; return false; &#125;&#125; 进入DexFile::OpenFile函数发现通过MemMap::MapFile将dex进行了内存映射 12345678map.reset(MemMap::MapFile(length, PROT_READ, MAP_PRIVATE, fd, 0, &#x2F;*low_4gb*&#x2F;false, location.c_str(), error_msg)); 再进入OpenCommon函数中，参数中也包含了dex文件的映射区域的起始地址，出现了第二个脱壳点。 12345678std::unique_ptr&lt;DexFile&gt; dex_file &#x3D; OpenCommon(map-&gt;Begin(), map-&gt;Size(), location, dex_header-&gt;checksum_, kNoOatDexFile, verify, verify_checksum, error_msg); 跟进DexFile::OpenCommon中，发现其中调用了DexFile的构造函数 12345std::unique_ptr&lt;DexFile&gt; dex_file(new DexFile(base, size, location, location_checksum, oat_dex_file)); 至此出现了第三个脱壳点DexFile::DexFile 12345DexFile::DexFile(const uint8_t* base, size_t size, const std::string&amp; location, uint32_t location_checksum, const OatDexFile* oat_dex_file) 通用脱壳点： OpenAndReadMagic OpenCommon DexFile::DexFile 通过对比：InMemoryDexClassLoader和DexClassLoader的脱壳点，发现OpenCommon是两者通用脱壳点。 定制源码脱壳DexFile::OpenCommon修改/art/runtime/dex_file.cc中DexFile::OpenCommon方法 12345678910 int pid&#x3D;getpid(); char dexfilepath[100]&#x3D;&#123;0&#125;; sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_OpenCommon.dex&quot;,(int)size,pid); int fd&#x3D;open(dexfilepath,O_CREAT|O_RDWR,666); if (fd&gt;0)&#123;int number&#x3D;write(fd,base,size);if(number&gt;0)&#123;&#125;close(fd); &#125; DexFile::DexFile修改/art/runtime/dex_file.cc中DexFile::DexFile方法 12345678910 int pid&#x3D;getpid(); char dexfilepath[100]&#x3D;&#123;0&#125;; sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_DexFile.dex&quot;,(int)size,pid); int fd&#x3D;open(dexfilepath,O_CREAT|O_RDWR,666); if (fd&gt;0)&#123;int number&#x3D;write(fd,base,size);if(number&gt;0)&#123;&#125;close(fd); &#125; 编译1234~&#x2F;Android8.0&#x2F;android-8.0.0_r1$ source build&#x2F;envsetup.sh~&#x2F;Android8.0&#x2F;android-8.0.0_r1$ lunch23 选择aosp_sailfish-userdebug~&#x2F;Android8.0&#x2F;android-8.0.0_r1$ time make -j4 如果报错直接make单线程编译 生成路径~/Android8.0/android-8.0.0_r1/out/target/product/sailfish，将boot.img,ramdisk.img,system.img,system_other.img,userdata.img,vendor.img拷出来 安装LoadDex.apk，并把ClassLoaderTest生成的classes.dex放入/sdcard。并在设置中授予该app读写sdcard的权限。在Activity启动的时候加载/sdcard的classes.dex的TestActivity并打印I&#39;m from TestActivity.onCreate，这就是一代壳的基本原理。 重启系统后/sdcard中已经出现一些系统中脱下的dex，启动LoadDex，grep -ril &quot;TestActivity&quot; ./*.dex 找到LoadDex中脱下的dex，DexClassLoader加载的插件dex已经被dump下来，gda可以看到优化后的odex的TestActivity中onCreate方法。 真实案例a.apk 《百度》加固 启动后进入/sdcard , grep -ril “SplashActivity” ./*.dex b.apk 《爱加密》企业版本加固 启动后进入/sdcard , grep -ril “mvp/ui/SplashActivity” ./*.dex，内容都为null，说明用了函数抽取，这就是需要fart解决的问题。 ExecAndReturnCode中调用execve(program, &amp;args[0], envp);,dex2oat流程也可以脱壳,main函数中调用int result = static_cast&lt;int&gt;(art::Dex2oat(argc, argv));,跟进Setup()方法最后会出现对要编译dex文件的处理，CompileApp也出现了DexFile对象等等非常多的流程出现Dexfile对象，都可以成为脱壳点","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"Dalvik","slug":"Dalvik","permalink":"http://onejane.gitee.io/tags/Dalvik/"},{"name":"ART","slug":"ART","permalink":"http://onejane.gitee.io/tags/ART/"}]},{"title":"Socket&Websocket&Protobuf自吐通杀","slug":"Socket&Websocket&Protobuf自吐通杀","date":"2021-03-14T10:00:50.000Z","updated":"2021-03-27T03:42:32.300Z","comments":true,"path":"2021/03/14/Socket&Websocket&Protobuf自吐通杀/","link":"","permalink":"http://onejane.gitee.io/2021/03/14/Socket&Websocket&Protobuf%E8%87%AA%E5%90%90%E9%80%9A%E6%9D%80/","excerpt":"","text":"Socket所有的应用层都逃不掉底层用Socket来传输,只要掌握了Socket，对上层应用就是降维打击。 新建HttpSocket项目，并在AndroidManifest.xml配置网络权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true)&#123; newHttp(); try &#123; Thread.sleep(10*1000); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125; private static void newHttp()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; String url &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&quot;; URL urlConn &#x3D; new URL(url); HttpURLConnection connection &#x3D; (HttpURLConnection)urlConn.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.connect(); int responseCode &#x3D; connection.getResponseCode(); if (responseCode &#x3D;&#x3D; HttpURLConnection.HTTP_OK) &#123; InputStream inputStream &#x3D; connection.getInputStream(); String result &#x3D; is2String(inputStream); Log.d(&quot;onejane&quot;,&quot;result&#x3D;&#x3D;&#x3D;&#x3D;&quot;+result); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private static String is2String(InputStream inputStream) throws IOException &#123; byte[] buffer &#x3D; new byte[1024]; ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream(); for (int len &#x3D; 0; (len &#x3D; inputStream.read(buffer)) &gt; 0;) &#123; baos.write(buffer, 0, len); &#125; String result &#x3D; new String(baos.toByteArray(), &quot;utf-8&quot;); System.out.println(result); return result ; &#125;&#125; 关键类定位objection -g com.onejane.httpsocket explore android heap search instances java.net.Socket 查看堆内存中是否有该实例 android hooking search classes Socket 搜索与Socket相关的类 android hooking watch class java.net.Socket 默认hook类的所有方法没有构造函数 android hooking watch class_method java.net.Socket.$init –dump-args –dump-backtrace –dump-return 手动调用hook构造函数 vim ~/.pyenv/versions/3.8.0/lib/python3.8/site-packages/objection/agent.js 输入:9211跳转到9211行，加上.concat([“$init”])，会影响objection的稳定性 将与Socket相关的类添加前缀android hooking watch class存入socket.txt objection -g com.onejane.httpsocket explore -c ~/Desktop/socket.txt 批量hook，如果崩掉，需要将崩掉的类从文本中移除 okhttp底层走的socket android hooking watch class_method java.net.AbstractPlainSocketImpl.acquireFD --dump-args --dump-backtrace --dump-return 根据hook的结果拿到java.net.SocketOutputStream.write方法就是socket写入时调用的方法，针对该方法进行hook android hooking watch class_method java.net.SocketOutputStream.write --dump-args --dump-backtrace --dump-return SocketInputStream.read的hook结果复制到010Editor，搜索1f8b,删除前面所有字符，保存为gzip,解压查看结果就是百度网页结果 socket自吐实现http与https的socket自吐，修改url地址http://www.baidu.com/为https://www.baidu.com/, 有这两个自吐，可以通杀所有协议层的收发包内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function hook_socket()&#123; Java.perform(function()&#123; console.log(&quot;hook_socket;&quot;) Java.use(&quot;java.net.SocketOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTP write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; Java.use(&quot;java.net.SocketInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTP read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; &#125;)&#125;function hook_SSLsocketandroid8()&#123; Java.perform(function()&#123; console.log(&quot;hook_SSLsocket&quot;) Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTPS write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTPS read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; &#125;)&#125;function hook_SSLsocket2android10()&#123; Java.perform(function()&#123; console.log(&quot; hook_SSLsocket2&quot;) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_write.implementation &#x3D; function(long,NS,fd,NC,bytearray,int1,int2,int3)&#123; var result &#x3D; this .SSL_write(long,NS,fd,NC,bytearray,int1,int2,int3); console.log(&quot;SSL_write(long,NS,fd,NC,bytearray,int1,int2,int3),result&#x3D;&gt;&quot;,long,NS,fd,NC,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex()); return result; &#125; Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_read.implementation &#x3D; function(long,NS,fd,NC,bytearray,int1,int2,int3)&#123; var result &#x3D; this .SSL_read(long,NS,fd,NC,bytearray,int1,int2,int3); console.log(&quot;SSL_read(long,NS,fd,NC,bytearray,int1,int2,int3),result&#x3D;&gt;&quot;,long,NS,fd,NC,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex()); return result; &#125; &#125;)&#125;function main()&#123; console.log(&quot;Main&quot;) hook_socket(); hook_SSLsocketandroid8(); &#x2F;&#x2F;hook_SSLsocket2android10();&#125;setImmediate(main) frida -UF -l hookSocket.js 使用git clone https://github.com/peiniwan/Ganhuo.git 编译源码编译安装GanHuo.apk查看代码家栏,通过010Editor获取转换后的Unicode码，即为抓包结果 Websocket虚拟机网卡切换为桥接模式:192.168.0.104 server wget https://github.com/gotify/server/releases/download/v2.0.20/gotify-linux-amd64.zip unzip gotify-linux-amd64.zip chmod +x gotify-linux-amd64 ./gotify-linux-amd64 client adb install Gotify.apk 输入server地址http://192.168.0.104 admin/admin cli wget -O gotify https://github.com/gotify/cli/releases/download/v1.2.0/gotify-cli-linux-amd64 chmod +x gotify mv gotify /usr/bin/gotify gotify init gotify push -t “my title” -p 10 “my message” 服务器向手机发送消息 hook_okhttp3_logging添加十六进制转换，在控制台中以字符串显示 123456function jhexdump(array) &#123; var ptr &#x3D; Memory.alloc(array.length); for(var i &#x3D; 0; i &lt; array.length; ++i) Memory.writeS8(ptr.add(i), array[i]); console.log(hexdump(ptr, &#123; offset: 0, length: array.length, header: false, ansi: false &#125;));&#125; 使用console.log(jhexdump(bytearry))替换console.log(“bytearray contents=&gt;”, ByteString.of(bytearry).hex()) frida -UF -l hookSocket.js 使用socket自吐依旧可以通杀抓包 pm list packages|grep -i gotify 获取包名 frida -U -f com.github.gotify -l hookSocket.js –no-pause -o gotify.log objection -g com.github.gotify explore android hooking search classes websocket 查找内存中和websocket相关的类很少，可以通过android hooking watch class * ,存入websocket.txt文件批量hook 123objection -g com.github.gotify explore -c ~&#x2F;Desktop&#x2F;gotify&#x2F;websocket.txtplugin wallbreaker objectsearch com.github.gotify.client.model.Message 获取内存中的Message对象pluginwallbreaker objectdump --fullname 0x2576 获取该对象中字段在内存中的内容 android hooking search classes websocket 发现okhttp3.WebSocket,通过hook_okhttp3_logging脚本进行hook抓包frida -U -f com.github.gotify -l hookOkhttp3.js --no-pause，logcat|grep okhttpGET 查看可以抓到ok3的websocket包 android hooking search classes com.xabber.xmpp.smack 基于xmpp协议聊天软件xabber搜索包名并批量hook android hooking watch class_method java.lang.String.toString –dump-args -dump-backtrace –dump-return hookWebSocketvim hookWebSocket.js 综合基于hook和枚举的方式抓包websocket 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384function hook_okhttp3() &#123; &#x2F;&#x2F; 1. frida Hook java层的代码必须包裹在Java.perform中，Java.perform会将Hook Java相关API准备就绪。 Java.perform(function () &#123; Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;okhttp3logging.dex.dex&quot;).load(); &#x2F;&#x2F; 只修改了这一句，换句话说，只是使用不同的拦截器对象。 var MyInterceptor &#x3D; Java.use(&quot;com.roysue.octolesson2ok3.okhttp3Logging&quot;); var MyInterceptorObj &#x3D; MyInterceptor.$new(); var Builder &#x3D; Java.use(&quot;okhttp3.OkHttpClient$Builder&quot;); console.log(Builder); Builder.build.implementation &#x3D; function () &#123; this.networkInterceptors().add(MyInterceptorObj); console.log(&quot;hook Build.build successfully !&quot;) return this.build(); &#125;; console.log(&quot;hooking_okhttp3...&quot;); &#125;);&#125;function EnumerateClient()&#123; Java.perform(function()&#123; &#x2F;&#x2F;Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;r0gson.dex&quot;).load(); &#x2F;&#x2F;const gson &#x3D; Java.use(&#39;com.r0ysue.gson.Gson&#39;); var gson2 &#x3D; Java.use(&#39;com.google.gson.Gson&#39;); &#x2F;&#x2F; 加载包含CurlInterceptor拦截器的DEX Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;myok2curl.dex&quot;).load(); console.log(&quot;loading dex successful!&quot;) const curlInterceptor &#x3D; Java.use(&quot;com.moczul.ok2curl.CurlInterceptor&quot;); const loggable &#x3D; Java.use(&quot;com.moczul.ok2curl.logger.Loggable&quot;); var Log &#x3D; Java.use(&quot;android.util.Log&quot;); var TAG &#x3D; &quot;okhttpGETcurl&quot;; &#x2F;&#x2F;注册类————一个实现了所需接口的类 var MyLogClass &#x3D; Java.registerClass(&#123; name: &quot;okhttp3.MyLogClass&quot;, implements: [loggable], methods: &#123; log: function (MyMessage) &#123; Log.v(TAG, MyMessage); &#125;&#125; &#125;); const mylog &#x3D; MyLogClass.$new(); &#x2F;&#x2F; 得到所需拦截器对象 var curlInter &#x3D; curlInterceptor.$new(mylog); &#x2F;&#x2F; 加载包含logging-interceptor拦截器的DEX Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;okhttplogging.dex&quot;).load(); var MyInterceptor &#x3D; Java.use(&quot;com.r0ysue.learnokhttp.okhttp3Logging&quot;); var MyInterceptorObj &#x3D; MyInterceptor.$new(); Java.choose(&quot;okhttp3.OkHttpClient&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;1. found instance:&quot;,instance) console.log(&quot;2. instance.interceptors():&quot;,instance.interceptors().$className) console.log(&quot;3. instance._interceptors:&quot;,instance._interceptors.value.$className) &#x2F;&#x2F;console.log(&quot;4. interceptors:&quot;,gson2.$new().toJson(instance.interceptors())) console.log(&quot;5. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(instance.interceptors().toArray())) var newInter &#x3D; Java.use(&quot;java.util.ArrayList&quot;).$new(); newInter.addAll(instance.interceptors()); console.log(&quot;6. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(newInter.toArray())); console.log(&quot;7. interceptors:&quot;,newInter.$className); newInter.add(MyInterceptorObj); newInter.add(curlInter); instance._interceptors.value &#x3D; newInter; &#125;,onComplete:function()&#123; console.log(&quot;Search complete!&quot;) &#125; &#125;) &#125;)&#125;function main()&#123; hook_okhttp3(); EnumerateClient(); &#125;setImmediate(main) OkHttpLogger-Fridafrida -UF -l OkHttpLogger-Frida/okhttp_poker.js 抓包websocket Protobuf直播/弹幕协议Protobuf逆向分析，手把手教你使用ProtoBuf，通过gRPC服务在Android上进行网络请求 服务端192.168.0.102 官方教程 123456789101112131415161718192021systemctl stop firewalld.service systemctl disable firewalld.servicesetenforce 0/etc/selinux/config 修改为SELINUX=disabledtar -zxvf jdk-8u60-linux-x64.tar.gzmv jdk1.8.0_60/ /usr/local/tar -zxf apache-maven-3.6.3-bin.tar.gz -C /usr/local/vim /etc/profileJAVA_HOME=/usr/local/jdk1.8.0_60JRE_HOME=$JAVA_HOME/jreMAVEN_HOME=/usr/local/apache-maven-3.6.3PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin::$MAVEN_HOME/binCLASSPATH=:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/dt.jarexport JAVA_HOME JRE_HOME PATH CLASSPATH MAVEN_HOMEsource /etc/profilegit clone -b v1.36.1 https://github.com/grpc/grpc-javagit checkout -b v1.32.1 避免无法连接国外仓库ggcd grpc-java/examples./gradlew installDist./build/install/examples/bin/hello-world-server 启动server端口在50051./build/install/examples/bin/hello-world-client 通过HelloRequest发送Hello World 客户端192.168.0.104 git clone https://github.com/xuexiangjys/Protobuf-gRPC-Android.git ，其中helloworld.proto通过protoc编译生成HelloReply.java 手动编译，idea中安装GenProtobuf将binary进行encode和decode wget https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-linux-x86_64.zip unzip protoc-3.13.0-linux-x86_64.zip as-Tools-Configure GenProtobuf 右键hellooworld.proto点击quick gen protobuf here 实现手动编译，生成的编译代码使用了大量的google的protobuf基础库 安装启动Protobuf-gRPC-Android，保证服务端和客户端互相ping通，可以通过nc 192.168.0.102 50052 给服务端发送数据，服务端使用nc -l 50052接收，如果互通消息就可以收到，否则使用NPS将服务端的50051端口服务映射到指定服务器ip的指定端口(需要在服务端安装nps客户端，在nps服务端配置该nps客户端)。 如果没有响应，ps -ef|grep protobuf 获取到进程id后，logcat|grep -i 22916 查看log，退出重进gRPC-普通请求按钮，输入服务端ip，端口及内容发送请求。 1234567adb shellps -ef|grep protobuf 获取包名.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64 启动frida serverpyenv local 3.8.0objection -g com.xuexiang.protobufdemo exploreandroid hooking search classes protobuf 将打印出的类前面加上android hooking watch class,存入hook_list.txtobjection -g com.xuexiang.protobufdemo explore -c &#x2F;root&#x2F;Desktop&#x2F;hook_list.txt 实现批量hook，点击发送请求，从请求找寻找调用到的protobuf类相关方法 关注打印出来的几个函数： com.google.protobuf.WireFormat.makeTagcom.google.protobuf.CodedOutputStream$OutputStreamEncoder.write([B, int, int)com.google.protobuf.CodedInputStream.readTag()com.google.protobuf.WireFormat.getTagFieldNumber(int)com.google.protobuf.Utf8.encode(java.lang.CharSequence, [B, int, int)com.google.protobuf.CodedInputStream.newInstance([B, int, int, boolean) 1android hooking watch class_method com.google.protobuf.Utf8.encode --dump-args --dump-backtrace --dump-return 同理，makeTag的调用栈也是从用户代码中的writeTo调用而来。 frida -UF -l hookSocket.js -o protobuf.txt 通杀自吐打印出protubuf的包数据 12plugin wallbreaker objectsearch com.xuexiang.protobufdemo.HelloReplyplugin wallbreaker objectdump --fullname 0x22ea 内存漫游的源码 Protobuf协议逆向和仿真&amp;举个栗子 抓包+逆向app分析protobuf -Protobuf协议解析文档-某音弹幕","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"Socket","slug":"Socket","permalink":"http://onejane.gitee.io/tags/Socket/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://onejane.gitee.io/tags/WebSocket/"},{"name":"Protobuf","slug":"Protobuf","permalink":"http://onejane.gitee.io/tags/Protobuf/"},{"name":"XMPP","slug":"XMPP","permalink":"http://onejane.gitee.io/tags/XMPP/"}]},{"title":"Spring-Cloud-Alibaba","slug":"Spring-Cloud-Alibaba","date":"2021-03-11T08:03:07.000Z","updated":"2021-03-16T13:56:30.893Z","comments":true,"path":"2021/03/11/Spring-Cloud-Alibaba/","link":"","permalink":"http://onejane.gitee.io/2021/03/11/Spring-Cloud-Alibaba/","excerpt":"","text":"SpringCloudAlibabaSpring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。 依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。 Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。 Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。 Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。 Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。 Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 虚拟机安装virtualbox 6 vagrant安装好后进入镜像仓库搜索需要安装的镜像 mkdir centos7 &amp;&amp; vagrant init centos/7 &amp;&amp; vagrant up &amp;&amp; vagrant ssh 创建并开启镜像，修改网络桥接 如果太慢，进入centos/7仓库下载，手动加载vagrant box add centos/7 CentOS-7-x86_64-Vagrant-2004_01.VirtualBox.box vim Vagrantfile 修改配置并重启vagrant reload，保存虚拟机与主机可ping通，sudo passwd root 设置root权限 12# config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot; host-onlyconfig.vm.network &quot;public_network&quot; 桥接 安装nodejs并配置淘宝源npm config set registry http://registry.npm.taobao.org/ 安装docker 1234567891011121314151617sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-enginesudo yum install -y yum-utilssudo yum-config-manager \\ --add-repo \\ https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.reposudo yum install -y docker-ce docker-ce-cli containerd.ioyum list docker-ce --showduplicates | sort -rsudo systemctl start dockersudo docker imagessudo systemctl enable docker 镜像加速器 12345678sudo mkdir -p &#x2F;etc&#x2F;dockersudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;3gki6pei.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker mysql 12345678910docker run -p 3306:3306 --name mysql \\-v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysal \\-v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql \\-e MYSQL_ROOT_PASSWORD&#x3D;root \\-d mysql:5.7docker exec -it mysql &#x2F;bin&#x2F;bashmysql -uroot -prootuse mysql;alter user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;root&#39;;flush privileges; vi /mydata/mysql/conf/my.cnf 修改编码配置 1234567891011[client]default-character-set&#x3D;utf8[mysql]default-character-set&#x3D;utf8[mysqld]init_connect&#x3D;&#39;SET collation_connection &#x3D; utf8_unicode_ci&#39;init_connect&#x3D;&#39;SET NAMES utf8&#39;character-set-server&#x3D;utf8collation-server&#x3D;utf8_unicode_ciskip-character-set-client-handshakeskip-name-resolve docker restart mysql &amp;&amp; cat /etc/mysql/my.cnf &amp;&amp; docker update mysql –restart=always redis vi /mydata/redis/conf/redis.conf 配置appendonly yes持久化硬盘 12345docker run -p 6379:6379 --name redis -v &#x2F;mydata&#x2F;redis&#x2F;data:&#x2F;data \\-v &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf \\-d redis:3.2 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf --appendonly yesdocker exec -it redis redis-clidocker update redis --restart&#x3D;always maven 123456789101112131415161718&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt; &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt;&lt;&#x2F;mirror&gt; &lt;profile&gt; &lt;id&gt;jdk18&lt;&#x2F;id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt; &lt;jdk&gt;1.8&lt;&#x2F;jdk&gt; &lt;&#x2F;activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;&#x2F;maven.compiler.compilerVersion&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;profile&gt; idea安装lombok，mybatisX插件 vscode安装Auto Close Tag,Auto Rename Tag,Chinese,Eslint,HTML CSS Support,HTML Snippets,JavaScript(ES6),Live Server,open in browser,Vetur,Vue 2 Snippets插件 git配置 12345git config --global user.name &quot;username&quot; &#x2F;&#x2F;（名字） # 配置邮箱git config --global user.email &quot;username@email.com&quot; &#x2F;&#x2F;(注册账号时用的邮箱)ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; 进入git bash生成公私钥cat ~&#x2F;.ssh&#x2F;id_rsa.pubssh -T git@gitee.com 测试是否成功即可 Nacos注册中心新建Spring Initializr作为provider项目jdk1.8并导入Web中的Spring Web和Spring Cloud Routing的OpenFeign组件，设置-Xmx100m 启动Application使用最大内存 启动nacos-server-1.3.1.zip访问nacos 修改依赖如下 123456789101112131415161718192021222324252627282930313233343536373839&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;&#x2F;spring-cloud.version&gt; &lt;spring-cloud-alibaba.version&gt;2.1.0.RELEASE&lt;&#x2F;spring-cloud-alibaba.version&gt;&lt;&#x2F;properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt; 添加application.yml配置 123456789spring: application: name: provider cloud: nacos: discovery: server-addr: 127.0.0.1:8848server: port: 8000 ProviderApplication启动类添加@EnableDiscoveryClient,启动后在nacos控制台查看已经上线的服务 Nacos配置中心默认配置读取application.properties添加配置 12user.name&#x3D;onejaneuser.age&#x3D;20 Controller实现读取 123456789101112@RestController@RequestMapping(&quot;test&quot;)public class UserController &#123; @Value(&quot;$&#123;user.name&#125;&quot;) private String name; @Value(&quot;$&#123;user.age&#125;&quot;) private Integer age; @RequestMapping(&quot;&#x2F;user&quot;) public void test()&#123; System.out.println(name+&quot;:&quot;+age); &#125;&#125; Nacos配置项目添加config依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; Provider项目创建bootstrap.properties 12spring.application.name&#x3D;providerspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848 Nacos中配置provider.properties，默认规则，取public命名空间的应用名.properties，类型为Properties，相同与application.properties时优先使用配置中心的配置。 12user.name&#x3D;onejane1user.age&#x3D;23 多环境配置配置命名空间provider，命名空间ID为f7d49148-09a8-4ca1-8a40-c52e9cb627b5，在该命名空间下配置provider.properties，Group为prod 12user.name&#x3D;onejane2user.age&#x3D;23 配置bootstrap.properties 1234spring.application.name&#x3D;providerspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848spring.cloud.nacos.config.namespace&#x3D;f7d49148-09a8-4ca1-8a40-c52e9cb627b5spring.cloud.nacos.config.group&#x3D;prod 命名空间，用于配置隔离，默认新增的所有配置都在public空间。 1、开发，测试，生产：利用命名空间来做环境隔离。在bootstrap.properties；配置spring.cloud.nacos.config.namespace需要使用哪个命名空间下的配置 2、每一个微服务之间互相隔离配置，每一个微服务都创建自己的命名空间，只加载自己命名空间下的所有配置 每个微服务创建自己的命名空间，使用配置分组区分环境，dev，test，prod 多文件配置在Nacos中provider微服务命名空间配置datasource.yml 123456spring: datasource: username: root password: root url: jdbc:mysql:&#x2F;&#x2F;172.20.1.185:3306&#x2F;user driver-class-name: com.mysql.jdbc.Driver 配置mybatis.yml 12345mybatis-plus: mapper-locations: classpath:&#x2F;mapper&#x2F;**&#x2F;*.xml global-config: db-config: id-type: auto 配置service.yml 123456789spring: application: name: provider cloud: nacos: discovery: server-addr: 127.0.0.1:8848 server: port: 7000 注释application.yml中所有配置并在bootstrap.properties中实现多文件配置 1234567891011121314151617spring.application.name&#x3D;providerspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848spring.cloud.nacos.config.namespace&#x3D;f7d49148-09a8-4ca1-8a40-c52e9cb627b5spring.cloud.nacos.config.group&#x3D;prodspring.cloud.nacos.config.ext-config[0].data-id&#x3D;datasource.ymlspring.cloud.nacos.config.ext-config[0].group&#x3D;devspring.cloud.nacos.config.ext-config[0].refresh&#x3D;truespring.cloud.nacos.config.ext-config[1].data-id&#x3D;mybatis.ymlspring.cloud.nacos.config.ext-config[1].group&#x3D;devspring.cloud.nacos.config.ext-config[1].refresh&#x3D;truespring.cloud.nacos.config.ext-config[2].data-id&#x3D;other.ymlspring.cloud.nacos.config.ext-config[2].group&#x3D;devspring.cloud.nacos.config.ext-config[2].refresh&#x3D;true Mybatis-Plus持久化引入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;3.2.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.17&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;version&gt;1.18.8&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 配置数据源 123456789101112131415spring: datasource: username: root password: root url: jdbc:mysql:&#x2F;&#x2F;172.20.1.185:3306&#x2F;user driver-class-name: com.mysql.jdbc.Driver jackson: date-format: yyyy-MM-dd HH:mm:ss # 输出日期自动转换mybatis-plus: mapper-locations: classpath:&#x2F;mapper&#x2F;**&#x2F;*.xml global-config: db-config: id-type: auto logic-delete-value: 1 # 逻辑删除 logic-not-delete-value: 0 配置扫描包 1@MapperScan(&quot;com.onejane.demo.provider.dao&quot;) 添加实体类 123456789101112131415@Data@TableName(&quot;user_info&quot;)public class UserInfoEntity implements Serializable &#123; private static final long serialVersionUID &#x3D; 1L; @TableId private Long id; private String name; private Long age; &#x2F;** * 是否显示[0-不显示，1显示] 用于逻辑删除 *&#x2F; @TableLogic(value &#x3D; &quot;1&quot;,delval &#x3D; &quot;0&quot;) private Integer status;&#125; 逻辑删除实现 1234567@AutowiredUserInfoSerivce userInfoSerivce;@RequestMapping(&quot;&#x2F;delete&quot;)public R delete(Long[] ids)&#123; userInfoSerivce.removeByIds(Arrays.asList(ids)); return R.ok();&#125; 分页查询实现 1234567891011121314151617181920public interface UserInfoSerivce extends IService&lt;UserInfoEntity&gt; &#123; PageUtils queryPage(Map&lt;String, Object&gt; params);&#125;@Service(&quot;userInfoService&quot;)public class UserInfoServiceImpl extends ServiceImpl&lt;UserInfoDao, UserInfoEntity&gt; implements UserInfoSerivce &#123; @Override public PageUtils queryPage(Map&lt;String, Object&gt; params) &#123; IPage&lt;UserInfoEntity&gt; page &#x3D; this.page( new Query&lt;UserInfoEntity&gt;().getPage(params), new QueryWrapper&lt;UserInfoEntity&gt;() ); return new PageUtils(page); &#125;&#125;@RequestMapping(&quot;&#x2F;list&quot;)public R list(@RequestParam Map&lt;String, Object&gt; params)&#123; PageUtils page &#x3D; userInfoSerivce.queryPage(params); return R.ok().put(&quot;page&quot;, page);&#125; 分页配置 12345678910111213141516@Configuration@EnableTransactionManagement &#x2F;&#x2F;开启事务@MapperScan(&quot;com.onejane.demo.provider.dao&quot;)public class MyBatisConfig &#123; &#x2F;&#x2F;引入分页插件 @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor paginationInterceptor &#x3D; new PaginationInterceptor(); &#x2F;&#x2F; 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false paginationInterceptor.setOverflow(true); &#x2F;&#x2F; 设置最大单页限制数量，默认 500 条，-1 不受限制 paginationInterceptor.setLimit(1000); return paginationInterceptor; &#125;&#125; Feign远程调用新建Spring Initializr作为consumer项目jdk1.8并导入Web中的Spring Web和Spring Cloud Routing的OpenFeign组件，设置-Xmx100m 启动Application使用最大内存 provider提供api，启动类配置@EnableDiscoveryClient后启动应用 consumer中引入nacos依赖 123456789101112131415161718192021222324252627282930313233&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;&#x2F;spring-cloud.version&gt; &lt;spring-cloud-alibaba.version&gt;2.1.0.RELEASE&lt;&#x2F;spring-cloud-alibaba.version&gt;&lt;&#x2F;properties&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt; Member作为consumer获取feign调用，定义feign方法 1234567@FeignClient(&quot;provider&quot;)public interface ProviderFeignService &#123; @RequestMapping(&quot;&#x2F;test&#x2F;list&quot;) public void test();&#125; consumer在控制器中申请远程调用，并在启动类中开启feign调用@EnableFeignClients(basePackages = &quot;com.onejane.demo.consumer.feign&quot;)并将consumer加入nacos注册中心@EnableDiscoveryClient 12345@FeignClient(&quot;provider&quot;)public interface ProviderFeignService &#123; @RequestMapping(&quot;&#x2F;test&#x2F;user&quot;) public void test();&#125; 在application.yml中配置nacos 123456789spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 application: name: consumerserver: port: 7000 开启feign远程调用 12345678910@RestController@RequestMapping(&quot;test&quot;)public class UserInfoController &#123; @Autowired ProviderFeignService providerFeignService; @RequestMapping(&quot;&#x2F;user&quot;) public void test()&#123; providerFeignService.test(); &#125;&#125; Gateway网关修改provider项目新增server.servlet.context-path: /provider 新建Spring Initializr作为网关项目项目jdk1.8并导入Spring Cloud Routing的Gateway组件 pom依赖修改 12345678910&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;&#x2F;spring-cloud.version&gt;&lt;&#x2F;properties&gt; application.properties添加配置 123spring.cloud.nacos.discovery.server-addr&#x3D;127.0.0.1:8848spring.application.name&#x3D;gatewayserver.port&#x3D;88 在nacos中配置微服务命名空间gateway,ID为7601cb5a-a9dd-43d8-a1b9-a37952674df2，添加配置文件gateway.yml 123spring: application: name: gateway bootstrap.properties配置命名空间 123spring.application.name&#x3D;gatewayspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848spring.cloud.nacos.config.namespace&#x3D;7601cb5a-a9dd-43d8-a1b9-a37952674df2 application.yml中添加网关配置，访问http://localhost:88/?url=qq 则跳转到https://www.qq.com?url=qq， 访问http://localhost:88/?url=baidu 则跳转到https://www.baidu.com?url=baidu 123456789101112131415161718192021222324spring: cloud: gateway: routes: - id: test_route uri: https:&#x2F;&#x2F;www.baidu.com predicates: - Query&#x3D;url,baidu - id: qq_route uri: https:&#x2F;&#x2F;www.qq.com predicates: - Query&#x3D;url,qq - id: provider_route uri: lb:&#x2F;&#x2F;provider predicates: - Path&#x3D;&#x2F;api&#x2F;provider&#x2F;** filters: - RewritePath&#x3D;&#x2F;api&#x2F;(?&lt;segment&gt;.*),&#x2F;$\\&#123;segment&#125; application: name: gateway# http:&#x2F;&#x2F;localhost:88&#x2F;api&#x2F;provider&#x2F;test&#x2F;user &#x3D;&#x3D;&gt; http:&#x2F;&#x2F;localhost:8000&#x2F;provider&#x2F;test&#x2F;user 在启动类中配置@EnableDiscoveryClient，并过滤掉数据库配置@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) 跨域12345678910111213141516171819@Configurationpublic class GulimallCorsConfiguration &#123; @Bean public CorsWebFilter corsWebFilter()&#123; UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource(); CorsConfiguration corsConfiguration &#x3D; new CorsConfiguration(); &#x2F;&#x2F;1、配置跨域 corsConfiguration.addAllowedHeader(&quot;*&quot;); corsConfiguration.addAllowedMethod(&quot;*&quot;); corsConfiguration.addAllowedOrigin(&quot;*&quot;); corsConfiguration.setAllowCredentials(true); source.registerCorsConfiguration(&quot;&#x2F;**&quot;,corsConfiguration); return new CorsWebFilter(source); &#125;&#125; 阿里云oss引入阿里云oss依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alicloud-oss&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; application.yml配置阿里云AccessKey 12345678spring: cloud: alicloud: access-key: *** secret-key: *** oss: endpoint: oss-cn-beijing.aliyuncs.com bucket: onejane-opencv 上传图片一般先通过服务端签名后前端直传 JSR303通过自定义校验，分组校验及全局校验实现对Spring MVC入参的参数校验。 加入validation依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;&#x2F;groupId&gt; &lt;artifactId&gt;validation-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0.1.Final&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 加入校验注解 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;** * 品牌id *&#x2F;@NotNull(message &#x3D; &quot;修改必须指定品牌id&quot;,groups &#x3D; &#123;UpdateGroup.class&#125;)@Null(message &#x3D; &quot;新增不能指定id&quot;,groups &#x3D; &#123;AddGroup.class&#125;)@TableIdprivate Long brandId;&#x2F;** * 品牌名 *&#x2F;@NotBlank(message &#x3D; &quot;品牌名必须提交&quot;,groups &#x3D; &#123;AddGroup.class,UpdateGroup.class&#125;)private String name;&#x2F;** * 品牌logo地址 *&#x2F;@NotBlank(groups &#x3D; &#123;AddGroup.class&#125;)@URL(message &#x3D; &quot;logo必须是一个合法的url地址&quot;,groups&#x3D;&#123;AddGroup.class,UpdateGroup.class&#125;)private String logo;&#x2F;** * 介绍 *&#x2F;private String descript;&#x2F;** * 显示状态[0-不显示；1-显示] *&#x2F;@NotNull(groups &#x3D; &#123;AddGroup.class, UpdateStatusGroup.class&#125;)@ListValue(vals&#x3D;&#123;0,1&#125;,groups &#x3D; &#123;AddGroup.class, UpdateStatusGroup.class&#125;)private Integer showStatus;&#x2F;** * 检索首字母 *&#x2F;@NotEmpty(groups&#x3D;&#123;AddGroup.class&#125;)@Pattern(regexp&#x3D;&quot;^[a-zA-Z]$&quot;,message &#x3D; &quot;检索首字母必须是一个字母&quot;,groups&#x3D;&#123;AddGroup.class, UpdateGroup.class&#125;)private String firstLetter;&#x2F;** * 排序 *&#x2F;@NotNull(groups&#x3D;&#123;AddGroup.class&#125;)@Min(value &#x3D; 0,message &#x3D; &quot;排序必须大于等于0&quot;,groups&#x3D;&#123;AddGroup.class,UpdateGroup.class&#125;)private Integer sort; 建立分组校验类 123public interface AddGroup &#123;&#125;public interface UpdateGroup &#123;&#125;public interface UpdateStatusGroup &#123;&#125; 自定义异常注解 12345678910111213@Documented@Constraint(validatedBy &#x3D; &#123; ListValueConstraintValidator.class &#125;)@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)@Retention(RUNTIME)public @interface ListValue &#123; String message() default &quot;&#123;com.onejane.demo.provider.valid.ListValue.message&#125;&quot;; Class&lt;?&gt;[] groups() default &#123; &#125;; Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;; int[] vals() default &#123; &#125;;&#125; 自定义异常实现 12345678910111213141516171819202122232425262728public class ListValueConstraintValidator implements ConstraintValidator&lt;ListValue,Integer&gt; &#123; private Set&lt;Integer&gt; set &#x3D; new HashSet&lt;&gt;(); &#x2F;&#x2F;初始化方法 @Override public void initialize(ListValue constraintAnnotation) &#123; int[] vals &#x3D; constraintAnnotation.vals(); for (int val : vals) &#123; set.add(val); &#125; &#125; &#x2F;&#x2F;判断是否校验成功 &#x2F;** * * @param value 需要校验的值 * @param context * @return *&#x2F; @Override public boolean isValid(Integer value, ConstraintValidatorContext context) &#123; return set.contains(value); &#125;&#125; 控制器层加入字段校验配置 12345678910111213141516171819202122232425262728293031323334353637@RequestMapping(&quot;&#x2F;save&quot;)public R save(@Validated(&#123;AddGroup.class&#125;) @RequestBody BrandEntity brand&#x2F;*,BindingResult result*&#x2F;)&#123;&#x2F;&#x2F; if(result.hasErrors())&#123;&#x2F;&#x2F; Map&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F; &#x2F;&#x2F;1、获取校验的错误结果&#x2F;&#x2F; result.getFieldErrors().forEach((item)-&gt;&#123;&#x2F;&#x2F; &#x2F;&#x2F;FieldError 获取到错误提示&#x2F;&#x2F; String message &#x3D; item.getDefaultMessage();&#x2F;&#x2F; &#x2F;&#x2F;获取错误的属性的名字&#x2F;&#x2F; String field &#x3D; item.getField();&#x2F;&#x2F; map.put(field,message);&#x2F;&#x2F; &#125;);&#x2F;&#x2F;&#x2F;&#x2F; return R.error(400,&quot;提交的数据不合法&quot;).put(&quot;data&quot;,map);&#x2F;&#x2F; &#125;else &#123;&#x2F;&#x2F; 为避免每次请求都判断异常输出，通过ExceptionControllerAdvice实现全局异常控制 brandService.save(brand); return R.ok();&#125;&#x2F;** * 修改 *&#x2F;@RequestMapping(&quot;&#x2F;update&quot;)public R update(@Validated(UpdateGroup.class) @RequestBody BrandEntity brand)&#123; brandService.updateById(brand); return R.ok();&#125;&#x2F;** * 修改状态 *&#x2F;@RequestMapping(&quot;&#x2F;update&#x2F;status&quot;)public R updateStatus(@Validated(UpdateStatusGroup.class) @RequestBody BrandEntity brand)&#123; brandService.updateById(brand); return R.ok();&#125; 全局异常控制配置 123456789101112131415161718192021222324252627@Slf4j&#x2F;&#x2F;@ResponseBody&#x2F;&#x2F;@ControllerAdvice(basePackages &#x3D; &quot;com.onejane.demo.provider.controller&quot;)@RestControllerAdvice(basePackages &#x3D; &quot;com.onejane.demo.provider.controller&quot;)public class ExceptionControllerAdvice &#123; @ExceptionHandler(value&#x3D; MethodArgumentNotValidException.class) public R handleVaildException(MethodArgumentNotValidException e)&#123; log.error(&quot;数据校验出现问题&#123;&#125;，异常类型：&#123;&#125;&quot;,e.getMessage(),e.getClass()); BindingResult bindingResult &#x3D; e.getBindingResult(); Map&lt;String,String&gt; errorMap &#x3D; new HashMap&lt;&gt;(); bindingResult.getFieldErrors().forEach((fieldError)-&gt;&#123; errorMap.put(fieldError.getField(),fieldError.getDefaultMessage()); &#125;); return R.error(BizCodeEnume.VAILD_EXCEPTION.getCode(),BizCodeEnume.VAILD_EXCEPTION.getMsg()).put(&quot;data&quot;,errorMap); &#125; @ExceptionHandler(value &#x3D; Throwable.class) public R handleException(Throwable throwable)&#123; log.error(&quot;错误：&quot;,throwable); return R.error(BizCodeEnume.UNKNOW_EXCEPTION.getCode(),BizCodeEnume.UNKNOW_EXCEPTION.getMsg()); &#125;&#125;","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.gitee.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"nacos","slug":"nacos","permalink":"http://onejane.gitee.io/tags/nacos/"},{"name":"feign","slug":"feign","permalink":"http://onejane.gitee.io/tags/feign/"},{"name":"gateway","slug":"gateway","permalink":"http://onejane.gitee.io/tags/gateway/"},{"name":"sentinel","slug":"sentinel","permalink":"http://onejane.gitee.io/tags/sentinel/"}]},{"title":"HttpURLConnection&OK3&Retrofit自吐通杀","slug":"HttpURLConnection&OK3&Retrofit自吐通杀","date":"2021-03-01T17:28:26.000Z","updated":"2021-03-14T06:36:19.311Z","comments":true,"path":"2021/03/02/HttpURLConnection&OK3&Retrofit自吐通杀/","link":"","permalink":"http://onejane.gitee.io/2021/03/02/HttpURLConnection&OK3&Retrofit%E8%87%AA%E5%90%90%E9%80%9A%E6%9D%80/","excerpt":"","text":"HttpURLConnectionadb install -r -t network-debug.apk 启动frida 12adb shell .&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64 内存漫游 123456pyenv local 3.8.0objection -g com.example.network explore -P ~&#x2F;.objection&#x2F;pluginsandroid hooking list classes 查看所有可hook的类android hooking search classes URLandroid hooking watch class java.net.URL 由于hookURL类遗漏构造函数需要手动hook $initandroid hooking watch class_method java.net.URL.$init --dump-args --dump-backtrace --dump-return hook构造函数并打印 点击HTTP图片获取按钮，实现自吐第一步，并拿到上层实现类HttpURLConnectionImpl 123android hooking search classes HttpURLConnectionImplandroid hooking watch class com.android.okhttp.internal.huc.HttpURLConnectionImpl hook类所有方法并打印方法android hooking watch class_method com.android.okhttp.internal.huc.HttpURLConnectionImpl.setRequestProperty --dump-args --dump-backtrace --dump-return hook类指定方法并打印出入参及调用栈 点击HTTP图片获取按钮，实现自吐第二步 plugin wallbreaker objectsearch com.android.okhttp.internal.huc.HttpURLConnectionImpl 存在多个实例说明每次点击生成新的对象且不释放 plugin wallbreaker objectdump –fullname 0x2972 打印其中一个对象在内存中的结构 android heap search instances com.android.okhttp.internal.huc.HttpURLConnectionImpl 获取内存中的实例地址 android heap execute 0x21e6 defaultUserAgent 手动调用defaultUserAgent 自吐frida -U -f com.cz.babySister -l hook_HttpUrlConnection.js --no-pause 12345678910111213141516171819202122232425262728function hook_HttpUrlConnection()&#123; Java.perform(function()&#123; &#x2F;&#x2F; java.net.URL.URL ($init) (得到URL) Java.use(&quot;java.net.URL&quot;).$init.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (str)&#123; var result &#x3D; this.$init(str) console.log(&quot;result , str &#x3D;&gt; &quot;,result,str); return result; &#125; &#x2F;&#x2F;HttpURLConnection setRequestProperty 得到各种请求头、属性等，不能hook抽象类HttpURLConnection，只能hook抽象类的实现类HttpURLConnectionImpl Java.use(&quot;com.android.okhttp.internal.huc.HttpURLConnectionImpl&quot;).setRequestProperty.implementation &#x3D; function(str1,str2)&#123; var result &#x3D; this.setRequestProperty(str1,str2); console.log(&quot;.setRequestProperty result,str1,str2-&gt;&quot;,result,str1,str2); return result; &#125; Java.use(&quot;com.android.okhttp.internal.huc.HttpURLConnectionImpl&quot;).setRequestMethod.implementation &#x3D; function(str1)&#123; var result &#x3D; this.setRequestMethod(str1); console.log(&quot;.setRequestMethod result,str1,str2-&gt;&quot;,result,str1); return result; &#125; &#125;)&#125;setImmediate(hook_HttpUrlConnection) OkHttp3搭建抓包环境默认创建Okhttp框架帮我们默认所有配置，因此无法自定义添加用户拦截器。 as新建Ok3Demo项目，创建页面button布局 12345678910111213141516171819&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot; android:gravity&#x3D;&quot;center|center_horizontal|center_vertical&quot; tools:context&#x3D;&quot;.MainActivity&quot;&gt; &lt;Button android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:gravity&#x3D;&quot;center|center_horizontal|center_vertical&quot; android:id&#x3D;&quot;@+id&#x2F;mybtn&quot; android:text&#x3D;&quot;发送请求&quot; android:textSize&#x3D;&quot;45sp&quot;&gt; &lt;&#x2F;Button&gt;&lt;&#x2F;LinearLayout&gt; build.gradle引入ok3依赖 12&#x2F;&#x2F; 增加对Okhttp3的依赖implementation(&quot;com.squareup.okhttp3:okhttp:3.12.0&quot;) AndroidManifest.xml配置网络权限 12&lt;!-- 申请网络请求权限 --&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt; 创建异步请求线程，在RealCall.newRealCall()中，创建了一个新的RealCall对象，RealCall对象是Okhttp3.Call接口的一个实现，也是Okhttp3中Call的唯一实现。它表示一个等待执行的请求，它只能被执行一次，但实际上，到这一步，请求依然可以被取消。因此只有Hook 了execute()和enqueue(new Callback())才能真正保证每个从Okhttp出去的请求都能被Hook到 1234567891011121314151617181920212223242526272829303132public class example &#123; &#x2F;&#x2F; TAG即为日志打印时的标签 private static String TAG &#x3D; &quot;learnokhttp&quot;; &#x2F;&#x2F; 新建一个Okhttp客户端 OkHttpClient client &#x3D; new OkHttpClient(); void run(String url) throws IOException &#123; &#x2F;&#x2F; 构造request Request request &#x3D; new Request.Builder() .url(url) .build(); &#x2F;&#x2F; 发起异步请求 client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; call.cancel(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#x2F;&#x2F;打印输出 Log.d(TAG, response.body().string()); &#125; &#125; ); &#125;&#125; MainActivity中调用网络请求线程 12345678910111213141516171819202122232425262728public class MainActivity extends AppCompatActivity &#123; private static String TAG &#x3D; &quot;learnokhttp&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#x2F;&#x2F; 定位发送请求按钮 Button btn &#x3D; findViewById(R.id.mybtn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#x2F;&#x2F; 访问百度首页 String requestUrl &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;; example myexample &#x3D; new example(); try &#123; myexample.run(requestUrl); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 建造者(Builder)模式新建LoggingInterceptor类，实现Interceptor接口，这代表它是一个拦截器，接下来实现intercept方法，我们的拦截器会打印URL和请求headers 123456789101112131415class LoggingInterceptor implements Interceptor &#123; &#x2F;&#x2F; TAG即为日志打印时的标签 private static String TAG &#x3D; &quot;learnokhttp&quot;; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Request request &#x3D; chain.request(); Log.i(TAG, &quot;请求URL：&quot;+String.valueOf(request.url())+&quot;\\n&quot;); Log.i(TAG, &quot;请求headers：&quot;+&quot;\\n&quot;+String.valueOf(request.headers())+&quot;\\n&quot;); Response response &#x3D; chain.proceed(request); return response; &#125;&#125; 拦截器是Okhttp中重要的一个概念，Okhttp通过Interceptor来完成监控管理、重写和重试请求。Okhttp本身存在五大拦截器，每个网络请求，不管是GET还是PUT/POST或者其他，都必须经过这五大拦截器。拦截器可以对request做出一定修改，同时对返回的Response做出一定修改，因此Interceptor是一个绝佳的Hook点，可以同时打印输出请求和相应。 自定义配置所有参数 1234567&#x2F;&#x2F; 此为原先的clientOkHttpClient client &#x3D; new OkHttpClient();&#x2F;&#x2F; 基于原先的client创建新的clientOkHttpClient newClient &#x3D; client.newBuilder() .addNetworkInterceptor(new LoggingInterceptor()) .build(); 将example中代码转移到MainActivity中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MainActivity extends AppCompatActivity &#123; private static String TAG &#x3D; &quot;learnokhttp&quot;; public static final String requestUrl &#x3D; &quot;http:&#x2F;&#x2F;www.kuaidi100.com&#x2F;query?type&#x3D;yuantong&amp;postid&#x3D;11111111111&quot;; &#x2F;&#x2F; 全局只使用这一个拦截器 public static final OkHttpClient client &#x3D; new OkHttpClient.Builder() .addNetworkInterceptor(new LoggingInterceptor()) .build(); Request request &#x3D; new Request.Builder() .url(requestUrl) .build(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#x2F;&#x2F; 定位发送请求按钮 Button btn &#x3D; findViewById(R.id.mybtn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#x2F;&#x2F; 发起异步请求 client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; call.cancel(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#x2F;&#x2F;打印输出 Log.d(TAG, response.body().string()); &#125; &#125; ); &#125; &#125;); &#125;&#125; hookadb shell &amp;&amp; ./data/local/tmp/fs128arm64 启动frida pyenv local 3.8.0 切换python环境 objection -g com.onejane.ok3demo explore -P ~/.objection/plugins 加载所有插件，点击发送请求并开启内存漫游 12345plugin wallbreaker classsearch OkHttpClient 内存搜索OkHttpClient类plugin wallbreaker classdump --fullname okhttp3.OkHttpClient 打印该类结构plugin wallbreaker objectsearch okhttp3.OkHttpClient 获取该类的内存地址plugin wallbreaker objectdump --fullname 0x2592 打印内存中该地址的类结构plugin wallbreaker objectsearch okhttp3.OkHttpClient 内存中存在多个OkHttpClient,默认不回收对象实例 okhttp3Logging新增okhttp3Logging类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171public final class okhttp3Logging implements Interceptor &#123; private static final String TAG &#x3D; &quot;okhttpGET&quot;; private static final Charset UTF8 &#x3D; Charset.forName(&quot;UTF-8&quot;); @Override public Response intercept(Chain chain) throws IOException &#123; Request request &#x3D; chain.request(); RequestBody requestBody &#x3D; request.body(); boolean hasRequestBody &#x3D; requestBody !&#x3D; null; Connection connection &#x3D; chain.connection(); String requestStartMessage &#x3D; &quot;--&gt; &quot; + request.method() + &#39; &#39; + request.url(); Log.e(TAG, requestStartMessage); if (hasRequestBody) &#123; &#x2F;&#x2F; Request body headers are only present when installed as a network interceptor. Force &#x2F;&#x2F; them to be included (when available) so there values are known. if (requestBody.contentType() !&#x3D; null) &#123; Log.e(TAG, &quot;Content-Type: &quot; + requestBody.contentType()); &#125; if (requestBody.contentLength() !&#x3D; -1) &#123; Log.e(TAG, &quot;Content-Length: &quot; + requestBody.contentLength()); &#125; &#125; Headers headers &#x3D; request.headers(); for (int i &#x3D; 0, count &#x3D; headers.size(); i &lt; count; i++) &#123; String name &#x3D; headers.name(i); &#x2F;&#x2F; Skip headers from the request body as they are explicitly logged above. if (!&quot;Content-Type&quot;.equalsIgnoreCase(name) &amp;&amp; !&quot;Content-Length&quot;.equalsIgnoreCase(name)) &#123; Log.e(TAG, name + &quot;: &quot; + headers.value(i)); &#125; &#125; if (!hasRequestBody) &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method()); &#125; else if (bodyHasUnknownEncoding(request.headers())) &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (encoded body omitted)&quot;); &#125; else &#123; Buffer buffer &#x3D; new Buffer(); requestBody.writeTo(buffer); Charset charset &#x3D; UTF8; MediaType contentType &#x3D; requestBody.contentType(); if (contentType !&#x3D; null) &#123; charset &#x3D; contentType.charset(UTF8); &#125; Log.e(TAG, &quot;&quot;); if (isPlaintext(buffer)) &#123; Log.e(TAG, buffer.readString(charset)); Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (&quot; + requestBody.contentLength() + &quot;-byte body)&quot;); &#125; else &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (binary &quot; + requestBody.contentLength() + &quot;-byte body omitted)&quot;); &#125; &#125; long startNs &#x3D; System.nanoTime(); Response response; try &#123; response &#x3D; chain.proceed(request); &#125; catch (Exception e) &#123; Log.e(TAG, &quot;&lt;-- HTTP FAILED: &quot; + e); throw e; &#125; long tookMs &#x3D; TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs); ResponseBody responseBody &#x3D; response.body(); long contentLength &#x3D; responseBody.contentLength(); String bodySize &#x3D; contentLength !&#x3D; -1 ? contentLength + &quot;-byte&quot; : &quot;unknown-length&quot;; Log.e(TAG, &quot;&lt;-- &quot; + response.code() + (response.message().isEmpty() ? &quot;&quot; : &#39; &#39; + response.message()) + &#39; &#39; + response.request().url() + &quot; (&quot; + tookMs + &quot;ms&quot; + (&quot;, &quot; + bodySize + &quot; body:&quot; + &quot;&quot;) + &#39;)&#39;); Headers myheaders &#x3D; response.headers(); for (int i &#x3D; 0, count &#x3D; myheaders.size(); i &lt; count; i++) &#123; Log.e(TAG, myheaders.name(i) + &quot;: &quot; + myheaders.value(i)); &#125; if (!HttpHeaders.hasBody(response)) &#123; Log.e(TAG, &quot;&lt;-- END HTTP&quot;); &#125; else if (bodyHasUnknownEncoding(response.headers())) &#123; Log.e(TAG, &quot;&lt;-- END HTTP (encoded body omitted)&quot;); &#125; else &#123; BufferedSource source &#x3D; responseBody.source(); source.request(Long.MAX_VALUE); &#x2F;&#x2F; Buffer the entire body. Buffer buffer &#x3D; source.buffer(); Long gzippedLength &#x3D; null; if (&quot;gzip&quot;.equalsIgnoreCase(myheaders.get(&quot;Content-Encoding&quot;))) &#123; gzippedLength &#x3D; buffer.size(); GzipSource gzippedResponseBody &#x3D; null; try &#123; gzippedResponseBody &#x3D; new GzipSource(buffer.clone()); buffer &#x3D; new Buffer(); buffer.writeAll(gzippedResponseBody); &#125; finally &#123; if (gzippedResponseBody !&#x3D; null) &#123; gzippedResponseBody.close(); &#125; &#125; &#125; Charset charset &#x3D; UTF8; MediaType contentType &#x3D; responseBody.contentType(); if (contentType !&#x3D; null) &#123; charset &#x3D; contentType.charset(UTF8); &#125; if (!isPlaintext(buffer)) &#123; Log.e(TAG, &quot;&quot;); Log.e(TAG, &quot;&lt;-- END HTTP (binary &quot; + buffer.size() + &quot;-byte body omitted)&quot;); return response; &#125; if (contentLength !&#x3D; 0) &#123; Log.e(TAG, &quot;&quot;); Log.e(TAG, buffer.clone().readString(charset)); &#125; if (gzippedLength !&#x3D; null) &#123; Log.e(TAG, &quot;&lt;-- END HTTP (&quot; + buffer.size() + &quot;-byte, &quot; + gzippedLength + &quot;-gzipped-byte body)&quot;); &#125; else &#123; Log.e(TAG, &quot;&lt;-- END HTTP (&quot; + buffer.size() + &quot;-byte body)&quot;); &#125; &#125; return response; &#125; &#x2F;** * Returns true if the body in question probably contains human readable text. Uses a small sample * of code points to detect unicode control characters commonly used in binary file signatures. *&#x2F; static boolean isPlaintext(Buffer buffer) &#123; try &#123; Buffer prefix &#x3D; new Buffer(); long byteCount &#x3D; buffer.size() &lt; 64 ? buffer.size() : 64; buffer.copyTo(prefix, 0, byteCount); for (int i &#x3D; 0; i &lt; 16; i++) &#123; if (prefix.exhausted()) &#123; break; &#125; int codePoint &#x3D; prefix.readUtf8CodePoint(); if (Character.isISOControl(codePoint) &amp;&amp; !Character.isWhitespace(codePoint)) &#123; return false; &#125; &#125; return true; &#125; catch (EOFException e) &#123; return false; &#x2F;&#x2F; Truncated UTF-8 sequence. &#125; &#125; private boolean bodyHasUnknownEncoding(Headers myheaders) &#123; String contentEncoding &#x3D; myheaders.get(&quot;Content-Encoding&quot;); return contentEncoding !&#x3D; null &amp;&amp; !contentEncoding.equalsIgnoreCase(&quot;identity&quot;) &amp;&amp; !contentEncoding.equalsIgnoreCase(&quot;gzip&quot;); &#125;&#125; 打包编译后取出dex改名为okhttp3logging.dex，push到/data/locol/tmp目录下 编写frida进行hook,frida -U -f com.onejane.ok3demo -l hookOkhttp3.js --no-pause并通过adb logcat 查看系统log 123456789101112131415161718function hook_okhttp3_logging() &#123; &#x2F;&#x2F; 1. frida Hook java层的代码必须包裹在Java.perform中，Java.perform会将Hook Java相关API准备就绪。 Java.perform(function () &#123; Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;okhttp3logging.dex&quot;).load(); &#x2F;&#x2F; 只修改了这一句，换句话说，只是使用不同的拦截器对象。 var MyInterceptor &#x3D; Java.use(&quot;com.onejane.ok3demo.okhttp3Logging&quot;); var MyInterceptorObj &#x3D; MyInterceptor.$new(); var Builder &#x3D; Java.use(&quot;okhttp3.OkHttpClient$Builder&quot;); console.log(Builder); Builder.build.implementation &#x3D; function () &#123; this.networkInterceptors().add(MyInterceptorObj); return this.build(); &#125;; console.log(&quot;hook_okhttp3...&quot;); &#125;);&#125; Retrofitgit clone https://github.com/peiniwan/Ganhuo.git 编译源码编译安装apk 修改build.gradle,buildscript.repositories和allprojects.repositories添加google() 1classpath &#39;com.android.tools.build:gradle:3.5.3&#39; frida -U -f ganhuo.ly.com.ganhuo -l hookOkhttp3.js --no-pause 调用hook_okhttp3_logging()通过adb logcat查看后台log git clone https://github.com/siyujie/OkHttpLogger-Frida.git 获取Frida 实现拦截okhttp的脚本，首先将 okhttpfind.dex 拷贝到 /data/local/tmp/ 目录下，执行命令启动frida -UF -l okhttp_poker.js -f ganhuo.ly.com.ganhuo --no-pause 可追加 -o [output filepath]保存到文件 原理： 由于所有使用的okhttp框架的App发出的请求都是通过RealCall.java发出的，那么我们可以hook此类拿到request和response, 也可以缓存下来每一个请求的call对象，进行再次请求，所以选择了此处进行hook。 find前新增check，根据特征类寻找是否使用了okhttp3库，如果没有特征类，则说明没有使用okhttp; 找到特征类，说明使用了okhttp的库，并打印出是否被混淆。 12345&#96;find()&#96; 要等完全启动并执行过网络请求后再进行调用,检查是否使用了Okhttp &amp; 是否可能被混淆 &amp; 寻找okhttp3关键类及函数 &#96;switchLoader(\\&quot;okhttp3.OkHttpClient\\&quot;)&#96; 参数：静态分析到的okhttpclient类名&#96;hold()&#96; 要等完全启动再进行调用,开启HOOK拦截&#96;history()&#96; 打印可重新发送的请求&#96;resend(index)&#96; 重新发送请求 baseUrl自吐 Hook RetrofitUtils 中的new Retrofit.Builder().baseUrl(baseurl)的baseUrl 12345objection -g ganhuo.ly.com.ganhuo exploreandroid hooking search classes retrofitandroid hooking list class_methods retrofit2.Retrofitandroid hooking list class_methods retrofit2.Retrofit$Builder 发现只有baseUrl()无参构造，可能在app启动时就执行了baseUrl(baseurl)objection -g ganhuo.ly.com.ganhuo explore --startup-command &quot;android hooking list class_methods retrofit2.Retrofit$Builder&quot; 没有反应 通过编写frida脚本实现hook有参构造baseUrl 12345678910111213141516function hookbaseurl()&#123; Java.perform(function()&#123; Java.use(&quot;retrofit2.Retrofit$Builder&quot;).baseUrl.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(str)&#123; var result &#x3D; this.baseUrl(str) console.log(&quot;result1,str&#x3D;&gt;&quot;,result,str) return result &#125; Java.use(&quot;retrofit2.Retrofit$Builder&quot;).baseUrl.overload(&#39;okhttp3.HttpUrl&#39;).implementation &#x3D; function(str)&#123; var result &#x3D; this.baseUrl(str) console.log(&quot;result2,str&#x3D;&gt;&quot;,result,str) return result &#125; &#125;)&#125;setImmediate(hookbaseurl)","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.gitee.io/tags/frida/"},{"name":"okhttp3","slug":"okhttp3","permalink":"http://onejane.gitee.io/tags/okhttp3/"},{"name":"HttpURLConnection","slug":"HttpURLConnection","permalink":"http://onejane.gitee.io/tags/HttpURLConnection/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://onejane.gitee.io/tags/Retrofit/"}]},{"title":"强大的脚本","slug":"强大的脚本","date":"2021-02-22T07:48:20.000Z","updated":"2021-03-27T00:36:51.357Z","comments":true,"path":"2021/02/22/强大的脚本/","link":"","permalink":"http://onejane.gitee.io/2021/02/22/%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%84%9A%E6%9C%AC/","excerpt":"","text":"Python合并多dex1234567891011121314151617181920import os, sys# python3.7 merge_dex.py .&#x2F;file&#x2F; livedexif __name__ &#x3D;&#x3D; &quot;__main__&quot;: if len(sys.argv) &lt; 3 : print(&quot;start error&quot;) sys.exit() print(sys.argv[1], sys.argv[2]) path &#x3D; sys.argv[1] #文件夹目录files&#x3D; os.listdir(path) #得到文件夹下的所有文件名称s &#x3D; []for file in files: #遍历文件夹 if file.find(&quot;dex&quot;) &gt; 0: ## 查找dex 文件 sh &#x3D; &#39;jadx -j 1 -r -d &#39; + sys.argv[2] + &quot; &quot; + path + file print(sh) os.system(sh) 集合排列组合12345678910111213141516171819productType = [1, 2, 3]goodType = [4, 5]energyType = [6, 7]productGoodEnergyType = [[1,2,3],[4,5],[6, 7]]# 多个集合随机有序排列,同itertools.product(*productGoodEnergyType)for newValue in itertools.product(productType,goodType,energyType): print(newValue)# 按组合个数进行无序组合print(list(itertools.permutations(productType))) for productTypeIndex in range(1, len(productType) + 1): # 单个集合按指定个数随机有序排列 productTypeTter1 = itertools.combinations(productType, productTypeIndex) print(list(productTypeTter1)) # 单个集合按指定个数随机无序组合 productTypeTter2 = itertools.permutations(productType, productTypeIndex) print(list(productTypeTter2)) 多集合组合 拿到集合的组合 根据这些组合进行分组笛卡尔积 1234567891011121314151617181920212223242526272829def combine(big_dict): # Cn1+Cn2+...+Cnn # Cmn&#x3D;m!&#x2F;n!*(m-n)! keys &#x3D; list(big_dict.keys()) # 获取keyList combine_key_list &#x3D; [] # key值 排列组合 valueList &#x3D; [] # 将key替换为值 for i in range(1, len(keys) + 1): iter &#x3D; itertools.combinations(keys, i) # [(&#39;a&#39;,), (&#39;b&#39;,), (&#39;c&#39;,), (&#39;a&#39;, &#39;b&#39;), (&#39;a&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)] combine_key_list.extend(list(iter)) # key的所有组合 以list形式加入列表 for m in combine_key_list: # [[[1, 2, 3]], [[4, 5]], [[6, 7, 8, 9]], [[1, 2, 3], [4, 5]], [[1, 2, 3], [6, 7, 8, 9]], [[4, 5], [6, 7, 8, 9]], [[1, 2, 3], [4, 5], [6, 7, 8, 9]]] valueList.append([big_dict.get(n) for n in m if n in keys]) # key所有组合转value组合 以object形式加入列表 param_list &#x3D; [] for index, value in enumerate(valueList): # list转为索引序列 search_type_key &#x3D; list(combine_key_list[index]) # 根据当前值对应key for item in itertools.product(*value): # 集合中n个集合n组笛卡尔积 params &#x3D; dict(zip(search_type_key, list(item))) param_list.append(urlencode(params)) print(param_list)d &#x3D; &#123; &#39;a&#39;: [1,2,3], &#39;b&#39;: [4,5], &#39;c&#39;: [6,7,8,9],&#125;combine(d) 格式转换转str 1234t &#x3D; (1,2)l &#x3D; [3,4]print(&#39;,&#39;.join(map(str, t)) if isinstance(t,tuple) else t)print(&#39;,&#39;.join(map(str, l)) if isinstance(l,list) else l) 转dict 1print(dict(zip(productType,goodType))) 转list 12def flatten(li): return sum(([x] if not isinstance(x, list) else flatten(x) for x in li), []) 字典key替换 1param_dict[&#39;area&#39;] &#x3D; param_dict.pop(&#39;ownerProvince&#39;)+&#39;-&#39;+param_dict.pop(&#39;ownerCity&#39;) Mongo123456import pymongoclient &#x3D; pymongo.MongoClient(settings.get(&#39;MONGO_URI&#39;))[settings.get(&#39;MONGO_DB&#39;)]client[&#39;MUsedCar&#39;].create_index([(&quot;url&quot;, 1)], unique&#x3D;True)client[&#39;MUsedCar&#39;].insert(dict(&#123;&#39;url&#39;:used_car_url+urlencode(param_dict)&#125;))for doc in client[&#39;MUsedCarParams&#39;].find(): print(doc[&#39;params&#39;]) 爬虫url12param_dict &#x3D; dict(parse.parse_qsl(parse.unquote(doc[&#39;params&#39;]))) url解码并转为字典urlencode(param_dict) 字典转url编码 JavaGit多仓库12git remote set-url --add origin git@github.com:OneJane&#x2F;CrawlerBase.gitgit push origin --all 版本回退12git refloggit reset --hard 版本号 Mongo更新批量将字段更新成字符串 1234db.getCollection(&#39;alimama&#39;).find(&#123;&#125;).forEach(function(x)&#123; db.getCollection(&#39;alimama&#39;).updateOne( &#123;_id: x._id&#125;, &#123;$set:&#123;income_rate: String(x.income_rate)&#125;&#125;)&#125;) 批量新增字段 1db.getCollection(&#39;taobao&#39;).update(&#123;&#125;, &#123;$set: &#123;&#39;name&#39;:&quot;taobao&quot;&#125;&#125;, &#123;multi: true&#125;); 批量修改字段名 1db.getCollection(&#39;long_link&#39;).update(&#123;&#125;, &#123;&quot;$rename&quot;:&#123;&quot;long_link&quot;:&quot;orientPlanLinkUrl&quot;&#125;&#125;, false, true) 查询返回指定字段id 1db.getCollection(&#39;alimama&#39;).find(&#123;&#125;,&#123;_id:0,id:1&#125;) 按照url分组查询并倒序 1db.getCollection(&#39;conditions&#39;).aggregate([&#123;$group : &#123;_id : &quot;$url&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;,&#123; $sort : &#123; num_tutorial: -1 &#125; &#125;]) 模糊查询 1db.getCollection(&#39;conditions&#39;).find(&#123;&#39;url&#39;:&#123;&#39;$regex&#39;:&#39;https:*&#39;&#125;&#125;).count() 导出 sublime 中ctrl+h 进行 {“_id”:.:”(.)”}\\n 替换为 $1\\n 1mongoexport -h 172.20.0.186:27017 -d jddmoto -c mbrand -o mbrand.json --type json -f url Mysqllocate1SELECT GROUP_CONCAT(a.n_id), COUNT(a.&#96;n_id&#96;) FROM &#96;motor_business_essay&#96; a, &#96;motor_business_essay_ext&#96; b where locate(&#39;&quot;img&quot;:&quot;&quot;&#39;,a.c_short_vod_info) Linux删除大文件123df -hlsof | grep deleted 查询内存中持续删除的进程kill -9 id windows新增复制文件路径.regUTF-8-BOM编码 1234567891011121314151617181920Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\*\\shell\\copypath]@&#x3D;&quot;复制文件路径到剪贴板&quot;[HKEY_CLASSES_ROOT\\*\\shell\\copypath\\command]@&#x3D;&quot;cmd &#x2F;c echo %1 | clip&quot;[HKEY_CLASSES_ROOT\\*\\shell\\copypathwithquote]@&#x3D;&quot;复制文件路径到剪贴板(带引号)&quot;[HKEY_CLASSES_ROOT\\*\\shell\\copypathwithquote\\command]@&#x3D;&quot;cmd &#x2F;c echo \\&quot;%1\\&quot; | clip&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypath]@&#x3D;&quot;复制文件夹路径到剪贴板&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypath\\command]@&#x3D;&quot;cmd &#x2F;c echo %1 | clip&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypathwithquote]@&#x3D;&quot;复制文件夹路径到剪贴板(带引号)&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypathwithquote\\command]@&#x3D;&quot;cmd &#x2F;c echo \\&quot;%1\\&quot; | clip&quot;","categories":[{"name":"脚本","slug":"脚本","permalink":"http://onejane.gitee.io/categories/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"python","slug":"python","permalink":"http://onejane.gitee.io/tags/python/"}]},{"title":"加壳与脱壳之分类技术","slug":"加壳与脱壳之分类技术","date":"2021-02-21T09:16:27.000Z","updated":"2021-03-25T00:09:11.473Z","comments":true,"path":"2021/02/21/加壳与脱壳之分类技术/","link":"","permalink":"http://onejane.gitee.io/2021/02/21/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%88%86%E7%B1%BB%E6%8A%80%E6%9C%AF/","excerpt":"","text":"历代加壳技术分类动态加载是用到的时候再去加载，也叫懒加载，是dex加壳，插件化，热更新的基础，避免发布新版本需要用户全量更新app，快速迭代，提升用户体验。比如阿里的AndFix和HotFix，腾讯的tinker，美团的Robust等热修复框架的基础。动态加载的dex不具有生命周期特征，APP中的Activity，Service等组件无法正常工作，只能完成一般函数的调用。需要对ClassLoader进行修正，APP才能够正常运行，有反射替换和反射插入两种修正手段，这是加壳app必然要做的一步。 第一代壳:dex加密 Dex字符串加密 资源加密 对抗反编译 反调试 自定义 DexClass Loader 由于是dex整体保护，在内存中映射是整体连续的，通过定位起始地址将app完整脱下来 第二代壳:dex抽取与加固 对抗第一代壳常见的脱壳法 Dex method代码抽取到外部(通常企业版) Dex动态加载 So加密 首先dex整体保护，其次对关键函数进行抽取(dump内存区域中dex关键类为空)进行so加密，对抗第一代壳常用脱壳法(从关键hook点dump dex) 第三代壳:dex动态解密与混淆 Dex method代码动态解密 So代码膨胀混淆 对抗之前出现的所有脱壳法 对抗第二代壳的一个通用脱壳工具DexHunter(通过遍历dex所有类进行加载初始化，将内存中dex完整恢复),dex中method动态解密，指定函数只有被调用时才执行，dex在内存中始终不是完整的状态 第四代壳:vmp壳目前仍然是smali指令级别的vmp，未来将出现arm指令级别vmp 加壳技术分析dex加固 dex整体加固:文件加载（监控app访问文件的记录）和内存加载（对内存dex的解密直接动态加载） 函数抽取:在函数粒度完成代码的保护：dump下dex的关键函数体置空 VMP和Dex2C:JAVA函数 Native化。vmp-&gt;逆向分析解释器找到取址译码 dex整体加固dex整体加壳是基础防护，所有加壳的app必然都有，关键在于怎么区分函数抽取，vmp以及dex2c甚至多种技术混合的混合型壳。 文件加载:定位解密文件是关键 内存加载:加载时机和内存起始地址是关键 通用方案:dex打开和优化的流程以及产出的odex、dex2oat编译的流程和生成的oat文件等等 函数抽取获取到保护的dex后,函数体的内容是无效的,注意这里说的是无效,而不是无意义,有的app壳后函数依然是有意义的,但不是我们想要的。f5查看函数体全部为空，则表现为函数抽取。 VMP获取到保护的dex后,函数的属性由java属性变为 Native,典型的有数字的 onCreate函数 Native化JNI函数。vmp壳的核心就是dalvik虚拟机的解释器原理。 若所有vmp保护的函数都有自己的解释器则so必然很大，所以必然共享一个解释器，vmp化的函数注册地址一致或者函数逻辑相似。 MainActivity动态注册地址在d3dec3f1,TestActivity地址一致，说明vmp保护。 参考vmp加壳方案之ADVMP，vmp对每一种smali指令处理，保护了函数后函数属性发生改变，因为解释器一般是用JNI实现，java易被反编译，故没用java实现，基本由c实现，防止快速定位到解释器的取址译码和执行的流程会加ollvm混淆保护之类。 Dex2c获取到保护的dex后保护的函数属性有java变成native，dcc保护后所有java属性的函数变成jni函数，只能看到类名和参数。核心原理与编译原理相关，传统编译原理是编译器经过词法分析语法分析生成二进制代码，dex2c中生成结果是c、c++文件，经过ndk编译器最终编译为so,每一个函数基本编译成一个c/c++文件，ubuntu中编译最终生成一个so。 dex2c核心对指定java函数进行语义分析生成各个不同的c/c++代码编译为相应so，自然dex2c保护的函数逻辑不一致，自然注册地址不同。 MainActivity的地址在7ba61b17c0，TestActivity地址在7ba61ac604，说明dex2c保护。 dcc_out.apk在lib下编译生成了so文件中,jni函数静态注册都存放于so文件中，使用IDA v7打开libnc.so，搜索java就可以找到所有jni函数。 dcc_out编译于项目LoadDex,新增FirstActivity，SecondActivity MainActivity.java 12345678910111213141516171819202122static&#123; try &#123; System.loadLibrary(&quot;nc&quot;); &#125; catch (UnsatisfiedLinkError e) &#123; e.printStackTrace(); &#125;&#125;setContentView(R.layout.activity_main);Button mybutton01&#x3D;findViewById(R.id.button01);mybutton01.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; context.startActivity(new Intent(context,FirstActivity.class)); &#125;&#125;);Button mybutton02&#x3D;findViewById(R.id.button02);mybutton02.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; context.startActivity(new Intent(context,SecondActivity.class)); &#125;&#125;); AndroidManifest.xml 12&lt;activity android:name&#x3D;&quot;.FirstActivity&quot;&gt;&lt;&#x2F;activity&gt;&lt;activity android:name&#x3D;&quot;.SecondActivity&quot;&gt;&lt;&#x2F;activity&gt; activity_main.xml 12345678910111213141516171819202122232425&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot; android:id&#x3D;&quot;@+id&#x2F;LinearLayout1&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;button01&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center_horizontal&quot; android:text&#x3D;&quot;FirstActivity&quot; &#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;button02&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center_horizontal&quot; android:text&#x3D;&quot;SecondActivity&quot; &#x2F;&gt;&lt;&#x2F;LinearLayout&gt; dcc_ollvm.apk 在dex2c过程中加入了ollvm，在ida中打开so，jni找不到。 参考dex2c加壳方案之dcc 1234git clone https:&#x2F;&#x2F;github.com&#x2F;amimo&#x2F;dcc.gitpyenv local 3.8.5 &amp;&amp; cd dcc &amp;&amp; pip install -r requirements.txtvim filter.txt 添加.*onejane*. 编译函数名含有onejane的函数python dcc.py dcc.apk -o dcc_out.apk 加固app VMP和dex2c是高级防护 VMP:定位解释器是关键,找到映射关系便可恢复 dex2c:基础是编译原理,进行了等价语义转换,彻底还原难度巨大: 通用分类技术:关注JNI相关的ap调用是关键,也是分析VMP和dex2c保护的函数的逻辑的关键。 混合型壳多种加固技术混合使用,比如先将原有smal指令流使用VMP或dex2c保护,构建object数组传递给jni函数进行调用，然后再经过函数抽取进一步保护 区分apk保护技术 是否Native化 函数体无效 函数抽取类壳 否 是 vmp壳 是 native化 Dex2c壳 是 native化 so加固 基于init、 init_array以及JNI_Onload函数的加壳 基于自定义linker的加壳 IDA快捷键 空格键 反汇编窗口切换文本跟图形 ESC 退到上一个操作地址 F5 C伪代码 alt+t 搜索文本","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"fart","slug":"fart","permalink":"http://onejane.gitee.io/tags/fart/"},{"name":"vmp","slug":"vmp","permalink":"http://onejane.gitee.io/tags/vmp/"},{"name":"dex2c","slug":"dex2c","permalink":"http://onejane.gitee.io/tags/dex2c/"}]},{"title":"主动调用java及native层","slug":"主动调用java及native层","date":"2021-02-16T15:27:08.000Z","updated":"2021-03-24T01:38:39.147Z","comments":true,"path":"2021/02/16/主动调用java及native层/","link":"","permalink":"http://onejane.gitee.io/2021/02/16/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8java%E5%8F%8Anative%E5%B1%82/","excerpt":"","text":"examplefrida-server-linuxfrida-python修改examples中rpc.py 12345678910111213141516171819# -*- coding: utf-8 -*-from __future__ import print_functionimport fridaimport timesession &#x3D; frida.attach(&quot;mousepad&quot;)script &#x3D; session.create_script(&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; hello: function () &#123; return &#39;Hello&#39;; &#125;, failPlease: function () &#123; return &#39;oops&#39;; &#125;&#125;;&quot;&quot;&quot;)script.load()api &#x3D; script.exportsprint(&quot;api.hello() &#x3D;&gt;&quot;, api.hello())print(&quot;api.fail_please() &#x3D;&gt;&quot;,api.fail_please()) 7z x frida-server-14.2.12-linux-x86_64.xz &amp;&amp; chmod 777 frida-server-14.2.12-linux-x86_64 &amp;&amp; ./frida-server-14.2.12-linux-x86_64 启动linux的frida server 通过netstat -tuulp可以查询被frida-server listen的27042端口 echo 123&gt;1.txt &amp;&amp; mousepad 1.txt 记事本打开1.txt,ps aux|grep -i mousepad查看该进程 python rpc.py 查看rpc attach mousepad引用打印结果 python-binding里连接frida-server的非标准端口: ./fs1428arm64 -l 0.0.0.0:6666import fridadevice = frida.get_device_manager().add_remote_device(‘192.168.1.101:6666’)print(device.name,devie.type,device.id) frida-python修改examples中bytecode.py 1234567891011121314system_session &#x3D; frida.attach(0)bytecode &#x3D; system_session.compile_script(name&#x3D;&quot;bytecode-example&quot;, source&#x3D;&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; listThreads: function () &#123; return Process.enumerateThreadsSync(); &#125;&#125;;&quot;&quot;&quot;)session &#x3D; frida.attach(&quot;mousepad&quot;)script &#x3D; session.create_script_from_bytes(bytecode)script.load()api &#x3D; script.exportsprint(&quot;api.list_threads() &#x3D;&gt;&quot;, api.list_threads()) python bytecode.py 查看rpc 编译生成的thread列表 frida-server-androidfrida-python修改examples中rpc.py 1234567891011121314151617181920device &#x3D; frida.get_usb_device()#device &#x3D; frida.get_device_manager.add_remote_device(&quot;192.168.0.2:8888&quot;) # 基于远程ip的集群pid &#x3D; device.spawn([&quot;com.android.settings&quot;])device.resume(pid)time.sleep(1)session &#x3D; device.attach(pid)script &#x3D; session.create_script(&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; hello: function () &#123; return &#39;Hello&#39;; &#125;, failPlease: function () &#123; return &#39;oops&#39;; &#125;&#125;;&quot;&quot;&quot;)script.load()api &#x3D; script.exportsprint(&quot;api.hello() &#x3D;&gt;&quot;, api.hello())print(&quot;api.fail_please() &#x3D;&gt;&quot;,api.fail_please()) ./fs1428arm64 pyenv local 3.8.5 &amp;&amp; python rpc.py 自启动进程查看rpc attach pid引用打印结果 frida-python修改examples中detached.py 1234567891011121314151617181920def on_detached(): print(&quot;on_detached&quot;)def on_detached_with_reason(reason): print(&quot;on_detached_with_reason:&quot;, reason)def on_detached_with_varargs(*args): print(&quot;on_detached_with_varargs:&quot;, args)device &#x3D; frida.get_usb_device()#device &#x3D; frida.get_device_manager.add_remote_device(&quot;192.168.0.2:8888&quot;) # 基于远程ip的集群pid &#x3D; device.spawn([&quot;com.android.settings&quot;])device.resume(pid)time.sleep(1)session &#x3D; device.attach(pid)print(&quot;attached&quot;)session.on(&#39;detached&#39;, on_detached)session.on(&#39;detached&#39;, on_detached_with_reason)session.on(&#39;detached&#39;, on_detached_with_varargs)sys.stdin.read() ./fs1428arm64 pyenv local 3.8.5 &amp;&amp; python detached.py 自启动进程detach进程后捕获进程退出打印log frida-python修改examples中crash_reporting.py 123456789101112131415def on_process_crashed(crash): print(&quot;on_process_crashed&quot;) print(&quot;\\tcrash:&quot;, crash)def on_detached(reason, crash): print(&quot;on_detached()&quot;) print(&quot;\\treason:&quot;, reason) print(&quot;\\tcrash:&quot;, crash)device &#x3D; frida.get_usb_device()device.on(&#39;process-crashed&#39;, on_process_crashed)session &#x3D; device.attach(&quot;com.android.settings&quot;)session.on(&#39;detached&#39;, on_detached)print(&quot;[*] Ready&quot;)sys.stdin.read() ./fs1428arm64 pyenv local 3.8.5 &amp;&amp; python crash_reporting.py 进程运行中detach进程后捕获进程退出打印log 当需要hook一个app的子进程时，调用child_gating.py在子进程创建时创建脚本打印内容。 argv = [“/bin/sh”, “-c”, “cat /etc/hosts”] # 在bullhead中/system/bin/sh frida-python修改examples中bytecode.py 1234567891011121314151617181920device &#x3D; frida.get_usb_device()#device &#x3D; frida.get_device_manager.add_remote_device(&quot;192.168.0.2:8888&quot;) # 基于远程ip的集群pid &#x3D; device.spawn([&quot;com.hd.zhibo&quot;])device.resume(pid)time.sleep(1)system_session &#x3D; device.attach(0)bytecode &#x3D; system_session.compile_script(name&#x3D;&quot;bytecode-example&quot;, source&#x3D;&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; listThreads: function () &#123; return Process.enumerateThreadsSync(); &#125;&#125;;&quot;&quot;&quot;)session &#x3D; device.attach(pid)script &#x3D; session.create_script_from_bytes(bytecode)script.load()api &#x3D; script.exportsprint(&quot;api.list_threads() &#x3D;&gt;&quot;, api.list_threads()) python bytecode.py 查看rpc 编译生成的thread列表 DEXDump:js暴露3个export api(memorydump,switchmode,scandex)，在py层调用三个api进行交互 Zentracer:使用替换js中字符串(MATCHREGEX,BLACKREGEX)将黑白名单传输给js文件，将js文件直接加载通过send将信息传输给py端 java层主动调用pyenv 升级12git clone https:&#x2F;&#x2F;github.com&#x2F;pyenv&#x2F;pyenv-update.git $(pyenv root)&#x2F;plugins&#x2F;pyenv-updatepyenv update pyenv 3.8.0 IDA从入门到理解 某加固系统运行信息获取frida 脚本 unidbg学习笔记 浅谈渗透江湖之细水柔情 领悟Frida的精髓_0512newCodeAndProject.zip","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"rpc","slug":"rpc","permalink":"http://onejane.gitee.io/tags/rpc/"},{"name":"frida","slug":"frida","permalink":"http://onejane.gitee.io/tags/frida/"}]},{"title":"基于内存漫游定位分析","slug":"基于内存漫游定位分析","date":"2021-02-12T13:54:40.000Z","updated":"2021-03-01T17:12:15.236Z","comments":true,"path":"2021/02/12/基于内存漫游定位分析/","link":"","permalink":"http://onejane.gitee.io/2021/02/12/%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E6%BC%AB%E6%B8%B8%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90/","excerpt":"","text":"三板斧： 先hook、看参数和返回值，利用命令行定位 再利用命令行/写代码构造参数、主动调用 最后规模化利用PYTHON配RPC导出结果 基于内存漫游定位案例一adb install -r -t movetv.apk 移动tv onejane/123456,-r强制升级，-t允许装debug版本 jadx打开发现com.tecent.StubShell加壳，找不到MainActivity 123456pyenv local 3.8.0adb shell.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64objection -g com.cz.babySister exploreandroid hooking search classes com.wrapper.proxyapplicationandroid hooking watch class com.wrapper.proxyapplication.WrapperProxyApplication 该类在启动则被调用，attach将无法hook Frida附加app的两种模式： SPAWN：创建进程时就hook，有壳的话就不行 ATTACH：应用运行过程中hook，有壳也是ok 分析123android hooking list activitiesandroid intent launch_activity com.cz.babySister.activity.LoginActivity 指定启动Activityps -ef|grep baby 进程一直自动启动 objection -d -g com.cz.babySister explore --startup-command &quot;android hooking watch class com.wrapper.proxyapplication.WrapperProxyApplication&quot; 开启debug -d 由于该app会自动后台启动 需要在前台启动时立即使用objection漫游 批量hookandroid hooking search classes com.wrapper.proxyapplication 枚举包中所有类 12345com.wrapper.proxyapplication.CustomerClassLoadercom.wrapper.proxyapplication.MultiDexcom.wrapper.proxyapplication.MultiDex$V19com.wrapper.proxyapplication.Utilcom.wrapper.proxyapplication.WrapperProxyApplication 如何使用objection去批量hook和trace？ 把~/.objection/objection.log删掉； 到objection界面中运行android hooking list classes，列出所有的类； 对新生成的~/.objection/objection.log文件进行过滤，比如只关心http相关的。cat objection.log|grep -i http 将输出结果保存到一个excel列中，前面补全android hooking watch class xxxxx，另存为文本文件 加载这个文件：objection -g com.android.settings explore -c “2.txt” ，这样一下子就hook上了几千个相关类的所有方法及其所有重载。 如果trace感兴趣的方法也是同理，android hooking search methods * ，会打印出所有的方法。 vim hooklist.txt 12345android hooking watch class com.wrapper.proxyapplication.CustomerClassLoaderandroid hooking watch class com.wrapper.proxyapplication.MultiDexandroid hooking watch class com.wrapper.proxyapplication.MultiDex$V19android hooking watch class com.wrapper.proxyapplication.Utilandroid hooking watch class com.wrapper.proxyapplication.WrapperProxyApplication objection -g com.cz.babySister explore -c “hooklist.txt” 批量hook android hooking list class_methods com.wrapper.proxyapplication.Util 枚举类中所有方法 Zentraceradb shell &amp;&amp; top 根据负载查看包名 java.net.HttpUrlConnection 1234objection -g com.cz.babySister explore --startup-command &quot;android hooking watch class java.net.HttpURLConnection&quot;jobs listjobs kill idandroid hooking watch class_method java.net.HttpURLConnection.getFollowRedirects --dump-args 登录发现堆栈来自于com.cz.babySister.c.a.a 通过jadx搜索com.cz.babySister.c.a.a所在类，通过android hooking watch class com.cz.babySister.c.a进行trace类 通过android hooking watch class_method com.cz.babySister.c.a.a --dump-args --dump-backtrace --dump-return 进行trace方法 什么叫trace？hook多了就成了trace 系统框架是不可能被混淆的，基于枚举的内存漫游定位思路的含义是：怀疑你使用了什么框架API、怀疑你经过了哪个包哪处地方、就去那里埋伏起来，等待经过。 针对混淆后的okhttp3,通过Frida实现的拦截okhttp脚本 ./data/local/tmp/fs1428arm64 cd ZenTracer &amp;&amp; proxychains pip install PyQt5 &amp;&amp; python ZenTracer.py 报错：Could not load the Qt platform plugin “xcb” in “” even though it was found 1export QT_DEBUG_PLUGINS&#x3D;1 python ZenTracer.py ldd libqxcb.so 查看具体哪个so文件为not found apt install libxcb-util1 libxcb-xinerama0 Action-Match RegEx Action-Start 启动trace,登录trace保存为json thunar . 打开当前目录 查看babySister查看json 极端情况：Match RegEx 填写com.cz.babySister主包名，trace所有的方法 1234objection -g com.cz.babySister exploreandroid hooking search classes com.cz.babySistercat ~&#x2F;.objection&#x2F;objection.log|grep com.cz.babySister 拿到所有的类 在前面添加命令 android hooking watch class保存到classes.txt中objection -g com.cz.babySister explore -c classes.txt 实现批量hook 案例二adb install xes.apk 123456objection -g com.xes.jazhanghui.activity explore -P ~&#x2F;.objection&#x2F;plugins 启动objection加载所有插件android hooking search classes okhttp3android hooking list class_methods okhttp3.OkHttpClientandroid heap search instances okhttp3.OkHttpClient 找到对象实例plugin wallbreaker objectsearch okhttp3.OkHttpClient 拿到ok3对象的地址，如混淆在jadx中找到ok3的类注释中的renameplugin wallbreaker objectdump --fullname 0x37d2 分析adb push okhttplogging.dex /data/local/tmp adb push myok2curl.dex /data/local/tmp cd ~/Desktop/frida-agent-example &amp;&amp; npm run watch frida -UF -l hookOkhttp3.js 通过adb logcat | grep “okhttpGet”查看log 原生：离解释器更近：安卓原生就是dex被libart.so来解释、linux原生就是CPU直接解释的机器码 123ps -e |grep -i chromeobjection -g com.android.chrome explorememory list modules 发现dex被libart.so加载解析执行 脱壳frida_fart 12cd frida_fart &amp;&amp; adb push lib&#x2F;* &#x2F;data&#x2F;local&#x2F;tmpcd &#x2F;data&#x2F;local&#x2F;tmp&#x2F; &amp;&amp; cp fart* &#x2F;data&#x2F;app &amp;&amp; cd &#x2F;data&#x2F;app &amp;&amp; chmod 777 fart* 加权限 修改源码dex保存路径：var savepath = “/sdcard/com.cz.babySister.activity/“; 1234mkdir &#x2F;sdcard&#x2F;com.cz.babySister.activity&#x2F; frida -U -f com.cz.babySister -l frida_fart_reflection.js --no-pausefrida -UF -l frida_fart_reflection.jsfrida -U -f com.cz.babySister -l frida_fart_hook.js --no-pause 基于安卓8，生成dex frida-dexdump 核心原理：进程级别的内存漫游 cd ~/.objection/plugins/dexdump &amp;&amp; python main.py 自动脱壳(前台运行的学而思app) cd com.xes.jazhanghui.activity &amp;&amp; grep -ril “okhttp3.OkHttpClient” * du -h * 查看文件最大的dex使用jadx打开 objection -g com.xes.jazhanghui.activity explore -P ~/.objection/plugins android hooking list activities 在jadx中查找到dex包含com.xes.jazhanghui.activity.mvp.live.activity.LiveMainActivity 同理：脱壳移动TV，grep -ril “MainActivity” *,grep -ril “LoginActivity” *,找到唯一入口dex 案例三adb install 免费电影院v2.1.0_210.apk 分析静态：通过jadx搜索OkHttpClient,或者apktool d 免费电影院v2.1.0_210.apk &amp;&amp; grep -ril &quot;OkHttpClient&quot; * 动态： 12345cat smali&#x2F;فمضﺝ&#x2F;ﻙﺫتك$ﺯﺵتﻝ.smali拿到.class public Lفمضﺝ&#x2F;ﻙﺫتك;类名objection -g com.singleman.freevideo explore -P &#x2F;root&#x2F;.objection&#x2F;plugins 点击登录调用ok3plugin wallbreaker objectsearch فمضﺝ.ﻙﺫتكplugin wallbreaker objectdump --fullname 0x2452 查看该类是否ok3Client，获取其中List&lt;Interceptor&gt;地址，用wallbreaker dump下来class为Collections$UnmodifiableRandomAccessList 即为OkHttpClient类 在hookOkhttp3.js中实现hook 12345678910111213141516171819202122Java.choose(&quot;فمضﺝ.ﻙﺫتك&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;1. found instance:&quot;,instance) &#x2F;&#x2F;console.log(&quot;2. instance.interceptors():&quot;,instance.interceptors().$className) console.log(&quot;3. instance._interceptors:&quot;,instance.ﻭﻍﺫﻉ.value.$className) &#x2F;&#x2F;console.log(&quot;4. interceptors:&quot;,gson2.$new().toJson(instance.interceptors())) console.log(&quot;5. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(instance.ﻭﻍﺫﻉ.value.toArray())) &#x2F;* var newInter &#x3D; Java.use(&quot;java.util.ArrayList&quot;).$new(); newInter.addAll(instance.interceptors()); console.log(&quot;6. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(newInter.toArray())); console.log(&quot;7. interceptors:&quot;,newInter.$className); newInter.add(MyInterceptorObj); newInter.add(curlInter); instance._interceptors.value &#x3D; newInter; *&#x2F; &#125;,onComplete:function()&#123; console.log(&quot;Search complete!&quot;) &#125;&#125;) 基于Frida的Hook案例一adb install -r -t junior.apk 开启远程调用frida -UF -l demo.js 像素显示dip2px123456789101112131415161718objection -g com.example.junior explore -P ~&#x2F;.objection&#x2F;plugins 加载所有插件android hooking list activities 查看用于展示的界面android intent launch_activity com.example.junior.CalculatorActivity 启动计算器界面cat objection.log | grep com.example.junior.util.Utilsandroid hooking list class_methods com.example.junior.util.Utils 打印来中所有可hook的函数android hooking watch class_method com.example.junior.util.Utils.dip2px --dump-args --dump-return --dump-backtrace hook方法并打印像素显示出入参与调用栈function main() &#123; Java.perform(function () &#123;&#x2F;&#x2F;只要是java的代码都要跑在Java.perform里面 console.log(&quot;Entering Hook!&quot;) Java.use(&quot;com.example.junior.util.Utils&quot;).dip2px.implementation &#x3D; function (context, float) &#123; &#x2F;&#x2F;return null; var result &#x3D; this.dip2px(context, 100) console.log(&quot;context,float,result &#x3D;&#x3D;&gt; &quot;, context, float, result); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return 26; &#125; &#125;)&#125; 分辨率显示setTexthook用不上Java.choose的，hook函数时不分动静态 123456789101112131415161718192021222324252627282930android intent launch_activity com.example.junior.ScreenActivity cat objection.log|grep -i android.widget.TextViewandroid hooking list class_methods android.widget.TextView 打印来中所有可hook的函数android hooking watch class_method android.widget.TextView.setText --dump-args --dump-backtrace --dump-return hook公共方法setTextandroid heap search instances com.example.junior.ScreenActivity 搜索activity类内存地址android heap execute 0x6f72 showScreenInfo 主动调用该类的指定方法，frida端hook自动执行function Screen() &#123; Java.perform(function () &#123; &#x2F;&#x2F; 重载 Java.use(&quot;android.widget.TextView&quot;).setText.overload(&#39;java.lang.CharSequence&#39;).implementation &#x3D; function (text) &#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;); var newString &#x3D; javaString.$new(&quot;onejane&quot;) var result &#x3D; null; var realText &#x3D; String(text); console.log(&quot;real text is &#x3D;&#x3D;&gt; &quot;,realText); if (realText.indexOf(&quot;junior&quot;) &gt;&#x3D; 0) &#123; var result &#x3D; this.setText(newString); console.log(&quot;text,result &#x3D;&#x3D;&gt; &quot;, newString, result); &#125; else &#123; var result &#x3D; this.setText(text); console.log(&quot;text,result &#x3D;&#x3D;&gt; &quot;, text, result); &#125; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return result; &#125; &#125;)&#125; 计算器123456789101112131415161718192021222324cat objection.log|grep -i com.example.junior.util.Arithandroid hooking list class_methods com.example.junior.util.Arith 查看Arith类有哪些hook的方法android hooking watch class_method com.example.junior.util.Arith.sub --dump-args --dump-backtrace --dump-return hook静态方法subfunction Equals()&#123; Java.perform(function()&#123; Java.use(&quot;java.lang.String&quot;).equals.implementation &#x3D; function(obj)&#123; var result &#x3D; this.equals(obj); console.log(&quot;obj,result &#x3D;&#x3D;&gt; &quot;,obj,result); return result; &#125; &#125;)&#125;function sub()&#123; Java.perform(function()&#123; Java.use(&quot;com.example.junior.util.Arith&quot;).sub.overload(&#39;java.lang.String&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function(str1,str2)&#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) var result &#x3D; this.sub(str1,javaString.$new(&quot;2&quot;)); &#x2F;&#x2F; 本质上属于主动调用构造函数 console.log(&quot;str1,str2,result&#x3D;&#x3D;&gt;&quot;,str1,str2,result) return javaString.$new(&quot;10&quot;); &#125; &#125;)&#125; 静态变量运行junior的计算器 12plugin wallbreaker classsearch Arith 内存漫游搜索Arith类plugin wallbreaker classdump --fullname com.example.junior.util.Arith 将Arith类dump发现有静态变量 通过frida获取静态变量DEF_DIV_SCALE并修改值为20，内存中的静态变量DEF_DIV_SCALE即变为20 123456789function staticField()&#123; Java.perform(function()&#123; var divscale &#x3D; Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value; console.log(&quot;divscale1 is &#x3D;&gt;&quot;,divscale); Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value&#x3D;20; divscale &#x3D; Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value; console.log(&quot;divscale2 is &#x3D;&gt;&quot;,divscale); &#125;)&#125; 静态主动调用frida -UF -l demo.js主动调用Arith.add方法 123456function operate()&#123; Java.perform(function()&#123; var Arith &#x3D; Java.use(&quot;com.example.junior.util.Arith&quot;); console.log(&quot;addResult is &#x3D;&gt;&quot;,Arith.add(&quot;1&quot;,&quot;1&quot;)); &#125;)&#125; plugin wallbreaker classsearch Build 搜索含有Build的类 plugin wallbreaker classdump --fullname android.os.Build 将Build类dump下来 123456789function fingerPrint()&#123; Java.perform(function()&#123; var Build &#x3D; Java.use(&quot;android.os.Build&quot;); console.log(Build.DEVICE.value,Build.ID.value,Build.MODEL.value,Build.SERIAL.value); Build.SERIAL.value &#x3D; &#39;F123456&#39;; console.log(Build.SERIAL.value,Build.getSerial()); &#x2F;&#x2F; 若app无权限getSerial()，换设置重新主动调用 console.log(&#39;sdk is &#39;,Build.getString(&quot;ro.build.version.sdk&quot;)); &#125;)&#125; 动态变量plugin wallbreaker objectsearch com.example.junior.CalculatorActivity 获取该类地址 plugin wallbreaker objectdump 0x1eea 计算1+2=3后查看该类的动态变量 寻找CalculatorActivity实例，通过frida动态hook，通过修改showText值时内存中变量变为123 12345678910111213function dynamicField()&#123; Java.perform(function()&#123; Java.choose(&quot;com.example.junior.CalculatorActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance &#x3D;&gt;&quot;,instance); console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.showText.value) instance.showText.value &#x3D; &quot;123&quot; &#125;,onComplete:function()&#123; console.log(&#39;Search complete&#39;) &#125; &#125;) &#125;)&#125; 动态主动调用动态调用有参函数，计算机显示666，打印666 12345678910111213function dynamic()&#123; Java.perform(function()&#123; Java.choose(&quot;com.example.junior.CalculatorActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance &#x3D;&gt;&quot;,instance); console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.clear(&quot;666&quot;)) console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.showText.value) &#125;,onComplete:function()&#123; console.log(&#39;Search complete&#39;) &#125; &#125;) &#125;)&#125; RPC调用12345678910111213141516171819import frida# device&#x3D;frida.get_device_manager().add_remote_device(&#39;192.168.0.100:5555&#39;) 远程连接.&#x2F;fs128arm64 -l 0.0.0.0:5555,可定义多个device实现批量自动化群控device &#x3D; frida.get_usb_device()### attachpid&#x3D;device.get_frontmost_application().pid # 若双进程保护，指定pid进行hooksession &#x3D; device.attach(pid)### spawn #pid &#x3D; device.spawn([&quot;com.example.junior&quot;])#device.resume(pid)#time.sleep(1)#session &#x3D; device.attach(pid)with open(&quot;demo.js&quot;) as f: script &#x3D; session.create_script(f.read())script.load()input() 键盘操作input keyevent 4 表示后退 1234567function subcommand()&#123; Java.perform(function()&#123; &#x2F;&#x2F; adb input api var process &#x3D; Java.use(&#39;java.lang.Runtime&#39;).getRuntime().exec(&#39;input keyevent 4&#39;); console.log(&#39;subcommand success process is &#39;, process) &#125;)&#125; 循环调用 demo.js中导出指定方法 123rpc.exports &#x3D; &#123; subcommand: subcommand&#125; demo.py中开启循环 1234567command &#x3D; &quot;&quot;while 1 &#x3D;&#x3D; 1: command &#x3D; input(&quot;Enter command:\\n1: Exit\\n2: Call secret function\\nchoice:&quot;) if command &#x3D;&#x3D; &quot;1&quot;: break elif command &#x3D;&#x3D; &quot;2&quot;: # 在这里调用，可以设置多个条件判断 script.exports.subcommand() 输入2对当前进程持续后退 案例二利用nps实现启动了frida-server和nps-client的device的内网穿透，真正意义上实现批量自动化群控 案例三利用ssr通过nps内网穿透实现4G作为出口ip代理供request/scrapy调用 objection和frida不可同时hook一个函数, hook Non-ASCII 对于有些混淆后不可见或乱码的函数名，可以先编码打印出来, 再用编码后的字符串去 hook. 123456789101112131415161718192021Java.perform( function x() &#123; var targetClass &#x3D; &quot;com.example.hooktest.MainActivity&quot;; var hookCls &#x3D; Java.use(targetClass); var methods &#x3D; hookCls.class.getDeclaredMethods(); for (var i in methods) &#123; console.log(methods[i].toString()); console.log(encodeURIComponent(methods[i].toString().replace(&#x2F;^.*?\\.([^\\s\\.\\(\\)]+)\\(.*?$&#x2F;, &quot;$1&quot;))); &#125; hookCls[decodeURIComponent(&quot;%D6%8F&quot;)] .implementation &#x3D; function (x) &#123; console.log(&quot;original call: fun(&quot; + x + &quot;)&quot;); var result &#x3D; this[decodeURIComponent(&quot;%D6%8F&quot;)](900); return result; &#125; &#125;) hook Intent MainActivity中Intent intent2 = new Intent(this, Class.forName(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;));我们通过frida打印Intent 参考资料： Android App 保护那些事儿 （一） Android App 保护那些事儿 (二) frida dexclassloader 从三道题目入手入门frida Frida 入门小练习 举杯邀Frida，对影成三题 Null混淆 Android 字符串及字典混淆开源实现 资源压缩 Android微信逆向–实现发朋友圈动态 微信朋友圈分析 实用FRIDA进阶：脱壳、自动化、高频问题","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.gitee.io/tags/frida/"},{"name":"objection","slug":"objection","permalink":"http://onejane.gitee.io/tags/objection/"}]},{"title":"加壳与脱壳之基本原理","slug":"加壳与脱壳之基本原理","date":"2021-02-04T02:39:05.000Z","updated":"2021-03-25T00:06:03.316Z","comments":true,"path":"2021/02/04/加壳与脱壳之基本原理/","link":"","permalink":"http://onejane.gitee.io/2021/02/04/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","excerpt":"","text":"逆向基本流程 使用自动化检测工具检测apk是否加壳，或者借助一些反编译工具依靠经验推断是否加壳 GDA3.85 或者 常见so文件 《娜迦》企业版本加固 libedog.so 《娜迦》免费版本加固 libddog.so 《梆梆》企业版本加固 libDexHelper.so 《梆梆》免费版本加固 libsecexe.so 《爱加密》企业版本加固 ijiami.ajm 《爱加密》免费版本加固 libexec.so 《通付盾》加固 libegis.so 《360》加固 libprotectClass.so，libjiagu.so 《百度》加固 libbaiduprotect.so 《阿里》加固 libmobisec.so 《腾讯》加固 libtup.so 《盛大》加固 libapssec.so 《瑞星》加固 librsprotect.so 《网秦》加固 nqdata 《国信灵通》加固 libnqshield.so 《apkprotect》加固 apkprotect 《几维安全》加固 libkwscmm.so，libkwscr.so，libkwslinker.so 《UU安全》加固 libuusafe.jar.so，libuusafe.so，libuusafeempty.so 几维安全 lib/armeabi-v7a/libkwscmm.so，lib/armeabi-v7a/libkwscr.so，lib/armeabi-v7a/libkwslinker.so UU安全 assets/libuusafe.jar.so，assets/libuusafe.so，lib/armeabi/libuusafeempty.so 如果apk加壳，则需要首先对apk进行脱壳 使用jeb，jadx，apktool等反编译工具对apk进行反编译 如果反编译工具打不开，使用010Editor把文件魔术字修复前8个字节 64 65 78 0A 30 33 35 00 dex.035. 再使用jadx反编译 grep -ril “MainAcitvity” ./*.txt 找到对应dex前缀名 先依据静态分析中得到的关键字字符串，关键api调用等方法快速定位需要分析的关键函数和流程 如果依据简单的字符串，关键api无法快速定位，则apk可能使用了字符串加密，反射调用等手段，此时可以结合hook，动态调试等 定位到关键函数后，再根据是java实现还是jni实现进一步分析 类加载基本原理JVM类加载器 Bootstrap ClassLoader（引导类加载器） C/C++代码实现的加载器,用于加载指定的JDK的核心类库,比如java. lang、java.utI等这些系统类。Java虚拟机的启动就是通过 Bootstrap,该 Classloader在java里无法获取,负责加载/lib下的类。 Extensions Classloader(拓展类加载器) Java中的实现类为 Extclassloader,提供了除了系统类之外的额外功能,可以在java里获取,负责加载/lib/ext下的类 Application ClassLoader(应用程序类加载器) Java中的实现类为 AppClassLoader,是与我们接触对多的类加载器,开发人员写的代码默认就是由它来加载, ClassLoader.getSystemClassLoader返回的就是它。 可以自定义类加载器，只需要通过java.lang.ClassLoader来实现自己的类加载器。 加载顺序：Bootstrap ClassLoader-&gt;Extensions Classloader-&gt;Application ClassLoader 双亲委派 如果一个类加载器收到了类加载请求,它并不会自己先去加载,而是把这个请求委托给父类的加载器去执行,如果父类加载器还存在其父类加载器,则进一步向上委托,依次递归,请求最终将到达顶层的启动类加载器,如果父类加载器可以完成类加载任务,就成功返回,倘若父类加载器无法完成此加载任务,子加载器才会尝试自己去加载。 1)避免重复加载,如果已经加载过一次class,可以直接读取已经加载的class 2)更加安全,无法自定义类来替代系统的类,可以防止核心API库被随意篡改 Android类加载器加载时机： 隐式加载：创建类的实例，访问类的静态变量，或者为静态变量赋值，调用类的静态方法，使用反射方式来强制创建某个类或接口对应的java.lang.Class对象，初始化某个类的子类 显式加载：使用LoadClass()加载，使用forName()加载 加载过程： 装载：查找和导入Class文件 链接：其中解析步骤是可以选择的（a）检查：检查载入的class文件数据的正确性（b）准备：给类的静态变量分配存储空间（c）解析：将符号引用转成直接引用 初始化：即调用&lt;clinit&gt;函数，对静态变量，静态代码块执行初始化工作 ClassLoader继承关系 ClassLoader:抽象类；BootClassLoader:预加载常用类，单例模式。与Java中的BootClassLoader不同，它并不是由C/C++代码实现，而是由Java实现的；BaseDexClassLoader是PathClassLoader、DexClassLoader、InMemoryDexClassLoader的父类，类加载的主要逻辑都是在BaseDexClassLoader完成的。SecureClassLoader继承了抽象类ClassLoader，拓展了ClassLoader类加入了权限方面的功能，加强了安全性，其子类URLClassLoader是用URL路径从jar文件中加载类和资源。其中重点关注的是PathClassLoader和DexClassLoader。PathClassLoader是Android默认使用的类加载器，一个apk中的Activity等类便是在其中加载。DexClassLoader可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更灵活，是实现插件化、热修复以及dex加壳的重点。 DexClassLoader方法参数 dexPath:目标所在的apk或者jar文件的路径，装载器将从路径中寻找指定的目标类。dexOutputDir:由于dex 文件在APK或者 jar文件中，所以在装载前面前先要从里面解压出dex文件，这个路径就是dex文件存放的路径，在 android系统中，一个应用程序对应一个linux用户id ,应用程序只对自己的数据目录有写的权限，所以我们存放在这个路径中。libPath :目标类中使用的C/C++库。parent：该装载器的父装载器，一般为当前执行类的装载器。 Android8.0新引入InMemoryDexClassLoader，用于直接从内存中加载dex。 http://androidxref.com/8.0.0_r4/ 搜索位于libcore中的Definition的DexClassLoader 、PathClassLoader、 InmemoryDexClassLoader查看源码。 ClassLoaderTest新建项目ClassLoaderTest验证类加载器的加载顺序 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); testClassLoader(); &#125; /** * I/kanxue: thisClassLoader:dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/base.apk\"],nativeLibraryDirectories=[/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/lib/x86, /system/lib, /system/product/lib]]] * I/kanxue: this:dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/base.apk\"],nativeLibraryDirectories=[/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/lib/x86, /system/lib, /system/product/lib]]]===java.lang.BootClassLoader@232d58a * I/kanxue: root:java.lang.BootClassLoader@232d58a * */ public void testClassLoader()&#123; ClassLoader thisClassLoader=MainActivity.class.getClassLoader(); Log.i(\"kanxue\",\"thisClassLoader:\"+thisClassLoader); ClassLoader tmpClassLoader = null; ClassLoader parentClassLoader=thisClassLoader.getParent(); while (parentClassLoader!=null)&#123; Log.i(\"kanxue\",\"this:\"+thisClassLoader+\"===\"+parentClassLoader); tmpClassLoader=parentClassLoader.getParent(); thisClassLoader=parentClassLoader; parentClassLoader=tmpClassLoader; &#125; Log.i(\"kanxue\",\"root:\"+thisClassLoader); &#125;&#125; LoadDex通过DexClassLoader实现一个动态加载的dex插件 在ClassLoaderTest项目中打印log 12345public class TestDexClass &#123; public void testFunc()&#123; Log.i(\"kanxue\",\"I'm from com.onejane.classloadertest.TestDexClass.testFunc\"); &#125;&#125; 通过build生成ClassLoaderTest\\app\\build\\outputs\\apk\\debug\\app-debug.apk, apktool d -s app-debug.apk保留并抽取出classes.dex adb push classes.dex /sdcard 创建LoadDex空白Android项目，加载调用位于dex下com.onejane.classloadertest.TestDexClass 在AndroidManifest.xml中添加读写权限 12&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt; 新增application配置android:requestLegacyExternalStorage=”true” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context = this.getApplicationContext(); /** * Android 10 sdk30 无法获取sdcard权限，通过获取当前app的cache目录 * if(!getExternalCacheDir().exists()) getExternalCacheDir().mkdirs(); * testDexClassLoader(context,getExternalCacheDir().getAbsolutePath()+\"/classes.dex\"); * 再将TestDexClass所在的adb push classes.dex /sdcard/Android/data/com.onejane.loaddex/cache/ */ // 若sdk30需要sdcard，通过requestMyPermissions动态获取读写权限 testDexClassLoader(context,\"/sdcard/classes.dex\"); &#125; private void requestMyPermissions() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; //没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(\"kanxue\", \"requestMyPermissions: 有写SD权限\"); &#125; if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; //没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(\"kanxue\", \"requestMyPermissions: 有读SD权限\"); &#125; &#125; // 可应对app热更新bug修复 public void testDexClassLoader(Context context, String dexfilepath)&#123; // 存放dex文件 File optFile = context.getDir(\"opt_dex\",0); // 存放依赖的so文件 File libFile = context.getDir(\"lib_path\",0); ClassLoader parentClassLoader=MainActivity.class.getClassLoader(); Log.i(\"kanxue\",parentClassLoader.toString()); //PathClassLoader ClassLoader tmpClassLoader=context.getClassLoader(); Log.i(\"kanxue\",tmpClassLoader.toString()); // PathClassLoader requestMyPermissions(); DexClassLoader dexClassLoader = new DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity.class.getClassLoader()); Class&lt;?&gt; clazz=null; try&#123; clazz=dexClassLoader.loadClass(\"com.onejane.classloadertest.TestDexClass\"); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; if(clazz!=null)&#123; try &#123; Method testFuncMethod=clazz.getDeclaredMethod(\"testFunc\"); Object obj = clazz.newInstance(); testFuncMethod.invoke(obj); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 利用外部dex下发热修复bug，用户无感知更新。 APP启动流程由发起进程通过binder进程间通信告知system_server进程启动指定的app，system_server通过socket方式与安卓孵化器进程进行通信，告诉孵化器进程启动指定app，由进程fork产生新的进程真正进入ActivityThread.main()，在此之前一直处于安卓的framework中。 ActivityThread是单例模式，在app整个进程的生命周期中，只存在一个实例，http://androidxref.com/8.0.0_r4/ 搜索位于frameworks中的ActivityThread 调用静态函数currentActivityThread获取当前进程中的ActivityThread实例，进而可以获取ActivityThread的重要变量,如mPackages 1234public static ActivityThread currentActivityThread() &#123; return sCurrentActivityThread;&#125;final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages &#x3D; new ArrayMap&lt;&gt;(); 其中LoadedApk中有加载app组件的PathClassLoader,即mClassLoader 通过反射获取app进程中单例ActivityThread，其中的sCurrentActivityThread静态变量用于全局保存创建的ActivityThread实例，同时还提供了currentActivityThread()静态函数用于获取当前虚拟机创建的ActivityThread实例。 反射拿到ActivityThread中的 mPackages的ArrayMap，通过当前app包名获取LoadedApk。 最后通过LoadedApk获取mClassLoader-&gt;PathClassLoader。 PathClassLoader: app运行过程中用于加载四大组件类的ClassLoader **ActivityThread.main()**函数是java中的入口main函数,这里会启动主消息循环，并创建ActivityThread实例，之后调用thread.attach(false)完成一系列初始化准备工作，并完成全局静态变量sCurrentActivityThread的初始化。之后主线程进入消息循环，等待接收来自系统的消息。当收到系统发送来的bindapplication的进程间调用时，调用函数handleBindApplication来处理该请求。 12345678910111213141516171819202122private void handleBindApplication(AppBindData data) &#123; &#x2F;&#x2F;step 1: 创建LoadedApk对象 data.info &#x3D; getPackageInfoNoCheck(data.appInfo, data.compatInfo); ... &#x2F;&#x2F;step 2: 创建ContextImpl对象; final ContextImpl appContext &#x3D; ContextImpl.createAppContext(this, data.info); &#x2F;&#x2F;step 3: 创建Instrumentation mInstrumentation &#x3D; new Instrumentation(); &#x2F;&#x2F;step 4: 创建Application对象;在makeApplication函数中调用了newApplication，真正执行app代码。在该函数中又调用了app.attach(context)，在attach函数中调用了Application.attachBaseContext函数 Application app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication &#x3D; app; &#x2F;&#x2F;step 5: 安装providers List&lt;ProviderInfo&gt; providers &#x3D; data.providers; installContentProviders(app, providers); &#x2F;&#x2F;step 6: 执行Application.Create回调 mInstrumentation.callApplicationOnCreate(app); ...&#125; 在 handleBindApplication函数中第一次进入了app的代码世界，该函数功能是启动一个application，并把系统收集的apk组件等相关信息绑定到application里，在创建完application对象后，接着调用了application的attachBaseContext方法，之后调用了application的onCreate函数。由此可以发现，app的Application类中的attachBaseContext和onCreate这两个函数是最先获取执行权进行代码执行的。这也是为什么各家的加固工具的主要逻辑都是通过替换app入口Application，并自实现这两个函数，在这两个函数中进行加密dex释放以及执行权交付的原因。 APP运行流程 无壳：PathClassLoader加载自身app自身dex，包括app声明的Application及所有其他类信息 加壳：PathClassLoader只加载壳自身代码，不包含app自身真正代码。首先进入壳的application的attachBaseContext，解密原始dex，再完成执行权的交付。 DexClassLoader加载的类是没有组件生命周期的，也就是说即使DexClassLoader通过对APK的动态加载完成了对组件类的加载，当系统启动该组件时，依然会出现加载类失败的异常，因为插件没有组件相关的类，如一些activity或service，若只用DexClassLoader进行动态加载，系统PathClassLoader无法找到相关组件信息，app将直接崩溃。所以如何解决动态加载dex中的生命周期成为加壳厂商首先需要解决的问题！！！ 在项目ClassLoaderTest中新建TestActivity ，并将build的apk中的classes.dex取出，adb push classes.dex /sdcard 12345678public class TestActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#x2F;&#x2F; adb push classes.dex &#x2F;sdcard Log.i(&quot;kanxue&quot;,&quot;I&#39;m from TestActivity.onCreate&quot;); &#125;&#125; 在项目LoadDex中，配置AndroidManifest.xml&lt;activity android:name=&quot;com.onejane.classloadertest.TestActivity&quot;&gt;&lt;/activity&gt;,在MainActivity中新增方法，并启动运行 123456789101112131415161718192021222324252627protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context &#x3D; this.getApplicationContext(); startTestActivity(context,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;);&#125;public void startTestActivity(Context context,String dexfilepath)&#123; &#x2F;&#x2F; 存放dex文件 File optFile &#x3D; context.getDir(&quot;opt_dex&quot;,0); &#x2F;&#x2F; 存放依赖的so文件 File libFile &#x3D; context.getDir(&quot;lib_path&quot;,0); ClassLoader parentClassLoader&#x3D;MainActivity.class.getClassLoader(); Log.i(&quot;kanxue&quot;,parentClassLoader.toString()); &#x2F;&#x2F;PathClassLoader ClassLoader tmpClassLoader&#x3D;context.getClassLoader(); Log.i(&quot;kanxue&quot;,tmpClassLoader.toString()); &#x2F;&#x2F; PathClassLoader requestMyPermissions(); DexClassLoader dexClassLoader &#x3D; new DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity.class.getClassLoader()); Class&lt;?&gt; clazz&#x3D;null; try&#123; clazz&#x3D;dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; if(clazz!&#x3D;null)&#123; context.startActivity(new Intent(context,clazz)); &#125;&#125; 启动app将报错ClassNotFoundException: Didn’t find class “com.onejane.classloadertest.TestActivity” 说明组件相关的Activity由mClassLoader-&gt;PathClassLoader加载了，虽然获取到非空TestActivity，却无法找到启动的目标Activity。 方案一反射替换，替换系统组件类加载器mClassLoader为我们的DexClassLoader，同时设置DexClassLoader的parent为系统组件类加载器PathClassLoader； 修改LoadDex项目的MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context &#x3D; this.getApplicationContext(); startTestActivityReplaceMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;); &#125; private void requestMyPermissions() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有写SD权限&quot;); &#125; if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有读SD权限&quot;); &#125; &#125; public void replaceClassloader(ClassLoader classloader)&#123; try &#123; Class&lt;?&gt; ActivityThreadClazz&#x3D;classloader.loadClass(&quot;android.app.ActivityThread&quot;); &#x2F;&#x2F; 获取静态函数currentActivityThread Method currentActivityThreadMethod&#x3D; ActivityThreadClazz.getDeclaredMethod(&quot;currentActivityThread&quot;); currentActivityThreadMethod.setAccessible(true); Object activityThreadObj&#x3D;currentActivityThreadMethod.invoke(null); &#x2F;&#x2F; 获取ActivityThread对象 &#x2F;&#x2F;final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages &#x3D; new ArrayMap&lt;&gt;(); Field mPackagesField&#x3D;ActivityThreadClazz.getDeclaredField(&quot;mPackages&quot;); &#x2F;&#x2F; 获取ActivityThread对象的ArrayMap的Field mPackagesField.setAccessible(true); ArrayMap mPackagesObj&#x3D; (ArrayMap) mPackagesField.get(activityThreadObj); &#x2F;&#x2F; 通过Field获取mPackages实例 WeakReference wr&#x3D; (WeakReference) mPackagesObj.get(this.getPackageName()); &#x2F;&#x2F; 从ArrayMap中获取LoadApk Object loadedApkObj&#x3D;wr.get(); Class LoadedApkClazz&#x3D;classloader.loadClass(&quot;android.app.LoadedApk&quot;); &#x2F;&#x2F;private ClassLoader mClassLoader; Field mClassLoaderField&#x3D;LoadedApkClazz.getDeclaredField(&quot;mClassLoader&quot;); mClassLoaderField.setAccessible(true); mClassLoaderField.set(loadedApkObj,classloader); &#x2F;&#x2F; 将LoadApk(mClassLoader)替换为我们的DexClassLoader &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; &#125; public void startTestActivityReplaceMethod(Context context,String dexfilepath)&#123; &#x2F;&#x2F; 存放dex文件 File optFile &#x3D; context.getDir(&quot;opt_dex&quot;,0); &#x2F;&#x2F; 存放依赖的so文件 File libFile &#x3D; context.getDir(&quot;lib_path&quot;,0); requestMyPermissions(); DexClassLoader dexClassLoader &#x3D; new DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity.class.getClassLoader()); replaceClassloader(dexClassLoader); Class&lt;?&gt; clazz&#x3D;null; try&#123; clazz&#x3D;dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; if(clazz!&#x3D;null)&#123; context.startActivity(new Intent(context,clazz)); &#125; &#125;&#125; 方案二打破原有的双亲关系，在系统组件类加载器和BootClassLoader的中间插入我们自己的DexClassLoader即可 修改ClassLoaderTest中的TestActivity类继承自Activity 123456789public class TestActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState);&#x2F;&#x2F; setContentView(R.layout.activity_main); &#x2F;&#x2F; adb push classes.dex &#x2F;sdcard Log.i(&quot;kanxue&quot;,&quot;I&#39;m from TestActivity.onCreate&quot;); &#125;&#125; 修改LoadDex中的MainActivity继承Activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context &#x3D; this.getApplicationContext(); &#x2F;&#x2F; 若sdk30需要sdcard，通过requestMyPermissions动态获取读写权限&#x2F;&#x2F; testDexClassLoader(context,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;);&#x2F;&#x2F; startTestActivityReplaceMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;); startTestActivityInsertMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;); &#125; private void requestMyPermissions() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有写SD权限&quot;); &#125; if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有读SD权限&quot;); &#125; &#125; public void startTestActivityInsertMethod(Context context,String dexfilepath)&#123; File optfile&#x3D;context.getDir(&quot;opt_dex&quot;,0); File libfile&#x3D;context.getDir(&quot;lib_path&quot;,0); requestMyPermissions(); ClassLoader pathClassloader&#x3D;MainActivity.class.getClassLoader(); ClassLoader bootClassloader&#x3D;MainActivity.class.getClassLoader().getParent(); &#x2F;&#x2F; 设置自定义dexClassLoader父ClassLoader为bootClassloader DexClassLoader dexClassLoader&#x3D;new DexClassLoader(dexfilepath,optfile.getAbsolutePath(),libfile.getAbsolutePath(),bootClassloader); try &#123; Field parentField&#x3D;ClassLoader.class.getDeclaredField(&quot;parent&quot;); parentField.setAccessible(true); &#x2F;&#x2F; 设置pathClassLoader父ClassLoader为自定义dexClassLoader parentField.set(pathClassloader,dexClassLoader); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; ClassLoader tmpClassloader&#x3D;pathClassloader; ClassLoader parentClassloader&#x3D;pathClassloader.getParent(); while(parentClassloader!&#x3D;null)&#123; Log.i(&quot;kanxue&quot;,&quot;this:&quot;+tmpClassloader+&quot;--parent:&quot;+parentClassloader); tmpClassloader&#x3D;parentClassloader; parentClassloader&#x3D;parentClassloader.getParent(); &#125; Log.i(&quot;kanxue&quot;,&quot;root:&quot;+tmpClassloader); Class&lt;?&gt; clazz&#x3D;null; try &#123; clazz &#x3D; dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; context.startActivity(new Intent(context,clazz)); &#125;&#125; 以上都是基于文件形式的外部加载，Android 8.0引入InMemoryDexClassLoader实现从内存中直接加载字节流，更加安全，不能通过文件监控形式达到脱壳目的，需要从进程内存中扣出这块完整的dex实现脱壳。 部分app在AndroidManifest.xml中没有声明application，加固厂商只需要添加一个application，在自己的application中完成classloader的替换。 部分app在AndroidManifest.xml中已经声明application，加固需要一个代理的application，壳的application不仅需要完成解密dex以及classloader相关修复，还需要完成解密dex后原app的application的attachBaseContext和onCreate函数调用。","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"classloader","slug":"classloader","permalink":"http://onejane.gitee.io/tags/classloader/"}]},{"title":"猿人学之访问逻辑罗生门","slug":"猿人学之访问逻辑罗生门","date":"2021-02-03T05:25:34.000Z","updated":"2021-02-10T01:52:51.716Z","comments":true,"path":"2021/02/03/猿人学之访问逻辑罗生门/","link":"","permalink":"http://onejane.gitee.io/2021/02/03/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8B%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91%E7%BD%97%E7%94%9F%E9%97%A8/","excerpt":"","text":"题目http://match.yuanrenxue.com/match/3 抓取下列5页商标的数据，并将出现频率最高的申请号填入答案中 抓包 分析http://match.yuanrenxue.com/match/3 请求原始网页后请求一堆js/css,并没有携带cookie和特殊的返回 http://match.yuanrenxue.com/logo 每次请求页数的时候都会先请求logo并set了一个cookie，说明cookie是从服务器返回的 http://match.yuanrenxue.com/api/match/3 请求返回页面json数据，携带logo返回的cookie 没有带cookie不能访问http://match.yuanrenxue.com/api/match/3 使用请求头加引号.py 将fiddler的请求头包上 请求头加引号.py 123456789101112131415161718import reold_headers ='''Connection: keep-aliveAccept: application/json, text/javascript, */*; q=0.01X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36Referer: http://match.yuanrenxue.com/match/3Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: sessionid=7ly07o9fclh1llfsposkhh9jqvujxkth'''pattern = '^(.*?):[\\s]*(.*?)$'headers = \"\"for line in old_headers.splitlines(): headers += (re.sub(pattern,'\\'\\\\1\\': \\'\\\\2\\',',line)) + '\\n'print(headers[:-2]) 加上cookie使用python请求抓取返回一堆js代码，因为cookie是由服务器生成的，所以这一段返回的js没有意义 12345678910111213headers = &#123; 'Connection': 'keep-alive', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'X-Requested-With': 'XMLHttpRequest', 'User-Agent': 'yuanrenxue.project', 'Referer': 'http://match.yuanrenxue.com/match/3', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Cookie': 'sessionid=7ly07o9fclh1llfsposkhh9jqvujxkth'&#125;url = 'http://match.yuanrenxue.com/api/match/3'res = requests.get(url=url, headers=headers)print(res.text) 爬虫规律：请求完logo后再请求api则正常返回，同理请求第二页 1234567891011121314151617session = requests.session()headers = &#123; 'Connection': 'keep-alive', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'X-Requested-With': 'XMLHttpRequest', 'User-Agent': 'yuanrenxue.project', 'Referer': 'http://match.yuanrenxue.com/match/3', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9'&#125;session.headers = headersurl_logo = 'http://match.yuanrenxue.com/logo'res = session.post(url_logo)print(res, res.cookies)url = 'http://match.yuanrenxue.com/api/match/3?page=1'res = session.get(url=url)print(res.text)","categories":[{"name":"js逆向","slug":"js逆向","permalink":"http://onejane.gitee.io/categories/js%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.gitee.io/tags/js/"}]},{"title":"猿人学之js混淆动态cookie","slug":"猿人学之js混淆动态cookie","date":"2021-02-03T02:19:32.000Z","updated":"2021-02-10T01:51:48.856Z","comments":true,"path":"2021/02/03/猿人学之js混淆动态cookie/","link":"","permalink":"http://onejane.gitee.io/2021/02/03/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8Bjs%E6%B7%B7%E6%B7%86%E5%8A%A8%E6%80%81cookie/","excerpt":"","text":"题目http://match.yuanrenxue.com/match/2 提取全部5页发布日热度的值，计算所有值的加和,并提交答案 抓包chrome无痕模式通过抓包获取所有请求 第一个match/2不携带cookie并返回一串js代码 第二个match/2最早携带cookie并返回html页面，且并没有在请求头set-cookie,说明cookie是本地生成，而非服务器生成带到前端的，那么第一个match/2返回的js很可能就会生成cookie 1Cookie m&#x3D;dd5572e825610043a17c791d1eadc601|1607590427000 第三个api/match/2携带cookie返回页面请求json数据 分析使用ob混淆专解测试版V0.1反混淆第一个match/2返回的js代码去掉script标签 将解析完的js放到notepad++中进行js format，查找eval，setInterval，document等函数或者cookie等关键字符串。 123456789101112131415161718function V(Y, Z, a0) &#123; // 空参数 M(); return Z ? a0 ? H(Z, Y) : y(Z, Y) : a0 ? T(Y) : U(Y); &#125; // Y=X()时间戳，Z无用 function W(Y, Z) &#123; // 获取cookie document[\"cookie\"] = \"m\" + M() + \"=\" + V(Y) + \"|\" + Y + \"; path=/\"; // 带上cookie重新刷新页面返回真实网页并发送ajax请求获取json数据 location[\"reload\"](); &#125; // 时间戳 function X(Y, Z) &#123; return Date[\"parse\"](new Date()); &#125; // 最先执行js W(X()); 查看W和V中的M(),都没有传参数 1234567891011121314151617181920212223242526272829303132333435function M(Y, Z) &#123; // 只定义函数并无更新值 var a2 = B(this, function () &#123; var a5 = &#123; \"JLTiy\": \"return /\\\" + this + \\\"/\", \"uynWF\": \"^([^ ]+( +[^ ]+)+)+[^ ]&#125;\" &#125;; var a7 = function () &#123; var a8 = a7[\"constructor\"](a5[\"JLTiy\"])()[\"compile\"](a5[\"uynWF\"]); return !a8[\"test\"](a2); &#125;; return a7(); &#125;); // 未传参 未改变全局变量 无返回 a2(); // 未传参 未改变全局变量 无返回 K(); qz = [10, 99, 111, 110, 115, 111, 108, 101, 32, 61, 32, 110, 101, 119, 32, 79, 98, 106, 101, 99, 116, 40, 41, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 115, 41, 32, 123, 10, 32, 32, 32, 32, 119, 104, 105, 108, 101, 32, 40, 49, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 40, 105, 61, 48, 59, 105, 60, 49, 49, 48, 48, 48, 48, 48, 59, 105, 43, 43, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 104, 105, 115, 116, 111, 114, 121, 46, 112, 117, 115, 104, 83, 116, 97, 116, 101, 40, 48, 44, 48, 44, 105, 41, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 10, 125, 10, 99, 111, 110, 115, 111, 108, 101, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 91, 111, 98, 106, 101, 99, 116, 32, 79, 98, 106, 101, 99, 116, 93, 39, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 402, 32, 116, 111, 83, 116, 114, 105, 110, 103, 40, 41, 32, 123, 32, 91, 110, 97, 116, 105, 118, 101, 32, 99, 111, 100, 101, 93, 32, 125, 39, 10]; eval(L(qz)); try &#123; if (global) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); &#125; else &#123; while (1) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); debugger; &#125; &#125; &#125; catch (a5) &#123; return navigator[\"vendorSub\"]; &#125; &#125; 通过WT-JS查看L(qz)，并没有对cookie进行影响 1234567function L(Y, Z) &#123; let a0 = \"\"; for (let a1 = 0; a1 &lt; Y[\"length\"]; a1++) &#123; a0 += String[\"fromCharCode\"](Y[a1]); &#125; return a0;&#125; navigator[“vendorSub”]放到console返回””,得出M()结论不返回或者返回””,也没修改变量参数 去除无用首行(function $c(k) {和尾行})(); 去除最先执行W(X()); 去除W内的location“reload”; 将document[“cookie”] =改为return 去除无用setInterval(M(), 500); 去除W函数无用Z,M()为null也可以去除 删除无返回js，因为会报test未定义 12345678910111213141516// 无返回 var a2 = B(this, function () &#123; var a5 = &#123; \"JLTiy\": \"return /\\\" + this + \\\"/\", \"uynWF\": \"^([^ ]+( +[^ ]+)+)+[^ ]&#125;\" &#125;; var a7 = function () &#123; var a8 = a7[\"constructor\"](a5[\"JLTiy\"])()[\"compile\"](a5[\"uynWF\"]); return !a8[\"test\"](a2); &#125;; return a7();&#125;);// 未传参 未改变全局变量 无返回a2(); 新增var navigator = {}; 使用鬼鬼调试工具，执行W(X()); 核心js如下2.js 1234567891011121314151617181920212223242526272829303132333435363738var navigator = &#123;&#125;;function M(Y, Z) &#123; // 未传参 未改变全局变量 无返回 K(); qz = [10, 99, 111, 110, 115, 111, 108, 101, 32, 61, 32, 110, 101, 119, 32, 79, 98, 106, 101, 99, 116, 40, 41, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 115, 41, 32, 123, 10, 32, 32, 32, 32, 119, 104, 105, 108, 101, 32, 40, 49, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 40, 105, 61, 48, 59, 105, 60, 49, 49, 48, 48, 48, 48, 48, 59, 105, 43, 43, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 104, 105, 115, 116, 111, 114, 121, 46, 112, 117, 115, 104, 83, 116, 97, 116, 101, 40, 48, 44, 48, 44, 105, 41, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 10, 125, 10, 99, 111, 110, 115, 111, 108, 101, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 91, 111, 98, 106, 101, 99, 116, 32, 79, 98, 106, 101, 99, 116, 93, 39, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 402, 32, 116, 111, 83, 116, 114, 105, 110, 103, 40, 41, 32, 123, 32, 91, 110, 97, 116, 105, 118, 101, 32, 99, 111, 100, 101, 93, 32, 125, 39, 10]; eval(L(qz)); try &#123; if (global) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); &#125; else &#123; while (1) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); debugger; &#125; &#125; &#125; catch (a5) &#123; return navigator[\"vendorSub\"]; &#125;&#125;function V(Y, Z, a0) &#123; // 空参数 M(); return Z ? a0 ? H(Z, Y) : y(Z, Y) : a0 ? T(Y) : U(Y);&#125;// Y=X()时间戳，Z无用function W(Y) &#123; return \"m\" + \"=\" + V(Y) + \"|\" + Y;&#125;function X(Y, Z) &#123; return Date[\"parse\"](new Date());&#125;function request() &#123; return W(X());&#125; 爬虫123456789101112131415161718192021222324252627282930313233import requestsimport execjsimport timedef get_page(page_num,param): url = \"http://match.yuanrenxue.com/api/match/2?page=&#123;&#125;\".format(page_num) headers = &#123; 'Host': 'match.yuanrenxue.com', 'Referer':'http://match.yuanrenxue.com/match/2', 'User-Agent':'yuanrenxue.project', 'X-Requested-With':'XMLHttpRequest', 'Cookie': param &#125; resonse = requests.get(url=url,headers=headers) return resonse.json()def calculate_m_value(): with open(r'2.js',encoding='utf-8',mode='r') as f: JsData = f.read() psd = execjs.compile(JsData).call('request') psd = psd.replace('丨','%E4%B8%A8') print('this request parameters is :',psd) return psdif __name__ == '__main__': sum_num = 0 for page_num in range(1,6): res = get_page(page_num,calculate_m_value()) data = [__['value'] for __ in res['data']] print(data) sum_num+=sum(data) time.sleep(1) print('the answer is :',sum_num)","categories":[{"name":"js逆向","slug":"js逆向","permalink":"http://onejane.gitee.io/categories/js%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.gitee.io/tags/js/"}]},{"title":"猿人学之js混淆源码乱码","slug":"猿人学之js混淆源码乱码","date":"2021-02-01T03:18:17.000Z","updated":"2021-02-10T01:52:29.653Z","comments":true,"path":"2021/02/01/猿人学之js混淆源码乱码/","link":"","permalink":"http://onejane.gitee.io/2021/02/01/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8Bjs%E6%B7%B7%E6%B7%86%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/","excerpt":"","text":"题目http://match.yuanrenxue.com/match/1抓取所有（5页）机票的价格，并计算所有机票价格的平均值，填入答案。 抓包打开控制台开始抓包，出现无限debugger循环,可以通过Never pause here或Fiddler过掉。 方案一：在第2行选中右键Never pause here 方案二：通过查看该debug的js名为uzt.js，本地创建uzt.js并修改其中的jsFiddler的AutoResponder下，选中Enable automatic reaponses 和Unmatched requests passthrough 通过翻页获取请求参数得其中1607516709为秒时间戳，即time.time() 12page: 2m: 3ddf4f4e72bd84562a0e0104d425a791丨1607657864 分析查看网页源码，搜索丨中文竖线，抠出js 通过notepad++插件进行js格式化后得到核心代码 修改得m的计算方式 12345request = function () &#123; var timestamp = Date.parse(new Date()) + 100000000; var m = oo0O0(timestamp.toString()) + window.f; m = m + '丨' + timestamp / 1000 &#125;; 扣出oo0O0方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function oo0O0(mw) &#123; window.b = ''; for (var i = 0, len = window.a.length; i &lt; len; i++) &#123; console.log(window.a[i]); window.b += String[document.e + document.g](window.a[i][document.f + document.h]() - i - window.c) &#125; var U = ['W5r5W6VdIHZcT8kU', 'WQ8CWRaxWQirAW==']; var J = function (o, E) &#123; o = o - 0x0; var N = U[o]; if (J['bSSGte'] === undefined) &#123; var Y = function (w) &#123; var m = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=', T = String(w)['replace'](/=+$/, ''); var A = ''; for (var C = 0x0, b, W, l = 0x0; W = T['charAt'](l++); ~W &amp;&amp; (b = C % 0x4 ? b * 0x40 + W : W, C++ % 0x4) ? A += String['fromCharCode'](0xff &amp; b &gt;&gt; (-0x2 * C &amp; 0x6)) : 0x0) &#123; W = m['indexOf'](W) &#125; return A &#125;; var t = function (w, m) &#123; var T = [], A = 0x0, C, b = '', W = ''; w = Y(w); for (var R = 0x0, v = w['length']; R &lt; v; R++) &#123; W += '%' + ('00' + w['charCodeAt'](R)['toString'](0x10))['slice'](-0x2) &#125; w = decodeURIComponent(W); var l; for (l = 0x0; l &lt; 0x100; l++) &#123; T[l] = l &#125; for (l = 0x0; l &lt; 0x100; l++) &#123; A = (A + T[l] + m['charCodeAt'](l % m['length'])) % 0x100, C = T[l], T[l] = T[A], T[A] = C &#125; l = 0x0, A = 0x0; for (var L = 0x0; L &lt; w['length']; L++) &#123; l = (l + 0x1) % 0x100, A = (A + T[l]) % 0x100, C = T[l], T[l] = T[A], T[A] = C, b += String['fromCharCode'](w['charCodeAt'](L) ^ T[(T[l] + T[A]) % 0x100]) &#125; return b &#125;; J['luAabU'] = t, J['qlVPZg'] = &#123;&#125;, J['bSSGte'] = !![] &#125; var H = J['qlVPZg'][o]; return H === undefined ? (J['TUDBIJ'] === undefined &amp;&amp; (J['TUDBIJ'] = !![]), N = J['luAabU'](N, E), J['qlVPZg'][o] = N) : N = H, N &#125;; eval(atob(window['b'])[J('0x0', ']dQW')](J('0x1', 'GTu!'), '\\x27' + mw + '\\x27')); return ''&#125; 由于返回是个空字符串，则oo0O0(timestamp.toString())=‘’，m=window.f，查看源码得知window.f只有一个，那么f作为全局变量可能在oo0O0中被修改 1eval(atob(window[&#39;b&#39;])[J(&#39;0x0&#39;, &#39;]dQW&#39;)](J(&#39;0x1&#39;, &#39;GTu!&#39;), &#39;\\x27&#39; + mw + &#39;\\x27&#39;)); atob是解码使用 base-64 编码的字符串的函数，通过console中获取atob(window[‘b’]) 通过WT-JS加载计算f=hex_md5(mwqqppz) 报错未定义，mwqqppz可能是被其他地方替换或者加密来的 查看J(‘0x0’, ‘]dQW’)方法返回值，在console中执行J方法 1234var U = ['W5r5W6VdIHZcT8kU', 'WQ8CWRaxWQirAW=='];var J = function (o, E) &#123; ...&#125; 拼接得到eval(atob(window[&#39;b&#39;])[replace](&#39;mwqqppz&#39;, &#39;\\x27&#39; + mw + &#39;\\x27&#39;)); 搜索\\bmw\\b,发现mw为function oo0O0的参数，即时间戳 所以f=hex_md5(timestamp),在WT-JS中添加js，atob(window[‘b’])获取window.f 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210var hexcase = 0;var b64pad = \"\";var chrsz = 16;function hex_md5(a) &#123; return binl2hex(core_md5(str2binl(a), a.length * chrsz))&#125;function b64_md5(a) &#123; return binl2b64(core_md5(str2binl(a), a.length * chrsz))&#125;function str_md5(a) &#123; return binl2str(core_md5(str2binl(a), a.length * chrsz))&#125;function hex_hmac_md5(a, b) &#123; return binl2hex(core_hmac_md5(a, b))&#125;function b64_hmac_md5(a, b) &#123; return binl2b64(core_hmac_md5(a, b))&#125;function str_hmac_md5(a, b) &#123; return binl2str(core_hmac_md5(a, b))&#125;function md5_vm_test() &#123; return hex_md5(\"abc\") == \"900150983cd24fb0d6963f7d28e17f72\"&#125;function core_md5(p, k) &#123; p[k &gt;&gt; 5] |= 128 &lt;&lt; ((k) % 32); p[(((k + 64) &gt;&gt;&gt; 9) &lt;&lt; 4) + 14] = k; var o = 1732584193; var n = -271733879; var m = -1732584194; var l = 271733878; for (var g = 0; g &lt; p.length; g += 16) &#123; var j = o; var h = n; var f = m; var e = l; o = md5_ff(o, n, m, l, p[g + 0], 7, -680976936); l = md5_ff(l, o, n, m, p[g + 1], 12, -389564586); m = md5_ff(m, l, o, n, p[g + 2], 17, 606105819); n = md5_ff(n, m, l, o, p[g + 3], 22, -1044525330); o = md5_ff(o, n, m, l, p[g + 4], 7, -176418897); l = md5_ff(l, o, n, m, p[g + 5], 12, 1200080426); m = md5_ff(m, l, o, n, p[g + 6], 17, -1473231341); n = md5_ff(n, m, l, o, p[g + 7], 22, -45705983); o = md5_ff(o, n, m, l, p[g + 8], 7, 1770035416); l = md5_ff(l, o, n, m, p[g + 9], 12, -1958414417); m = md5_ff(m, l, o, n, p[g + 10], 17, -42063); n = md5_ff(n, m, l, o, p[g + 11], 22, -1990404162); o = md5_ff(o, n, m, l, p[g + 12], 7, 1804660682); l = md5_ff(l, o, n, m, p[g + 13], 12, -40341101); m = md5_ff(m, l, o, n, p[g + 14], 17, -1502002290); n = md5_ff(n, m, l, o, p[g + 15], 22, 1236535329); o = md5_gg(o, n, m, l, p[g + 1], 5, -165796510); l = md5_gg(l, o, n, m, p[g + 6], 9, -1069501632); m = md5_gg(m, l, o, n, p[g + 11], 14, 643717713); n = md5_gg(n, m, l, o, p[g + 0], 20, -373897302); o = md5_gg(o, n, m, l, p[g + 5], 5, -701558691); l = md5_gg(l, o, n, m, p[g + 10], 9, 38016083); m = md5_gg(m, l, o, n, p[g + 15], 14, -660478335); n = md5_gg(n, m, l, o, p[g + 4], 20, -405537848); o = md5_gg(o, n, m, l, p[g + 9], 5, 568446438); l = md5_gg(l, o, n, m, p[g + 14], 9, -1019803690); m = md5_gg(m, l, o, n, p[g + 3], 14, -187363961); n = md5_gg(n, m, l, o, p[g + 8], 20, 1163531501); o = md5_gg(o, n, m, l, p[g + 13], 5, -1444681467); l = md5_gg(l, o, n, m, p[g + 2], 9, -51403784); m = md5_gg(m, l, o, n, p[g + 7], 14, 1735328473); n = md5_gg(n, m, l, o, p[g + 12], 20, -1921207734); o = md5_hh(o, n, m, l, p[g + 5], 4, -378558); l = md5_hh(l, o, n, m, p[g + 8], 11, -2022574463); m = md5_hh(m, l, o, n, p[g + 11], 16, 1839030562); n = md5_hh(n, m, l, o, p[g + 14], 23, -35309556); o = md5_hh(o, n, m, l, p[g + 1], 4, -1530992060); l = md5_hh(l, o, n, m, p[g + 4], 11, 1272893353); m = md5_hh(m, l, o, n, p[g + 7], 16, -155497632); n = md5_hh(n, m, l, o, p[g + 10], 23, -1094730640); o = md5_hh(o, n, m, l, p[g + 13], 4, 681279174); l = md5_hh(l, o, n, m, p[g + 0], 11, -358537222); m = md5_hh(m, l, o, n, p[g + 3], 16, -722881979); n = md5_hh(n, m, l, o, p[g + 6], 23, 76029189); o = md5_hh(o, n, m, l, p[g + 9], 4, -640364487); l = md5_hh(l, o, n, m, p[g + 12], 11, -421815835); m = md5_hh(m, l, o, n, p[g + 15], 16, 530742520); n = md5_hh(n, m, l, o, p[g + 2], 23, -995338651); o = md5_ii(o, n, m, l, p[g + 0], 6, -198630844); l = md5_ii(l, o, n, m, p[g + 7], 10, 11261161415); m = md5_ii(m, l, o, n, p[g + 14], 15, -1416354905); n = md5_ii(n, m, l, o, p[g + 5], 21, -57434055); o = md5_ii(o, n, m, l, p[g + 12], 6, 1700485571); l = md5_ii(l, o, n, m, p[g + 3], 10, -1894446606); m = md5_ii(m, l, o, n, p[g + 10], 15, -1051523); n = md5_ii(n, m, l, o, p[g + 1], 21, -2054922799); o = md5_ii(o, n, m, l, p[g + 8], 6, 1873313359); l = md5_ii(l, o, n, m, p[g + 15], 10, -30611744); m = md5_ii(m, l, o, n, p[g + 6], 15, -1560198380); n = md5_ii(n, m, l, o, p[g + 13], 21, 1309151649); o = md5_ii(o, n, m, l, p[g + 4], 6, -145523070); l = md5_ii(l, o, n, m, p[g + 11], 10, -1120210379); m = md5_ii(m, l, o, n, p[g + 2], 15, 718787259); n = md5_ii(n, m, l, o, p[g + 9], 21, -343485551); o = safe_add(o, j); n = safe_add(n, h); m = safe_add(m, f); l = safe_add(l, e) &#125; return Array(o, n, m, l)&#125;function md5_cmn(h, e, d, c, g, f) &#123; return safe_add(bit_rol(safe_add(safe_add(e, h), safe_add(c, f)), g), d)&#125;function md5_ff(g, f, k, j, e, i, h) &#123; return md5_cmn((f &amp; k) | ((~f) &amp; j), g, f, e, i, h)&#125;function md5_gg(g, f, k, j, e, i, h) &#123; return md5_cmn((f &amp; j) | (k &amp; (~j)), g, f, e, i, h)&#125;function md5_hh(g, f, k, j, e, i, h) &#123; return md5_cmn(f ^ k ^ j, g, f, e, i, h)&#125;function md5_ii(g, f, k, j, e, i, h) &#123; return md5_cmn(k ^ (f | (~j)), g, f, e, i, h)&#125;function core_hmac_md5(c, f) &#123; var e = str2binl(c); if (e.length &gt; 16) &#123; e = core_md5(e, c.length * chrsz) &#125; var a = Array(16), d = Array(16); for (var b = 0; b &lt; 16; b++) &#123; a[b] = e[b] ^ 909522486; d[b] = e[b] ^ 1549556828 &#125; var g = core_md5(a.concat(str2binl(f)), 512 + f.length * chrsz); return core_md5(d.concat(g), 512 + 128)&#125;function safe_add(a, d) &#123; var c = (a &amp; 65535) + (d &amp; 65535); var b = (a &gt;&gt; 16) + (d &gt;&gt; 16) + (c &gt;&gt; 16); return (b &lt;&lt; 16) | (c &amp; 65535)&#125;function bit_rol(a, b) &#123; return (a &lt;&lt; b) | (a &gt;&gt;&gt; (32 - b))&#125;function str2binl(d) &#123; var c = Array(); var a = (1 &lt;&lt; chrsz) - 1; for (var b = 0; b &lt; d.length * chrsz; b += chrsz) &#123; c[b &gt;&gt; 5] |= (d.charCodeAt(b / chrsz) &amp; a) &lt;&lt; (b % 32) &#125; return c&#125;function binl2str(c) &#123; var d = \"\"; var a = (1 &lt;&lt; chrsz) - 1; for (var b = 0; b &lt; c.length * 32; b += chrsz) &#123; d += String.fromCharCode((c[b &gt;&gt; 5] &gt;&gt;&gt; (b % 32)) &amp; a) &#125; return d&#125;function binl2hex(c) &#123; var b = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\"; var d = \"\"; for (var a = 0; a &lt; c.length * 4; a++) &#123; d += b.charAt((c[a &gt;&gt; 2] &gt;&gt; ((a % 4) * 8 + 4)) &amp; 15) + b.charAt((c[a &gt;&gt; 2] &gt;&gt; ((a % 4) * 8)) &amp; 15) &#125; return d&#125;function binl2b64(d) &#123; var c = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; var f = \"\"; for (var b = 0; b &lt; d.length * 4; b += 3) &#123; var e = (((d[b &gt;&gt; 2] &gt;&gt; 8 * (b % 4)) &amp; 255) &lt;&lt; 16) | (((d[b + 1 &gt;&gt; 2] &gt;&gt; 8 * ((b + 1) % 4)) &amp; 255) &lt;&lt; 8) | ((d[b + 2 &gt;&gt; 2] &gt;&gt; 8 * ((b + 2) % 4)) &amp; 255); for (var a = 0; a &lt; 4; a++) &#123; if (b * 8 + a * 6 &gt; d.length * 32) &#123; f += b64pad &#125; else &#123; f += c.charAt((e &gt;&gt; 6 * (3 - a)) &amp; 63) &#125; &#125; &#125; return f&#125;;function get_m_value() &#123; //var timestamp = Date.parse(new Date()) + 100000000; timestamp = '1607657864000' f = hex_md5(timestamp) return f;&#125; 以上获取m=window.f的值 爬虫pip3 install PyExecJS 123456789101112131415161718192021222324252627282930313233343536import timeimport execjsimport requestsdef get_page(page_num,parameters): url = 'http://match.yuanrenxue.com/api/match/1?page=&#123;&#125;&amp;m=&#123;&#125;'.format(page_num,parameters) headers = &#123; 'Host': 'match.yuanrenxue.com', 'Referer': 'http://match.yuanrenxue.com/match/1', 'User-Agent': 'yuanrenxue.project', 'X-Requested-With': 'XMLHttpRequest', 'Cookie': 'qpfccr=true; Hm_lvt_c99546cf032aaa5a679230de9a95c7db=1607556997,1607557857; Hm_lpvt_c99546cf032aaa5a679230de9a95c7db=1607557857; no-alert=true' &#125; response = requests.get(url=url,headers=headers) return response.json()def calculate_m_value(): with open(r'1.js',encoding='utf-8',mode='r') as f: JsData = f.read() psd = execjs.compile(JsData).call('request') psd = psd.replace('丨','%E4%B8%A8') print('this request parameters is :',psd) return psdif __name__ == '__main__': sum_num = 0 index_num = 0 for page_num in range(1,6): res = get_page(page_num,calculate_m_value()) data = [__['value'] for __ in res['data']] print(data) sum_num+=sum(data) index_num += len(data) time.sleep(1) average = sum_num/index_num print('the answer is :',average) 1.js中获取param的函数如下 12345678function request() &#123; var timestamp = Date.parse(new Date()) + 100000000; // timestamp = '1607657864000' f = hex_md5(timestamp+'') var m = f; m = m + '丨' + timestamp / 1000 return m;&#125;","categories":[{"name":"js逆向","slug":"js逆向","permalink":"http://onejane.gitee.io/categories/js%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.gitee.io/tags/js/"}]},{"title":"博客搭建","slug":"博客搭建","date":"2021-01-31T14:51:49.000Z","updated":"2021-02-23T14:55:51.689Z","comments":true,"path":"2021/01/31/博客搭建/","link":"","permalink":"http://onejane.gitee.io/2021/01/31/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Hexo12345678https://nodejs.org/download/release/v10.15.3/ 安装nodenpm install -g cnpm --registry=https://registry.npm.taobao.orgnpm config set registry https://registry.npm.taobao.org npm install -g hexo@4.1.1npm install -g hexo-cli@1.3.0 hexo init blog cd blog npm install Melody12345678910111213set http_proxy=http://127.0.0.1:1080set https_proxy=https://127.0.0.1:1080git clone -b master https://github.com/Molunerfinn/hexo-theme-melody themes/melodynpm install hexo-renderer-pug hexo-renderer-styluscp themes\\melody\\_config.yml themes\\melody\\melody.yml 通过git pull 即可更新melodynpm i --save hexo-wordcountnpm i hexo-deployer-git --save 使用git bashnpm install --save-dev gulp@3.9.1npm install -g gulp@3.9.1npm install gulp-imagemin@3.1.1 --savenpm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify --save blog\\package.json 12345\"scripts\": &#123; \"build\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d &amp; git add * &amp; git commit -m 'deploy' &amp; git push origin master\", \"test\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo s\", \"dev\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\" &#125; 通过npm run build 即可自动打包上传发布http://onejane.gitee.io/ 新建Onajane公开项目，hexo d后启用服务的Gitee Pages 新建picture公开项目，上传图片后启动服务的Gitee Pages图床服务，http://onejane.gitee.io/picture/avatar.jpg blog_config.yml 1234567891011121314151617title: Jsubtitle: '朝花夕拾'description: '逆向,爬虫'keywords:author: Jlanguage: zh-Hanstimezone: 'Hongkong'url: https://gitee.com/OneJanetheme: melodypost_asset_folder: true # npm install https://github.com/CodeFalling/hexo-asset-image --save 上传图片到博客deploy: type: git repo: gitee: https://gitee.com/OneJane/OneJane.git github: git@github.com:OneJane/OneJane.github.io.git branch: master message: gitee 评论https://leancloud.cn/dashboard/applist.html#/apps 新建应用获取AppID,AppKey 123456789101112valine: enable: true # if you want use valine,please set this value is true appId: cWLsquGr5PNi33OWXNhzerep-gzGzoHsz # leancloud application app id appKey: S35phfCSbm8dAG9LpOc5rjm3 # leancloud application app key notify: false # valine mail notify (true/false) https://github.com/xCss/Valine/wiki verify: false # valine verify code (true/false) recordip: false # whether record commentor's ip (true/false) pageSize: 10 # comment list page size avatar: mm # gravatar style https://valine.js.org/#/avatar lang: zh-cn # i18n: zh-cn/en placeholder: 一起来吹牛逼好吗！ # valine comment input placeholder(like: Please leave your footprints ) guest_info: nick,mail,link #valine comment header inf 分享123sharejs: enable: true disabled_sites: google,facebook 搜索本地 npm install hexo-generator-search –save 12345local_search: enable: true # or false labels: input_placeholder: Search for Posts hits_empty: \"We didn't find any results for the search: $&#123;query&#125;\" # if there are no result 头像1avatar: http://onejane.gitee.io/picture/avatar.jpg # 网站 Logo 导航菜单1234567891011121314151617181920hexo new page tags修改source/tags/index.md---title: 标签date: 2018-01-05 00:00:00type: \"tags\"---hexo new page categories修改source/categories/index.md---title: 分类date: 2018-01-05 00:00:00type: \"categories\"---修改_config.ymlmenu: 主页: / 归档: /archives 标签: /tags 分类: /categories 自动节选123auto_excerpt: enable: true length: 150 顶部图12top_img_height: 80 top_img: http://onejane.gitee.io/picture/hacker.jpg 在_config.yml和文章中使用 打赏1234567QR_code: - itemlist: img: http://onejane.gitee.io/picture/alipay.png text: 支付宝打赏 - itemlist: img: http://onejane.gitee.io/picture/wx.png text: 微信打赏 广告/音乐播放器123adv: enable: true info: &lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"center\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=572547816&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt; Follow1234follow: enable: true url: 'https://gitee.com/OneJane/' text: 'Follow Me' 友链123links_title: 友链 # 配置友链的标题文字links: OneJane: http://onejane.gitee.io/ 目录1234toc: enable: true # or false number: true # or false. 版本v1.5.6新增 在文章头部加入toc_number: true 页脚1footer_custom_text: Hi, welcome to my &lt;a href=http://onejane.gitee.io/\"&gt;blog&lt;/a&gt;! 配置成hitokoto则是随机的谚语 点击特效1fireworks: true 彩带123456canvas_ribbon: enable: true size: 150 alpha: 0.6 zIndex: -1 click_to_change: false 阅读密码npm install –save hexo-blog-encrypt 123文中标题填入password: blogJmessage: 请联系微信：codewj，获取本文密码","categories":[{"name":"生活","slug":"生活","permalink":"http://onejane.gitee.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://onejane.gitee.io/tags/hexo/"}]},{"title":"逆向环境搭建","slug":"逆向环境搭建","date":"2021-01-31T03:20:05.000Z","updated":"2021-03-01T14:56:12.020Z","comments":true,"path":"2021/01/31/逆向环境搭建/","link":"","permalink":"http://onejane.gitee.io/2021/01/31/%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Pixel玩逆向必备一台真机，那么非谷歌亲儿子莫属，模拟器缺失native/so层，属于精简版系统，故还是真机香呀。 官网下载pixel 8.1.0镜像，建议刷OPM1.171019.011版本安卓8.1.0 12adb reboot bootloader 或 按住音量向下键和开机键 进入fastboot状态cd sailfish-opm4.171019.021.p1-factory-0bcf4315/sailfish-opm4.171019.021.p1 &amp;&amp; flash-all.sh 开始刷机 设置-关于手机-版本号8下点击-进入开发者模式，进入系统-高级-打开开发者选项-USB调试 123456adb push Magisk-v20.4.zip /sdcard adb push magisk-riru-v21.3.zip /sdcard/Download 使用magisk模块安装并重启adb push magisk-EdXposed-SandHook-v0.4.5.1_beta.4463.-release.zip /sdcard/Download 使用magisk模块安装并重启adb install EdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apk 安装xposedadb push MagiskHidePropsConf-v5.3.4.zip /sdcard/Download adb install JustTrustMePlus-debug.apk 用于结合xposed突破SSL Pinning抓包限制 twrp作为第三方刷机工具，刷入Magisk，nethunter等魔改系统。 fastboot flash recovery twrp-3.3.0-0-angler.img 12345678adb reboot bootloaderfastboot boot twrp-3.4.0-0-sailfish.img 进入recovery modeinstall Magisk-v20.4.zipadb install MagiskManager-v7.5.1.apksettings put global captive_portal_http_url https://www.google.cn/generate_204 去除wifi上的×settings put global captive_portal_https_url https://www.google.cn/generate_204settings put global ntp_server 1.hk.pool.ntp.org 修改时区reboot linux下载最新的platform-tools刷机的时候，fastboot会报各种unknow command或接近的错误，把fastboot文件替换成随着aosp一起编译出来的即可,使用自行编译的fastboot即可。 123rm ~&#x2F;Android&#x2F;Sdk&#x2F;platform-tools&#x2F;fastbootcp fastboot810r1 fastbootfastboot --version 通过wifi连接adb可实现群控adb -s 192.168.0.104:5555 install com.ttxapps.wifiadb_2.1.3-810031745_minAPI15(nodpi)_apkmirror.com.apk 安装apk adb connect 192.168.0.104:5555 使用adb连接手机 termux adb -s 192.168.0.104:5555 install com.termux_92.apk adb被禁时在app端使用命令行操作 pkg update &amp;&amp; pkg install htop 在app端安装管理进程的包 xdebuggable &amp;&amp; XAppDebug启动EdXposed,搜索xdebuggable 和XAppDebug模块并安装开启debug apk(需要借助ssr科学上网) ro.debuggable adb push MagiskHidePropsConf-v5.3.4.zip /sdcard/Download 并通过Magisk Manager-模块-下载-安装MagiskHidePropsConf-v5.3.4.zip reboot-adb shell-props 123456789101112131415161718192021222324252627282930313233343536373839404142434445461 - Edit device fingerprint2 - Force BASIC key attestation3 - Device simulation (disabled)4 - Edit MagiskHide props5 - Add&#x2F;edit custom props6 - Delete prop values7 - Script settings8 - Collect logsu - Perform module update checkr - Reset all options&#x2F;settingsb - Reboot devicee - ExitSee the module readme or thesupport thread @ XDA for details.Enter your desired option: 41 - ro.debuggable2 - ro.secure3 - ro.build.type4 - ro.build.tags5 - ro.bootmode6 - ro.boot.modea - Change all propsb - Go back to main menue - ExitPick several options at once byseparating inputs with a comma.Example: 1,3,4See the module readme or thesupport thread @ XDA for details.Enter your desired option: 1You currently have the safe value set.Are you sure you want to change it to 1?Enter y(es), n(o) or e(xit): yDo you want to reboot now (y&#x2F;n)?Enter y(es), n(o) or e(xit): y getprop ro.debuggable 即可查看1,开启全局可调式 Genymotion安装全程开全局代理，安装nexus 5x 8.0network mode选择Bridge或者在virtualbox中修改网络为桥接，如virtualbox网络连接里没有桥接网卡选择修改D:\\VirtualBox\\drivers\\network\\netlwf\\VBoxNetLwf.infsettings-system-Languages&amp;input-Languages-Add a language-简体中文 adb 无法连接genymotion怎么办？ 修改genymotion的settings，Use custom Android SDK tools为本地android sdk路径adb kill-server + adb start-server 重启adb安装wifiadb后即可，默认可以连接192网段，配置桥接，可adb connect 192.168.0.104:5555 arm桥接 uname -a i686 查看cpu架构为x86 32位 不支持arm，需要安装arm桥，直接将 Genymotion-ARM-Translation_for_8.0.zip拖入nexus 5x 8.0, 进行安装adb reboot 即可安装带有arm的so的apk Kali别用Windows了，鲁迅曾经说过，他在逆向生涯中超过一半的苦难均由Windows赐予。 vmware安装文件 秘钥：YC34H-6WWDK-085MQ-JYPNX-NZRA2 kali-linux-2020.4-vmware-amd64.7z种子，使用vmware打开vmx文件，配置6g内存，80g磁盘存储，网络适配选择桥接到本地网卡(虚拟网络编辑器)，默认账密：kali/kali，sudo passwd root 修改密码123456 重启后使用root登录，android-studio-ide-201.7042882-linux.tar.gz安装包~/.cache/vmware/drag_and_drop 定期删除拷贝的文件缓存 基本配置12345apt update;apt install htop jnettop tmux iotopdpkg-reconfigure tzdata 选择Asia-Shanghai apt update 更新自动同步时间apt install xfonts-intl-chinese 装中文字体apt-get install ttf-wqy-microhei 常用软件1234567tar zxf android-studio-ide-201.7042882-linux.tar.gzcd ~/Desktop/android-studio/bin &amp;&amp; ./studio.sh 启动android studioctrl+shift+t 当前窗口新建终端vim ~/.zshrcexport PATH=\"/root/Android/Sdk/platform-tools:$PATH\" 加入环境变量exec \"$SHELL\"dpkg -i code_1.52.1-1608136922_amd64.deb 安装vscode as若报错To build this project, accept the SDK license agreements and install the missing components？ 执行/root/Android/Sdk/tools/bin/sdkmanager –licenses Android设备投屏 NodeJs 123curl -fsSL https://deb.nodesource.com/setup_14.x | bash -apt-get install -y nodejsnpm install --save @types/frida-gum frida代码提示 jeb-pro-3.19.1.202005071620_pwd_ilbtcdnwiuypbzeo_.7z 运行./jeb_linux.sh，输入密码：ilbtcdnwiuypbzeo，进入界面点击Manual Key Generation中间按钮获取LICENSE DATA，运行jebKeygen.py 获取license key后输入到界面的key中，continue Kali Linux里的as4的DDMS启动失败，原因是要用as自带的jre来启动，直接./monitor用的是Kali系统的jdk，版本太高了ln -s /root/Desktop/android-studio/jre/ /root/Android/Sdk/tools/lib/monitor-x86_64/,然后通过~/Android/Sdk/tools/monitor打开ddms vim ~/.bashrc &amp;&amp; source ~/.bashrc export PATH=$PATH:/root/Android/Sdk/platform-tools jdk1.8 123456789101112apt-get remove openjdk-11-jre-headless:amd64apt-get remove openjdk-11-jre:amd64tar zxf jdk-8u191-linux-x64.tar.gz -C &#x2F;opt&#x2F;jdkvim ~&#x2F;.zshrcexport JAVA_HOME&#x3D;&#x2F;opt&#x2F;jdkexport CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;libexport PATH&#x3D;&quot;&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;ndk-bundle:&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;platform-tools:$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH&quot;source ~&#x2F;.zshrcupdate-alternatives --install &#x2F;usr&#x2F;bin&#x2F;java java &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;java 1update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;javac javac &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;javac 1update-alternatives --set java &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;javaupdate-alternatives --set javac &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;javac nexus 5x 安装流程 twrp-&gt;SuperSu-&gt; nethunter kali nethunter下载nexus 5x nethunter，使用投屏可变成一个迷你的linux渗透系统，通过twrp进行install ，sh userinit.sh 同步时间 tab smali与java代码转换 ctrl+b 下断点（注意这个必须在smali代码界面才有用） esc 回退上一级引用 activity_main.xml中配置的view组件：jeb中以十六进制存在于代码中，利用计算器的程序员模式转为十进制，jadx将该十进制存入resources.arsc，gda有APK入口直接进入MainActivity，同样以十六进制存入代码中。 科学上网dpkg -i electron-ssr-0.2.6.deb 卸载使用-r，查询使用-l ,失败缺少包，经过https://pkgs.org/ 查找所缺的包并安装 123456apt --fix-broken installapt-get install gconf2dpkg -i libdbusmenu-gtk4_18.10.20180917_bzr492+repack1-2_amd64.deb dpkg -i libindicator7_0.5.0-4_amd64.deb dpkg -i libappindicator1_0.4.92-8_amd64.debdpkg -i electron-ssr-0.2.6.deb 启动electron-ssr的pac模式即可vim /etc/proxychains4.conf 通过右键复制SSR服务器订阅代理设置 1http 127.0.0.1 12333 基本命令 getprop ro.product.cpu.abi 判断系统cpu版本 虚拟机一般都是x86 dumpsys meminfo pid 查看进程占用内存映射的信息 cat /proc/pid/maps 进程加载的so cat /proc/pid/maps | grep -i libart.so 所有java代码通过libart.so解析，脱壳机的关键 dumpsys activity top 显示当前的Activity，显示View Hierarchy，看view的类信息 dumpsys package com.soviet.hook4crawler 查看运行包信息 pm list packages 查看所有安装的包 pyenv环境对python不同包(frida,objection…)多版本管理 3.8.512345678910111213ctrl+alt+t 新建终端git clone https://github.com/pyenv/pyenv.git ~/.pyenv 安装pyenv，python全版本随意切echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' &gt;&gt; ~/.zshrcecho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' &gt;&gt; ~/.zshrcecho -e 'if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\\n eval \"$(pyenv init -)\"\\nfi' &gt;&gt; ~/.zshrcexec \"$SHELL\"apt-get update; apt-get install --no-install-recommends make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-devPYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pyenv install 3.8.5 使用代理访问，不然会报错you can specify \"--disable-ipv6\".pyenv local 3.8.5python -Vpyenv local system 切换原系统pyenvpip install frida-toolsproxychains4 pip install objection==1.9.5 针对指定frida版本的objection，通过pypi中查找frida release日期稍后一点版本的objection即可7x x frida-server-14.2.8-android-arm64.xz 123456adb push frida-server-14.2.8-android-arm64 /data/local/tmpmv frida-server-14.2.8-android-arm64 fs1428arm64 改名fs1428arm64,防止反调试chmod 777 fs1428arm64 加权./fs1428arm64frida-ps -Uandroid hooking list classes 3.8.0123456PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pyenv install 3.8.0 pyenv local 3.8.0 PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pip install frida==12.8.0PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pip install frida-tools==5.3.0PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pip install objection==1.8.4objection -g com.android.settings explore 7z x frida-server-12.8.0-android-arm64 12345adb push frida-server-12.8.0-android-arm64 /data/local/tmpmv frida-server-12.8.0-android-arm64 fs128arm64 改名防止反调试chmod 777 frida-server-12.8.0-android-arm64objection -g com.android.settings exploreandroid hooking list classes 特定版本frida 按照这个顺序，在装objection的时候，就会直接Requirement already satisfied，不会再去下载新的frida来安装了。 123pip install frida&#x3D;&#x3D;12.8.0 pip install frida-tools&#x3D;&#x3D;5.3.0 pip install objection&#x3D;&#x3D;1.8.4 frida开发环境 pyenv local 3.8.0 &amp;&amp; ./fs128arm64 git clone https://github.com/oleavr/frida-agent-example.git cd frida-agent-example/ npm install 使用VSCode等IDE打开此工程，在agent下编写typescript，会有智能提示。 npm run watch会监控代码修改自动编译生成js文件 frida -UF -l demo.js usb连接手机保存将自动调用demo.js 进行hook Java.perform(function(){console.log(&quot;frida hook&quot;)}) frida -UF -l demo.js –runtime=v8 使用v8引擎 Java.perform(()=&gt;{console.log(&quot;Hello World&quot;)}) frida-ps -U 查看所有进程 frida -H 192.168.0.100:5555 -f com.ttxapps.wifiadb -l demo.js –runtime=v8 远程hook,-l指定脚本 frida -Uf com.android.settings -l demo.js –runtime=v8 –no-pause 经过usb主动启动应用调用demo.js,-f是spawn模式,–no-pause直接加载应用，没有的话需要%resume启动主线程 frida -UF –runtime=v8 -e “Java.perform(()=&gt;{console.log(‘Hello World’)})” -o /root/log.txt 直接执行脚本写入文件 远程连接 ./fs128arm64 -v -l 0.0.0.0:8888 指定端口启动frida，默认端口27042 frida-ps -H 192.168.0.8:8888 指定-U表示usb,-H表示主机ip frida -H 192.168.0.8:8888 -F 指定-H表示主机ip，-F表示前台应用，输入frida即可查看Frida信息 cd frida-agent-example/ &amp;&amp; npm install &amp;&amp; npm run watch &amp;&amp; frida -H 192.168.0.8:8888 -F -l agent/demo.js 远程调用js脚本 1234567Java.perform(()&#x3D;&gt;&#123;console.log(&quot;Hello World&quot;)&#125;) function main()&#123; Java.perform(function()&#123; console.log(&quot;hello&quot;) &#125;)&#125;setImmediate(main) 远程调用 12345678910111213import fridadevice &#x3D; frida.get_usb_device() print(device.get_frontmost_application())#pid &#x3D; device.spawn([&quot;com.onejane.demo02&quot;])pid&#x3D;device.get_frontmost_application().pid # 若双进程保护，指定pid进行hook print(device.enumerate_processes()) # 枚举所有进程print(device.enumerate_applications()) # 枚举所有包名# device.resume(pid)# time.sleep(1)session &#x3D; device.attach(pid) with open(&quot;demo.js&quot;) as f: script &#x3D; session.create_script(f.read())script.load() plugins 1234proxychains git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;FRIDA-DEXDump ~&#x2F;Downloads&#x2F;FRIDA-DEXDump 脱壳mv ~&#x2F;Downloads&#x2F;FRIDA-DEXDump&#x2F;frida_dexdump ~&#x2F;.objection&#x2F;plugins&#x2F;dexdump 在plugins子目录插件下必须有__init__.pyproxychains git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;Wallbreaker ~&#x2F;.objection&#x2F;plugins&#x2F;Wallbreaker 内存漫游objection -N -h 192.168.0.8 -p 8888 -g com.android.settings explore -P ~&#x2F;.objection&#x2F;plugins 远程连接批量加载插件","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.gitee.io/tags/frida/"},{"name":"objection","slug":"objection","permalink":"http://onejane.gitee.io/tags/objection/"},{"name":"kali","slug":"kali","permalink":"http://onejane.gitee.io/tags/kali/"},{"name":"xposed","slug":"xposed","permalink":"http://onejane.gitee.io/tags/xposed/"}]}],"categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.gitee.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"},{"name":"架构","slug":"架构","permalink":"http://onejane.gitee.io/categories/%E6%9E%B6%E6%9E%84/"},{"name":"脚本","slug":"脚本","permalink":"http://onejane.gitee.io/categories/%E8%84%9A%E6%9C%AC/"},{"name":"js逆向","slug":"js逆向","permalink":"http://onejane.gitee.io/categories/js%E9%80%86%E5%90%91/"},{"name":"生活","slug":"生活","permalink":"http://onejane.gitee.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"classloader","slug":"classloader","permalink":"http://onejane.gitee.io/tags/classloader/"},{"name":"Dalvik","slug":"Dalvik","permalink":"http://onejane.gitee.io/tags/Dalvik/"},{"name":"ART","slug":"ART","permalink":"http://onejane.gitee.io/tags/ART/"},{"name":"Socket","slug":"Socket","permalink":"http://onejane.gitee.io/tags/Socket/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://onejane.gitee.io/tags/WebSocket/"},{"name":"Protobuf","slug":"Protobuf","permalink":"http://onejane.gitee.io/tags/Protobuf/"},{"name":"XMPP","slug":"XMPP","permalink":"http://onejane.gitee.io/tags/XMPP/"},{"name":"nacos","slug":"nacos","permalink":"http://onejane.gitee.io/tags/nacos/"},{"name":"feign","slug":"feign","permalink":"http://onejane.gitee.io/tags/feign/"},{"name":"gateway","slug":"gateway","permalink":"http://onejane.gitee.io/tags/gateway/"},{"name":"sentinel","slug":"sentinel","permalink":"http://onejane.gitee.io/tags/sentinel/"},{"name":"frida","slug":"frida","permalink":"http://onejane.gitee.io/tags/frida/"},{"name":"okhttp3","slug":"okhttp3","permalink":"http://onejane.gitee.io/tags/okhttp3/"},{"name":"HttpURLConnection","slug":"HttpURLConnection","permalink":"http://onejane.gitee.io/tags/HttpURLConnection/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://onejane.gitee.io/tags/Retrofit/"},{"name":"python","slug":"python","permalink":"http://onejane.gitee.io/tags/python/"},{"name":"fart","slug":"fart","permalink":"http://onejane.gitee.io/tags/fart/"},{"name":"vmp","slug":"vmp","permalink":"http://onejane.gitee.io/tags/vmp/"},{"name":"dex2c","slug":"dex2c","permalink":"http://onejane.gitee.io/tags/dex2c/"},{"name":"rpc","slug":"rpc","permalink":"http://onejane.gitee.io/tags/rpc/"},{"name":"objection","slug":"objection","permalink":"http://onejane.gitee.io/tags/objection/"},{"name":"js","slug":"js","permalink":"http://onejane.gitee.io/tags/js/"},{"name":"hexo","slug":"hexo","permalink":"http://onejane.gitee.io/tags/hexo/"},{"name":"kali","slug":"kali","permalink":"http://onejane.gitee.io/tags/kali/"},{"name":"xposed","slug":"xposed","permalink":"http://onejane.gitee.io/tags/xposed/"}]}