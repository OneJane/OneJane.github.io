{"meta":{"title":"J","subtitle":"朝花夕拾","description":"逆向,爬虫","author":"J","url":"http://onejane.github.io","root":"/"},"pages":[{"title":"404","date":"2021-01-30T10:32:36.000Z","updated":"2021-01-30T10:33:01.911Z","comments":true,"path":"/404.html","permalink":"http://onejane.github.io/404.html","excerpt":"","text":""},{"title":"标签","date":"2021-01-30T07:34:05.000Z","updated":"2021-01-30T08:00:59.817Z","comments":true,"path":"tags/index.html","permalink":"http://onejane.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-30T07:34:23.000Z","updated":"2021-01-30T08:30:40.321Z","comments":true,"path":"categories/index.html","permalink":"http://onejane.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"违法应用移动TV取证分析","slug":"违法应用移动TV取证分析","date":"2021-04-21T14:37:18.000Z","updated":"2021-04-22T18:04:08.833Z","comments":true,"path":"2021/04/21/违法应用移动TV取证分析/","link":"","permalink":"http://onejane.github.io/2021/04/21/%E8%BF%9D%E6%B3%95%E5%BA%94%E7%94%A8%E7%A7%BB%E5%8A%A8TV%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/","excerpt":"","text":"抓包应用层抓包 传输层抓包charles开启Enable socks proxy wget https://www.charlesproxy.com/assets/release/4.6.1/charles-proxy-4.6.1_amd64.tar.gz?k=17bcbd3dc2 tar zxf charles-proxy-4.6.1_amd64.tar.gz &amp;&amp; ./charles 通过注册码注册或生成加权jar包破解 vim ~/.zshrc 并source ~/.zshrc 使得charles在任意路径可启动 1export PATH&#x3D;&quot;&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;ndk-bundle:&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;platform-tools:$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH:&#x2F;root&#x2F;Desktop&#x2F;charles&#x2F;bin:&#x2F;root&#x2F;Desktop&#x2F;jadx-1.2.0&#x2F;bin&quot; htop 查看破解情况 电脑：192.168.0.106 手机：192.168.0.102 虚拟机：192.168.0.107 虚拟网络编辑器选择获取ip的网卡，保证这三台机器在同一局域网内且互相ping通。 配置charlessocks proxy工作于传输层，更好的观察应用层协议和socks抓包。 开启ssl posternadb install 0714com.tunnelworkshop.postern_2018-10-07.apk QtScrcpy 设置投屏 配置socks5抓包代理 配置socks5抓包配置规则 打开socks vpn连接虚拟机抓包，虚拟机收到连接请求后点击Allow 在手机浏览器输入地址 chls.pro/ssl 或者 charlesproxy.com/getssl ，出现证书安装页面，点击安装，如果依旧app抓不到，需要把个人证书放到系统根目录 Android8 12345cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o remount,rw &#x2F;chmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o remount,ro &#x2F; Android 7 12345cd &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;mount -o rw,remount &#x2F;systemchmod 777 *cp * &#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;mount -o ro,remount &#x2F;system movetv分析1234.&#x2F;fs1428arm64 pyenv local 3.8.5frida -UF -l hookSocket.js -o moveTV.txt attach方式hook登录抓包，基于socks层抓包无法对抗，除非做了VPN检测frida -U -f com.cz.babySister -l hookSocket.js -o moveTV.txt spawn方式hook，输入%resume重新启动，或者直接在命令后加--no-pause jadx-gui movetv.apk 已经加壳一个Activity都找不到 脱壳FRIDA-DEXDumpgit clone https://github.com/hluwa/FRIDA-DEXDump.git 启动app放在前台 cd ~/Desktop/FRIDA-DEXDump/frida_dexdump &amp;&amp; python main.py 开始脱壳 1234android hooking list activities 查看所有Activitygrep -ril &quot;MainActivity&quot; * 从脱下的dex中查找MainActivitygrep -ril &quot;LoginActivity&quot; *jadx-gui com.cz.babySister&#x2F;0x748d44201c.dex 登录抓登录包获取memi1字段其实来源于android-id android hooking watch class com.cz.babySister.activity.LoginActivity –dump-args –dump-backtrace –dump-return hook类中所有方法 android hooking watch class_method com.cz.babySister.activity.LoginActivity.b –dump-args –dump-backtrace –dump-return hook登录b方法 进入b方法中调用的RunnableC0042q类中 android hooking watch class_method com.cz.babySister.c.a.a –dump-args –dump-backtrace –dump-return hook方法a 12345objection -g com.cz.babySister exploreandroid hooking search classes Settings android hooking list class_methods android.provider.Settings android hooking list class_methods android.provider.Settings$Secureandroid hooking watch class_method android.provider.Settings$Secure.getString --dump-args --dump-backtrace --dump-return 通过hook获取返回的结果50463fa80244d95f和chales中抓包的memi1完全一致 注册android hooking watch class_method com.cz.babySister.c.a.a –dump-args –dump-backtrace –dump-return 对比抓包结果 取证实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import base64import timeimport requestsrequests.packages.urllib3.disable_warnings()class tv: def __init__(self): self.root &#x3D; &#39;http:&#x2F;&#x2F;39.108.64.125&#x2F;WebRoot&#x2F;superMaster&#x2F;Server&#39; self.memi1 &#x3D; &quot;50463fa80244d95f&quot; self.rightkey &#x3D; &quot;376035775&quot; self.key &#x3D; &quot;308202d5308201bda00302010202041669d9bf300d06092a864886f70d01010b0500301b310b3009060355040613023836310c300a06035504031303776569301e170d3136303731383038313935395a170d3431303731323038313935395a301b310b3009060355040613023836310c300a0603550403130377656930820122300d06092a864886f70d01010105000382010f003082010a028201010095f85892400aae03ca4ed9dcd838d162290ae8dd51939aac6ecfde8282f207c4cd9e507929a279e0a36f1e4847330cb53908c92915b2c6a93d7064be452d073a472093f7ca14f4ab68f827582fe0988e9e4bc8a6ea3b56001cbbbb760f9eec571b0bbc97392e65aaf08c686f0e2ba353896d48a37c36716239977bd0e4dd878025cab497d8164537aec9f6599eefb98577dce972a1b794e211226520e23497beec3fd8548bb5b4d263120d40115cca28116bac32378df5033f536a0d7367fef78c587fefed28c5c9b35ba684ed6e46d9369c40950cf7ad7236d10b7a51dfd2a8f218db72323bbd19f46947410b1191f263012ad4ba8f749223e37591254ee7f50203010001a321301f301d0603551d0e041604143d43284bd5e4b0d322c9962a5b70aad4dcbc3634300d06092a864886f70d01010b050003820101000f04c51ff763311aa011777ba2842b441b15c316373d1e1ed4116cf86e29d55c6ed3fa4c475251b1fb4fac57195dbca0166ebe565d9834552a3758b97c4528bab1f7ab82bb3a9faa932f5bc10943f3daf52e0fe5889ffb58a6be67ea1c9a2fb37dc8aa6f3af476039a467336991a4e52dccd520195cd473eb5b984e702ed9ff638a14c3abb575a7a80ae4062084d1138a06a20e173be9df32df631311b07352898706198ddebaaa011f0da8e5f288f7cfb77505bc943f6476d6cc1feef56b68137aad91f23c4bb772169539d05653a6f0d75f7192164e822b934322f3a975df677903b1667f5dc1e9ddb185da3281d31bfb8f67a84bd23bbcb398f8bb637dd72&quot; def post(self, data&#x3D;None): if data is None: data &#x3D; &#123;&#125; return requests.post(url&#x3D;self.root, data&#x3D;data) def query(self, name, password): ret &#x3D; self.post(&#123;&#39;name&#39;: name, &#39;pass&#39;: password&#125;) print(&quot;query result is : &quot;) print(ret.content.decode(&#39;utf-8&#39;)) def register(self, name, password): ret &#x3D; self.post(&#123;&#39;name&#39;: name, &#39;pass&#39;: password, &#39;memi1&#39;: self.memi1, &#39;key&#39;: self.key, &#39;rightkey&#39;: self.rightkey, &#39;register&#39;: &#39;register&#39;&#125;) print(&quot;Register response data: &quot;) print(ret.content.decode(&#39;utf-8&#39;)) def login(self, name, password): ret &#x3D; self.post(&#123;&#39;name&#39;: name, &#39;pass&#39;: password, &#39;memi1&#39;: self.memi1, &#39;key&#39;: self.key, &#39;rightkey&#39;: self.rightkey, &#39;login&#39;: &#39;login&#39;&#125;) print(&quot;Login response data: &quot;) print(ret.content.decode(&#39;utf-8&#39;)) def updateSocre(self, name, password, jifen): t &#x3D; int(round(time.time() * 1000)) sign &#x3D; base64.b64encode(str(5 * t).encode(&#39;utf-8&#39;)).decode(&#39;utf-8&#39;) ret &#x3D; self.post(&#123;&#39;name&#39;: name, &#39;pass&#39;: password, &#39;jifen&#39;: jifen, &#39;time&#39;: t, &#39;sign&#39;: sign&#125;) print(&quot;UpdataScore response data: &quot;) print(ret.content.decode(&#39;utf-8&#39;))if __name__ &#x3D;&#x3D; &quot;__main__&quot;: tv &#x3D; tv() # print(tv.query(&quot;eeeeffff&quot;, &quot;gggghhhh&quot;)) # 注册账号 print(tv.register(&quot;onejane3&quot;, &quot;123456&quot;)) # time.sleep(3) # 登录账号 print(tv.login(&quot;onejane3&quot;, &quot;123456&quot;)) # 更新积分 # print(tv.updateSocre(&quot;mee4&quot;,&quot;mee4&quot;,&quot;1000&quot;)) Youpkhttps://bbs.pediy.com/thread-259854.htm linux平台下载最新的platform-tools刷机的时候，fastboot会报各种unknow command或接近的错误，把fastboot文件替换成以下随着aosp一起编译出来的即可： fastboot_aosp7.1.zip fastboot6.0.zip fastboot8.1.0r1.zip 下载Youpk_v1.1 重启至bootloader: adb reboot bootloader 解压 Youpk_sailfish.zip 并双击 flash-all.bat,（尽量在kali上刷机，./flash-all.sh,因为windows会给我们的编程生涯带来80%的苦难） adb install movetv.apk adb shell “echo com.cz.babySister &gt;&gt; /data/local/tmp/unpacker.config” 启动apk等待脱壳，每隔10秒将自动重新脱壳(已完全dump的dex将被忽略), 当日志打印unpack end时脱壳完成 adb pull /data/data/com.cz.babySister/unpacker/ mv unpacker youpk/ 调用修复工具 dexfixer.jar, 两个参数, 第一个为dump文件目录(必须为有效路径), 第二个为重组后的DEX目录(不存在将会创建) java -jar dexfixer.jar youpk/ youpk_out/ jadx-gui _data_app_com.cz.babySister-1_base.apk_54276.dex 查看脱壳后的dex 使用场景 整体加固 抽取: nop占坑型(类似某加密) naitve化, 在中解密(类似早期阿里) goto解密型(类似新版某加密?najia): https://bbs.pediy.com/thread-259448.htm 问题 dump中途退出或卡死，重新启动进程，再次等待脱壳即可 当前仅支持被壳保护的dex, 不支持App动态加载的dex/jar fart脱抽取型壳并回填dex 安装新环境vim /etc/proxychains4.conf 配置代理 12socks5 192.168.0.106 1080#http 127.0.0.1 12333 主机192.168.0.106 ssr开启运行局域网连接 配置新环境 12PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains pyenv install 3.9.0 创建python3.9.0环境PYTHON_CONFIGURE_OPTS&#x3D;&quot;--disable-ipv6&quot; proxychains pip install objection&#x3D;&#x3D;1.9.5 安装objection 1.9.5套件包括frida-tools 9.2.4，frida 14.2.16 wget frida-server-14.2.16-android-arm64.xz 7z x frida-server-14.2.16-android-arm64.xz 12345adb push ~&#x2F;Desktop&#x2F;frida-server-14.2.16-android-arm64 &#x2F;data&#x2F;local&#x2F;tmp&#x2F;adb shellmv &#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server-14.2.16-android-arm64 &#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs1426arm64 chmod 777 &#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs1426arm64.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs1426arm64 事实证明，新版本不兼容还是用12.8.0的frida吧 调用fart基于hook和反射脱壳，对比发现youpk最优秀。 adb reboot bootloader cd ~/Desktop/sailfish-opm4.171019.021.p1 ./flash-all.sh 刷回去 root及基础配置 123456789101112131415adb push Magisk-v20.4.zip &#x2F;sdcard adb push magisk-riru-v21.3.zip &#x2F;sdcard&#x2F;Download 使用magisk模块安装并重启adb push magisk-EdXposed-SandHook-v0.4.5.1_beta.4463.-release.zip &#x2F;sdcard&#x2F;Download 使用magisk模块安装并重启adb install EdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apk 安装xposedadb push MagiskHidePropsConf-v5.3.4.zip &#x2F;sdcard&#x2F;Download adb install JustTrustMePlus-debug.apk 用于结合xposed突破SSL Pinning抓包限制adb reboot bootloaderfastboot boot twrp-3.4.0-0-sailfish.img 进入recovery modeinstall Magisk-v20.4.zipadb install MagiskManager-v7.5.1.apk 模块安装MagiskHidePropsConf，riru，EdXposed，adb shell su通过Magisk获取root权限settings put global captive_portal_http_url https:&#x2F;&#x2F;www.google.cn&#x2F;generate_204 去除wifi上的×settings put global captive_portal_https_url https:&#x2F;&#x2F;www.google.cn&#x2F;generate_204settings put global ntp_server 1.hk.pool.ntp.org 修改时区props Edit MagiskHide props--ro.debuggable 设置全局可调试，getprop ro.debuggable 即可查看1,开启全局可调试 1234567pyenv local 3.8.0proxychains4 wget https:&#x2F;&#x2F;github.com&#x2F;hanbinglengyue&#x2F;FART.git7z x frida_fart.zip &amp;&amp; adb push lib&#x2F;fart* &#x2F;data&#x2F;app &amp;&amp; chmod 777 *.so 如果没有权限，放到&#x2F;sdcard中再放入&#x2F;data&#x2F;appcd Desktop&#x2F;FART-master&#x2F;frida_fart&#x2F; &amp;&amp; frida -UF -l frida_fart_reflection.js attach模式启动frida -U -f com.cz.babySister -l frida_fart_reflection.js --no-pause spawn模式启动fart() 全量主动调用frida -U -f com.cz.babySister -l frida_fart_hook.js --no-pause 基于安卓8，生成dex，hook连壳一起脱 12adb pull &#x2F;sdcard&#x2F;com.cz.babySister.activitygrep -ril &quot;LoginActivity&quot; *.dex","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"postern","slug":"postern","permalink":"http://onejane.github.io/tags/postern/"}]},{"title":"爬虫基础篇之selenium","slug":"爬虫基础篇之selenium","date":"2021-04-21T02:25:19.000Z","updated":"2021-04-21T11:53:19.047Z","comments":true,"path":"2021/04/21/爬虫基础篇之selenium/","link":"","permalink":"http://onejane.github.io/2021/04/21/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8Bselenium/","excerpt":"","text":"简介selenium本身是自动化测试框架，只是在爬虫领域更能够显示出其一把梭的威力，所有网站比如淘宝，微博等必须登录状态才能访问页面，对数据进行抓取时，逆向分析js将是一条不归路，而自动化测试框架selenium完全模拟人的行为模式，对网站按钮的点击，元素的获取，内容文本的输入有着得天独厚的优势。不过相对于逆向加密参数执行的爬虫程序来说，selenium还是太过效率低下了，常规套路一般是通过selenium拿到cookie或者token后，再通过爬虫程序去抓取页面，事半功倍。 实战以阿里妈妈后台为例，通过分析我们拿到了请求json来自于https://pub.alimama.com/campaign/joinedSpecialCampaigns.json?toPage=1&amp;status=2&amp;perPageSize=40 不过单独访问该页面，会将我们地址重定向到登录界面，这种网站就必须我们登录再发起请求抓取数据了。 模拟登录该登录页面是淘宝的统一登录框架，右键重新加载时抓包拿到框架地址，去除无用参数拿到原始地址https://login.taobao.com/member/login.jhtml?style=mini&amp;newMini2=true&amp;from=alimama，避免其他请求干扰我们的判断。 步骤如下： 获取账户，密码，滑块，按钮的元素位置 输入账户密码 判断滑块存在并滑动滑块 点击登录 保存cookie并调用cookie发起请求 chromedriver初始化根据本机的chrome版本获取selenium的驱动程序chromedriver版本 特征隐藏面对一些网站通过ajax请求，同时携带一些难以破解加密参数，虽然selenium模拟浏览器行为操作，绕过这些反爬虫的手段，不过依旧有一些站点通过JavaScript 探测到Selenium启动的浏览器的天生存在的几十个特征来屏蔽这些爬虫的运行。通过https://bot.sannysoft.com/ 可以查看当前浏览器的一些特征值，正常浏览器打开如下： 而通过selenium打开该网站时，部分特征被检测到，这就被安全人员拿来作为关键参数，禁止改浏览器的数据请求。 比如某平台中对selenium的属性$cdc_asdjflasutopfhvcZLmcfl_做了校验，应对解决方案使用HexEdit 4.2修改chromedriver.exe 的$cdc_asdjflasutopfhvcZLmcfl_修改为同长度的字符串,如$ccccccccccccccccccccccccccc。 针对chrome弹窗请停用以开发者模式运行插件，可以通过Chrome.dll-patch75and76.exe放入chrome文件夹下包含包含chrome.dll文件的目录下并管理员身份执行。 针对CHROME正受到组件控制的提示，可以通过chrome_options.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])实现屏蔽’CHROME正受到组件控制’的提示。 针对chrome自带密码保存对爬虫的干扰影响，通过chrome_options.add_experimental_option(&quot;prefs&quot;, prefs)屏蔽。 针对封禁ip可以通过chrome_options.add_argument(&quot;--proxy-server=http://58.243.205.102:4543&quot;)开启ip代理。 设置请求头UA,browser.execute_cdp_cmd(&#39;Network.setUserAgentOverride&#39;, {&quot;userAgent&quot;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36&#39;}) 针对navigator属性中存在webdriver，新页面加载后browser.execute_script(&#39;Object.defineProperty(navigator,&quot;webdriver&quot;,{get:() =&gt; false,});&#39;)去除特征无效，可以通过CDP协议browser.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, {&quot;source&quot;: &quot;&quot;&quot;Object.defineProperty(navigator, &#39;webdriver&#39;, {get: () =&gt; undefined})&quot;&quot;&quot;, }) 不过仅仅靠隐藏几个特征是毫无意义的，针对众多的特征已经有大牛为我们做了完美隐藏，那就是stealth.min.js 道高一尺魔高一丈，完整隐藏特征代码如下： 1234567891011121314151617181920212223242526272829# chrome 版本78.0.3904.70，chromedriver版本78.0.3904.70# 设置代理# chrome_options.add_argument(&quot;--proxy-server&#x3D;http:&#x2F;&#x2F;58.243.205.102:4543&quot;)# chrome.exe --remote-debugging-port&#x3D;7222 本地启动selenium# chrome_options.add_experimental_option(&quot;debuggerAddress&quot;, &quot;127.0.0.1:7222&quot;)chrome_options &#x3D; Options()# 设置无头chrome_options.add_argument(&quot;--headless&quot;)chrome_options.add_argument( &#39;user-agent&#x3D;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.198 Safari&#x2F;537.36&#39;)# 屏蔽&#39;CHROME正受到组件控制&#39;的提示chrome_options.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])# 屏蔽保存密码prefs &#x3D; &#123;&quot;&quot;: &quot;&quot;&#125;prefs[&quot;credentials_enable_service&quot;] &#x3D; Falseprefs[&quot;profile.password_manager_enabled&quot;] &#x3D; Falsechrome_options.add_experimental_option(&quot;prefs&quot;, prefs)driver &#x3D; Chrome(&#39;.&#x2F;chromedriver&#39;, options&#x3D;chrome_options)#driver.execute_script(&#39;Object.defineProperty(navigator,&quot;webdriver&quot;,&#123;get:() &#x3D;&gt; false,&#125;);&#39;)#driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, &#123;&quot;source&quot;: &quot;&quot;&quot;Object.defineProperty(navigator, &#39;webdriver&#39;, &#123;get: () &#x3D;&gt; undefined&#125;)&quot;&quot;&quot;, &#125;)#driver.execute_cdp_cmd(&#39;Network.setUserAgentOverride&#39;, &#123;&quot;userAgent&quot;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;83.0.4103.97 Safari&#x2F;537.36&#39;&#125;) driver.set_page_load_timeout(10)with open(&#39;.&#x2F;stealth.min.js&#39;) as f: js &#x3D; f.read()driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, &#123; &quot;source&quot;: js&#125;) 保存cookie1234567891011121314151617181920212223242526def save_cookies(self): # 隐式等待，设置了一个最长等待时间 self.browser.implicitly_wait(10) # 最大化窗口 self.browser.maximize_window() # 向文本框发送账户密码 self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;input[@name&#x3D;&quot;fm-login-id&quot;]&#39;).send_keys(&#39;***&#39;) self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;input[@name&#x3D;&quot;fm-login-password&quot;]&#39;).send_keys(&#39;***&#39;) # 解决滑块 slide_block &#x3D; self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;nc_1_n1z&quot;]&#39;) if (slide_block.is_displayed()): # 点击移动滑块 action &#x3D; ActionChains(self.browser) action.click_and_hold(on_element&#x3D;slide_block) action.move_by_offset(xoffset&#x3D;258, yoffset&#x3D;0) action.pause(0.5).release().perform() # perform指定动作链 self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;button[@class&#x3D;&quot;fm-button fm-submit password-login&quot;]&#39;).click() time.sleep(5) if &quot;login_unusual&quot; in self.browser.current_url: print(&quot;gg了，要手机验证码了，救命啊啊啊啊啊&quot;) input(&quot;输入手机验证码啦：&quot;) self.cookies &#x3D; &#39;; &#39;.join( item for item in [item[&quot;name&quot;] + &quot;&#x3D;&quot; + item[&quot;value&quot;] for item in self.browser.get_cookies()]) with open(COOKIES_FILE_PATH, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as file: file.write(self.cookies) print(&quot;cookie写入成功：&quot;, self.cookies) 使用cookie登录123456789101112131415def taobao_login(self): print(&quot;登录中。。。。。&quot;) ok &#x3D; False while not ok: with open(COOKIES_FILE_PATH, &#39;r+&#39;, encoding&#x3D;&#39;utf-8&#39;) as file: self.headers[&quot;cookie&quot;] &#x3D; file.read() response &#x3D; self.session.get(self.shop_plan_url, headers&#x3D;self.headers, verify&#x3D;False) try: ok &#x3D; json.loads(response.text) except: self.browser.get(self.alimama_login_url) self.browser.delete_all_cookies() self.save_cookies() self.browser.close() self.browser.quit() 常用操作不同系统12345678910chrome_options &#x3D; webdriver.ChromeOptions()if platform.system() &#x3D;&#x3D; &quot;Windows&quot;: driver &#x3D; webdriver.Chrome(&#39;chromedriver.exe&#39;, chrome_options&#x3D;chrome_options)elif platform.system() &#x3D;&#x3D; &quot;Linux&quot;: chrome_options.add_argument(&quot;--headless&quot;) chrome_options.add_argument(&#39;--disable-gpu&#39;) chrome_options.add_argument(&#39;--no-sandbox&#39;) driver &#x3D; webdriver.Chrome( executable_path&#x3D;&quot;&#x2F;usr&#x2F;bin&#x2F;chromedriver&quot;, chrome_options&#x3D;chrome_options) 获取元素信息12345678910111213141516def get_data(): divs &#x3D; driver.find_elements_by_xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;items&quot;]&#x2F;div[@class&#x3D;&quot;item J_MouserOnverReq &quot;]&#39;) for div in divs: info &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;div[@class&#x3D;&quot;row row-2 title&quot;]&#x2F;a&#39;).text price &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;strong&#39;).text deal &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;div[@class&#x3D;&quot;deal-cnt&quot;]&#39;).text shop &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;div[@class&#x3D;&quot;shop&quot;]&#x2F;a&#39;).text print(info, price, deal, shop, sep&#x3D;&quot;|&quot;) with open(&#39;taobao.csv&#39;, mode&#x3D;&#39;a&#39;, newline&#x3D;&quot;&quot;) as csvfile: csvwrite &#x3D; csv.writer(csvfile, delimiter&#x3D;&#39;,&#39;) csvwrite.writerow([info, price, deal, shop])browser.find_elements_by_xpath(&quot;&#x2F;&#x2F;div[@id&#x3D;&#39;J_DivItemDesc&#39;]&#x2F;descendant::*&#x2F;img&quot;) 查找后代元素 browser.find_elements_by_xpath(&quot;&#x2F;&#x2F;div[@id&#x3D;&#39;J_DivItemDesc&#39;]&#x2F;descendant::*&#x2F;img&quot;).tag_name 获取标签browser.find_elements_by_xpath(&quot;&#x2F;&#x2F;div[@id&#x3D;&#39;J_DivItemDesc&#39;]&#x2F;descendant::*&#x2F;img&quot;).get_attribute(&#39;value&#39;) 获取属性value信息或文本框信息js &#x3D; &#39;return document.getElementById(&quot;su&quot;).getAttribute(&quot;value&quot;)&#39;res &#x3D; driver.excute_script(js) 利用js获取元素属性值 鼠标操作1234567891011121314151617181920212223def get_data(): # 移动鼠标到距离元素的位置 title &#x3D; browser.find_element_by_xpath(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;title-bar&#39;]&quot;) ActionChains(browser).move_to_element_with_offset(title, 100, 600).perform() # 键盘指令 # browser.find_element_by_tag_name(&#39;body&#39;).send_keys(Keys.CONTROL + Keys.SHIFT + &#39;J&#39;) # hover到指定元素 # ActionChains(browser).move_to_element(browser.find_elements_by_xpath(&#39;&#x2F;&#x2F;tbody[@mx-ie&#x3D;&quot;mouseover&quot;]&#x2F;tr&#39;)[1]).perform() # 页面双击操作才能获取列表 ActionChains(browser).double_click(browser.find_element_by_xpath(&quot;&#x2F;&#x2F;body&quot;)).perform() tr_list &#x3D; browser.find_elements_by_xpath(&#39;&#x2F;&#x2F;tbody[contains(@mx-ie,&quot;mouseover&quot;)]&#x2F;tr&#39;) if len(tr_list) &#x3D;&#x3D; 0: # 页面重载 browser.execute_script(&quot;location.reload()&quot;) title &#x3D; browser.find_element_by_xpath(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;title-bar&#39;]&quot;) # 鼠标移动位置 ActionChains(browser).move_to_element_with_offset(title, 100, 600).perform() # 双击 ActionChains(browser).double_click(browser.find_element_by_xpath(&quot;&#x2F;&#x2F;body&quot;)).perform() # 判断元素属性是否包含 tr_list &#x3D; browser.find_elements_by_xpath(&#39;&#x2F;&#x2F;tbody[contains(@mx-ie,&quot;mouseover&quot;)]&#x2F;tr&#39;) # 滚轮直接滑到底部 browser.execute_script(&quot;window.scrollTo(0,document.body.scrollHeight);&quot;) 查找元素1234567891011121314151617181920212223# 通过不同的方式查找界面元素def findElement(by, value): if (by &#x3D;&#x3D; &quot;id&quot;): element &#x3D; browser.find_element_by_id(value) return element elif (by &#x3D;&#x3D; &quot;name&quot;): element &#x3D; browser.find_element_by_name(value) return element elif (by &#x3D;&#x3D; &quot;xpath&quot;): element &#x3D; browser.find_element_by_xpath(value) return element elif (by &#x3D;&#x3D; &quot;classname&quot;): element &#x3D; browser.find_element_by_class_name(value) return element elif (by &#x3D;&#x3D; &quot;css&quot;): element &#x3D; browser.find_element_by_css_selector(value) return element elif (by &#x3D;&#x3D; &quot;link_text&quot;): element &#x3D; browser.find_element_by_link_text(value) return element else: print(&quot;无对应方法，请检查&quot;) return None 元素存在123456789101112from selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdef is_element_present(locator): wait &#x3D; WebDriverWait(browser, 2) try: # 显式等待 wait.until(EC.visibility_of_element_located(locator)) except TimeoutException: return False return Trueis_element_present((By.XPATH, &#39;&#x2F;&#x2F;*[@id&#x3D;\\&quot;sufei-dialog-content\\&quot;]&#39;)) 点击元素1234567def move_element_click(xpath): if is_element_present((By.XPATH, xpath)): ele_loc &#x3D; browser.find_element_by_xpath(xpath) browser.execute_script(&quot;arguments[0].scrollIntoView();&quot;, ele_loc) ActionChains(browser).move_to_element(ele_loc).click().perform() time.sleep(random.randint(1, 3))move_element_click(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;dialog-contentbox&#39;]&#x2F;vframe&#x2F;div&#x2F;div&#x2F;button&quot;) hover元素1234def hover(by, value): element &#x3D; findElement(by, value) ActionChains(browser).move_to_element(element).perform()hover(&quot;xpath&quot;, &#39;&#x2F;&#x2F;tbody[contains(@mx-ie,&quot;mouseover&quot;)]&#x2F;tr[&#39; + str(tr_list.index(tr) + 1) + &#39;]&#39;) 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"selenium","slug":"selenium","permalink":"http://onejane.github.io/tags/selenium/"}]},{"title":"JS逆向之红岭创投encryption","slug":"JS逆向之红岭创投encryption","date":"2021-04-19T07:13:48.000Z","updated":"2021-04-19T13:10:02.468Z","comments":true,"path":"2021/04/19/JS逆向之红岭创投encryption/","link":"","permalink":"http://onejane.github.io/2021/04/19/JS%E9%80%86%E5%90%91%E4%B9%8B%E7%BA%A2%E5%B2%AD%E5%88%9B%E6%8A%95encryption/","excerpt":"","text":"https://sso.my089.com/sso/login 抓包登录url： POST https://sso.my089.com/sso/login 参数： 12345678910111213username: 15806204095phone: encryption: e10adc3949ba59abbe56e057f20f883epassword: password2: randomPageId: dc88cc75d91f4ecaa519f232a9a66361checkCode: 4ctksession_kept: 30loginCategory: 0back_url: app_key: 16ae450f970448619c3ce7193982089eltcc: requestId: my089-21041920-0757-0529-1535-632509802406 分析搜索sso/login，进入了html页面，点击登录或者回车跳转到loginSubmit方法 搜索loginSubmit 加密方法在jQuery.md5.js中，将js整个拷出，修改得到md5方法，完成encryption的解密。 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之万创帮sign","slug":"JS逆向之万创帮sign","date":"2021-04-18T03:46:33.000Z","updated":"2021-04-18T04:52:51.540Z","comments":true,"path":"2021/04/18/JS逆向之万创帮sign/","link":"","permalink":"http://onejane.github.io/2021/04/18/JS%E9%80%86%E5%90%91%E4%B9%8B%E4%B8%87%E5%88%9B%E5%B8%AEsign/","excerpt":"","text":"https://m.wcbchina.com/invite/invite.html 抓包注册urlPOST https://m.wcbchina.com/api/userRegister/registerByInvite?rnd=0.5886187290129845 参数{“auth”:{“timestamp”:1618717702730,”sign”:”81D4F3A45B3202E33971304201135FE5”},”phone”:”15806204095”,”validateCode”:”123”,”inviteCode”:””} 分析搜索userRegister/registerByInvite，进入函数中，打上断点，发起注册请求，此刻的参数中害没有出现加密参数sign，postJson时传递了一个大json数据包括参数service,data和方法success,error 进入postJson方法，发现重组了请求地址，这就是为什么搜索api/userRegister/registerByInvite不到的原因 跟进A(a)函数，发现其中的h对象中是data参数有W()构成，W()正是构成sign的关键函数","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之5173password","slug":"JS逆向之5173password","date":"2021-04-17T02:10:40.000Z","updated":"2021-04-18T03:36:09.493Z","comments":true,"path":"2021/04/17/JS逆向之5173password/","link":"","permalink":"http://onejane.github.io/2021/04/17/JS%E9%80%86%E5%90%91%E4%B9%8B5173password/","excerpt":"","text":"https://passport.5173.com/?returnUrl=http%3a%2f%2fwww.5173.com%2f 抓包登录URL： POST https://passport.5173.com/?returnUrl=http%3A//www.5173.com/ 参数： 123456789smsLogin: 0userName: 15806204095password: 6a771c7ecf7ebe2c3d4c0075cdb96ae5mobileNo: smsCaptcha: category: passpod: __validationToken__: 1680e6a3947c43aea45d83e69b0d7291__validationDna__: 分析password有32位，有可能是md5 搜索md5，出现的地方太多了，懒得看，放弃 点击登录按钮，肯定触发事件发送请求，搜索submit-btn无效，搜索tnSubmit加上断点 点击登录按钮时，果然断在了这个function中，不过此刻Network面板的请求包已经发送出去了，gg了 在加密password时肯定要获取该输入框的值，通过id获取元素的话，我们搜索#txtPass在所出现的位置都打上断点 点击登录时查看Network已经拦截在了ValidateSlide请求，还没有到登录请求 查看断点时先打印o为aec712a02d8c835b92369e5d7e5494cf,并直接跳到return $[[&quot;ajax&quot;]]处，查看此时提交的data中的a[[&quot;serialize&quot;]]()为&quot;smsLogin=0&amp;userName=15806204095&amp;password=aec712a02d8c835b92369e5d7e5494cf&amp;mobileNo=&amp;smsCaptcha=&amp;category=&amp;passpod=&amp;__validationToken__=31004cd552c94687ba27d1c7258576f7&amp;__validationDna__=&quot;,其中的password就是之前打印的o参数。 这个o参数往上追溯是onsubmit: function(f, o)中作为第二个参数o传递进来的，通过调用的堆栈查看上一级调用方法submitHandle submitHandler这段代码中a.usingTpm || a.passwordHash是true，那么这个c就是通过a.getPassword(a.pkey)获取。 进入getPassword后，this.ready &amp;&amp; this.activeTpm &amp;&amp; this.usingTpm为false，必然进入的是else中的c = hex_md5(hex_md5(c).substr(8, 16) + a);实现加密。 (c = b(&quot;#&quot; + this.passwordControlId).val()) &amp;&amp; this.passwordHash赋值必然是true，其中(c = b(&quot;#&quot; + this.passwordControlId).val())的结果为123456，即我们输入的密码，由于传入的a为42m2gl，那么加密逻辑整理为c = hex_md5(hex_md5(&quot;123456&quot;).substr(8, 16) + &quot;42m2gl&quot;) 那么问题来了，传入的a是哪里来的，通过搜索42m2gl，原来每次页面生成的时候页面会加载PasswordKey，通过PasswordKey和SecurityToken等key实现相互验证进行校验。 validationToken这个字段6b16902a6b134dc9a2c333b965c9405f在请求里面无法搜到是因为页面已经刷新，通过fiddler抓包https://passport.5173.com/?returnUrl=http%3a%2f%2fwww.5173.com%2f历史可以看到首页加载时传入该参数 爬虫实现首次先请求https://passport.5173.com/?returnUrl=http%3a%2f%2fwww.5173.com%2f 获取页面中的PasswordKey的值和SecurityToken的值，通过两次md5密码hex_md5(hex_md5(&quot;123456&quot;).substr(8, 16) + &quot;42m2gl&quot;)拿到password加密结果。","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"JS逆向之金逸电影params","slug":"JS逆向之金逸电影params","date":"2021-04-17T00:10:27.000Z","updated":"2021-04-17T02:13:15.751Z","comments":true,"path":"2021/04/17/JS逆向之金逸电影params/","link":"","permalink":"http://onejane.github.io/2021/04/17/JS%E9%80%86%E5%90%91%E4%B9%8B%E9%87%91%E9%80%B8%E7%94%B5%E5%BD%B1params/","excerpt":"","text":"http://www.jycinema.com/wap/#/register 抓包登录url: POST http://www.jycinema.com/frontUIWebapp/appserver/photoMessageService/newsSendMessage 参数： params:ey622Jt557b2114Jp469bG373VO310dW8741i248ZX535Ii076Oi988Ix997NT571gw811Nj907Iw911ND991A5893NS763Is198In627Nl690bm498RU398eX141Bl991Ij727oi670cm475Vn649Ii854wi037Y2151hh831bm4625l109bE023lk146Ij946o3769LC284Jj066aG622Fu333bm353Vs667Q26149k642ZS856I6624Ik524ow241MD637A1091Ii342wi356bW787Vt825Ym215Vy105SW604Qi506Oi857Ii850fQ497==152 分析ey开头是base64中的{，fq是base64中的}，有可能是base64加密 搜索photoMessageService/newsSendMessage 定义了sendMg属性，那么必定被调用才发起请求，搜索.sendMg 点击获取验证码,请求参数中$scope.registerData.tel就是我们提交的手机号，那么加密必然是在getData中 跟进getData后对params进行处理生成{&quot;mobileNumber&quot;:&quot;15806204095&quot;,&quot;sendType&quot;:&quot;reg&quot;,&quot;channelId&quot;:7,&quot;channelCode&quot;:&quot;J0005&quot;,&quot;memberId&quot;:&quot;&quot;} 并发现了密码加密的函数，在下方通过$rootScope.getEncryption(params.params)调用生成密码。 由于Base64.encode有utf-8乱码问题，无法直接使用，var re_btou = new RegExp([&quot;[À-ß][-¿]&quot;, &quot;[à-ï][-¿]{2}&quot;, &quot;[ð-÷][-¿]{3}&quot;].join(&quot;|&quot;),&quot;g&quot;);通过base64.js源码提供Base64.encode(value)实现params加密关键函数getEncryption。 爬虫实现由于个人的js学的太孬了，在python调用js时报错execjs._exceptions.ProgramError: ReferenceError: Base64 is not defined,那么我只能避开，使用python实现base64加密并作为参数传入调用getEncryption。 1234567891011121314151617181920212223242526272829303132import jsonimport requestsimport execjsimport base64from requests_toolbelt import MultipartEncoderusername &#x3D; &quot;15806204095&quot;psssword &#x3D; &quot;123456&quot;with open(r&#39;jy_params.js&#39;, encoding&#x3D;&#39;utf-8&#39;, mode&#x3D;&#39;r&#39;) as f: JsData &#x3D; f.read()param &#x3D; &#123;&quot;mobileNumber&quot;: &quot;15806204095&quot;, &quot;sendType&quot;: &quot;reg&quot;, &quot;channelId&quot;: 7, &quot;channelCode&quot;: &quot;J0005&quot;, &quot;memberId&quot;: &quot;&quot;&#125;val &#x3D; base64.b64encode(json.dumps(param).encode())params &#x3D; execjs.compile(JsData).call(&#39;getEncryption&#39;, val.decode())print(params)headers &#x3D; &#123; &#39;Accept&#39;: &#39;application&#x2F;json, text&#x2F;plain, *&#x2F;*&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept-Language&#39;: &#39;zh-CN,zh;q&#x3D;0.9&#39;, &#39;Content-Length&#39;: &#39;341&#39;, &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8&#39;, &#39;Cookie&#39;: &#39;JSESSIONID&#x3D;DD188088D4E4EAC0098C9CCBCC32E52F; Hm_lvt_62d04228e1f84e012c1d9c0227f722c3&#x3D;1618618136; Hm_lpvt_62d04228e1f84e012c1d9c0227f722c3&#x3D;1618618136&#39;, &#39;Host&#39;: &#39;www.jycinema.com&#39;, &#39;Origin&#39;: &#39;http:&#x2F;&#x2F;www.jycinema.com&#39;, &#39;Proxy-Connection&#39;: &#39;keep-alive&#39;, &#39;Referer&#39;: &#39;http:&#x2F;&#x2F;www.jycinema.com&#x2F;wap&#x2F;&#39;, &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Linux; Android 6.0; Nexus 5 Build&#x2F;MRA58N) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;90.0.4430.72 Mobile Safari&#x2F;537.36&#39;,&#125;data &#x3D; &#123;&#39;params&#39;: params&#125;r &#x3D; requests.post(&quot;http:&#x2F;&#x2F;www.jycinema.com&#x2F;frontUIWebapp&#x2F;appserver&#x2F;photoMessageService&#x2F;newsSendMessage&quot;, data, headers&#x3D;headers)print(r.text) {“msg”:”短信发送成功”,”count”:0,”status”:”S”} 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"违法应用fulao2取证分析","slug":"违法应用fulao2取证分析","date":"2021-04-15T00:08:51.000Z","updated":"2021-04-21T14:33:33.262Z","comments":true,"path":"2021/04/15/违法应用fulao2取证分析/","link":"","permalink":"http://onejane.github.io/2021/04/15/%E8%BF%9D%E6%B3%95%E5%BA%94%E7%94%A8fulao2%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/","excerpt":"","text":"vip破解adb install -r -t fulao2.apk 通过jadx查询已经被混淆 hookEvent.js实现trace系统框架库android.view.View快速定位关键代码，trace所有的mOnClickListener，hook它们的onClick函数，实现点到哪里，定位到哪个类的功能。 前台运行fulao2.apk后，frida -UF -l hookEvent.js 启动hook 清晰度切换点击切换高清标清按钮，触发了发现在q0时的com.ilulutv.fulao2.film.l$t类，根据获取的类名进入jadx中搜索t，实现bool判断，下面我们手动将内存中的q0改成true。 12345pyenv local 3.8.0 objection -g com.ilulutv.fulao2 explore -P ~&#x2F;.objection&#x2F;pluginsplugin wallbreaker classdump --fullname com.ilulutv.fulao2.film.l\\$tplugin wallbreaker objectsearch com.ilulutv.fulao2.film.l\\$tplugin wallbreaker objectdump --fullname 0x26a2 获取到com.ilulutv.fulao2.film.l的对象实例 1plugin wallbreaker objectdump --fullname 0x2406 拿到内存中的对象数据 通过内存漫游修改q0的False的默认值，frida -UF -l fulao2.js 1234567891011121314151617181920212223function hookq0()&#123; Java.perform(function()&#123; Java.choose(&quot;com.ilulutv.fulao2.film.l&quot;,&#123; onMatch:function(ins)&#123; if(ins.e0.value)&#123; ins.q0.value &#x3D; true &#x2F;* if(ins.e0.value.toString().indexOf(&quot;宝宝睡&quot;)&gt;0)&#123; console.log(&quot;e0 value is :&quot;, ins.e0.value); &#x2F;&#x2F;ins.q0.value &#x3D; Java.use(&quot;java.lang.Boolean&quot;).\\$new(&quot;true&quot;); &#x2F;&#x2F;ins.q0.value &#x3D; true &#125; *&#x2F; &#125; &#125;,onComplete:function()&#123; console.log(&quot;search complete!&quot;) &#125; &#125;) &#125;)&#125;setImmediate(hookq0) android hooking search classes Boolean 获取Boolean类全路径java.lang.Boolean 重新调用plugin wallbreaker objectdump –fullname 0x2406 查看q0的值 这样就实现了标清切换高清的功能，破解了vip的切换视频清晰度。这种基于本地代码判断容易破解，基于服务器判断就只能根据逻辑漏洞判断。可以通过setInterval实现不断在内存循环调用，将内存中所有实例的q0改成true。 线路切换frida -UF -l hookEvent.js attach模式 frida -U -f com.ilulutv.fulao2 -l hookEvent.js –no-pause spawn模式一开始把所有View的OnClick类hook上，不用从内存中枚举 点击线路切换按钮，触发了com.ilulutv.fulao2.film.l$s和com.ilulutv.fulao2.film.l$m类方法 通过jadx查看这两个类方法 由于com.ilulutv.fulao2.film.l$s和之前的com.ilulutv.fulao2.film.l$t类似，都是以q0判断，不过没有生效，现在关注com.ilulutv.fulao2.film.l$m中的OnClick里的i方法 查看jadx的i方法 进入g()方法 通过hook androidx.fragment.app.Fragment.g方法，点击切换高清1的线路按钮，触发并返回了调用栈 登录抓包frida -UF -l hookSocket.js -o login.txt 所有内容包括手机号全部加密，除了一些请求头，gzip协议头关键字是1f 8b ，包括视频 图片都是加密的 图片下载12android hooking search classes ImageViewplugin wallbreaker objectsearch android.widget.ImageView 1234plugin wallbreaker classsearch bitmapandroid hooking search classes bitmap 将所有相关类保存到file.txt中，sed -i -e &#39;s&#x2F;^&#x2F;android hooking watch class &#x2F;&#39; file.txtobjection -g com.ilulutv.fulao2 explore -c file.txt 批量hookplugin wallbreaker objectsearch android.graphics.Bitmap Java.choose属于内存的搜刮，将现有内存的Bigmap对象实例保存，基于hook的话可以将未来持续增长的setInterval定时保存一份内存中的图片setInterval(main,5*1000) 1android hooking watch class_method android.graphics.BitmapFactory.decodeByteArray --dump-args --dump-backtrace --dump-return 通过批量hook拿到下拉触发的方法进行hook打印堆栈，glide是流式图片展示的框架 通过jadx搜索com.ilulutv.fulao2.other.helper.glide.b.a，decodeByteArray应该是解密开始了，返回b2应该就是明文。 开始hook Base64系统库，因为系统库不可能被混淆，下拉加载图片发现确实经过了android.util.Base64.encodeToString 1android hooking watch class_method android.util.Base64.encodeToString --dump-args --dump-backtrace --dump-return frida -UF -l fulao2.js -o /root/raw.txt 通过hook发现Base64.encodeToString得到的和SSLOutputStream得到的数据流一致 12345678910111213141516171819202122232425262728293031323334353637function hookImageByteCiphered()&#123; # 传输中的流 Java.perform(function()&#123; Java.use(&quot;android.util.Base64&quot;).encodeToString.overload(&#39;[B&#39;, &#39;int&#39;).implementation &#x3D; function(bytearray,int)&#123; var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;IMAGE DATA:bytearray,int&#x3D;&gt;&quot;,ByteString.of(bytearray).hex(),int) var result &#x3D; this.encodeToString(bytearray,int) return result; &#125; &#125;)&#125;function hook_SSLsocketandroid8()&#123; Java.perform(function()&#123; console.log(&quot;hook_SSLsocket&quot;) Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket\\$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTPS write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;HTTPS bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) &#x2F;&#x2F;console.log(jhexdump(bytearry,int1,int2)); console.log(jhexdump(bytearry)); return result; &#125; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket\\$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTPS read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;HTTPS bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) &#x2F;&#x2F;console.log(jhexdump(bytearry,int1,int2)); &#x2F;&#x2F;console.log(jhexdump(bytearry)); return result; &#125; &#125;)&#125; 说明com.ilulutv.fulao2.other.i.b.a((ByteBuffer) obj)确实是https传输的流，也是加密前的流，ffd8ff 是png文件头，通过后面的代码实现解密。 12android hooking search classes BitmapFactoryandroid hooking watch class_method android.graphics.BitmapFactory.decodeByteArray --dump-args --dump-backtrace --dump-return 开始hook BitmapFactory.decodeByteArray(b2, 0, b2.length) frida -UF -l fulao2.js 12345678910111213141516171819202122function hookImage()&#123; Java.perform(function()&#123; Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory\\$Options&#39;) .implementation &#x3D; function(data, offset, length, opts)&#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); &#x2F;&#x2F;console.log(&quot;data, offset, length, opts&#x3D;&gt;&quot;,data, offset, length, opts) &#x2F;&#x2F;console.log(&quot;IMAGE DATA:bytearray,int&#x3D;&gt;&quot;,ByteString.of(data).hex()) var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot;+guid()+&quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;,path) var file &#x3D; Java.use(&quot;java.io.File&quot;).\\$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).\\$new(file); fos.write(data); fos.close(); fos.close(); return result; &#125; &#125;)&#125; python调用保存fulao2.js 将解密后的字节数组发送给python，二进制写入图片 12345678910function hookImage()&#123; Java.perform(function()&#123; Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory\\$Options&#39;) .implementation &#x3D; function(data, offset, length, opts)&#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); send(data) return result; &#125; &#125;)&#125; 调用fulao2.js发送到本机 123456789101112131415161718192021222324252627282930313233343536373839import fridaimport jsonimport timeimport uuidimport base64import redef my_message_handler(message, payload): print(message) print(payload) if message[&quot;type&quot;] &#x3D;&#x3D; &quot;send&quot;: print(message[&quot;payload&quot;]) #image &#x3D; re.findall(&quot;(-?\\d+)&quot;, message[&quot;payload&quot;]) image &#x3D; message[&quot;payload&quot;] intArr &#x3D; [] for m in image: ival &#x3D; int(m) if ival &lt; 0: ival +&#x3D; 256 intArr.append(ival) bs &#x3D; bytes(intArr) fileName &#x3D; str(uuid.uuid1()) + &quot;.jpg&quot; f &#x3D; open(fileName,&#39;wb&#39;) f.write(bs) f.close() device &#x3D; frida.get_usb_device()target &#x3D; device.get_frontmost_application()session &#x3D; device.attach(target.pid)# 加载脚本with open(&quot;fulao2.js&quot;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot; , my_message_handler) #调用错误处理script.load()# 脚本会持续运行等待输入input() 不能够以战术的勤奋，掩盖战略的懒惰。 大多数人努力的程度还谈不上拼天分。 脱机二进制写入图片12objection -g com.ilulutv.fulao2 explore -P ~&#x2F;.objection&#x2F;pluginsandroid hooking watch class_method android.graphics.BitmapFactory.decodeByteArray --dump-args --dump-backtrace --dump-return hook解密方法，下拉获取调用栈 jadx搜索com.ilulutv.fulao2.other.helper.glide.b.a，抓包抓到的二进制数据流是encodeToString之前的b.a返回的数据，可以将协议中内容直接解密，不需要app参与，可以直接hook收发包 1android hooking watch class_method com.ilulutv.fulao2.other.i.b.a --dump-args --dump-backtrace --dump-return 下拉加载图片，关注Hooking com.ilulutv.fulao2.other.i.b.a(java.nio.ByteBuffer)，可以看到其他协议的解密也通过这个方法 由于返回是[object Object]，看不出结果还是通过hook实现吧。尽量不要用hookImageByteCiphered，因为其他类可能也用到了Base64 12345678910function hookImageByteCiphered() &#123; Java.perform(function () &#123; Java.use(&quot;android.util.Base64&quot;).encodeToString.overload(&#39;[B&#39;, &#39;int&#39;).implementation &#x3D; function (bytearray, int) &#123; var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;IMAGE DATA:bytearray,int&#x3D;&gt;&quot;, ByteString.of(bytearray).hex(), int) var result &#x3D; this.encodeToString(bytearray, int) return result; &#125; &#125;)&#125; 通过hook ByteBuffer获取com.ilulutv.fulao2.other.i.b.a 的入参实现hook com.ilulutv.fulao2.other.i.b.a((ByteBuffer) obj) 12345678910111213function hookByteBuffer() &#123; Java.perform(function () &#123; Java.use(&quot;com.ilulutv.fulao2.other.i.b&quot;).a.overload(&#39;java.nio.ByteBuffer&#39;).implementation &#x3D; function (bf) &#123; var result &#x3D; this.a(bf) &#x2F;&#x2F; [b &#x2F;&#x2F;var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) &#x2F;&#x2F;console.log(&quot;result is &#x3D;&gt; &quot;,result); send(result) &#x2F;&#x2F;console.log( gson.$new().toJson(result)) return result; &#125; &#125;)&#125; frida -UF -l fulao2.js 下拉显示图片，将打印返回的字节数组的结果，通过python实现解密后结果用于脱机处理。 通过hook byte[] b2 = com.ilulutv.fulao2.other.i.b.b(decode, Base64.decode(bytes2, 0), encodeToString);中的com.ilulutv.fulao2.other.i.b.b android hooking list class_methods com.ilulutv.fulao2.other.i.b 获取需要hook的方法 android hooking watch class_method net.idik.lib.cipher.so.CipherClient.decodeImgKey –dump-args –dump-backtrace –dump-return 获取hook的返回 android hooking search classes base64 获取android.util.Base64方法 123456789101112131415function hookdecodeimgkey() &#123; Java.perform(function () &#123; var base64 &#x3D; Java.use(&quot;android.util.Base64&quot;) Java.use(&quot;com.ilulutv.fulao2.other.i.b&quot;).b.overload(&#39;[B&#39;, &#39;[B&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function (key, iv, image) &#123; var result &#x3D; this.b(key, iv, image); console.log(&quot;key&quot;, base64.encodeToString(key, 0)); console.log(&quot;iv&quot;, base64.encodeToString(iv, 0)); return result; &#125; &#125;) &#x2F;* key svOEKGb5WD0ezmHE4FXCVQ&#x3D;&#x3D; iv 4B7eYzHTevzHvgVZfWVNIg&#x3D;&#x3D; *&#x2F;&#125; frida -UF -l fulao2.js 下拉加载图片 查看加密方式com.ilulutv.fulao2.other.i.b.b python实现解密 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pycrypto 1234567891011121314151617def IMGdecrypt(bytearray): imgkey &#x3D; base64.decodebytes( bytes(&quot;svOEKGb5WD0ezmHE4FXCVQ&#x3D;&#x3D;&quot;, encoding&#x3D;&#39;utf8&#39;)) imgiv &#x3D; base64.decodebytes( bytes(&quot;4B7eYzHTevzHvgVZfWVNIg&#x3D;&#x3D;&quot;, encoding&#x3D;&#39;utf8&#39;)) cipher &#x3D; AES.new(imgkey, AES.MODE_CBC, imgiv) # enStr +&#x3D; (len(enStr) % 4)*&quot;&#x3D;&quot; # decryptByts &#x3D; base64.urlsafe_b64decode(enStr) msg &#x3D; cipher.decrypt(bytearray) def unpad(s): return s[0:-s[-1]] return unpad(msg)# 拿到数据后Base64解密bs &#x3D; IMGdecrypt(bs) 将比较耗性能的加解密计算放到电脑端处理，减少了手机端的资源损耗，实现脱机处理。抓包后直接使用以上算法解码。 查看BitmapFactory.decodeByteArray返回的类型 12android hooking search classes Bitmapandroid hooking list class_methods android.graphics.Bitmap 123456789101112131415161718192021222324function getObjClassName(obj) &#123; if (!jclazz) &#123; var jclazz &#x3D; Java.use(&quot;java.lang.Class&quot;); &#125; if (!jobj) &#123; var jobj &#x3D; Java.use(&quot;java.lang.Object&quot;); &#125; return jclazz.getName.call(jobj.getClass.call(obj));&#125;function hookImage()&#123; Java.perform(function()&#123; Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory$Options&#39;) .implementation &#x3D; function(data, offset, length, opts)&#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) console.log(&quot;result is &#x3D;&gt;&quot;,gson.$new().toJson(result)) &#x2F;&#x2F; 打印BitmapFactory对象属性，说明BitmapFactory.decodeByteArray返回对象 console.log(&quot;className is &#x3D;&gt;&quot;,getObjClassName(result)) console.log(&#39;Object.getOwnPropertyNames()&#x3D;&gt;&#39;,Object.getOwnPropertyNames(result.$className)) return result; &#125; &#125;)&#125; 安卓保存图片12android hooking search classes CompressFormatplugin wallbreaker classdump --fullname android.graphics.Bitmap$CompressFormat frida -UF -l fulao2.js 123456789101112131415161718192021222324function hookImage()&#123; Java.perform(function()&#123; Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory$Options&#39;) .implementation &#x3D; function(data, offset, length, opts)&#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot; + guid() + &quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;, path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); result.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value, 100, fos) console.log(&quot;success!&quot;) fos.flush(); fos.close(); return result; &#125; &#125;)&#125; 多线程保存创建线程com.onejane.runnable，android hooking search classes onejane 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788function hookImage() &#123; Java.perform(function () &#123; var Runnable &#x3D; Java.use(&quot;java.lang.Runnable&quot;); var saveImg &#x3D; Java.registerClass(&#123; name: &quot;com.onejane.runnable&quot;, implements: [Runnable], fields: &#123; bm: &quot;android.graphics.Bitmap&quot;, &#125;, methods: &#123; $init: [&#123; returnType: &quot;void&quot;, argumentTypes: [&quot;android.graphics.Bitmap&quot;], implementation: function (bitmap) &#123; this.bm.value &#x3D; bitmap; &#125; &#125;], run: function () &#123; var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot; + guid() + &quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;, path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); this.bm.value.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value, 100, fos) console.log(&quot;success!&quot;) fos.flush(); fos.close(); &#125; &#125; &#125;); Java.use(&quot;android.graphics.BitmapFactory&quot;).decodeByteArray.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;, &#39;android.graphics.BitmapFactory$Options&#39;).implementation &#x3D; function (data, offset, length, opts) &#123; var result &#x3D; this.decodeByteArray(data, offset, length, opts); var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); &#x2F;&#x2F;var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) &#x2F;&#x2F;send(data) &#x2F;&#x2F;send(gson.$new().toJson(data)) &#x2F;&#x2F;console.log(&quot;data, offset, length, opts&#x3D;&gt;&quot;,data, offset, length, opts) &#x2F;&#x2F;console.log(&quot;IMAGE DATA:bytearray,int&#x3D;&gt;&quot;,ByteString.of(data).hex()) &#x2F;* var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot;+guid()+&quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;,path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); fos.write(data); fos.flush(); fos.close(); *&#x2F; &#x2F;*var gson &#x3D; Java.use(&#39;com.google.gson.Gson&#39;) console.log(&quot;result is &#x3D;&gt;&quot;,gson.$new().toJson(result)) # 打印BitmapFactory对象属性，说明BitmapFactory.decodeByteArray返回 console.log(&quot;className is &#x3D;&gt;&quot;,getObjClassName(result)) console.log(&#39;Object.getOwnPropertyNames()&#x3D;&gt;&#39;,Object.getOwnPropertyNames(result.$className))*&#x2F; &#x2F;* var path &#x3D; &quot;&#x2F;sdcard&#x2F;Download&#x2F;tmp&#x2F;&quot; + guid() + &quot;.jpg&quot; console.log(&quot;path&#x3D;&gt; &quot;, path) var file &#x3D; Java.use(&quot;java.io.File&quot;).$new(path) var fos &#x3D; Java.use(&quot;java.io.FileOutputStream&quot;).$new(file); result.compress(Java.use(&quot;android.graphics.Bitmap$CompressFormat&quot;).JPEG.value, 100, fos) console.log(&quot;success!&quot;) fos.flush(); fos.close(); *&#x2F; var runnable &#x3D; saveImg.$new(result); runnable.run() return result; &#125; &#125;)&#125; so分析CipherClient类中所有的返回都是CipherCore.get 而CipherCore又加载了cipher-lib的so库 1234objection -g com.ilulutv.fulao2 explore -P ~&#x2F;.objection&#x2F;pluginsmemory list modules 搜索cipher-libls -alt &#x2F;data&#x2F;app&#x2F;com.ilulutv.fulao2-6tvMrrptF1h1A4NvQbV85A&#x3D;&#x3D;&#x2F;lib&#x2F;arm&#x2F;memory list exports libcipher-lib.so 查看该so中有哪些导出函数 其中的getString对应了private static native String getString(String str); 1cp libcipher-lib.so &#x2F;sdcard&#x2F;Download&#x2F; 取出so后丢到IDA中分析 通过jnitrace trace下所有native的执行流。 1234.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs1428arm64 pyenv local 3.8.5pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple jnitracejnitrace -m attach -l libcipher-lib.so com.ilulutv.fulao2 下拉加载图片 查看trace的调用栈,默认是spawn so层再次调用java层方法AESEncryptor 1android hooking watch class net.idik.lib.cipher.so.encrypt.AESEncryptor 下拉图片加载，虽然到native进行转化，但是啥也没干，重新从java层调用加解密 由于每次hook时app总是崩掉，objection在app启动时直接执行hook方法 1objection -g com.ilulutv.fulao2 explore -P ~&#x2F;.objection&#x2F;plugins -s &quot;android hooking watch class_method net.idik.lib.cipher.so.encrypt.AESEncryptor.decrypt --dump-args --dump-backtrace --dump-return&quot; 堆栈说明确实从native层到了java层","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"js逆向之爱拍password","slug":"js逆向之爱拍password","date":"2021-04-13T02:33:44.000Z","updated":"2021-04-15T00:07:46.020Z","comments":true,"path":"2021/04/13/js逆向之爱拍password/","link":"","permalink":"http://onejane.github.io/2021/04/13/js%E9%80%86%E5%90%91%E4%B9%8B%E7%88%B1%E6%8B%8Dpassword/","excerpt":"","text":"http://www.aipai.com/ 抓包登录url： POST http://www.aipai.com/login.php 参数： 123456action: loginNewuser: 15806204095password: 202cb962ac59075b964b07152d234b70keeplogin: 1comouterTime: 1userNowTime: 1618281089 分析参数中只有password加密，搜索/login.php,出现在了sea.js,header.js?t=20210312,global.js的多个地方中 逐步分析各个位置的/login.php,初步定位到两个地方的js处可能是加密password 的位置，因为这两处附近都有user,action等其他参数生成。 这两处同样的通过md5函数加密password所在id的内容，我们为这两处加上断点，重新登录发现停在了header.js?t=20210312 F10单步逐行跳过到metadata=&#39;action=&#39;+ action +&#39;&amp;account=&#39;+ user +&#39;&amp;password=&#39;+ _ts.md5(pass) +&#39;&amp;keeplogin=&#39;+ keep +&#39;&amp;comouterTime=&#39;+ keep +&#39;&amp;userNowTime=&#39;+ userNowTime; 通过Watch面板拿到idPass，pass和_ts.md5(pass)的值 点击进入md5方法，打上断点后，F9单步跳入后抠出md5算法js 爬虫实现通过python调用js实现password的逆向分析。 1234567891011121314151617181920import requestsimport execjsusername &#x3D; &quot;15806204095&quot;password &#x3D; &quot;123&quot;with open(r&#39;aipai_password.js&#39;, encoding&#x3D;&#39;utf-8&#39;, mode&#x3D;&#39;r&#39;) as f: JsData &#x3D; f.read()password &#x3D; execjs.compile(JsData).call(&#39;pwd&#39;, password)print(password)data &#x3D; &#123; &#39;action&#39;: &#39;loginNew&#39;, &#39;user&#39;: username, &#39;password&#39;: password, &#39;keeplogin&#39;: &#39;1&#39;, &#39;comouterTime&#39;: &#39;1&#39;, &#39;userNowTime&#39;: &#39;1618281089&#39;,&#125;r &#x3D; requests.post(&quot;http:&#x2F;&#x2F;www.aipai.com&#x2F;login.php&quot;, data)print(r.text) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"js逆向之拉勾password","slug":"js逆向之拉勾password","date":"2021-04-12T11:43:44.000Z","updated":"2021-04-15T00:07:45.997Z","comments":true,"path":"2021/04/12/js逆向之拉勾password/","link":"","permalink":"http://onejane.github.io/2021/04/12/js%E9%80%86%E5%90%91%E4%B9%8B%E6%8B%89%E5%8B%BEpassword/","excerpt":"","text":"https://www.lagou.com/ 抓包登录url: GET https://passport.lagou.com/login/login.json 参数： 1234567jsoncallback: jQuery11130510950445912626_1618227551741isValidate: trueusername: 15806204095password: 990eb670f81e82f546cfaaae1587279arequest_form_verifyCode: challenge: c7a96a290ed4d75ca2a8bf139172dbe0_: 1618227551745 分析参数中password和challenge看起来是加密参数，其实challenge是极验验证码请求的参数，本文针对password进行参数分析，暂时先不做讨论。 搜索login/login.json并格式化js后，发现改password通过md5实现加密，在Watch界面输入g查看g的内容 放行程序后，在g.isValidate &amp;&amp; (g.password = md5(g.password)处重新打上断点并登录 那么分析得出password=md5(“veenike”+md5(passwrod)+”veenike”) 爬虫实现12345678910import requestsfrom hashlib import md5username &#x3D; &#39;15806204095&#39;pwd &#x3D; &#39;123&#39;md5_pwd &#x3D; md5((&quot;veenike&quot; + md5(pwd.encode(&#39;utf8&#39;)).hexdigest() + &quot;veenike&quot;).encode(&quot;utf8&quot;)).hexdigest()print(md5_pwd)url &#x3D; &#39;https:&#x2F;&#x2F;passport.lagou.com&#x2F;login&#x2F;login.json?jsoncallback&#x3D;jQuery111306946515748870927_1618229101639&amp;isValidate&#x3D;true&amp;username&#x3D;&#39;+username+&#39;&amp;password&#x3D;+&#39;+md5_pwd+&#39;+&amp;request_form_verifyCode&#x3D;&amp;challenge&#x3D;c3bebcad0648898aa58cb3f4dbf2f820&amp;_&#x3D;1618229101642&#39;r &#x3D;requests.get(url)print(r.text) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"js逆向之中关村在线pwd","slug":"js逆向之中关村在线pwd","date":"2021-04-12T03:19:07.000Z","updated":"2021-04-15T00:07:45.969Z","comments":true,"path":"2021/04/12/js逆向之中关村在线pwd/","link":"","permalink":"http://onejane.github.io/2021/04/12/js%E9%80%86%E5%90%91%E4%B9%8B%E4%B8%AD%E5%85%B3%E6%9D%91%E5%9C%A8%E7%BA%BFpwd/","excerpt":"","text":"https://www.zol.com.cn/ 抓包本登录页面既然是框架，找到php页面，https://service.zol.com.cn/user/siteLogin.php?type=small&amp;callback=userLoginCallback&amp;backurl=https://www.zol.com.cn/ 直接访问该php网址，避免其他请求干扰分析 登录url: POST https://service.zol.com.cn/user/ajax/siteLogin/login.php 请求头： 12345678910111213141516:authority: service.zol.com.cn:method: POST:path: &#x2F;user&#x2F;ajax&#x2F;siteLogin&#x2F;login.php:scheme: httpsaccept: application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01accept-encoding: gzip, deflate, braccept-language: zh-CN,zh;q&#x3D;0.9content-length: 138content-type: application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8cookie: ip_ck&#x3D;5cKC7&#x2F;vxj7QuMjUzODE2LjE2MTgxOTc3OTM%3D; lv&#x3D;1618197793; vn&#x3D;1; Hm_lvt_ae5edc2bc4fc71370807f6187f0a2dd0&#x3D;1618197793; questionnaire_pv&#x3D;1618185602; Hm_lpvt_ae5edc2bc4fc71370807f6187f0a2dd0&#x3D;1618197883origin: https:&#x2F;&#x2F;service.zol.com.cnreferer: https:&#x2F;&#x2F;service.zol.com.cn&#x2F;user&#x2F;siteLogin.php?type&#x3D;small&amp;callback&#x3D;userLoginCallback&amp;backurl&#x3D;https:&#x2F;&#x2F;www.zol.com.cn&#x2F;sec-fetch-mode: corssec-fetch-site: same-originuser-agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;78.0.3904.70 Safari&#x2F;537.36x-requested-with: XMLHttpRequest 参数： 1234567userid: 15806204096pwd: 74ce2ba17b2c218246e778fb5e895c95isAuto: 1backurl: http:&#x2F;&#x2F;www.zol.com.cn&#x2F;tmallBtn: 0activeBtn: 0headPicid: 0 分析全局搜索siteLogin/login.php 中关村非常的耿直，加密使用md5,var md5Password = CryptoJS.MD5(password+&quot;zol&quot;) + &#39;&#39;;输入123提交的pwd为74ce2ba17b2c218246e778fb5e895c95，通过md5比对 爬虫实现拷贝Form Data到请求头加引号.py中自动生成dict格式 12345678910111213141516171819import requestsfrom hashlib import md5username &#x3D; &#39;15806204095&#39;pwd &#x3D; &#39;123&#39;md5_pwd &#x3D; md5((pwd + &#39;zol&#39;).encode(&#39;utf8&#39;)).hexdigest()print(md5_pwd)url &#x3D; &#39;https:&#x2F;&#x2F;service.zol.com.cn&#x2F;user&#x2F;ajax&#x2F;siteLogin&#x2F;login.php&#39;data &#x3D; &#123; &#39;userid&#39;: username, &#39;pwd&#39;: md5_pwd, &#39;isAuto&#39;: &#39;1&#39;, &#39;backurl&#39;: &#39;http:&#x2F;&#x2F;www.zol.com.cn&#x2F;&#39;, &#39;tmallBtn&#39;: &#39;0&#39;, &#39;activeBtn&#39;: &#39;0&#39;, &#39;headPicid&#39;: &#39;0&#39;,&#125;r &#x3D;requests.post(url,data)print(r.text) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"js逆向之融金所sign","slug":"js逆向之融金所sign","date":"2021-04-11T02:20:26.000Z","updated":"2021-04-15T00:07:46.056Z","comments":true,"path":"2021/04/11/js逆向之融金所sign/","link":"","permalink":"http://onejane.github.io/2021/04/11/js%E9%80%86%E5%90%91%E4%B9%8B%E8%9E%8D%E9%87%91%E6%89%80sign/","excerpt":"","text":"https://m.rjs.com/member/user.html#1 抓包登录url: POST https://m.rjs.com/japi/account/login.json 请求头： 12345678910111213141516171819:authority: m.rjs.com:method: POST:path: &#x2F;japi&#x2F;account&#x2F;login.json:scheme: httpsaccept: application&#x2F;json, text&#x2F;plain, *&#x2F;*accept-encoding: gzip, deflate, braccept-language: zh-CN,zh;q&#x3D;0.9content-length: 172content-type: application&#x2F;jsoncookie: riskTipTimes1&#x3D;1; Hm_lvt_7ff1e43d61e6b35b46f6bb33c3aba9bb&#x3D;1618099071; Hm_lpvt_7ff1e43d61e6b35b46f6bb33c3aba9bb&#x3D;1618099071datatype: jsonorigin: https:&#x2F;&#x2F;m.rjs.comreferer: https:&#x2F;&#x2F;m.rjs.com&#x2F;member&#x2F;user.htmlsec-ch-ua: &quot;Google Chrome&quot;;v&#x3D;&quot;89&quot;, &quot;Chromium&quot;;v&#x3D;&quot;89&quot;, &quot;;Not\\&quot;A\\\\Brand&quot;;v&#x3D;&quot;99&quot;sec-ch-ua-mobile: ?1sec-fetch-dest: emptysec-fetch-mode: corssec-fetch-site: same-originUser-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;50.0.2661.87 Safari&#x2F;537.36 参数： 1&#123;&quot;platform&quot;:&quot;wap&quot;,&quot;session_token&quot;:&quot;&quot;,&quot;session_id&quot;:&quot;&quot;,&quot;data&quot;:&#123;&quot;userName&quot;:&quot;15806204085&quot;,&quot;password&quot;:&quot;123&quot;&#125;,&quot;sign&quot;:&quot;b6a20a0b1c82b87d65b78b2943bb3fbc&quot;,&quot;timestamp&quot;:1618099099626&#125; 分析搜索japi/account/login.json 无果 搜索account/login.json 1234567891011121314151617181920loginAction: function() &#123; if (this.checkLoginKey() &amp;&amp; this.checkLoginPwd()) &#123; var e &#x3D; this; c.Common.fajax(&#123; url: &quot;account&#x2F;login.json&quot;, easyOriginData: &#123; userName: e.loginKey, password: e.loginPwd &#125;, success: function(t) &#123; 1 &#x3D;&#x3D; t.status ? (c.Common.cookie.set(&quot;session_token_dp&quot;, t.data.sessionToken, &quot;&#x2F;&quot;, &quot;&#x2F;&quot;, 168), c.Common.cookie.set(&quot;platform&quot;, &quot;wap&quot;, &quot;&#x2F;&quot;, &quot;&#x2F;&quot;, 168), c.Common.localStore.set(&quot;session_token_dp&quot;, t.data.sessionToken), c.Common.localStore.set(&quot;uid_dp&quot;, t.data.uid), c.Common.cookie.set(&quot;secretKey&quot;, t.data.secretKey, &quot;&#x2F;&quot;, &quot;&#x2F;&quot;, 168), c.Common.alert(&quot;simpleSuccess&quot;, &quot;登录成功&quot;, 1, e.goHref, &quot;&#x2F;member-undp&#x2F;index.html&quot;)) : e.alert(t.message) &#125; &#125;) &#125;&#125;, 此时并没有出现sign,说明sign应该是在fajax中生成，进入fajax中，逐步调试，t[&quot;sign&quot;] = i(f + &quot;&amp;&quot; + i(o.genSignData(t.data)) + &quot;&amp;&quot; + d),这一步出现了sign进行填值， f为/account/login.json d是””空字符串 接下来分析i(o.genSignData(t.data))中的o.genSignData(t.data),其中t.data为账户密码的对象 genSignData进入o.genSignData函数，拆分出来js如下 123456789101112131415161718192021222324var genSignData &#x3D; function(e) &#123; var t &#x3D; &quot;&quot; , n &#x3D; []; for (var r in e) n.push(r); n &#x3D; n.sort(); for (var i &#x3D; 0; i &lt; n.length; i++) &#123; var o &#x3D; n[i] , s &#x3D; e[o] , l &#x3D; !1; if (&quot;object&quot; &#x3D;&#x3D; (&quot;undefined&quot; &#x3D;&#x3D; typeof s ? &quot;undefined&quot; : (0, a.default)(s))) &#123; var c &#x3D; &quot;&#123;&quot;; for (var u in s) c +&#x3D; u + &quot;&#x3D;&quot; + s[u] + &quot;, &quot;, l &#x3D; !0; l &amp;&amp; (s &#x3D; c.substring(0, c.length - 2) + &quot;&#125;&quot;) &#125; &quot;sign&quot; !&#x3D; o &amp;&amp; null !&#x3D;&#x3D; s &amp;&amp; void 0 !&#x3D;&#x3D; s &amp;&amp; &quot;&quot; !&#x3D;&#x3D; s &amp;&amp; (&quot;object&quot; !&#x3D; (&quot;undefined&quot; &#x3D;&#x3D; typeof s ? &quot;undefined&quot; : (0, a.default)(s)) || l) &amp;&amp; (t +&#x3D; (0 &#x3D;&#x3D; i ? &quot;&quot; : &quot;&amp;&quot;) + o + &quot;&#x3D;&quot; + s) &#125; return null !&#x3D; t &amp;&amp; &quot;&quot; !&#x3D; t &amp;&amp; &quot;&amp;&quot; &#x3D;&#x3D; t.substr(0, 1) &amp;&amp; (t &#x3D; t.substr(1, t.length)), t&#125; 单独运行时报错Uncaught ReferenceError: a is not defined,打印a.default 进入a.default,该三元运算所得结果即为控制台打印结果，必然前面的是完全匹配的 123 t.default &#x3D; &quot;function&quot; &#x3D;&#x3D; typeof s.default &amp;&amp; &quot;symbol&quot; &#x3D;&#x3D;&#x3D; l(a.default) ? function(e) &#123; return &quot;undefined&quot; &#x3D;&#x3D; typeof e ? &quot;undefined&quot; : l(e)&#125; 该l函数在上面也有定义如下 那么我们定义函数k即a.default如下,替换genSignData完成函数解密password=123&amp;userName=15806204095 123var k &#x3D; function(e)&#123; return&quot;undefined&quot;&#x3D;&#x3D;typeof e?&quot;undefined&quot;: typeof e&#125; i接下来就是i函数的分析，进入i函数 第一次调用i函数时，先调用o函数进行加密，再调用wordsToBytes转成字节，返回bytesToHex生成16进制字符串，整体逻辑理清后先进入o函数 o 该函数中引用了n(694),n(247).utf8,n(974),n(247).bin,通过debug可知以上都生成了加密函数 这些加密函数搜索分别发现出现在了694function，247function等等，可以断定，这些函数其实就是作为变量在o函数中调用 扣出694,247,974的代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293var liu94 &#x3D; function (e, t) &#123; var t &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&quot; , n &#x3D; &#123; rotl: function (e, t) &#123; return e &lt;&lt; t | e &gt;&gt;&gt; 32 - t &#125;, rotr: function (e, t) &#123; return e &lt;&lt; 32 - t | e &gt;&gt;&gt; t &#125;, endian: function (e) &#123; if (e.constructor &#x3D;&#x3D; Number) return 16711935 &amp; n.rotl(e, 8) | 4278255360 &amp; n.rotl(e, 24); for (var t &#x3D; 0; t &lt; e.length; t++) e[t] &#x3D; n.endian(e[t]); return e &#125;, randomBytes: function (e) &#123; for (var t &#x3D; []; e &gt; 0; e--) t.push(Math.floor(256 * Math.random())); return t &#125;, bytesToWords: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0, r &#x3D; 0; n &lt; e.length; n++, r +&#x3D; 8) t[r &gt;&gt;&gt; 5] |&#x3D; e[n] &lt;&lt; 24 - r % 32; return t &#125;, wordsToBytes: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; 32 * e.length; n +&#x3D; 8) t.push(e[n &gt;&gt;&gt; 5] &gt;&gt;&gt; 24 - n % 32 &amp; 255); return t &#125;, bytesToHex: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; e.length; n++) t.push((e[n] &gt;&gt;&gt; 4).toString(16)), t.push((15 &amp; e[n]).toString(16)); return t.join(&quot;&quot;) &#125;, hexToBytes: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; e.length; n +&#x3D; 2) t.push(parseInt(e.substr(n, 2), 16)); return t &#125;, bytesToBase64: function (e) &#123; for (var n &#x3D; [], r &#x3D; 0; r &lt; e.length; r +&#x3D; 3) for (var i &#x3D; e[r] &lt;&lt; 16 | e[r + 1] &lt;&lt; 8 | e[r + 2], a &#x3D; 0; a &lt; 4; a++) 8 * r + 6 * a &lt;&#x3D; 8 * e.length ? n.push(t.charAt(i &gt;&gt;&gt; 6 * (3 - a) &amp; 63)) : n.push(&quot;&#x3D;&quot;); return n.join(&quot;&quot;) &#125;, base64ToBytes: function (e) &#123; e &#x3D; e.replace(&#x2F;[^A-Z0-9+\\&#x2F;]&#x2F;gi, &quot;&quot;); for (var n &#x3D; [], r &#x3D; 0, i &#x3D; 0; r &lt; e.length; i &#x3D; ++r % 4) 0 !&#x3D; i &amp;&amp; n.push((t.indexOf(e.charAt(r - 1)) &amp; Math.pow(2, -2 * i + 8) - 1) &lt;&lt; 2 * i | t.indexOf(e.charAt(r)) &gt;&gt;&gt; 6 - 2 * i); return n &#125; &#125;; return n;&#125;var er47 &#x3D; &#123; utf8: &#123; stringToBytes: function (e) &#123; return er47.bin.stringToBytes(unescape(encodeURIComponent(e))) &#125;, bytesToString: function (e) &#123; return decodeURIComponent(escape(er47.bin.bytesToString(e))) &#125; &#125;, bin: &#123; stringToBytes: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; e.length; n++) t.push(255 &amp; e.charCodeAt(n)); return t &#125;, bytesToString: function (e) &#123; for (var t &#x3D; [], n &#x3D; 0; n &lt; e.length; n++) t.push(String.fromCharCode(e[n])); return t.join(&quot;&quot;) &#125; &#125;&#125;;var jiu74 &#x3D; function (e, t) &#123; function n(e) &#123; return !!e.constructor &amp;&amp; &quot;function&quot; &#x3D;&#x3D; typeof e.constructor.isBuffer &amp;&amp; e.constructor.isBuffer(e) &#125; function r(e) &#123; return &quot;function&quot; &#x3D;&#x3D; typeof e.readFloatLE &amp;&amp; &quot;function&quot; &#x3D;&#x3D; typeof e.slice &amp;&amp; n(e.slice(0, 0)) &#125; return function (e) &#123; return null !&#x3D; e &amp;&amp; (n(e) || r(e) || !!e._isBuffer) &#125;&#125; 在o函数中改写t,r,i,a 1234var t &#x3D; liu94() , r &#x3D; er47.utf8 , i &#x3D; jiu74() , a &#x3D; er47.bin 最终只要将o函数中exports的函数return出来即可 1234567891011res &#x3D; function (e, n) &#123; console.log(e) if (void 0 &#x3D;&#x3D;&#x3D; e || null &#x3D;&#x3D;&#x3D; e) throw new Error(&quot;Illegal argument &quot; + e); var r &#x3D; t.wordsToBytes(o(e, n)); console.log(r) return n &amp;&amp; n.asBytes ? r : n &amp;&amp; n.asString ? a.bytesToString(r) : t.bytesToHex(r)&#125;&#x2F;&#x2F;res(&quot;password&#x3D;123&amp;userName&#x3D;158062204095&quot;, undefined);&#x2F;&#x2F;console.log(&#39;--------&gt;&#39;,res(origin, undefined))return res; 由于o(e,n)中的即为o.genSignData生成的账密参数password=123&amp;userName=15806204095，n为undefined，那么我们就可以直接调用该方法返回真正的sign。 console.log(encrypt()(&quot;/account/login.json&quot;+&quot;&amp;&quot;+encrypt()(genSignData(UP))+&quot;&amp;&quot;+&quot;&quot;)); 查看抓包后的结果如下 爬虫实现12345678910111213import jsonimport requestsimport execjsusername &#x3D; &quot;15806204095&quot;psssword &#x3D; &quot;123&quot;with open(r&#39;rjs_sign.js&#39;, encoding&#x3D;&#39;utf-8&#39;, mode&#x3D;&#39;r&#39;) as f: JsData &#x3D; f.read()sign &#x3D; execjs.compile(JsData).call(&#39;request&#39;,username,psssword)data &#x3D; json.dumps(&#123;&quot;platform&quot;:&quot;wap&quot;,&quot;session_token&quot;:&quot;&quot;,&quot;session_id&quot;:&quot;&quot;,&quot;data&quot;:&#123;&quot;userName&quot;:username,&quot;password&quot;:psssword&#125;,&quot;sign&quot;:sign,&quot;timestamp&quot;:1618153079455&#125;)r &#x3D;requests.post(&quot;https:&#x2F;&#x2F;m.rjs.com&#x2F;japi&#x2F;account&#x2F;login.json&quot;,data)print(r.text) 完整源码请关注微信公众号：ReverseCode，回复：JS逆向","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"hook抓包trace定位实战","slug":"hook抓包trace定位实战","date":"2021-04-10T02:54:10.000Z","updated":"2021-04-10T02:54:10.441Z","comments":true,"path":"2021/04/10/hook抓包trace定位实战/","link":"","permalink":"http://onejane.github.io/2021/04/10/hook%E6%8A%93%E5%8C%85trace%E5%AE%9A%E4%BD%8D%E5%AE%9E%E6%88%98/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"爬虫基础篇之Scrapy抓取京东","slug":"爬虫基础篇之Scrapy抓取京东","date":"2021-04-09T05:54:41.000Z","updated":"2021-04-22T12:46:32.068Z","comments":true,"path":"2021/04/09/爬虫基础篇之Scrapy抓取京东/","link":"","permalink":"http://onejane.github.io/2021/04/09/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BScrapy%E6%8A%93%E5%8F%96%E4%BA%AC%E4%B8%9C/","excerpt":"","text":"虚拟环境同一台服务器上不同的项目可能依赖的包不同版本，新版本默认覆盖旧版本，可能导致其他项目无法运行，通过虚拟环境，完全隔离各个项目各个版本的依赖包，实现运行环境互不影响。 virtualenv1234567891011121314pip install virtualenv 安装virtualenvpython -m pip install --upgrade pip 升级pippip install -i https:&#x2F;&#x2F;pypi.doubanio.com&#x2F;simple&#x2F; --trusted-host pypi.doubanio.com scrapypip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple 使用清华源pip uninstall scrapy 卸载django virtualenv scrapytest 默认环境创建虚拟环境cd scrapytest&#x2F;Scripts &amp;&amp; activate.bat &amp;&amp; python 进入3.7虚拟环境virtualenv -p D:\\Python27\\python.exe scrapytestcd scrapytest&#x2F;Scripts &amp;&amp; activate.bat &amp;&amp; python 进入2.7虚拟环境deactivate.bat 退出虚拟环境apt-get install python-virtualenv 安装虚拟环境virtualenv py2 &amp;&amp; cd py2 &amp;&amp; cd bin &amp;&amp; source activate &amp;&amp; python 进入2.7虚拟环境virtualenv -p &#x2F;usr&#x2F;bin&#x2F;python3 py3 &amp;&amp; &amp;&amp; cd py3 &amp;&amp; cd bin &amp;&amp; source activate &amp;&amp; python 进入3.7虚拟环境 virtualenvwrapper123456789101112131415161718192021222324252627pip install virtualenvwrapperpip install virtualenvwrapper-win 解决workon不是内部指令workon 列出所有虚拟环境新建环境变量 WORKON_HOME&#x3D;E:\\envsmkvirtualenv py3scrapy 新建并进入虚拟环境deactivate 退出虚拟环境workon py3scrapy 进入指定虚拟环境 pip install -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple scrapy 安装scrapy源 若缺少lxml出错https:&#x2F;&#x2F;www.lfd.uci.edu&#x2F;~gohlke&#x2F;pythonlibs&#x2F;寻找对应版本的lxml的whl源 python -m pip install --upgrade pip 更新pip pip install lxml-4.1.1-cp35-cp35m-win_amd64.whl 若缺少Twisted出错http:&#x2F;&#x2F;www.lfd.uci.edu&#x2F;~gohlke&#x2F;pythonlibs&#x2F;#lxml搜对应版本Twisted pip install Twisted‑17.9.0‑cp35‑cp35m‑win_amd64.whlmkvirtualenv --python&#x3D;D:\\Python27\\python.exe py2scrapy 一般不会出问题 pip install -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple scrapy pip install virtualenvwrapper find &#x2F; -name virualenvwrapper.sh vim ~&#x2F;.bashrc export WORKON_HOME&#x3D;$HOME&#x2F;.virtualenvs source &#x2F;home&#x2F;wj&#x2F;.local&#x2F;bin&#x2F;virtualenvwrapper.sh source ~&#x2F;.bashrc mkvirtualenv py2scrapy 指向生成~&#x2F;.virtualenvdeactivate 退出虚拟环境mkdirtualenv --python&#x3D;&#x2F;usr&#x2F;bin&#x2F;python3 py3scrapyrmvirtualenv py3scrapy 删除虚拟环境 Scrapy 12345678910pip install -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F; scrapy 安装scrapyscrapy startproject mall_spider 创建mall_spider项目scrapy genspider jd_category https:&#x2F;&#x2F;dc.3.cn&#x2F;category&#x2F;get 创建分类爬虫scrapy genspider --list 查看爬虫生成模板scrapy genspider -t crawl lagou www.lagou.com 创建全站爬虫pip freeze &gt; requirements.txt 生成依赖到文件pip install -r requirements.txt 一键安装依赖scrapy shell http:&#x2F;&#x2F;blog.jobbole.com&#x2F; 可以在脚本中调试xpath或者chrome浏览器右键copy xpath,chrome浏览器右键copy selectorscrapy shell -s USER_AGENT&#x3D;&quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64; rv:51.0) Gecko&#x2F;20100101 Firefox&#x2F;51.0&quot; https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;56320032view(response) 需求1.1 抓取首页的分类信息 抓取数据: 各级分类的名称 和 URL 1.2 抓取商品信息 抓取: 商品名称, 商品价格, 商品评论数量, 商品店铺, 商品促销, 商品选项, 商品图片的URL 由于全网爬虫, 抓取页面非常多, 为了提高抓的速度, 选择使用scrapy框架 + scrapy_redis分布式组件 由于京东全网的数据量达到了亿级, 存储又是结构化数据, 数据库, 选择使用MongoDB; 实现我们采用广度优先策略, 我们把类别和商品信息的抓取分开来做. 模型类别模型1234567891011121314class Category(scrapy.Item): &quot;&quot;&quot;商品类别&quot;&quot;&quot; # 大分类名称 b_category_name &#x3D; scrapy.Field() # 大分类URL b_category_url &#x3D; scrapy.Field() # 中分类名称 m_category_name &#x3D; scrapy.Field() # 中分类URL m_category_url &#x3D; scrapy.Field() # 小分类名称 s_category_name &#x3D; scrapy.Field() # 小分类URL s_category_url &#x3D; scrapy.Field() 数据模型123456789101112131415161718192021class Product(scrapy.Item): # 商品类别 product_category &#x3D; scrapy.Field() # 商品ID product_sku_id &#x3D; scrapy.Field() # 商品名称 product_name &#x3D; scrapy.Field() # 商品图片URL product_img_url &#x3D; scrapy.Field() # 商品店铺 product_shop &#x3D; scrapy.Field() # 图书信息, 作者,出版社 product_book_info &#x3D; scrapy.Field() # 商品选项 product_option &#x3D; scrapy.Field() # 商品评论数量 product_comments &#x3D; scrapy.Field() # 商品促销 product_ad &#x3D; scrapy.Field() # 商品价格 product_price &#x3D; scrapy.Field() 分类爬虫分析, 分类信息的URL 目标: 确定分类信息的URL 步骤: 进入到京东首页 右键检查, 打开开发者工具, 搜索 家用电器 确定分类的URL 图解: 结论: 分类URL: https://dc.3.cn/category/get 创建爬虫, 抓取数据 目标: 抓取分类数据, 交给引擎 步骤: 创建类别爬虫 \b指定起始URL 解析数据, 交给引擎 创建爬虫 进入项目目录: cd mall_spider 创建爬虫: scrapy genspider category_spider jd.com 指定起始URL 修改起始URL: https://dc.3.cn/category/get 解析数据, 交给引擎 分析数据格式: 整体数据 各级分类位置 分类信息格式 格式1: jiadian.jd.com|家用电器||0 特点: 第一项分类URL,第二项分类名称 格式2: 652-654|摄影摄像||0 对应的URL: https://channel.jd.com/652-654.html 特点:第一项是频道ID, 包含一个 - 格式3: 1318-2628-12131|户外风衣||0 对应URL: https://list.jd.com/list.html?cat=1318,2628,12131 特点: 第一项为分类ID, 包含两个 - 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class JdCategorySpider(scrapy.Spider): name &#x3D; &#39;jd_category&#39; allowed_domains &#x3D; [&#39;3.cn&#39;] start_urls &#x3D; [&#39;https:&#x2F;&#x2F;dc.3.cn&#x2F;category&#x2F;get&#39;] def parse(self, response): # print(response.body.decode(&#39;GBK&#39;)) result &#x3D; json.loads(response.body.decode(&#39;GBK&#39;)) datas &#x3D; result[&#39;data&#39;] # 遍历数据列表 for data in datas: item &#x3D; Category() b_category &#x3D; data[&#39;s&#39;][0] b_category_info &#x3D; b_category[&#39;n&#39;] # print(&#39;大分类: &#123;&#125;&#39;.format(b_category_info)) item[&#39;b_category_name&#39;], item[&#39;b_category_url&#39;] &#x3D; self.get_category_name_url(b_category_info) # 中分类信息列表 m_category_s &#x3D; b_category[&#39;s&#39;] # 遍历中分类列表 for m_category in m_category_s: # 中分类信息 m_category_info &#x3D; m_category[&#39;n&#39;] # print(&#39;中分类: &#123;&#125;&#39;.format(m_category_info)) item[&#39;m_category_name&#39;], item[&#39;m_category_url&#39;] &#x3D; self.get_category_name_url(m_category_info) # 小分类数据列表 s_category_s &#x3D; m_category[&#39;s&#39;] for s_category in s_category_s: s_category_info &#x3D; s_category[&#39;n&#39;] # print(&#39;小分类: &#123;&#125;&#39;.format(s_category_info)) item[&#39;s_category_name&#39;], item[&#39;s_category_url&#39;] &#x3D; self.get_category_name_url(s_category_info) # print(item) # 把数据交给引擎 yield item def get_category_name_url(self, category_info): &quot;&quot;&quot; 根据分类信息, 提取名称和URL :param category_info: 分类信息 :return: 分类的名称和URL 分析数据格式(三类数据格式) - book.jd.com&#x2F;library&#x2F;science.html|科学技术||0 - 1713-3287|计算机与互联网||0 - Https:&#x2F;&#x2F;channel.jd.com&#x2F;&#123;&#125;.html - 9987-12854-12856|屏幕换新||0 - Https:&#x2F;&#x2F;list.jd.com&#x2F;list.html?cat&#x3D;&#123;&#125; - 把 - 替换为逗号, 然后填充到占位的地方. &quot;&quot;&quot; category &#x3D; category_info.split(&#39;|&#39;) # 分类URL category_url &#x3D; category[0] # 分类名称 category_name &#x3D; category[1] # 处理第一类分类URL if category_url.count(&#39;jd.com&#39;) &#x3D;&#x3D; 1: # URL进行补全 category_url &#x3D; &#39;https:&#x2F;&#x2F;&#39; + category_url elif category_url.count(&#39;-&#39;) &#x3D;&#x3D; 1: # 1713-3287|计算机与互联网||0 category_url &#x3D; &#39;https:&#x2F;&#x2F;channel.jd.com&#x2F;&#123;&#125;.html&#39;.format(category_url) else: # 9987-12854-12856|屏幕换新||0 # 把URL中 &#96;-&#96; 替换为 &#96;,&#96; category_url &#x3D; category_url.replace(&#39;-&#39;, &#39;,&#39;) # 补全URL category_url &#x3D; &#39;https:&#x2F;&#x2F;list.jd.com&#x2F;list.html?cat&#x3D;&#123;&#125;&#39;.format(category_url) # 返回类别的名称 和 URL return category_name, category_url 保存分类数据12345# 在settings.py开启, 类别的PipelineROBOTSTXT_OBEY &#x3D; False 不遵守网络协议ITEM_PIPELINES &#x3D; &#123; &#39;mall_spider.pipelines.CategoryPipeline&#39;: 300,&#125; 步骤: open_spider方法中, 链接\bMongoDB数据库, 获取要操作的集合 process_item 方法中, 向MongoDB中插入类别\b数据 close_spider 方法中, 关闭MongoDB的链接 123456789101112131415161718192021222324252627&quot;&quot;&quot;实现保存分类的Pipeline类- open_spider方法中, 链接MongoDB数据库, 获取要操作的集合- process_item 方法中, 向MongoDB中插入类别数据- close_spider 方法中, 关闭MongoDB的链接&quot;&quot;&quot;class CategoryPipeline(object): def open_spider(self, spider): &quot;&quot;&quot;当爬虫启动的时候执行1次&quot;&quot;&quot; if isinstance(spider, JdCategorySpider): # open_spider方法中, 链接MongoDB数据库, 获取要操作的集合 self.client &#x3D; MongoClient(MONGODB_URL) self.collection &#x3D; self.client[&#39;jd&#39;][&#39;category&#39;] def process_item(self, item, spider): # process_item 方法中, 向MongoDB中插入类别数据 if isinstance(spider, JdCategorySpider): self.collection.insert_one(dict(item)) return item def close_spider(self, spider): # close_spider 方法中, 关闭MongoDB的链接 if isinstance(spider, JdCategorySpider): self.client.close() 商品爬虫总体设计: 把MongoDB中存储的分类信息, 放到redis_key指定列表中 支持分布式爬虫, 当然也可以在一台电脑上运行多次, 以启动多个进程,充分使用CPU的多核. 所以这里的爬虫, 先从一个分类开始抓就可以了, 后面再改造为分布式 分析 列表页 提取商品 skuid 实现翻页 获取下一页URL \b没有下一页的情况 详情页由于PC和手机页面商品信息, 在js中, 且比较分散, 并且每次请求数量页比较大, 我们这里使用手机抓包, 抓到json数据. 商品基本信息 图: URL: https://cdnware.m.jd.com/c1/skuDetail/apple/7.3.0/32426231880.json; 最后一部分是商品skuid 可以获取到的信息: 商品名称, 商品店铺信息 , 商品类别id, \b商品品牌id, 商品选项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 &#123;\"code\": \"0\",\"wareInfo\": &#123; \"recommendInfo\": &#123; \"recommendList\": null &#125;, // 商品店铺信息 \"shopInfo\": &#123; \"shop\": &#123; \"shopId\": 1000000127, \"name\": \"京东Apple产品专营店\", ... &#125;, \"basicInfo\": &#123; \"gift\": false, \"bookInfo\": &#123; // 如果是书, 这里是书的选项信息 \"display\": false &#125;, \"colorSizeInfo\": &#123; // 商品选项信息列表 有的没有 \"colorSize\": [&#123; \"buttons\": [&#123; \"no\": \"1\", \"skuList\": [\"100000177738\", \"100000287117\", \"100000287145\", \"100000309448\", \"100000309450\", \"100000375233\", \"100000435832\", \"100000458753\", \"100000458755\", \"100001860767\", \"100001860773\"], \"text\": \"金色\" &#125;, &#123; \"no\": \"2\", \"skuList\": [\"100000177764\", \"100000287113\", \"100000287135\", \"100000435780\", \"100000435816\", \"100000435818\", \"100000569049\", \"100000602206\", \"100000602208\", \"100001860765\", \"100002539302\"], \"text\": \"深空灰色\" &#125;, &#123; \"no\": \"3\", \"skuList\": [\"100000177740\", \"100000177784\", \"100000287147\", \"100000435834\", \"100000458737\", \"100000458739\", \"100000602174\", \"100000602176\", \"100000602204\", \"100001860789\", \"100002539304\"], \"text\": \"银色\" &#125;], \"title\": \"颜色\" &#125;, &#123; \"buttons\": [&#123; \"no\": \"1\", \"skuList\": [\"100000177738\", \"100000177740\", \"100000177764\", \"100000177784\", \"100000287113\", \"100000287117\", \"100000287135\", \"100000287145\", \"100000287147\"], \"text\": \"公开版\" &#125;, ... ], \"title\": \"版本\" &#125;, &#123; \"buttons\": [&#123; \"no\": \"1\", \"skuList\": [\"100000177764\", \"100000287145\", \"100000287147\", \"100000375233\", \"100000435818\", \"100000458739\", \"100000458755\", \"100000602204\", \"100000602208\", \"100001860765\", \"100001860773\", \"100001860789\"], \"text\": \"64GB\" &#125;, ... ], \"title\": \"内存\" &#125;], \"colorSizeTips\": \"#与其他已选项无法组成可售商品，请重选\" &#125;, ... // 品牌ID \"brandID\": \"14026\", ... // 商品图片 \"wareImage\": [&#123; \"small\": \"https://m.360buyimg.com/mobilecms/s720x720_jfs/t1/3/15/4536/138660/5b997bf8Ed72ebce7/819dcf182d743897.jpg!q70.jpg.webp\", ... &#125; ... ], ... // 商品名称 \"name\": \"Apple iPhone XS Max (A2104) 256GB 深空灰色 移动联通电信4G手机 双卡双待\", // 商品类别id \"category\": \"9987;653;655\" &#125; &#125; &#125; 商品促销信息(PC端): 图: URL: https://cd.jd.com/promotion/v2?skuId=4749506&amp;area=1_72_4137_0&amp;cat=737%2C794%2C798 参数 skuId=4749506: 商品sku_id area=1_72_4137_0: 购买者区域, 固定的 cat=737%2C794%2C798: 类别 数据 123456789&#123; ... // 商品促销信息 \"ads\": [&#123; \"id\": \"AD_4749506\", \"ad\": \"【即刻预约，21号秒杀到手价2999】\\n1、前100名晒单送腾讯企鹅影院季卡，联系客服领取！！\\n2、曲面爆款，5.5万好评推荐！&lt;a target=\\\"_blank\\\" href=\\\"https://item.jd.com/7055876.html\\\"&gt;升级55Q1D超清全面屏电视&lt;/a&gt;\" &#125;], ... &#125; 商品评论信息(PC端) 图: URL: https://club.jd.com/comment/productCommentSummaries.action?referenceIds=4749506 参数 referenceIds=4749506: 商品sku_id 数据: 12345678910&#123;\"CommentsCount\":[ &#123; \"CommentCountStr\":\"10万+\", \"CommentCount\":100000, //评论数量 \"AverageScore\":5, \"GoodRate\":0.98, //好评率 \"PoorCountStr\":\"600+\", \"PoorCount\":600, // 差评数量 ... &#125;]&#125; 商品价格信息: 图: URL: https://p.3.cn/prices/mgets?skuIds=J_4749506 参数: skuIds=J_4749506 商品的sku_id 数据: 12345678[ &#123; \"op\": \"5499.00\", \"m\": \"5999.00\", \"id\": \"J_4749506\", //商品skuid \"p\": \"3299.00\" // 商品价格 &#125; ] 代码实现 步骤: 重写start_requests方法, 根据分类信息构建列表页的请求 解析列表页, 提取商品的skuid, 构建商品基本的信息请求; 实现翻页 解析商品基本信息, 构建商品促销信息的请求 解析促销信息,构建商品评价信息的请求, 解析商品评价信息, 构建价格信息的请求 解析价格信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121class JdProductSpider(scrapy.Spider): name &#x3D; &#39;jd_product&#39; allowed_domains &#x3D; [&#39;jd.com&#39;, &#39;p.3.cn&#39;] def start_requests(self): category &#x3D; &#123; &quot;b_category_name&quot; : &quot;家用电器&quot;, &quot;b_category_url&quot; : &quot;https:&#x2F;&#x2F;jiadian.jd.com&quot;, &quot;m_category_name&quot; : &quot;洗衣机&quot;, &quot;m_category_url&quot; : &quot;https:&#x2F;&#x2F;list.jd.com&#x2F;list.html?cat&#x3D;737,794,880&quot;, &quot;s_category_name&quot; : &quot;洗衣机配件&quot;, &quot;s_category_url&quot; : &quot;https:&#x2F;&#x2F;list.jd.com&#x2F;list.html?cat&#x3D;737,794,877&quot; &#125; yield scrapy.Request(category[&#39;s_category_url&#39;], self.parse, meta&#x3D;&#123;&#39;category&#39;: category&#125;) def parse(self, response): # 获取类别信息 category &#x3D; response.meta[&#39;category&#39;] # 获取类别的URL category_url &#x3D; response.url.split(&#39;&amp;&#39;)[0] # 获取所有商品的sku_ids sku_ids &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[contains(@class, &quot;j-sku-item&quot;)]&#x2F;@data-sku&#39;).extract() # 遍历sku_ids, 构建基本详情信息的请求 for sku_id in sku_ids: item &#x3D; &#123; &#39;product_category&#39;: category, &#39;product_sku_id&#39;:sku_id &#125; product_url &#x3D; &#39;https:&#x2F;&#x2F;cdnware.m.jd.com&#x2F;c1&#x2F;skuDetail&#x2F;apple&#x2F;7.3.0&#x2F;&#123;&#125;.json&#39;.format(sku_id) yield scrapy.Request(product_url, callback&#x3D;self.parse_product, meta&#x3D;&#123;&#39;item&#39;: item&#125;) # 获取下一页的URL next_url &#x3D; response.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;&quot;pn-next&quot;]&#x2F;@href&#39;).extract_first() if next_url: # 补全URL next_url &#x3D; response.urljoin(next_url) # 构建下一页请求 yield scrapy.Request(next_url, callback&#x3D;self.parse, meta&#x3D;&#123;&#39;category&#39;: category&#125;) def parse_product(self, response): # 取出传递过来的数据 item &#x3D; response.meta[&#39;item&#39;] # 把响应数据数据转为字典 product_dic &#x3D; json.loads(response.text) # 获取商品名称 item[&#39;product_name&#39;] &#x3D; product_dic[&#39;wareInfo&#39;][&#39;basicInfo&#39;][&#39;name&#39;] if item[&#39;product_name&#39;]: # 获取类别id, 把 &#96;;&#96; 替换为 , item[&#39;product_category_id&#39;] &#x3D; product_dic[&#39;wareInfo&#39;][&#39;basicInfo&#39;][&#39;category&#39;].replace(&#39;;&#39;, &#39;,&#39;) # 获取店铺信息 product_shop &#x3D; jsonpath(product_dic, &#39;$..shop&#39;) if product_shop: product_shop &#x3D; product_shop[0] if product_shop is None: item[&#39;product_shop&#39;] &#x3D; &#123;&#39;name&#39;:&#39;京东自营&#39;&#125; else: item[&#39;product_shop&#39;] &#x3D; &#123; &quot;shopId&quot;: product_shop[&#39;shopId&#39;], &quot;name&quot;: product_shop[&#39;name&#39;], &quot;score&quot;: product_shop[&#39;score&#39;], &quot;url&quot;: product_shop[&#39;url&#39;], &#125; # 如果是书, 记录书的信息 if product_dic[&#39;wareInfo&#39;][&#39;basicInfo&#39;][&#39;bookInfo&#39;][&#39;display&#39;]: item[&#39;product_book_info&#39;] &#x3D; product_dic[&#39;wareInfo&#39;][&#39;basicInfo&#39;][&#39;bookInfo&#39;] # 删除display del item[&#39;book_info&#39;][&#39;display&#39;] # 获取商品选购信息 color_sizes &#x3D; jsonpath(product_dic, &#39;$..colorSize&#39;) product_option &#x3D; &#123;&#125; if color_sizes: for color_size in color_sizes[0]: title &#x3D; color_size[&#39;title&#39;] texts &#x3D; jsonpath(color_size, &#39;$..text&#39;) product_option.update(&#123;title:texts&#125;) # print(product_option) item[&#39;product_option&#39;] &#x3D; product_option # 商品图片 item[&#39;product_img_url&#39;] &#x3D; jsonpath(product_dic, &#39;$..wareImage[0].small&#39;)[0] # 构建促销信息的请求 ad_url &#x3D; &#39;https:&#x2F;&#x2F;cd.jd.com&#x2F;promotion&#x2F;v2?skuId&#x3D;&#123;&#125;&amp;area&#x3D;1_72_4137_0&amp;cat&#x3D;&#123;&#125;&#39;.format(item[&#39;product_sku_id&#39;], item[&#39;product_category_id&#39;]) yield scrapy.Request(ad_url, callback&#x3D;self.parse_ad, meta&#x3D;&#123;&#39;item&#39;: item&#125;) def parse_ad(self, response): &quot;&quot;&quot;获取商品促销&quot;&quot;&quot; item &#x3D; response.meta[&#39;item&#39;] ad_dic &#x3D; json.loads(response.body.decode(&#39;GB18030&#39;)) ad &#x3D; ad_dic[&#39;ads&#39;][0][&#39;ad&#39;] item[&#39;product_ad&#39;] &#x3D; ad # for key, value in item.items(): # print(&#39;&#123;&#125; &#x3D; &#123;&#125;&#39;.format(key, value)) # 构建平均信息请求 comments_url &#x3D; &#39;https:&#x2F;&#x2F;club.jd.com&#x2F;comment&#x2F;productCommentSummaries.action?referenceIds&#x3D;&#123;&#125;&#39;.format(item[&#39;product_sku_id&#39;]) yield scrapy.Request(comments_url, callback&#x3D;self.parse_comments, meta&#x3D;&#123;&#39;item&#39;: item&#125;) def parse_comments(self, response): &quot;&quot;&quot;解析商品评论信息&quot;&quot;&quot; item &#x3D; response.meta[&#39;item&#39;] comments_dic &#x3D; json.loads(response.text) comments &#x3D; &#123; &#39;comment_count&#39;: jsonpath(comments_dic, &#39;$..CommentCount&#39;)[0], &#39;good_rate&#39;: jsonpath(comments_dic, &#39;$..GoodRate&#39;)[0], &#39;poor_count&#39;: jsonpath(comments_dic, &#39;$..PoorCount&#39;)[0], &#125; item[&#39;product_comments&#39;] &#x3D; comments # print(item) # 构建价格请求 price_url &#x3D; &#39;https:&#x2F;&#x2F;p.3.cn&#x2F;prices&#x2F;mgets?skuIds&#x3D;J_&#123;&#125;&#39;.format(item[&#39;product_sku_id&#39;]) yield scrapy.Request(price_url, callback&#x3D;self.parse_price, meta&#x3D;&#123;&#39;item&#39;: item&#125;) def parse_price(self, response): &quot;&quot;&quot;解析价格&quot;&quot;&quot; item &#x3D; response.meta[&#39;item&#39;] item[&#39;product_price&#39;] &#x3D; json.loads(response.text)[0][&#39;p&#39;] # print(item) yield item 分布式 步骤: 修改爬虫类 在settings文件中配置scrapy_redis 写一个程序用于把MongoDB中分类信息, 放入到爬虫redis_key指定的列表中 修改爬虫类 步骤: 修改继承关系: 继承RedisSpider 指定redis_key 把重写start_requests 改为 重写 make_request_from_data 123456789101112131415from scrapy_redis.spiders import RedisSpiderimport pickle# 1. 修改继承关系: 继承RedisSpiderclass JdProductSpider(RedisSpider): name &#x3D; &#39;jd_product&#39; allowed_domains &#x3D; [&#39;jd.com&#39;, &#39;p.3.cn&#39;] # 2. 指定redis_key redis_key &#x3D; &#39;jd_product:start_category&#39; # 3. 把重写start_requests 改为 重写 make_request_from_data def make_request_from_data(self, data): # 把从Redis中读取到分类信息, 转换为字典 category &#x3D; pickle.loads(data) return scrapy.Request(category[&#39;s_category_url&#39;], self.parse, meta&#x3D;&#123;&#39;category&#39;: category&#125;) 注意: 在make_request_from_data不能使用 yield 必须使用 return 在settings文件中配置scrapy_redis 1234567891011121314# MongoDB数据库的URLMONGO_URL &#x3D; &#39;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#39;# REDIS数据链接REDIS_URL &#x3D; &#39; redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;0&#39;# 去重容器类: 用于把已爬指纹存储到基于Redis的set集合中DUPEFILTER_CLASS &#x3D; &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;# 调度器: 用于把待爬请求存储到基于Redis的队列SCHEDULER &#x3D; &quot;scrapy_redis.scheduler.Scheduler&quot;# 是不进行调度持久化:# 如果是True, 当程序结束的时候, 会保留Redis中已爬指纹和待爬的请求# 如果是False, 当程序结束的时候, 会清空Redis中已爬指纹和待爬的请求SCHEDULER_PERSIST &#x3D; True 把MongoDB中分类信息, 放入到爬虫redis_key指定的列表中 步骤: 在项目文件夹下创建 add_category_to_redis.py 实现方法 add_category_to_redis: 链接MongoDB 链接Redis 读取MongoDB中分类信息, 序列化后, 添加到商品爬虫redis_key指定的list 关闭MongoDB 在if __name__ == &#39;__main__&#39;:中调用add_category_to_redis方法 代码 123456789101112131415161718192021222324from redis import StrictRedisfrom pymongo import MongoClientimport picklefrom mall_spider.settings import MONGO_URL, REDIS_URLfrom mall_spider.spiders.jd_product import JdProductSpider# 把MongoDB中分类信息, 添加到Redis中def add_category_to_redis(): # 链接MongoDB client = MongoClient(MONGO_URL) # 链接Redis redis = StrictRedis.from_url(REDIS_URL) cursor = client['jd']['category'].find() # 读取MongoDB中分类信息, 序列化后, 添加到商品爬虫redis_key指定的list for category in cursor: redis.rpush(JdProductSpider.redis_key, pickle.dumps(category)) # 关闭MongoDB的链接 client.close()if __name__ == '__main__': add_category_to_redis() 保存商品数据步骤 在 open_spider方法, 建立MongoDB数据库连接, 获取要操作的集合 在 process_item方法, 把数据插入到MongoDB中 在close_spider方法, 关闭数据库连接 代码 1234567891011121314151617181920class ProductPipeline(object): def open_spider(self, spider): if isinstance(spider, JdProductSpider): # 建立MongoDB数据库链接 self.client = MongoClient(MONGO_URL) # 获取要操作集合 self.category = self.client['jd']['product'] def process_item(self, item, spider): if isinstance(spider, JdProductSpider): # 把数据插入到mongo中 self.category.insert_one(dict(item)) return item def close_spider(self, spider): \"\"\"关闭\"\"\" if isinstance(spider, JdProductSpider): self.client.close() 在settings.py中开启这个管道 12345ITEM_PIPELINES = &#123; 'mall_spider.pipelines.CategoryPipeline': 300, # 开启商品管道 'mall_spider.pipelines.ProductPipeline': 301,&#125; 反爬为了避免IP反爬, 我们实现随机User-Agent和代理IP的中间件 步骤: 实现随机User-Agent的中间件 实现代理IP中间件 在settings.py 文件开启, 下载器中间件 实现随机User-Agent的中间件 步骤 准备User-Agent列表 在middlewares.py中, 实现RandomUserAgent类 实现process_request方法 如果是请求是 https://cdnware.m.jd.com 开头的, 就是设置一个iPhone的user-agent 否则从User-Agent列表中随机取出一个 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import requestsimport random# 准备请求头USER_AGENTS = [ \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\", \"Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\", \"Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\", \"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\", \"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\", \"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\", \"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\", \"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\", \"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 LBBROWSER\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)\", \"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1\", \"Mozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko/20110307 Firefox/4.0b13pre\", \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko/20100101 Firefox/16.0\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11\", \"Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10\"]class RandomUserAgent(object): def process_request(self, request, spider): if request.url.startswith('https://cdnware.m.jd.com'): # 如果使用手机抓包, 获取到商品信息; 生成请求请求头 request.headers['user-agent'] = 'JD4iPhone/164880 (iPhone; iOS 12.1.2; Scale/2.00)' else: # 随机获取一个请求头, 进行设置 request.headers['user-agent'] = random.choice(USER_AGENTS) 实现代理IP中间件 步骤: 在middlewares.py中, 实现ProxyMiddleware类 实现process_request方法 \b从代理池中获取一个随机的代理IP, 需指定代理IP的协议, 和访问的域名 设置给request.meta[‘proxy’] \b实现process_exception方法 当请求出现异常的时候, 代理池哪些代理IP在本域名下是不可以用的 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849\"\"\"9.2. 实现代理IP中间件步骤: 在middlewares.py中, 实现ProxyMiddleware类 实现process_request方法 \b从代理池中获取一个随机的代理IP 设置给request.meta['proxy']\"\"\"from twisted.internet import deferfrom twisted.internet.error import TimeoutError, DNSLookupError, \\ ConnectionRefusedError, ConnectionDone, ConnectError, \\ ConnectionLost, TCPTimedOutErrorfrom twisted.web.client import ResponseFailedfrom scrapy.core.downloader.handlers.http11 import TunnelErrorclass ProxyMiddleware(object): EXCEPTIONS_TO_RETRY = (defer.TimeoutError, TimeoutError, DNSLookupError, ConnectionRefusedError, ConnectionDone, ConnectError, ConnectionLost, TCPTimedOutError, ResponseFailed, IOError, TunnelError) def process_request(self, request, spider): \"\"\" 从代理池中获取一个随机的代理IP 设置给request.meta['proxy'] \"\"\" response = requests.get('http://localhost:6868/random?protocol=https&amp;domain=jd.com') request.meta['proxy'] = response.content.decode() request.meta['dont_redirect'] = True return None def process_exception(self, request, exception, spider): if isinstance(exception, self.EXCEPTIONS_TO_RETRY): # 获取代理IP proxy = request.meta['proxy'] # 提取IP地址 ip = re.findall('https://(.+):\\d+', proxy)[0] params = &#123; 'ip': ip, 'domain': 'jd.com' &#125; requests.get('http://localhost:6868/disable_domain', params=params) # 构建请求返回 req = request.copy() req.dont_filter = True return req 在settings.py中开启上面的两个下载器中间件 12345# 配置下载器中间件DOWNLOADER_MIDDLEWARES = &#123;'mall_spider.middlewares.RandomUserAgent': 500,'mall_spider.middlewares.ProxyMiddl eware': 543,&#125; 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"http://onejane.github.io/tags/scrapy/"},{"name":"scrapy_redis","slug":"scrapy-redis","permalink":"http://onejane.github.io/tags/scrapy-redis/"},{"name":"mongo","slug":"mongo","permalink":"http://onejane.github.io/tags/mongo/"}]},{"title":"爬虫基础篇之斗鱼弹幕","slug":"爬虫基础篇之斗鱼弹幕","date":"2021-04-08T11:55:37.000Z","updated":"2021-04-09T00:01:17.101Z","comments":true,"path":"2021/04/08/爬虫基础篇之斗鱼弹幕/","link":"","permalink":"http://onejane.github.io/2021/04/08/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E6%96%97%E9%B1%BC%E5%BC%B9%E5%B9%95/","excerpt":"","text":"Socket asyncore 模块为异步socket的服务器客户端通信提供简单的接口。该模块提供了异步socket服务客户端和服务器的基础架构。 相比python原生的socket api，asyncore具备有很大的优势，asyncore对原生的socket进行封装，提供非常简洁优秀的接口，利用asyncore覆写相关需要处理的接口方法，就可以完成一个socket的网络编程，从而不需要处理复杂的socket网络状况以及多线程处理等等。 demo服务端1netcat-win32-1.12&gt;nc -l -p 9000 启动服务端 客户端telnet 127.0.0.1 9000 客户端连接到服务器 发送信息 定义类继承自asyncore.dispatcher 1class SocketClient(asyncore.dispatcher): 实现类中的回调代码 实现构造函数 调用父类方法 1asyncore.dispatcher.__init__(self) 创建 Socket 对象 1self.create_socket() 连接服务器 12address = (host,port)self.connect(address) 实现 handle_connect 回调函数 当 Socket 连接服务器成功时回调该函数 12def handle_connect(self): print(\"连接成功\") 实现 writable 回调函数 描述是否有数据需要被发送到服务器。返回值为 True 表示可写，False 表示不可写，如果不实现默认返回为 True，当返回 True 时，回调函数 handle_write 将被触发 12def writable(self): return True 实现 handle_write 回调函数 当有数据需要发送时（writable 回调函数返回True时），该函数被触发，通常情况下在该函数中编写 send 方法发送数据 1234def handle_write(self): # 内部实现对服务器发送数据的代码 # 调用 send 方法发送数据，参数是字节数据 self.send('hello world\\n'.encode('utf-8')) 实现 readable 回调函数 描述是否有数据从服务端读取。返回 True 表示有数据需要读取，False 表示没有数据需要被读取，当不实现默认返回为 True，当返回 True 时，回调函数 handle_read 将被触发 12def readable(self): return True 实现 handle_read 回调函数 当有数据需要读取时触发（readable 回调函数返回 True 时），该函数被触发，通常情况下在该函数中编写 recv 方法接收数据 12345def handle_read(self): # 主动接收数据，参数是需要接收数据的长度 # 返回的数据是字节数据 result = self.recv(1024) print(result) 实现 handle_error 回调函数 当程序运行过程发生异常时回调 1234def handle_error(self): # 编写处理错误方法 t,e,trace = sys.exc_info() self.close() 实现 handle_close 回调函数 当连接被关闭时触发 123def handle_close(self): print(\"连接关闭\") self.close() 创建对象并且执行 asyncore.loop 进入运行循环 timeout 表示一次循环所需要的时长 123client = SocketClient('127.0.0.1',9000)# 开始启动运行循环asyncore.loop(timeout=5) 抓取弹幕开发流程根据斗鱼弹幕服务器第三方接入协议v1.6.2.pdf 官方提供协议文档建立弹幕客户端开发流程。 连接初始化 使用TCP连接服务器 IP地址：openbarrage.douyutv.com 端口：8601 客户端向弹幕服务器发送登录请求，登录弹幕服务器 弹幕服务器收到客户端登录请求并完成登录后，返回登录成功消息给客户端 客户端收到登录成功消息后发送进入弹幕分组请求给弹幕服务器 弹幕服务器接受到客户端弹幕分组请求后将客户端添加到请求指定的弹幕分组中 服务过程 客户端每隔 45 秒发送心跳给弹幕服务器，弹幕服务器回复心跳信息给客户端 弹幕服务器如有广播信息，则推送给客户端，服务器消息协议 断开连接 客户端发送登出消息 客户端关闭 TCP 连接 数据包结构 消息长度:4 字节小端整数，表示整条消息(包括自身)长度(字节数)。 消息长度出现两遍，二者相同。 消息类型:2 字节小端整数，表示消息类型。取值如下: 689 客户端发送给弹幕服务器的文本格式数据 690 弹幕服务器发送给客户端的文本格式数据。 加密字段:1字节，暂时未用，默认为 0。 保留字段:1字节，暂时未用，默认为 0。 数据部分:n字节+1字节，斗鱼独创序列化文本数据，结尾必须为‘\\0’。(所有协议内容均为 UTF-8 编码) 数据包封装 对数据包进行对象化封装，对数据的封装方便以后使用，实现对象和二进制数据之间的转换 通过参数构建数据包对象 实现获取数据包长度的方法 实现获取二进制数据的方法 实现发送数据包 构建发送数据包的队列容器 1self.send_queue = Queue() 实现回调函数，判断容器中有数据就发送没有数据不发送 1234567891011121314151617def writable(self): return self.send_queue.qsize() &gt; 0def handle_write(self): # 从发送数据包队列中获取数据包对象 dp = self.send_queue.get() # 获取数据包的长度，并且发送给服务器 dp_length = dp.get_length() dp_length_data = dp_length.to_bytes(4,byteorder='little',signed=False) self.send(dp_length_data) # 发送数据包二进制数据 self.send(dp.get_bytes()) self.send_queue.task_done() pass 实现登录函数 构建登录数据包 12content = \"type@=loginreq/roomid@=&#123;&#125;/\".format(room_id)login_dp = DataPacket(DATA_PACKET_TYPE_SEND,content=content) 把数据包添加到发送数据包容器中 12# 把数据包添加到发送数据包容器中 self.send_queue.put(login_dp) 实现接收数据 构建接收数据包队列 12# 存放接收的数据包对象self.recv_queue = Queue() 读取回调函数中读取数据 读取长度 1234# 读取长度,二进制数据data_length_data = self.recv(4)# 通过二进制获取length 具体数据data_length = int.from_bytes(data_length_data,byteorder='little',signed=False) 读取内容 12# 通过数据包的长度获取数据data = self.recv(data_length) 构建数据包对象 数据包构造函数中解析二进制来构建数据包对象 12345self.type = int.from_bytes(data_bytes[4:6],byteorder='little',signed=False)self.encrypt_flag = int.from_bytes(data_bytes[6:7],byteorder='little',signed=False)self.preserve_flag = int.from_bytes(data_bytes[7:8],byteorder='little',signed=False)# 构建数据部分self.content = str(data_bytes[8:-1],encoding='utf-8') 通过二进制数据构建数据包对象 12# 通过二进制数据构建数据包对象dp = DataPacket(data_bytes=data) 把数据包放入接收数据包容器中 12# 把数据包放入接收数据包容器中self.recv_queue.put(dp) 构建处理线程专门处理接收数据包容器中数据 构建线程 1234# 构建一个专门处理接收数据包容器中的数据包的线程self.callback_thread = threading.Thread(target=self.do_callback)self.callback_thread.setDaemon(True)self.callback_thread.start() 实现回调函数处理接收的数据包 123456789101112def do_callback(self): ''' 专门负责处理接收数据包容器中的数据 :return: ''' while True: # 从接收数据包容器中获取数据包 dp = self.recv_queue.get() # 对数据进行处理 print(dp.content) pass 实现外部传入回调函数 通过外部指定回调函数实现自定义数据处理 添加参数 callback 构造函数中添加参数 123def __init__(self,host,port,callback=None): # 定义外部传入的自定义回调函数 self.callback = callback 外部传入自定义回调函数 123456789101112131415def data_callback(dp): ''' 自定义回调函数 :param dp: 数据包对象 :return: ''' print(\"data_callback:\",dp.content) passif __name__ == '__main__': client = DouyuClient('openbarrage.douyutv.com',8601,callback=data_callback) client.login_room_id(4494106) asyncore.loop(timeout=10) 在处理接收数据包的线程中调用回调函数 123456789101112def do_callback(self): ''' 专门负责处理接收数据包容器中的数据 :return: ''' while True: # 从接收数据包容器中获取数据包 dp = self.recv_queue.get() # 对数据进行处理 if self.callback is not None: self.callback(dp) self.recv_queue.task_done() 数据内容序列化与反序列化 键 key 和值 value 直接采用‘@=’分割 数组采用‘/’分割 如果 key 或者 value 中含有字符‘/’，则使用‘@S’转义 如果 key 或者 value 中含有字符‘@’，使用‘@A’转义 例子 多个键值对数据:key1@=value1/key2@=value2/key3@=value3/ 数组数据:value1/value2/value3/ 登录 123456789101112131415def login_room_id(self, room_id): # 2.客户端向弹幕服务器发送登录请求，登录弹幕服务器 self.room_id &#x3D; room_id send_data &#x3D; &#123; &quot;type&quot;: &quot;loginreq&quot;, &quot;roomid&quot;: str(room_id) &#125; # 构建登录数据包 content &#x3D; encode_content(send_data) login_dp &#x3D; DataPacket(DATA_PACKET_TYPE_SEND, content&#x3D;content) # 把数据包添加到发送数据包容器中 self.send_queue.put(login_dp) 加入弹幕分组 参看斗鱼弹幕文档,-9999 为海量弹幕 12345678910111213141516def join_room_group(self): &#39;&#39;&#39; 4.客户端收到登录成功消息后发送进入弹幕分组请求给弹幕服务器 :return: &#39;&#39;&#39; send_data &#x3D; &#123; &quot;type&quot;: &quot;joingroup&quot;, &quot;rid&quot;: str(self.room_id), &quot;gid&quot;: &#39;-9999&#39; &#125; content &#x3D; encode_content(send_data) dp &#x3D; DataPacket(type&#x3D;DATA_PACKET_TYPE_SEND, content&#x3D;content) self.send_queue.put(dp) pass 心跳机制 作用是让服务器解决假死连接问题，客户端必须每隔45秒发送一次请求，否则就会被主动断开。 实现发送心跳函数 构建心跳数据包 把数据包添加到发送数据包容器队列中 构建心跳线程 构建心跳线程 添加触发机制 添加暂停机制 12345678def send_heart_data_packet(self): # 6.客户端每隔 45 秒发送心跳给弹幕服务器，弹幕服务器回复心跳信息给客户端 send_data &#x3D; &#123; &quot;type&quot;: &quot;mrkl&quot; &#125; content &#x3D; encode_content(send_data) dp &#x3D; DataPacket(type&#x3D;DATA_PACKET_TYPE_SEND, content&#x3D;content) self.send_queue.put(dp) WebSocket以上方案已经失效，斗鱼弹幕已使用websocket实现，不过都是协议而已，基础逻辑没有变化。 通过抓包获取wss的地址及端口 查看抓包中的Messages中的二进制信息，数据格式和1.6.2保持一致。 run_forever是核心逻辑通过while循环实现自动重连，建立_job_open时调用_one_hello登录加入群组，通过_job_heartbeat持续接受心跳机制。 123456789101112131415161718192021222324252627282930313233343536373839async def run_forever(self) -&gt; None: &quot;&quot;&quot; 重写 @return: &quot;&quot;&quot; self._waiting_end &#x3D; self._loop.create_future() while not self._closed: self._logger_info(f&#39;正在启动 &#123;self._area_id&#125; 号数据连接&#39;) if self._waiting_pause is not None: self._logger_info(f&#39;暂停启动 &#123;self._area_id&#125; 号数据连接，等待 RESUME 指令&#39;) await self._waiting_pause async with self._opening_lock: if self._closed: self._logger_info(f&#39;&#123;self._area_id&#125; 号数据连接确认收到关闭信号，正在处理&#39;) break # 未成功建立数据连接，循环重试 if await self._prepare_client() and await self._job_open(): tasks &#x3D; [self._loop.create_task(i()) for i in self._funcs_task] self._task_main &#x3D; self._loop.create_task(self._job_main()) tasks.append(self._task_main) task_heartbeat &#x3D; self._loop.create_task(self._job_heartbeat()) tasks.append(task_heartbeat) else: continue _, pending &#x3D; await asyncio.wait(tasks, return_when&#x3D;asyncio.FIRST_COMPLETED) self._logger_info(f&#39;&#123;self._area_id&#125; 号数据连接异常或主动断开，正在处理剩余信息&#39;) for i in pending: if i !&#x3D; self._task_main: i.cancel() await self._job_close() if pending: await asyncio.wait(pending) self._logger_info(f&#39;&#123;self._area_id&#125; 号数据连接退出，剩余任务处理完毕&#39;) await self._conn.clean() self._waiting_end.set_result(True) 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"asyncore","slug":"asyncore","permalink":"http://onejane.github.io/tags/asyncore/"},{"name":"socket","slug":"socket","permalink":"http://onejane.github.io/tags/socket/"},{"name":"asyncio","slug":"asyncio","permalink":"http://onejane.github.io/tags/asyncio/"},{"name":"websocket","slug":"websocket","permalink":"http://onejane.github.io/tags/websocket/"}]},{"title":"爬虫基础篇之IP代理池","slug":"爬虫基础篇之IP代理池","date":"2021-03-30T08:09:50.000Z","updated":"2021-04-07T14:48:31.129Z","comments":true,"path":"2021/03/30/爬虫基础篇之IP代理池/","link":"","permalink":"http://onejane.github.io/2021/03/30/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BIP%E4%BB%A3%E7%90%86%E6%B1%A0/","excerpt":"","text":"代理池介绍由众多ip组成提供多个稳定可用代理IP的ip池。 当我们做爬虫时，最常见的反爬手段就是IP反爬，当同一个IP访问网站超出频控限制，将会被限制访问，那么代理IP池应运而生。资金充足的情况下个人建议还是付费ip代理池，比较免费ip时效性低，且难以维护。 本文将介绍通过requests库多线程抓取多个免费代理ip网站数据落库mongo后并动态维护保证IP高度可用，以API形式暴露接口获取代理IP的解决方案。 爬取流程 代理IP采集模块： 采集代理IP -&gt; 检测代理IP -&gt;如果不可用用, 直接过滤掉, 如果可用, 指定默认分数 -&gt; 存入数据库中 代理IP检测模块： 从数据库中获取所有代理IP -&gt; 检测代理IP -&gt; 如果代理IP不可用用, 就把分数-1, 如果分数为0从数据库中删除, 否则更新数据库, 如果代理IP可用, 恢复为默认分值,更新数据库 代理API模块：从数据库中高可用的代理IP给爬虫使用; 模块爬虫模块从代理IP网站上采集代理IP ,对抓取的ip进行校验(获取代理响应速度, 协议类型, 匿名类型), 并存储到数据库中。 校验模块网站上所标注的响应速度,协议类型和匿名类型是不准确的，通过httpbin.org进行检测，获取指定代理的响应速度, 支持的协议以及匿名程度。 数据库模块使用MongoDB来存储代理IP并实现对代理IP的增删改查操作。 检测模块定时从数据库读取所有的代理IP，对代理IP进行逐一检测, 开启多个协程, 以提高检测速度，如果该代理不可用, 就让这个代理分数-1, 当代理的分数到0了, 就删除该代理; 如果检测到代理可用就恢复为满分。 API模块根据协议类型和域名获取多个随机的高质量代理IP，根据代理IP不可用域名, 告诉代理池这个代理IP在该域名下不可用, 下次获取这个域名的代理IP时候, 就不会再获取这个代理IP了, 从而保证代理IP高可用性。 其他模块数据模型 代理IP的数据模型, 用于封装代理IP相关信息, 比如ip,端口号, 响应速度, 协议类型, 匿名类型,分数等。 程序入口 代理池提供一个统一的启动入口 工具模块 日志模块: 用于记录日志信息 http模块: 用于获取随机User-Agent的请求头 配置文件 用于默认代理的分数, 配置日志格式, 文件, 启动的爬虫, 检验的间隔时间 等。 实战思路1：依据流程图，逐步实现各个模块，当需要依赖其他模块时，暂停当前模块，开发其他模块功能，实现完毕再回头开发联调。 思路2：先实现不依赖其他模块的基础模块，再逐步实现具体的功能模块，比如爬虫模块, 检测模块, 代理API模块。 这里我们选择思路2实现爬虫代理IP池，因为思路1适合个人完成，不适合分工合作，且不易维护，思路跳来跳去，必须逻辑清晰。 数据模型domainsettings.py 中 定义MAX_SCORE = 50, 表示代理IP的默认最高分数 12345678910111213141516171819202122232425class Proxy(object): def __init__(self, ip, port, protocol&#x3D;-1, nick_type&#x3D;-1, speed&#x3D;-1, area&#x3D;None, score&#x3D;MAX_SCORE, disable_domains&#x3D;[]): # ip: 代理的IP地址 self.ip &#x3D; ip # port: 代理IP的端口号 self.port &#x3D; port # protocol: 代理IP支持的协议类型, http是0, https是1, https和http都支持是2，-1不可用 self.protocol &#x3D; protocol # nick_type: 代理IP的匿名程度, 高匿: 0, 匿名: 1, 透明: 2 self.nick_type &#x3D; nick_type # speed: 代理IP的响应速度, 单位s self.speed &#x3D; speed # area: 代理IP所在地区 self.area &#x3D; area # score: 代理IP的评分, 用于衡量代理的可用性; self.score &#x3D; score # 默认分值可以通过配置文件进行配置.在进行代理可用性检查的时候, 每遇到一次请求失败就减1份, 减到0的时候从池中删除.如果检查代理可用, 就恢复默认分值 # disable_domains: 不可用域名列表, 有些代理IP在某些域名下不可用, 但是在其他域名下可用 self.disable_domains &#x3D; disable_domains # 3. 提供 __str__ 方法, 返回数据字符串 def __str__(self): # 返回数据字符串 return str(self.__dict__) 日志模块log导入settings中日志配置信息,如下LOG_LEVEL = logging.DEBUG # 默认等级LOG_FMT = ‘%(asctime)s %(filename)s [line:%(lineno)d] %(levelname)s: %(message)s’ # 默认日志格式LOG_DATEFMT = ‘%Y-%m-%d %H:%M:%S’ # 默认时间格式LOG_FILENAME = ‘log.log’ # 默认日志文件名称 12345678910111213141516171819202122232425262728293031323334353637383940class Logger(object): def __init__(self): # 1. 获取一个logger对象 self._logger &#x3D; logging.getLogger() # 2. 设置format对象 self.formatter &#x3D; logging.Formatter(fmt&#x3D;LOG_FMT,datefmt&#x3D;LOG_DATEFMT) # 3. 设置日志输出 # 3.1 设置文件日志模式 self._logger.addHandler(self._get_file_handler(LOG_FILENAME)) # 3.2 设置终端日志模式 self._logger.addHandler(self._get_console_handler()) # 4. 设置日志等级 self._logger.setLevel(LOG_LEVEL) def _get_file_handler(self, filename): &#39;&#39;&#39;返回一个文件日志handler&#39;&#39;&#39; # 1. 获取一个文件日志handler filehandler &#x3D; logging.FileHandler(filename&#x3D;filename,encoding&#x3D;&quot;utf-8&quot;) # 2. 设置日志格式 filehandler.setFormatter(self.formatter) # 3. 返回 return filehandler def _get_console_handler(self): &#39;&#39;&#39;返回一个输出到终端日志handler&#39;&#39;&#39; # 1. 获取一个输出到终端日志handler console_handler &#x3D; logging.StreamHandler(sys.stdout) # 2. 设置日志格式 console_handler.setFormatter(self.formatter) # 3. 返回handler return console_handler @property def logger(self): return self._logger# 初始化并配一个logger对象，达到单例的# 使用时，直接导入logger就可以使用logger &#x3D; Logger().logger 请求模块http返回随机请求头和随机User-Agent,对抗反爬 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 1. 准备User-Agent的列表USER_AGENTS &#x3D; [ &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident&#x2F;4.0; WOW64; Trident&#x2F;4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit&#x2F;523.15 (KHTML, like Gecko, Safari&#x2F;419.3) Arora&#x2F;0.3 (Change: 287 c9dfb30)&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux; en-US) AppleWebKit&#x2F;527+ (KHTML, like Gecko, Safari&#x2F;419.3) Arora&#x2F;0.6&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko&#x2F;20070215 K-Ninja&#x2F;2.1.1&quot;, &quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko&#x2F;20080705 Firefox&#x2F;3.0 Kapiko&#x2F;3.0&quot;, &quot;Mozilla&#x2F;5.0 (X11; Linux i686; U;) Gecko&#x2F;20070322 Kazehakase&#x2F;0.4.5&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora&#x2F;1.9.0.8-1.fc10 Kazehakase&#x2F;0.5.6&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;535.11 (KHTML, like Gecko) Chrome&#x2F;17.0.963.56 Safari&#x2F;535.11&quot;, &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit&#x2F;535.20 (KHTML, like Gecko) Chrome&#x2F;19.0.1036.7 Safari&#x2F;535.20&quot;, &quot;Opera&#x2F;9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto&#x2F;2.9.168 Version&#x2F;11.52&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;536.11 (KHTML, like Gecko) Chrome&#x2F;20.0.1132.11 TaoBrowser&#x2F;2.0 Safari&#x2F;536.11&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.71 Safari&#x2F;537.1 LBBROWSER&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;535.11 (KHTML, like Gecko) Chrome&#x2F;17.0.963.84 Safari&#x2F;535.11 LBBROWSER&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser&#x2F;7.0.3698.400)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident&#x2F;4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident&#x2F;5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 5.1) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.89 Safari&#x2F;537.1&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;21.0.1180.89 Safari&#x2F;537.1&quot;, &quot;Mozilla&#x2F;5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit&#x2F;533.17.9 (KHTML, like Gecko) Version&#x2F;5.0.2 Mobile&#x2F;8C148 Safari&#x2F;6533.18.5&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko&#x2F;20110307 Firefox&#x2F;4.0b13pre&quot;, &quot;Mozilla&#x2F;5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko&#x2F;20100101 Firefox&#x2F;16.0&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.11 (KHTML, like Gecko) Chrome&#x2F;23.0.1271.64 Safari&#x2F;537.11&quot;, &quot;Mozilla&#x2F;5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko&#x2F;20100922 Ubuntu&#x2F;10.10 (maverick) Firefox&#x2F;3.6.10&quot;]# 实现一个方法, 获取随机User-Agent的请求头def get_request_headers(): headers &#x3D; &#123; &#39;User-Agent&#39;: random.choice(USER_AGENTS), &#39;Accept&#39;: &#39;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8&#39;, &#39;Accept-Language&#39;: &#39;en-US,en;q&#x3D;0.5&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#125; return headers 校验模块httpbin_validator 检查代理IP速度 和 匿名程度; 代理IP速度: 就是从发送请求到获取响应的时间间隔 匿名程度检查: 对 http://httpbin.org/get 或 https://httpbin.org/get 发送请求 如果 响应的origin 中有’,’分割的两个IP就是透明代理IP 如果 响应的headers 中包含 Proxy-Connection 说明是匿名代理IP 否则就是高匿代理IP 检查代理IP协议类型 如果 http://httpbin.org/get 发送请求可以成功, 说明支持http协议 如果 https://httpbin.org/get 发送请求可以成功, 说明支持https协议 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778def check_proxy(proxy): &quot;&quot;&quot; 用于检查指定 代理IP 响应速度, 匿名程度, 支持协议类型 :param proxy: 代理IP模型对象 :return: 检查后的代理IP模型对象 &quot;&quot;&quot; # 准备代理IP字典 proxies &#x3D; &#123; &#39;http&#39;:&#39;http:&#x2F;&#x2F;&#123;&#125;:&#123;&#125;&#39;.format(proxy.ip, proxy.port), &#39;https&#39;:&#39;https:&#x2F;&#x2F;&#123;&#125;:&#123;&#125;&#39;.format(proxy.ip, proxy.port), &#125; # 测试该代理IP http, http_nick_type, http_speed &#x3D; __check_http_proxies(proxies) https, https_nick_type, https_speed &#x3D; __check_http_proxies(proxies, False) # 代理IP支持的协议类型, http是0, https是1, https和http都支持是2 if http and https: proxy.protocol &#x3D; 2 proxy.nick_type &#x3D; http_nick_type proxy.speed &#x3D; http_speed elif http: proxy.protocol &#x3D; 0 proxy.nick_type &#x3D; http_nick_type proxy.speed &#x3D; http_speed elif https: proxy.protocol &#x3D; 1 proxy.nick_type &#x3D; https_nick_type proxy.speed &#x3D; https_speed else: proxy.protocol &#x3D; -1 proxy.nick_type &#x3D; -1 proxy.speed &#x3D; -1 return proxydef __check_http_proxies(proxies, is_http&#x3D;True): # 匿名类型: 高匿: 0, 匿名: 1, 透明: 2 nick_type &#x3D; -1 # 响应速度, 单位s speed &#x3D; -1 if is_http: test_url &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39; else: test_url &#x3D; &#39;https:&#x2F;&#x2F;httpbin.org&#x2F;get&#39; try: # 获取开始时间 start &#x3D; time.time() # 发送请求, 获取响应数据 response &#x3D; requests.get(test_url, headers&#x3D;get_request_headers(), proxies&#x3D;proxies, timeout&#x3D;TEST_TIMEOUT) if response.ok: # 计算响应速度 speed &#x3D; round(time.time() - start, 2) # 匿名程度 # 把响应的json字符串, 转换为字典 dic &#x3D; json.loads(response.text) # 获取来源IP: origin origin &#x3D; dic[&#39;origin&#39;] proxy_connection &#x3D; dic[&#39;headers&#39;].get(&#39;Proxy-Connection&#39;, None) if &#39;,&#39; in origin: # 1. 如果 响应的origin 中有&#39;,&#39;分割的两个IP就是透明代理IP nick_type &#x3D; 2 elif proxy_connection: # 2. 如果 响应的headers 中包含 Proxy-Connection 说明是匿名代理IP nick_type &#x3D; 1 else: # 3. 否则就是高匿代理IP nick_type &#x3D; 0 return True, nick_type, speed return False, nick_type, speed except Exception as ex: # logger.exception(ex) return False, nick_type, speed 数据库模块mongo_pool 在init中, 建立数据连接, 获取要操作的集合, 在 del 方法中关闭数据库连接 提供基础的增删改查功能 提供代理API模块使用的功能 实现查询功能: 根据条件进行查询, 可以指定查询数量, 先分数降序, 速度升序排, 保证优质的代理IP在上面. 实现根据协议类型 和 要访问网站的域名, 获取代理IP列表 实现根据协议类型 和 要访问网站的域名, 随机获取一个代理IP 实现把指定域名添加到指定IP的disable_domain列表中. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121class MongoPool(object): def __init__(self): # 1.1. 在init中, 建立数据连接 self.client &#x3D; MongoClient(MONGO_URL) # 1.2 获取要操作的集合 self.proxies &#x3D; self.client[&#39;proxies_pool&#39;][&#39;proxies&#39;] def __del__(self): # 1.3 关闭数据库连接 self.client.close() def insert_one(self, proxy): &quot;&quot;&quot;2.1 实现插入功能&quot;&quot;&quot; count &#x3D; self.proxies.count_documents(&#123;&#39;_id&#39;: proxy.ip&#125;) if count &#x3D;&#x3D; 0: # 我们使用proxy.ip作为, MongoDB中数据的主键: _id dic &#x3D; proxy.__dict__ dic[&#39;_id&#39;] &#x3D; proxy.ip self.proxies.insert_one(dic) logger.info(&#39;插入新的代理:&#123;&#125;&#39;.format(proxy)) else: logger.warning(&quot;已经存在的代理:&#123;&#125;&quot;.format(proxy)) def update_one(self, proxy): &quot;&quot;&quot;2.2 实现修改该功能&quot;&quot;&quot; self.proxies.update_one(&#123;&#39;_id&#39;: proxy.ip&#125;, &#123;&#39;$set&#39;:proxy.__dict__&#125;) def delete_one(self, proxy): &quot;&quot;&quot;2.3 实现删除代理: 根据代理的IP删除代理&quot;&quot;&quot; self.proxies.delete_one(&#123;&#39;_id&#39;: proxy.ip&#125;) logger.info(&quot;删除代理IP: &#123;&#125;&quot;.format(proxy)) def find_all(self): &quot;&quot;&quot;2.4 查询所有代理IP的功能&quot;&quot;&quot; cursor &#x3D; self.proxies.find() for item in cursor: # 删除_id这个key item.pop(&#39;_id&#39;) proxy &#x3D; Proxy(**item) yield proxy def find(self, conditions&#x3D;&#123;&#125;, count&#x3D;0): &quot;&quot;&quot; 3.1 实现查询功能: 根据条件进行查询, 可以指定查询数量, 先分数降序, 速度升序排, 保证优质的代理IP在上面. :param conditions: 查询条件字典 :param count: 限制最多取出多少个代理IP :return: 返回满足要求代理IP(Proxy对象)列表 &quot;&quot;&quot; cursor &#x3D; self.proxies.find(conditions, limit&#x3D;count).sort([ (&#39;score&#39;, pymongo.DESCENDING),(&#39;speed&#39;, pymongo.ASCENDING) ]) # 准备列表, 用于存储查询处理代理IP proxy_list &#x3D; [] # 遍历 cursor for item in cursor: item.pop(&#39;_id&#39;) proxy &#x3D; Proxy(**item) proxy_list.append(proxy) # 返回满足要求代理IP(Proxy对象)列表 return proxy_list def get_proxies(self, protocol&#x3D;None, domain&#x3D;None, count&#x3D;0, nick_type&#x3D;0): &quot;&quot;&quot; 3.2 实现根据协议类型 和 要访问网站的域名, 获取代理IP列表 :param protocol: 协议: http, https :param domain: 域名: jd.com :param count: 用于限制获取多个代理IP, 默认是获取所有的 :param nick_type: 匿名类型, 默认, 获取高匿的代理IP :return: 满足要求代理IP的列表 &quot;&quot;&quot; # 定义查询条件 conditions &#x3D; &#123;&#39;nick_type&#39;: nick_type&#125; # 根据协议, 指定查询条件 if protocol is None: # 如果没有传入协议类型, 返回支持http和https的代理IP conditions[&#39;protocol&#39;] &#x3D; 2 elif protocol.lower() &#x3D;&#x3D; &#39;http&#39;: conditions[&#39;protocol&#39;] &#x3D; &#123;&#39;$in&#39;: [0, 2]&#125; else: conditions[&#39;protocol&#39;] &#x3D; &#123;&#39;$in&#39;: [1, 2]&#125; if domain: conditions[&#39;disable_domains&#39;] &#x3D; &#123;&#39;$nin&#39;: [domain]&#125; # 满足要求代理IP的列表 return self.find(conditions, count&#x3D;count) def random_proxy(self, protocol&#x3D;None, domain&#x3D;None, count&#x3D;0, nick_type&#x3D;0): &quot;&quot;&quot; 3.3 实现根据协议类型 和 要访问网站的域名, 随机获取一个代理IP :param protocol: 协议: http, https :param domain: 域名: jd.com :param count: 用于限制获取多个代理IP, 默认是获取所有的 :param nick_type: 匿名类型, 默认, 获取高匿的代理IP :return: 满足要求的随机的一个代理IP(Proxy对象) &quot;&quot;&quot; proxy_list &#x3D; self.get_proxies(protocol&#x3D;protocol, domain&#x3D;domain, count&#x3D;count, nick_type&#x3D;nick_type) # 从proxy_list列表中, 随机取出一个代理IP返回 return random.choice(proxy_list) def disable_domain(self, ip, domain): &quot;&quot;&quot; 3.4 实现把指定域名添加到指定IP的disable_domain列表中. :param ip: IP地址 :param domain: 域名 :return: 如果返回True, 就表示添加成功了, 返回False添加失败了 &quot;&quot;&quot; # print(self.proxies.count_documents(&#123;&#39;_id&#39;: ip, &#39;disable_domains&#39;:domain&#125;)) if self.proxies.count_documents(&#123;&#39;_id&#39;: ip, &#39;disable_domains&#39;:domain&#125;) &#x3D;&#x3D; 0: # 如果disable_domains字段中没有这个域名, 才添加 self.proxies.update_one(&#123;&#39;_id&#39;:ip&#125;, &#123;&#39;$push&#39;: &#123;&#39;disable_domains&#39;: domain&#125;&#125;) return True return False 爬虫模块base_spider 在base_spider.py文件中,定义一个BaseSpider类, 继承object 提供三个类成员变量: urls: 代理IP网址的URL的列表 group_xpath: 分组XPATH, 获取包含代理IP信息标签列表的XPATH detail_xpath: 组内XPATH, 获取代理IP详情的信息XPATH, 格式为: {‘ip’:’xx’, ‘port’:’xx’, ‘area’:’xx’} 提供初始方法, 传入爬虫URL列表, 分组XPATH, 详情(组内)XPATH 对外提供一个获取代理IP的方法 遍历URL列表, 获取URL 根据发送请求, 获取页面数据 解析页面, 提取数据, 封装为Proxy对象 返回Proxy对象列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 1. 在base_spider.py文件中,定义一个BaseSpider类, 继承objectclass BaseSpider(object): # 2. 提供三个类成员变量: # urls: 代理IP网址的URL的列表 urls &#x3D; [] # group_xpath: 分组XPATH, 获取包含代理IP信息标签列表的XPATH group_xpath &#x3D; &#39;&#39; # detail_xpath: 组内XPATH, 获取代理IP详情的信息XPATH, 格式为: &#123;&#39;ip&#39;:&#39;xx&#39;, &#39;port&#39;:&#39;xx&#39;, &#39;area&#39;:&#39;xx&#39;&#125; detail_xpath &#x3D; &#123;&#125; # 3. 提供初始方法, 传入爬虫URL列表, 分组XPATH, 详情(组内)XPATH def __init__(self, urls&#x3D;[], group_xpath&#x3D;&#39;&#39;, detail_xpath&#x3D;&#123;&#125;): if urls: self.urls &#x3D; urls if group_xpath: self.group_xpath &#x3D; group_xpath if detail_xpath: self.detail_xpath &#x3D; detail_xpath def get_page_from_url(self, url): &quot;&quot;&quot;根据URL 发送请求, 获取页面数据&quot;&quot;&quot; response &#x3D; requests.get(url, headers&#x3D;get_request_headers()) print(url) print(response.status_code) return response.content def get_first_from_list(self, lis): # 如果列表中有元素就返回第一个, 否则就返回空串 return lis[0] if len(lis) !&#x3D; 0 else &#39;&#39; def get_proxies_from_page(self, page): &quot;&quot;&quot;解析页面, 提取数据, 封装为Proxy对象&quot;&quot;&quot; element &#x3D; etree.HTML(page) # 获取包含代理IP信息的标签列表 trs &#x3D; element.xpath(self.group_xpath) # 遍历trs, 获取代理IP相关信息 for tr in trs: ip &#x3D; self.get_first_from_list(tr.xpath(self.detail_xpath[&#39;ip&#39;])) port &#x3D; self.get_first_from_list(tr.xpath(self.detail_xpath[&#39;port&#39;])) area &#x3D; self.get_first_from_list(tr.xpath(self.detail_xpath[&#39;area&#39;])) proxy &#x3D; Proxy(ip, port, area&#x3D;area) # print(proxy) # 使用yield返回提取到的数据 yield proxy def get_proxies(self): # 4. 对外提供一个获取代理IP的方法 # 4.1 遍历URL列表, 获取URL for url in self.urls: # print(url) # 4.2 根据发送请求, 获取页面数据 page &#x3D; self.get_page_from_url(url) # 4.3 解析页面, 提取数据, 封装为Proxy对象 proxies &#x3D; self.get_proxies_from_page(page) # 4.4 返回Proxy对象列表 yield from proxies 具体爬虫实现proxy_spiders 实现西刺代理爬虫: http://www.xicidaili.com/nn/1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 实现ip3366代理爬虫: http://www.ip3366.net/free/?stype=1&amp;page=1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 实现快代理爬虫: https://www.kuaidaili.com/free/inha/1/ 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 实现proxylistplus代理爬虫: https://list.proxylistplus.com/Fresh-HTTP-Proxy-List-1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 实现66ip爬虫: http://www.66ip.cn/1.html 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 由于66ip网页进行js + cookie反爬, 需要重写父类的get_page_from_url方法 访问http://www.66ip.cn/1.html 时返回一堆js，并不返回具体ip信息，通过逐步增加请求头中的Cookie时发现真正生效的Cookie为_ydclearance，控制台打开Preserve log发现页面第一次1.html做了跳转，历史请求中都没有出现_ydclearance的cookie，第二次请求1.html时已经携带了_ydclearance说明该cookie已经不是服务端响应生成，而是由客户端js生成。 一开始我们访问http://www.66ip.cn/1.html 时返回一堆js，执行这段js，就是用来生成_ydclearance的。那么分析这段js本身做了加密，js中通过定义函数jp并调用后，由于qo=eval，那么等同于最终调用了eval(po)，真正js在 “po” 中。 1result &#x3D; re.findall(&#39;window.onload&#x3D;setTimeout\\(&quot;(.+?)&quot;, 200\\);\\s*(.+?)\\s*&lt;&#x2F;script&gt;&#39; ,text) 通过正则提取 jp(107) 调用函数方法, 以及函数内容 function jp(WI) { var qo, mo=&quot;&quot; ...，通过将替换eval拿到返回的真实js 12func_str &#x3D; result[0][1]func_str &#x3D; func_str.replace(&#39;eval(&quot;qo&#x3D;eval;qo(po);&quot;)&#39;, &#39;return po&#39;) 执行js并将返回作为Cookie添加到请求头中 12345context &#x3D; js2py.EvalJs()context.execute(func_str)context.execute(&#39;code &#x3D; &#123;&#125;;&#39;.format(result[0][0]))cookie_str &#x3D; re.findall(&quot;document.cookie&#x3D;&#39;(.+?); &quot;, context.code)[0]headers[&#39;Cookie&#39;] &#x3D; cookie_str 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125class XiciSpider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;https:&#x2F;&#x2F;www.xicidaili.com&#x2F;nn&#x2F;&#123;&#125;&#39;.format(i) for i in range(1, 11)] # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;ip_list&quot;]&#x2F;tr[position()&gt;1]&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[3]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[4]&#x2F;a&#x2F;text()&#39; &#125;&quot;&quot;&quot;2. 实现ip3366代理爬虫: http:&#x2F;&#x2F;www.ip3366.net&#x2F;free&#x2F;?stype&#x3D;1&amp;page&#x3D;1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath&quot;&quot;&quot;class Ip3366Spider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;http:&#x2F;&#x2F;www.ip3366.net&#x2F;free&#x2F;?stype&#x3D;&#123;&#125;&amp;page&#x3D;&#123;&#125;&#39;.format(i, j) for i in range(1, 4, 2) for j in range(1, 8)] # # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;list&quot;]&#x2F;table&#x2F;tbody&#x2F;tr&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[1]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[5]&#x2F;text()&#39; &#125;&quot;&quot;&quot;3. 实现快代理爬虫: https:&#x2F;&#x2F;www.kuaidaili.com&#x2F;free&#x2F;inha&#x2F;1&#x2F; 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath&quot;&quot;&quot;class KaiSpider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;https:&#x2F;&#x2F;www.kuaidaili.com&#x2F;free&#x2F;inha&#x2F;&#123;&#125;&#x2F;&#39;.format(i) for i in range(1, 6)] # # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;list&quot;]&#x2F;table&#x2F;tbody&#x2F;tr&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[1]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[5]&#x2F;text()&#39; &#125; # 当我们两个页面访问时间间隔太短了, 就报错了; 这是一种反爬手段. def get_page_from_url(self, url): # 随机等待1,3s time.sleep(random.uniform(1, 3)) # 调用父类的方法, 发送请求, 获取响应数据 return super().get_page_from_url(url)&quot;&quot;&quot;4. 实现proxylistplus代理爬虫: https:&#x2F;&#x2F;list.proxylistplus.com&#x2F;Fresh-HTTP-Proxy-List-1 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath&quot;&quot;&quot;class ProxylistplusSpider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;https:&#x2F;&#x2F;list.proxylistplus.com&#x2F;Fresh-HTTP-Proxy-List-&#123;&#125;&#39;.format(i) for i in range(1, 7)] # # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;page&quot;]&#x2F;table[2]&#x2F;tbody&#x2F;tr[position()&gt;2]&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[3]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[5]&#x2F;text()&#39; &#125;&quot;&quot;&quot;5. 实现66ip爬虫: http:&#x2F;&#x2F;www.66ip.cn&#x2F;1.html 定义一个类,继承通用爬虫类(BasicSpider) 提供urls, group_xpath 和 detail_xpath 由于66ip网页进行js + cookie反爬, 需要重写父类的get_page_from_url方法&quot;&quot;&quot;class Ip66Spider(BaseSpider): # 准备URL列表 urls &#x3D; [&#39;http:&#x2F;&#x2F;www.66ip.cn&#x2F;&#123;&#125;.html&#39;.format(i) for i in range(1, 11)] # # 分组的XPATH, 用于获取包含代理IP信息的标签列表 group_xpath &#x3D; &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;main&quot;]&#x2F;div&#x2F;div[1]&#x2F;table&#x2F;tbody&#x2F;tr[position()&gt;1]&#39; # 组内的XPATH, 用于提取 ip, port, area detail_xpath &#x3D; &#123; &#39;ip&#39;:&#39;.&#x2F;td[1]&#x2F;text()&#39;, &#39;port&#39;:&#39;.&#x2F;td[2]&#x2F;text()&#39;, &#39;area&#39;:&#39;.&#x2F;td[3]&#x2F;text()&#39; &#125; # 重写方法, 解决反爬问题 def get_page_from_url(self, url): headers &#x3D; get_request_headers() response &#x3D; requests.get(url, headers&#x3D;headers) if response.status_code &#x3D;&#x3D; 521: # 生成cookie信息, 再携带cookie发送请求 # 生成 &#96;_ydclearance&#96; cookie信息,控制台preserve log,第一个页面就是加密页面521用来做反爬跳转 # 1. 确定 _ydclearance 是从哪里来的; # 观察发现: 这个cookie在前两个页面都没有返回，说明信息不使用通过服务器响应设置过来的; 那么他就是通过js生成. # 2. 第一次发送请求的页面中, 有一个生成这个cookie的js; 执行这段js, 生成我们需要的cookie # 这段js是经过加密处理后的js, 真正js在 &quot;po&quot; 中. # 提取 &#96;jp(107)&#96; 调用函数的方法, 以及函数 result &#x3D; re.findall(&#39;window.onload&#x3D;setTimeout\\(&quot;(.+?)&quot;, 200\\);\\s*(.+?)\\s*&lt;&#x2F;script&gt; &#39;, response.content.decode(&#39;GBK&#39;)) # print(result) # 我希望执行js时候, 返回真正要执行的js # 把 &#96;eval(&quot;qo&#x3D;eval;qo(po);&quot;)&#96; 替换为 return po func_str &#x3D; result[0][1] func_str &#x3D; func_str.replace(&#39;eval(&quot;qo&#x3D;eval;qo(po);&quot;)&#39;, &#39;return po&#39;) # print(func_str) # 获取执行js的环境 context &#x3D; js2py.EvalJs() # 加载(执行) func_str context.execute(func_str) # 执行这个方法, 生成我们需要的js # code &#x3D; gv(50) context.execute(&#39;code &#x3D; &#123;&#125;;&#39;.format(result[0][0])) # 打印最终生成的代码 # print(context.code) cookie_str &#x3D; re.findall(&quot;document.cookie&#x3D;&#39;(.+?); &quot;, context.code)[0] # print(cookie_str) headers[&#39;Cookie&#39;] &#x3D; cookie_str response &#x3D; requests.get(url, headers&#x3D;headers) return response.content.decode(&#39;GBK&#39;) else: return response.content.decode(&#39;GBK&#39;) 运行爬虫模块run_spiders 创建RunSpider类 提供一个运行爬虫的run方法 根据配置文件信息, 加载爬虫, 把爬虫对象放到列表中 遍历爬虫对象列表, 获取代理, 检测代理(代理IP检测模块), 写入数据库(数据库模块) 使用异步来执行每一个爬虫任务 每隔一定的时间, 执行一次爬取任务 settings配置RUN_SPIDERS_INTERVAL作为爬虫运行时间间隔的配置, 单位为小时 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class RunSpider(object): def __init__(self): # 创建MongoPool对象 self.mongo_pool &#x3D; MongoPool() # 3.1 在init方法中创建协程池对象 self.coroutine_pool &#x3D; Pool() def get_spider_from_settings(self): &quot;&quot;&quot;根据配置文件信息, 获取爬虫对象列表.&quot;&quot;&quot; # 遍历配置文件中爬虫信息, 获取每个爬虫全类名 for full_class_name in PROXIES_SPIDERS: # core.proxy_spider.proxy_spiders.Ip66Spider # 获取模块名 和 类名 module_name, class_name &#x3D; full_class_name.rsplit(&#39;.&#39;, maxsplit&#x3D;1) # 根据模块名, 导入模块 module &#x3D; importlib.import_module(module_name) # 根据类名, 从模块中, 获取类 cls &#x3D; getattr(module, class_name) # 创建爬虫对象 spider &#x3D; cls() # print(spider) yield spider def run(self): # 2.1 根据配置文件信息, 获取爬虫对象列表. spiders &#x3D; self.get_spider_from_settings() # 2.2 遍历爬虫对象列表, 获取爬虫对象, 遍历爬虫对象的get_proxies方法, 获取代理IP for spider in spiders: # 2.5 处理异常, 防止一个爬虫内部出错了, 影响其他的爬虫. # 3.3 使用异步执行这个方法 # self.__execute_one_spider_task(spider) self.coroutine_pool.apply_async(self.__execute_one_spider_task,args&#x3D;(spider, )) # 3.4 调用协程的join方法, 让当前线程等待 协程 任务的完成. self.coroutine_pool.join() def __execute_one_spider_task(self, spider): # 3.2 把处理一个代理爬虫的代码抽到一个方法 # 用于处理一个爬虫任务的. try: # 遍历爬虫对象的get_proxies方法, 获取代理I for proxy in spider.get_proxies(): # print(proxy) # 2.3 检测代理IP(代理IP检测模块) proxy &#x3D; check_proxy(proxy) # 2.4 如果可用,写入数据库(数据库模块) # 如果speed不为-1, 就说明可用 if proxy.speed !&#x3D; -1: # 写入数据库(数据库模块) self.mongo_pool.insert_one(proxy) except Exception as ex: logger.exception(ex) @classmethod def start(cls): # 4. 使用schedule模块, 实现每隔一定的时间, 执行一次爬取任务 # 4.1 定义一个start的类方法 # 4.2 创建当前类的对象, 调用run方法 rs &#x3D; RunSpider() rs.run() # 4.3 使用schedule模块, 每隔一定的时间, 执行当前对象的run方法 # 4.3.1 修改配置文件, 增加爬虫运行时间间隔的配置, 单位为小时 schedule.every(RUN_SPIDERS_INTERVAL).hours.do(rs.run) while True: schedule.run_pending() time.sleep(1) 检测模块proxy_test 创建ProxyTester类，检查代理IP可用性, 保证代理池中代理IP基本可用 提供一个 run 方法, 用于处理检测代理IP核心逻辑 从数据库中获取所有代理IP 遍历代理IP列表 检查代理可用性 如果代理不可用, 让代理分数-1, 如果代理分数等于0就从数据库中删除该代理, 否则更新该代理IP 如果代理可用, 就恢复该代理的分数, 更新到数据库中 为了提高检查的速度, 使用异步来执行检测任务 把要检测的代理IP, 放到队列中 把检查一个代理可用性的代码, 抽取到一个方法中; 从队列中获取代理IP, 进行检查; 检查完毕, 调度队列的task_done方法 通过异步回调, 使用死循环不断执行这个方法, 开启多个一个异步任务, 来处理代理IP的检测; 可以通过配置文件指定异步数量 使用schedule模块, 每隔一定的时间, 执行一次检测任务 定义类方法 start, 用于启动检测模块 在start方法中 创建本类对象 调用run方法 每间隔一定时间, 执行一下, run方法 setting.py 文件, 检查代理IP可用性间隔时间的配置 RUN_SPIDERS_INTERVAL = 2 # 修改配置文件, 增加爬虫运行时间间隔的配置, 单位为小时TEST_PROXIES_ASYNC_COUNT = 10 # 配置检测代理IP的异步数量TEST_PROXIES_INTERVAL = 2 # 配置检查代理IP的时间间隔, 单位是小时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class ProxyTester(object): def __init__(self): # 创建操作数据库的MongoPool对象 self.mongo_pool &#x3D; MongoPool() # 3.1 在&#96;init&#96;方法, 创建队列和协程池 self.queue &#x3D; Queue() self.coroutine_pool &#x3D; Pool() def __check_callback(self, temp): self.coroutine_pool.apply_async(self.__check_one_proxy, callback&#x3D;self.__check_callback) def run(self): # 提供一个 run 方法, 用于处理检测代理IP核心逻辑 # 2.1 从数据库中获取所有代理IP proxies &#x3D; self.mongo_pool.find_all() # 2.2 遍历代理IP列表 for proxy in proxies: # 3.2 把要检测的代理IP, 放到队列中 self.queue.put(proxy) # 3.5 开启多个一个异步任务, 来处理代理IP的检测; 可以通过配置文件指定异步数量 for i in range(TEST_PROXIES_ASYNC_COUNT): # 3.4 通过异步回调, 使用死循环不断执行这个方法, self.coroutine_pool.apply_async(self.__check_one_proxy, callback&#x3D;self.__check_callback) # 让当前线程, 等待队列任务完成 self.queue.join() def __check_one_proxy(self): # 检查一个代理IP的可用性 # 3.3 把检查一个代理可用性的代码, 抽取到一个方法中; # 从队列中获取代理IP, 进行检查; 检查完毕 proxy &#x3D; self.queue.get() # 2.3 检查代理可用性 proxy &#x3D; check_proxy(proxy) # 2.4 如果代理不可用, 让代理分数-1, if proxy.speed &#x3D;&#x3D; -1: proxy.score -&#x3D; 1 # 如果代理分数等于0就从数据库中删除该代理 if proxy.score &#x3D;&#x3D; 0: self.mongo_pool.delete_one(proxy) else: # 否则更新该代理IP self.mongo_pool.update_one(proxy) else: # 2.5 如果代理可用, 就恢复该代理的分数, 更新到数据库中 proxy.score &#x3D; MAX_SCORE self.mongo_pool.update_one(proxy) # 调度队列的task_done方法 self.queue.task_done() @classmethod def start(cls): # 4.2.1 创建本类对象 proxy_tester &#x3D; cls() # 4.2.2 调用run方法 proxy_tester.run() # 4.2.3 每间隔一定时间, 执行一下, run方法 schedule.every(TEST_PROXIES_INTERVAL).hours.do(proxy_tester.run) while True: schedule.run_pending() time.sleep(1) API模块proxy_api 创建ProxyApi类，为爬虫提供高可用代理IP的服务接口 实现初始方法 初始一个Flask的Web服务 实现根据协议类型和域名, 提供随机的获取高可用代理IP的服务 可用通过 protocol 和 domain 参数对IP进行过滤 protocol: 当前请求的协议类型 domain: 当前请求域名 实现根据协议类型和域名, 提供获取多个高可用代理IP的服务 可用通过protocol 和 domain 参数对IP进行过滤 实现给指定的IP上追加不可用域名的服务 如果在获取IP的时候, 有指定域名参数, 将不在获取该IP, 从而进一步提高代理IP的可用性. 实现run方法, 用于启动Flask的WEB服务 实现start的类方法, 用于通过类名, 启动服务 settings中配置PROXIES_MAX_COUNT配置获取的代理IP最大数量; 这个越小可用性就越高; 但是随机性越差 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class ProxyApi(object): def __init__(self): # 2. 实现初始方法 # 2.1 初始一个Flask的Web服务 self.app &#x3D; Flask(__name__) # 创建MongoPool对象, 用于操作数据库 self.mongo_pool &#x3D; MongoPool() @self.app.route(&#39;&#x2F;random&#39;) def random(): &quot;&quot;&quot; localhost:6868&#x2F;random?protocol&#x3D;https&amp;domain&#x3D;jd.com 2.2 实现根据协议类型和域名, 提供随机的获取高可用代理IP的服务 可用通过 protocol 和 domain 参数对IP进行过滤 protocol: 当前请求的协议类型 domain: 当前请求域名 &quot;&quot;&quot; protocol &#x3D; request.args.get(&#39;protocol&#39;) domain &#x3D; request.args.get(&#39;domain&#39;) proxy &#x3D; self.mongo_pool.random_proxy(protocol, domain, count&#x3D;PROXIES_MAX_COUNT) if protocol: return &#39;&#123;&#125;:&#x2F;&#x2F;&#123;&#125;:&#123;&#125;&#39;.format(protocol, proxy.ip, proxy.port) else: return &#39;&#123;&#125;:&#123;&#125;&#39;.format(proxy.ip, proxy.port) @self.app.route(&#39;&#x2F;proxies&#39;) def proxies(): &quot;&quot;&quot; localhost:6868&#x2F;proxies?protocol&#x3D;https&amp;domain&#x3D;jd.com 2.3 实现根据协议类型和域名, 提供获取多个高可用代理IP的服务 可用通过protocol 和 domain 参数对IP进行过滤 实现给指定的IP上追加不可用域名的服务 &quot;&quot;&quot; # 获取协议: http&#x2F;https protocol &#x3D; request.args.get(&#39;protocol&#39;) # 域名: 如:jd.com domain &#x3D; request.args.get(&#39;domain&#39;) proxies &#x3D; self.mongo_pool.get_proxies(protocol, domain, count&#x3D;PROXIES_MAX_COUNT) # proxies 是一个 Proxy对象的列表, 但是Proxy对象不能进行json序列化, 需要转换为字典列表 # 转换为字典列表 proxies &#x3D; [proxy.__dict__ for proxy in proxies] # 返回json格式值串 return json.dumps(proxies) @self.app.route(&#39;&#x2F;disable_domain&#39;) def disable_domain(): &quot;&quot;&quot; localhost:6868&#x2F;disable_domain?ip&#x3D;120.92.174.12&amp;domain&#x3D;jd.com 2.4 如果在获取IP的时候, 有指定域名参数, 将不在获取该IP, 从而进一步提高代理IP的可用性. &quot;&quot;&quot; ip &#x3D; request.args.get(&#39;ip&#39;) domain &#x3D; request.args.get(&#39;domain&#39;) if ip is None: return &#39;请提供ip参数&#39; if domain is None: return &#39;请提供域名domain参数&#39; self.mongo_pool.disable_domain(ip, domain) return &quot;&#123;&#125; 禁用域名 &#123;&#125; 成功&quot;.format(ip, domain) def run(self): &quot;&quot;&quot;3. 实现run方法, 用于启动Flask的WEB服务&quot;&quot;&quot; self.app.run(&#39;0.0.0.0&#39;, port&#x3D;6868) @classmethod def start(cls): # 4. 实现start的类方法, 用于通过类名, 启动服务 proxy_api &#x3D; cls() proxy_api.run() 启动入口main 定义一个run方法用于启动动代理池，开启三个进程, 分别用于启动爬虫, 检测代理IP, WEB服务 定义一个列表, 用于存储要启动的进程 创建 启动爬虫 的进程, 添加到列表中 创建 启动检测 的进程, 添加到列表中 创建 启动提供API服务 的进程, 添加到列表中 遍历进程列表, 启动所有进程 遍历进程列表, 让主进程等待子进程的完成 在 if __name__ == &#39;__main__&#39;: 中调用run方法 12345678910111213141516171819202122def run(): # 1. 定义一个列表, 用于存储要启动的进程 process_list &#x3D; [] # 2. 创建 启动爬虫 的进程, 添加到列表中 process_list.append(Process(target&#x3D;RunSpider.start)) # 3. 创建 启动检测 的进程, 添加到列表中 process_list.append(Process(target&#x3D;ProxyTester.start)) # 4. 创建 启动提供API服务 的进程, 添加到列表中 process_list.append(Process(target&#x3D;ProxyApi.start)) # 5. 遍历进程列表, 启动所有进程 for process in process_list: # 设置守护进程 process.daemon &#x3D; True process.start() # 6. 遍历进程列表, 让主进程等待子进程的完成 for process in process_list: process.join()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: run() 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"requests","slug":"requests","permalink":"http://onejane.github.io/tags/requests/"},{"name":"pymongo","slug":"pymongo","permalink":"http://onejane.github.io/tags/pymongo/"},{"name":"flask","slug":"flask","permalink":"http://onejane.github.io/tags/flask/"}]},{"title":"爬虫基础篇之页面请求解析","slug":"爬虫基础篇之页面请求解析","date":"2021-03-30T08:09:50.000Z","updated":"2021-04-07T14:48:31.153Z","comments":true,"path":"2021/03/30/爬虫基础篇之页面请求解析/","link":"","permalink":"http://onejane.github.io/2021/03/30/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90/","excerpt":"","text":"CSS选择器html中为指定元素指定显示效果，比如颜色，背景，字体等不同的属性，这些样式都是通过css选择器告诉浏览器指定样式风格。 表达式 含义 #animal 获取id为animal的所有元素 .animal 获取class为animal的所有元素 a.active 获取类为active的a标签 .animal &gt; .pig 获取类animal直接子元素中类为.pig的元素 .animal .pig 获取类animal后代元素中类为.pig的元素 a[href*=”animal”] 获取包含类animal的a元素 a[href^=”http”] 获取href以http开头的a元素 a[href$=”gov.cn”] 获取href以gov.cn结尾的a元素 div[class=”animal”][ctype=”pig”] 获取多属性同时具备的元素 div &gt; a:nth-child(2) 获取div下的第二个a元素 .pig , .animal 同时选择两个class的所有元素 p:nth-last-child(1) 获取倒数第一个p元素 p:nth-child(even) p:nth-child(odd) 获取奇数偶数节点 h3 + span 获取h3 后面紧跟着的兄弟节点 span h3 ~ span 获取h3 后面所有的兄弟节点 span 实战链家目标抓取网站：https://su.lianjia.com/ershoufang/pg 抓取内容：分页抓取二手房的标题，地址，信息，关注量，标签，总价，单价等 分析 通过获取网页源代码发现所有的二手房信息都直接渲染在页面上，那么可以直接请求页面地址分析二手房源码后，通过parsel库parsel.Selector(html_data)转为我们可以使用选择器分析的对象。 通过css选择器.clear.LOGCLICKDATA拿到所有的二手房信息所在的li元素 在li元素下可以css选择器获取所有的.title a::text标题，.positionInfo a::text地址，.followInfo::text关注量等信息。 1234567891011121314selector &#x3D; parsel.Selector(html_data)lis &#x3D; selector.css(&#39;.clear.LOGCLICKDATA&#39;)for li in lis: title &#x3D; li.css(&#39;.title a::text&#39;).get() # 标题 address &#x3D; li.css(&#39;.positionInfo a::text&#39;).getall() # 地址 address &#x3D; &#39;,&#39;.join(address) houseInfo &#x3D; li.css(&#39;.houseInfo::text&#39;).get() # 信息 followInfo &#x3D; li.css(&#39;.followInfo::text&#39;).get() # 关注 tags &#x3D; li.css(&#39;.tag span::text&#39;).get() # 标签 tags &#x3D; &#39;,&#39;.join(tags) totalPrice &#x3D; li.css(&#39;.totalPrice span::text&#39;).get() + &#39;万&#39; # 总价 unitePrice &#x3D; li.css(&#39;.unitPrice span::text&#39;).get() # 单价 title_url &#x3D; li.css(&#39;.title a::attr(href)&#39;).get() # 标题 print(title, address, houseInfo, followInfo, tags, totalPrice, unitePrice, title_url, sep&#x3D;&quot;---&quot;) 爬取完成点击下一页的时候，页面url添加了路径参数pg{}，那么可以通过加该字段实现分页抓取。 猫眼电影分析目标抓取网站：https://maoyan.com/board 抓取内容：热映口碑榜的电影名，主演，上映时间等。 老规矩，查看网页源代码电影数据完整返回给前端，没有做异步请求。那么直接访问猫眼的热映口碑榜通过parsel库解析成Selector对象，开始利用css选择器分析页面字段。 通过控制台源码发现类.board-wrapper下dd元素包含了所有的电影信息，那么遍历其下的标签列表根据css选择器筛选拿到需要的数据即可。 1234567891011121314selector &#x3D; parsel.Selector(html_data)print(selector)dds &#x3D; selector.css(&#39;.board-wrapper dd&#39;)for dd in dds: title &#x3D; dd.css(&#39;.name a::attr(title)&#39;).get() star &#x3D; dd.css(&#39;.star::text&#39;).get().strip() releasetime &#x3D; dd.css(&#39;.releasetime::text&#39;).get() score &#x3D; dd.css(&#39;.score i::text&#39;).getall() score &#x3D; &#39;&#39;.join(score) print(title, star, releasetime, score) with open(&#39;maoyan.csv&#39;, mode&#x3D;&#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;, newline&#x3D;&#39;&#39;) as f: csv_write &#x3D; csv.writer(f) csv_write.writerow([title, star, releasetime, score]) 爬取完成 喜马拉雅分析目标网站：https://www.ximalaya.com/xiangsheng/9723091 抓取内容：下载当前主题的所有页面的音频文件。 老规矩，查看网页源代码发现所有的音频标签会在当前页面ur后添加音频的id跳转到一个新的页面，如：https://www.ximalaya.com/xiangsheng/9723091/45982355 点击播放后，控制台的Media出现请求的音频地址,如：https://aod.cos.tx.xmcdn.com/group31/M01/36/04/wKgJSVmC6drBDNayAh_Q8WincwI414.m4a 通过控制台搜索音频关键字段，找到返回音频地址的请求https://www.ximalaya.com/revision/play/v1/audio?id=46106992&amp;ptype=1 该请求参数由音频id和ptype=1组成，通过css选择器.sound-list li.lF_ a::attr(href)分析列表页的音频的href拿到音频id，通过css选择器.sound-list li.lF_ a::attr(title)拿到音频标题。点击下一页发现只是在原url后添加p{page}字段，综上通过open函数写入音频文件完成下载。 12345678910111213141516171819202122titles &#x3D; selector.css(&#39;.sound-list li.lF_ a::attr(title)&#39;).getall()href &#x3D; selector.css(&#39;.sound-list li.lF_ a::attr(href)&#39;).getall()# zip() 可以讲两个列表进行打包, 遍历之后 是一个元组data &#x3D; zip(titles, href)for index in data: title &#x3D; index[0] mp3_id &#x3D; index[1].split(&#39;&#x2F;&#39;)[-1] # f&#39;&#123;mp3_id&#125;&#39; &#39;&#123;&#125;&#39;.format(mp3_id) 字符串格式化方法 index_url &#x3D; f&#39;https:&#x2F;&#x2F;www.ximalaya.com&#x2F;revision&#x2F;play&#x2F;v1&#x2F;audio?id&#x3D;&#123;mp3_id&#125;&amp;ptype&#x3D;1&#39; response_1 &#x3D; requests.get(url&#x3D;index_url, headers&#x3D;headers) # 什么是json数据 字典嵌套字典 还嵌套一些列表 # json数据取值和字典取值方式是一样的 根据关键词提取内容 通俗的讲 就是根据左边的内容提取右边的内容 # print(response_1.text) mp3_url &#x3D; response_1.json()[&#39;data&#39;][&#39;src&#39;] print(title, mp3_url) # 保存数据 # 保存数据: 如果是图片&#x2F;音频&#x2F;视频 等 都是要获取它的二进制数据,要以二进制的数据保存 mp3_content &#x3D; requests.get(url&#x3D;mp3_url).content # 相对路径 with open(&#39;相声\\\\&#39; + title + &#39;.mp3&#39;, mode&#x3D;&#39;wb&#39;) as f: f.write(mp3_content) print(&#39;正在保存: &#39;, title) 爬取完成 XPATH选择器XPath (XML Path Language) 是由国际标准化组织W3C指定的，用来在 XML 和 HTML 文档中选择节点的语言。目前主流浏览器 (chrome、firefox，edge，safari) 都支持XPath语法，xpath有 1 和 2 两个版本，目前浏览器支持的是 xpath 1的语法，且比CSS选择器功能更强大。 表达式 含义 /html/body/div 选择根节点html下面的body下面的div元素，/从子节点找，//从所有子节点包括子节点的子节点中找 //div/* 所有div节点下所有元素 //*[@id=’west’] id为west的元素 //select[@class=’single_choice’] class为single_choice的select元素 //p[@class=”capital huge-city”] 多元素组合选择 //*[@multiple] 具有multiple属性的元素 //*[contains(@style,’color’)] style包含color的元素 //*[starts-with(@style,’color’)] 以style是color开头的元素，//*[ends-with(@style,’color’)]结尾元素 //div/p[2] 所有div下的第二个p标签 //p[last()] 最后一个p元素 //div/p[last()-2] 所有div下倒数第三个p元素 //option[position()&lt;=2] option类型的第1-2个元素 //*[@class=’multi_choice’]/*[position()&gt;=last()-2] 选择class属性为multi_choice的后3个子元素 //option|//h4 所有的option元素 和所有的 h4 元素 //*[@id=’china’]/.. 选择 id 为 china 的节点的父节点 //*[@id=’china’]/../../.. 上上父节点 //*[@class=’single_choice’]/following-sibling::div 选择后续节点中的div节点 等同于CSS选择器.single_choice ~ * //[@class=’single_choice’]/preceding-sibling:: 前面兄弟节点 实战新笔趣阁分析目标网站：http://www.xbiquge.la/10/10489/ 抓取内容：抓取三寸人间所有章节的文章保存。 章节列表只有小说章节信息，点击每个章节跳转到章节页面，通常xpath表达式//div[@id=&quot;info&quot;]/h1/text()拿到书籍名称，所有的章节都依赖于于id为list的div下的dl下的dd下的a标签的href属性跳转到章节页面。 拼接主域名http://www.xbiquge.la即可跳转到章节详情页面，通过xpath表达式//*[@id=&quot;content&quot;]/text()拿到详情页面小说的完整内容 1234567891011121314151617181920212223242526272829303132# 开文件流 打开一个文件 把我们数据写入到文件中去 a是追加写入 写入完第一章就继续追加写入第二章with open(book_name + &#39;.txt&#39;, &#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;)as f: f.write(book_name+&#39;\\n&#39;) # title 章节的名称 urls 每个章节的详情链接 # 遍历获取到该本书的每个章节和对应的内容详情链接 zip一次性遍历多个列表 for title,urls in zip(book_title,book_url): c_url&#x3D;&#39;http:&#x2F;&#x2F;www.xbiquge.la&#39;+urls print(title) print(c_url) # 异常处理 try: #捕捉异常 #参数1：单个章节的url:以获取到这个章节的小说内容的html源码 参数2：headers 参数3：请求等待时间3秒 titles_url &#x3D; requests.get(c_url, headers&#x3D;headers, timeout&#x3D;3).content.decode(&#39;utf-8&#39;) except: # 如果捕捉异常怎么办 请求失败那就再请求一遍 titles_url &#x3D; requests.get(c_url, headers&#x3D;headers).content.decode(&#39;utf-8&#39;) # 那我们还差一个小说文本内容对不对 那每个章节链接我们有了 # 每个章节里面的内容是不是好解决 一样xpath语法给他获取下来 # 通过xpath获取到小说文本内容 book_content &#x3D; etree.HTML(titles_url).xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;content&quot;]&#x2F;text()&#39;) f.write(title) # 先写入章节名称 f.write(&#39;\\n&#39;) # f.write不能够写列表，但可以写字符串格式（二进制）。。。 所以要for循环 for line in book_content: f.write(line) # 再写入章节对应的内容 f.write(&#39;\\n&#39;) # 每写完一章换行 一共1000多个章节 爬取完成 其实很多情况下不需要自己去分析dom节点定位css或xpath表达式，chrome已经为我们集成了插件。 JSON很多情况页面不直接返回html或xml文本元素，或者这些文本分析起来很困难的情况下，可以通过控制台中的xhr模式抓取后端请求回来的json数据，直接解析json即可拿到想要的数据。 实战拉勾分析目标网站：https://www.lagou.com/jobs/list_C%2B%2B?labelWords=&amp;fromSearch=true&amp;suginput= 抓取内容：抓取首页职位地址，公司名，规模等信息保存。 搜索C++后，打开控制台将结果中的带薪年假搜索拿到实际请求路径https://www.lagou.com/jobs/positionAjax.json?needAddtionalResult=false，该请求是post请求，参数如下 12345data &#x3D; &#123; &quot;first&quot;: &quot;true&quot;, &quot;pn&quot;: &quot;1&quot;, &quot;kd&quot;: &quot;C++&quot;&#125; 通过控制台Preview分析返回的json数据，data[&#39;content&#39;][&#39;positionResult&#39;][&#39;result&#39;]即为职位信息 不过当我们直接请求时会报dtacess deny,可能对请求头中的参数做了校验。 12345678Traceback (most recent call last): File &quot;F:&#x2F;MyProject&#x2F;CrawlerBase&#x2F;lagou&#x2F;lagou.py&quot;, line 21, in &lt;module&gt; result &#x3D; data[&#39;content&#39;][&#39;positionResult&#39;][&#39;result&#39;]KeyError: &#39;content&#39;&#123;&#39;clientIp&#39;: &#39;61.155.198.*&#39;, &#39;msg&#39;: &#39;dtaccess deny &#39;, &#39;state&#39;: 2410, &#39;status&#39;: False&#125; 我们将Cookie和User-Agent加入header后，即可以完整请求到json数据，进行数据分析。 123456789101112131415161718resp &#x3D; requests.post(api_url, headers&#x3D;headers)pprint(resp.json())data &#x3D; resp.json()result &#x3D; data[&#39;content&#39;][&#39;positionResult&#39;][&#39;result&#39;]# [print(r) for r in result]for r in result: d &#x3D; &#123; &#39;city&#39;: r[&#39;city&#39;], &#39;companyFullName&#39;: r[&#39;companyFullName&#39;], &#39;companySize&#39;: r[&#39;companySize&#39;], &#39;education&#39;: r[&#39;education&#39;], &#39;positionName&#39;: r[&#39;positionName&#39;], &#39;salary&#39;: r[&#39;salary&#39;], &#39;workYear&#39;: r[&#39;workYear&#39;] &#125; with open(&#39;拉钩职位.csv&#39;,mode&#x3D;&#39;a&#39;,encoding&#x3D;&#39;utf-8&#39;) as f: f.write(&quot;,&quot;.join(d.values())) f.write(&quot;\\n&quot;) 爬取完成 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"xpath","slug":"xpath","permalink":"http://onejane.github.io/tags/xpath/"},{"name":"css","slug":"css","permalink":"http://onejane.github.io/tags/css/"},{"name":"json","slug":"json","permalink":"http://onejane.github.io/tags/json/"}]},{"title":"爬虫基础篇之多线程实现","slug":"爬虫基础篇之多线程实现","date":"2021-03-28T00:18:03.000Z","updated":"2021-04-07T14:48:31.147Z","comments":true,"path":"2021/03/28/爬虫基础篇之多线程实现/","link":"","permalink":"http://onejane.github.io/2021/03/28/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"执行流程python并不像java这类高级语言需要将文件编译为机器码交给虚拟机执行，而是由python虚拟机一条条地将py语句解释运行，故而称之为解释型语言。 python先将py文件编译成字节码，交给字节码虚拟机后，虚拟机从编译得到的PyCodeObject对象在当前的上下文环境逐条执行字节码指令，完成整个程序的执行流程。 字节码在python虚拟机程序里对应的是PyCodeObject对象， .pyc文件是字节码在磁盘上的表现形式。 例如：在python test.py过程中会将test.py进行编译成字节码并解释执行，当test.py中加载了其他模块，如import urllib2，python会将urllib2.py进行编译成字节码，生成urllib2.pyc，并重新对字节码解释执行。加载模块时，当.py和.pyc同时存在时，优先运行.pyc文件，若.pyc文件比.py编译时间早，执行流程也会优先重新编译.py文件并更新.pyc文件。 .pyc文件通过内置模块py_compile来编译生成test.pyc,或者通过python -m test.py生成test.pyc GIL由于物理上的科技发展，各CPU厂商在核心频率上已经被多核CPU所取代，为了更有效的利用多核处理器的性能，就出现了多线程的编程技巧，又因为Python GIL的存在让Python虚拟机在进行运算时无法有效利用多核心，几乎只能单线程处理任务，所以将任务并行化，分散到多个线程或多个进程的实现和GIL本身的存在是天生冲突的矛盾。 首先，GIL不是python的特性，是实现python解析器(CPython)时的语法标准，并不是python的特性，类似的还有JPython等就没有GIL，但是CPython是大部分环境下默认的Python执行环境，自然而然CPython==python，自然而然GIL成为的python天生的缺陷。 当多核CPU出现在市场的时候，python为了支持多线程，首要解决的就是线程之间的数据完整性和数据同步性，GIL应运而生，简单粗暴的为线程加上了一把大锁，后起之库们默认都接受了这种实现方案，省去考虑额外线程间的内存锁和同步操作，导致大量的三方库都极度依赖GIL来实现线程安全。GIL这把全局排他锁，是多线程处理的致命伤，效率极底，因为python的线程就是C的一个pthread，通过操作系统的调度算法调度，为在调度过程中各线程平均利用CPU的时间，python会计算已执行的代码量，达到阈值强制释放GIL锁，触发一次操作系统的调度。 任何一个线程在唤起时可以成功获取到GIL，但是多核CPU上，release和acquire几乎没有间隔，导致其他核上的线程被唤醒时，主线程已经再次拿到GIL，导致被唤醒的其他线程只能白白浪费CPU时间，眼睁睁看着另一个线程拿个GIL快乐的执行，当达到切换时间后进入待调度状态，再次唤醒再次等待，恶性循环。 多线程方案multiprocessing一定程度弥补了thread库由于GIL锁导致低效的缺陷，完整的实现了一套thread接口，但是只是使用了多进程而本身不是多进程，原理上每个进程有自己独立的GIL，不会出现进程间的GIL争抢，但是增加了线程间数据通讯和同步的麻烦，由于不同进程间无法看到对方的数据状态，只能在主线程声明一个队列，通过队列的实现解决数据本身的问题，无疑徒增的代码的开发与维护成本。 concurrent提供了多线程ThreadPoolExecutor和多进程ProcessPoolExecutor两种并发模型。 计算密集型任务永远最多只能榨干单核CPU，如果需要提升效率，必须通过ProcessPoolExecutor fork出多个子进程来分担计算任务。 IO密集型任务CPU使用效率极低，虽然使用多线程加倍CPU使用率，但是还远远到不了饱和(100%)的地步，在单核心可以应付整体计算的前提下，自然是应该选择资源占用少的模式，也就是多线程模式。主线程是通过队列将任务传递给多个子线程的。一旦主线程将任务塞进任务队列，子线程们就会开始争抢，最终只有一个线程能抢到这个任务，并立即进行执行，执行完后将结果放进Future对象就完成了这个任务的完整执行过程。 concurrent的线程池有个重大的缺陷，那就是任务队列是无界的。如果队列的生产者任务生产的太快，而线程池消费太慢处理不过来，任务就会堆积。如果堆积一直持续下去，内存就会持续增长直到OOM，任务队列里堆积的所有任务全部彻底丢失。 主线程将任务塞进TaskQueue(普通内存队列)，拿到Future对象 唯一的管理线程从TaskQueue获取任务，塞进CallQueue(分布式跨进程队列) 子进程从CallQueue中争抢任务进行处理 子进程将处理结果塞进ResultQueue(分布式跨进程队列) 管理线程从ResultQueue中获取结果，塞进Future对象 主线程从Future对象中拿到结果 进程池模型中的跨进程队列是用multiprocessing.Queue实现的。它使用无名套接字sockerpair来完成的跨进程通信，socketpair和socket的区别就在于socketpair不需要端口，不需要走网络协议栈，通过内核的套接字读写缓冲区直接进行跨进程通信。multiprocessing.Queue是支持双工通信，数据流向是父子双向，只不过在concurrent的进程池实现中只用到了单工通信。CallQueue是从父到子，ResultQueue是从子到父。 当父进程要传递任务给子进程时，先使用pickle将任务对象进行序列化成字节数组，然后将字节数组通过socketpair的写描述符写入内核的buffer中。子进程接下来就可以从buffer中读取到字节数组，然后再使用pickle对字节数组进行反序列化来得到任务对象，这样总算可以执行任务了。同样子进程将结果传递给父进程走的也是一样的流程，只不过这里的socketpair是ResultQueue内部创建的无名套接字。 实战doutula上文讲到通过分析页面元素分页抓取doutula表情包并保存图片的的案例，由于网络请求结果返回往往比IO存储图片要快，接下来通过多线程的方式实现在IO相对较慢的前提下使用多线程处理存储图片。核心代码如下： 123456789101112131415def main(page): &quot;&quot;&quot;函数入口&quot;&quot;&quot; for page in range(1, page + 1): print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正在爬去第&#123;&#125;页数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;.format(page)) # 定义最多 max_workers 个线程的线程池来异步执行调用。如果 max_workers 为 None 或没有指定，将默认为机器处理器的个数 thread_pool &#x3D; concurrent.futures.ThreadPoolExecutor(max_workers&#x3D;3) res &#x3D; send_request(&#39;https:&#x2F;&#x2F;www.doutula.com&#x2F;photo&#x2F;list&#x2F;?page&#x3D;&#123;&#125;&#39;.format(str(page))) # 封装解析函数 src_url &#x3D; parse_data(res.text) for file, url in src_url: image_response &#x3D; send_request(url) # 提交线程请求，save_data是封装保存函数，file和image_response.content是save_data的入参 thread_pool.submit(save_data, file, image_response.content) # 关闭线程池 thread_pool.shutdown() guazi同时执行多个线程的确可以提高程序效率，但并非线程越多越好，相对计算机而言，线程越多越吃资源，成百上千个线程可能直接瘫痪。故而多线程在运行时，设置最大线程锁，设置最大线程同时允许处理任务，多线程threading使用Semaphore(无上限)或BoundedSemaphore(初始设置最大值), 如果release调用检查计数器的值是否超过了计数器最大值则出ValueError 实现并发限制。 例如：通过semaphore信号量可以利用内置计数器来控制同时运行线程的数量，启动线程(消耗信号量)内置计数器会自动减一，线程结束(释放信号量)内置计数器会自动加一；内置计数器为零，启动线程会阻塞，直到有本线程结束或者其他线程结束为止; 以下我们对瓜子二手车数据进行多线程抓取，并保存到csv中。 分析当我们访问第一页时，https://www.guazi.com/su/buy/o1 当我们访问第二页时，https://www.guazi.com/su/buy/o2 以此类推，不难得出分页数据以start_url = &#39;https://www.guazi.com/su/buy/o&#39;+str(i)形式拼接，i为页码数，根据页面控制台的Elements分析所有的数据都存在于含有类carlist clearfix js-top的ul节点下的所有li节点下，我们可以通过解析得到html代码转化为bs4库的BeautifulSoup对象，利用BeautifulSoup的api获取这些li节点的元素属性，解析拿到类型，年份，里程，售价，具体BeautifulSoup语法出门右转见中文文档。 12345678910111213141516171819202122232425def get_data(html): # 将之前抓取的html页面解析生成BeautifulSoup对象 soup &#x3D; BeautifulSoup(html, &#39;html.parser&#39;) # 调用api获取含有类carlist clearfix js-top的ul节点下的所有li节点 infos &#x3D; soup.find(&#39;ul&#39;, &#123;&#39;class&#39;: &#39;carlist clearfix js-top&#39;&#125;).find_all(&#39;li&#39;) # 打开文件开始写入 with open(&#39;.&#x2F;guazi.csv&#39;, &#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;) as f: pic_urls &#x3D; [] for info in infos: leixing &#x3D; info.find(&#39;h2&#39;).get_text() nianfen1 &#x3D; info.find(&#39;div&#39;, &#123;&#39;class&#39;: &#39;t-i&#39;&#125;).get_text() # 通过正则分割年份字符串 nianfen2 &#x3D; re.sub(r&#39;|&#39;, &#39;&#39;, nianfen1).split(&#39;|&#39;) nianfen &#x3D; nianfen2[0] licheng &#x3D; nianfen2[1] didian &#x3D; &#39;苏州&#39; shoujia &#x3D; info.find(&#39;div&#39;, &#123;&#39;class&#39;: &#39;t-price&#39;&#125;).find(&#39;p&#39;).get_text() try: yuanjia &#x3D; info.find(&#39;div&#39;, &#123;&#39;class&#39;: &#39;t-price&#39;&#125;).find(&#39;em&#39;).get_text() except AttributeError: yuanjia &#x3D; &#39;&#39; tupian &#x3D; info.find(&#39;a&#39;).find(&#39;img&#39;)[&#39;src&#39;] pic_urls.append(tupian) f.write(&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;\\n&quot;.format(leixing, nianfen, licheng, didian, shoujia, yuanjia)) return pic_urls get_data拿到所有的数据属性后，接下来通过含有信号量的多线程方式调用封装好的download_pics方法批量抓取图片。 1234567891011121314# 定义最多10个线程同时允许thread_lock &#x3D; threading.BoundedSemaphore(value&#x3D;10)def main(): n &#x3D; 0 for i in range(1,51): start_url &#x3D; &#39;https:&#x2F;&#x2F;www.guazi.com&#x2F;su&#x2F;buy&#x2F;o&#39;+str(i) html &#x3D; getHtmlText(start_url) pic_urls &#x3D; get_data(html) for url in pic_urls: n+&#x3D;1 print(&#39;正在下载第&#123;&#125;张图片&#39;.format(n)) # 上锁 避免下载同一张 thread_lock.acquire() t &#x3D; threading.Thread(target&#x3D;download_pics,args&#x3D;(url,n)) 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","permalink":"http://onejane.github.io/tags/ThreadPoolExecutor/"},{"name":"BoundedSemaphore","slug":"BoundedSemaphore","permalink":"http://onejane.github.io/tags/BoundedSemaphore/"}]},{"title":"爬虫基础篇之基本库的使用","slug":"爬虫基础篇之基本库的使用","date":"2021-03-28T00:18:03.000Z","updated":"2021-04-07T14:48:31.147Z","comments":true,"path":"2021/03/28/爬虫基础篇之基本库的使用/","link":"","permalink":"http://onejane.github.io/2021/03/28/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"爬虫介绍爬虫目的 大数据时代所谓的人工智能都需要建立海量基础的数据上，一切一切的分析都是一数据为基础核心，那么对于企业来说，合理采集数据是既节省成本同时间也可以完成业务分析的捷径。 企业需要大量数据进行测试，对网站或app的负载，流量，服务器的CPU进行测试，采集数据是保证大数据量业务上线正常流转的必备前提。 所有搜索引擎的底层都是一个个的自动化爬虫，在海量的互联网信息中进行分析处理收录。 各大企业都希望自己的产品搜索靠前，对于SEO来说，除了充钱，足够了解爬虫可以从原理上实现搜索引擎的工作原理，实现SEO优化。 从技术层面来说，爬虫虽不是成体系型的一种技术栈，不过技术涉及领域极光，包括html解析，js逆向，安卓底层逆向，汇编分析，反爬虫与反反爬虫的对抗等等，其实以上也属于网络安全层的一个方向，文明爬虫，技术无罪。 什么是最好的语言当之无愧强类型语言Python，毋庸置疑，一来Python的三方库种类繁多且爬虫框架日新月异，请求与解析模块成熟，且拥有很多有趣的语法糖可以快速处理数据。相对于代码量臃肿的java来说语法简单，学习曲线短，因为java需要jvm虚拟机的编译成字节码的过程，对于爬虫来讲，Python免编译即可跨平台运行，且基于C++更接近底层，性能在一定程度上领超java，故优先选择python(别跟我提php)。 当然玩到最后语言只是一种实现方式而已，只是这些路都通往罗马，哪条在实际场景中更方便到达而已。比如：安卓逆向过程hook框架中，xposed和frida是我们的首选，两者各有优劣，视不同场景而定。 Xposed是一个在andoid平台上比较成熟的hook框架，可以完美的在dalvik虚拟机上做到hook任意java方法，配置安装环境繁琐，兼容性差，无法对native层实现底层注入。 Frida是一个跨平台的hook框架，可以hook Java和native层，且不需要每次都重启手机，需要我们手动将java的语法转为frida的实现方式，无法像Xposed用于实践生产中。 爬虫路对抗现状 这是一张老图，当然现在很多网站在请求头中实现了对selenium，phantomjs底层的api监控，总之，道高一尺魔高一丈，攻防之间，其乐无穷。 实战话不多说，直接开干。鲁迅曾经说过，他在爬虫生涯中超过一半的苦难均由Windows赐予，所以我建议还是用kali或者ubuntu吧，如果嫌麻烦，就退一步用centos吧，当然你用windows出现的问题需要自行google解决，基础篇目测应该不存在，用windows可以直接跳到doutula内容。 服务器搭建这里就不聊kali或者ubuntu在虚拟机的搭建了，简单介绍一下使用vagrant创建centos虚拟机吧， 进入vagrant官网，vagrant安装好后进入镜像仓库搜索需要安装的镜像。 mkdir centos7 &amp;&amp; vagrant init centos/7 &amp;&amp; vagrant up &amp;&amp; vagrant ssh 创建并开启镜像，自动生成Vagrantfile，默认网络nat，初始配置如下 config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot; 配置NAT网络，选其一即可config.vm.network &quot;public_network&quot;, ip: &quot;192.168.0.102&quot; 配置桥接网络vi /etc/ssh/sshd_config 并注释#PasswordAuthentication yes,执行service sshd restart 安装nodejs并配置淘宝源npm config set registry http://registry.npm.taobao.org/ 多环境配置由于python2已经废弃维护，往后皆基于python3实战开发。进入python官网下载python 3.7.0，或者通过清华大学源下载anaconda 5.3.1会自动下载常用库。 为了避免不同项目间引用的依赖包冲突，我们将不同项目维护不同的环境。 123456789101112yum install -y wget zlib-devel gcc bzip2-devel openssl-devel libffi-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel net-tools ftp vsftpd 安装常用包mkdir &#x2F;usr&#x2F;local&#x2F;python3 由于默认centos已经有了python2，避免环境冲突，配置多环境python3wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.7.0&#x2F;Python-3.7.0.tgz 下载python3的包tar zxf Python-3.7.0.tgz 解压cd Python-3.7.0&#x2F; &amp;&amp; .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3 编译make &amp;&amp; make installvim &#x2F;etc&#x2F;profile 配置环境变量PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;export PATHsource &#x2F;etc&#x2F;profileln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3 配置软链接ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip3 12345678910pip3 install --upgrade pippip install virtualenvwrapper 安装虚拟环境vim ~&#x2F;.bashrc 配置环境变量VIRTUALENVWRAPPER_PYTHON&#x3D;&#x2F;usr&#x2F;bin&#x2F;python3export WORKON_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;python3&#x2F;venvsource ~&#x2F;.bashrc 编译mkvirtualenv --python&#x3D;&#x2F;usr&#x2F;bin&#x2F;python3 baseSpider 指定python3创建名为baseSpider环境mkvirtualenv --python&#x3D;&#x2F;usr&#x2F;bin&#x2F;python2 baseSpider2 指定python2创建名为baseSpider2环境workon baseSpider 进入baseSpider环境deactivate 退出环境 doutula这是一个表情包网站，本次就以本网站的最新表情页面作为案例。 ctrl+u获取网页源代码，发现本页面所有的表情包都以html表情直接显示在页面上，那么只需要使用requests库请求URL，parsel库来解析页面，通过xpath或者css选择器获取页面元素。 通过点击分页，该页面的url会跳转时添加page参数，从https://www.doutula.com/photo/list/变成https://www.doutula.com/photo/list/?page=2,重新向服务器发起请求。 1234import requestsbase_url &#x3D; &#39;https:&#x2F;&#x2F;www.doutula.com&#x2F;photo&#x2F;list&#x2F;&#39;response &#x3D; requests.get(url&#x3D;base_url)print(response.content) 打印出来的结果是b&#39;&lt;html&gt;\\r\\n&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;\\r\\n&lt;body bgcolor=&quot;white&quot;&gt;\\r\\n&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;\\r\\n&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;\\r\\n&lt;/body&gt;\\r\\n&lt;/html&gt;\\r\\n&#39;,说明做了反爬，可能对请求头的参数做了校验。先尝试将User-Agent加入请求头中，再次发起请求。 123456import requestsbase_url &#x3D; &#39;https:&#x2F;&#x2F;www.doutula.com&#x2F;photo&#x2F;list&#x2F;?page&#x3D;&#123;&#125;&#39;.format(1)headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&#39;&#125;response &#x3D; requests.get(url&#x3D;base_url, headers&#x3D;headers)print(response.content) 果然将页面内容完整打印出来，所有的图片地址也都明文显示在页面上。通过分析页面上的图片元素的dom节点，所有的图片节点都存在于类col-xs-6 col-sm-3的a标签下的img元素，通过xpath表达式可以取出这些元素下的属性，包括图片地址data-original，说明alt等。 12345678910111213for page in range(1,3466): print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正在爬去第&#123;&#125;页数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;.format(page)) base_url &#x3D; &#39;https:&#x2F;&#x2F;www.doutula.com&#x2F;photo&#x2F;list&#x2F;?page&#x3D;&#123;&#125;&#39;.format(page) headers &#x3D; &#123;&#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&#39;&#125; response &#x3D; requests.get(url&#x3D;base_url,headers&#x3D;headers) html_data&#x3D;response.text selector &#x3D; parsel.Selector(html_data) result_list &#x3D; selector.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;&quot;col-xs-6 col-sm-3&quot;]&#39;) for result in result_list: img_url &#x3D; result.xpath(&#39;.&#x2F;img&#x2F;@data-original&#39;).extract_first() img_title &#x3D; result.xpath(&#39;.&#x2F;img&#x2F;@alt&#39;).extract_first() print(img_url+&quot;---&quot;+img_title) 接下来在通过IO流将图片存储到本地完成基础图片爬取。 完整源码请关注微信公众号：ReverseCode，回复：爬虫基础","categories":[{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"requests","slug":"requests","permalink":"http://onejane.github.io/tags/requests/"},{"name":"parsel","slug":"parsel","permalink":"http://onejane.github.io/tags/parsel/"}]},{"title":"加壳与脱壳之二代壳函数抽取","slug":"加壳与脱壳之二代壳函数抽取","date":"2021-03-25T00:07:35.000Z","updated":"2021-03-27T00:36:51.346Z","comments":true,"path":"2021/03/25/加壳与脱壳之二代壳函数抽取/","link":"","permalink":"http://onejane.github.io/2021/03/25/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E4%BA%8C%E4%BB%A3%E5%A3%B3%E5%87%BD%E6%95%B0%E6%8A%BD%E5%8F%96/","excerpt":"","text":"函数抽取宣告一代壳整体保护的结束，由此进入二代壳的时代。 Dalvik Android中实现「类方法指令抽取方式」加固方案原理解析：对dex结构简单介绍，定位函数指令地址，实现函数抽取壳的demo，对getPwd函数进行指令抽取，类被加载时重填恢复指令。 Android免Root权限通过Hook系统函数修改程序运行时内存指令逻辑：为了修改原有系统对dex加载流程，需要hook系统某些关键函数，自然可以在原有函数逻辑中添加需要自定义的逻辑功能，再添加一些保护函数的填充。 源码分析实现函数抽取壳需要保证对函数恢复的时机肯定早于函数被调用的时机，即当函数被调用时指令流必须已经被修复了，否则app逻辑被破坏导致app崩了。再选择时机，Android中实现「类方法指令抽取方式」加固方案原理解析中选择了dexFindClass函数。。 对于函数来说在被调用之前，首先dex加载(dexclassloader动态加载)，对类加载需要经过装载-链接-初始化，在这些加载过程中有非常多的时机供我们选择，Dalvik源代码编译生成的libdvm.so通过ida打开，搜索文中的dexFindClass函数，获取导出的函数名可实现函数抽取。loadClass加载一个dex中的类的流程:DexClassLoader-&gt;BaseDexClassLoader-&gt;ClassLoader的loadClass,完整体现了双亲委派的特性。 1234567891011121314151617486 protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123; &#x2F;&#x2F; 为了提高加载类效率，如果已经加载直接返回，否则进行双亲委派的父节点加载487 Class&lt;?&gt; clazz &#x3D; findLoadedClass(className);488489 if (clazz &#x3D;&#x3D; null) &#123;490 try &#123;491 clazz &#x3D; parent.loadClass(className, false);492 &#125; catch (ClassNotFoundException e) &#123;493 &#x2F;&#x2F; Don&#39;t want to see this.494 &#125;495496 if (clazz &#x3D;&#x3D; null) &#123;497 clazz &#x3D; findClass(className);498 &#125;499 &#125;500501 return clazz;502 &#125; 对于使用DexClassLoader第一次加载类的parent节点是pathClassLoader或被指定的bootClassLoader,因为类只由当前的classloader加载必然是找不到的，因此进入BaseDexClassLoader的findClass实现中。 12345678910111252 protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;53 List&lt;Throwable&gt; suppressedExceptions &#x3D; new ArrayList&lt;Throwable&gt;();54 Class c &#x3D; pathList.findClass(name, suppressedExceptions);55 if (c &#x3D;&#x3D; null) &#123;56 ClassNotFoundException cnfe &#x3D; new ClassNotFoundException(&quot;Didn&#39;t find class \\&quot;&quot; + name + &quot;\\&quot; on path: &quot; + pathList);57 for (Throwable t : suppressedExceptions) &#123;58 cnfe.addSuppressed(t);59 &#125;60 throw cnfe;61 &#125;62 return c;63 &#125; 紧接着进入pathList.findClass，其中pathList是在BaseDexClassLoader构造函数中实例化化，跟着进入pathList.findClass，调用了dex.loadClassBinaryName查找类 1234567891011121314151617317 public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;318 for (Element element : dexElements) &#123;319 DexFile dex &#x3D; element.dexFile;320321 if (dex !&#x3D; null) &#123; &#x2F;&#x2F; 尝试从每个dex中遍历找到类所在的dex中并返回类所在dex322 Class clazz &#x3D; dex.loadClassBinaryName(name, definingContext, suppressed); 323 if (clazz !&#x3D; null) &#123;324 return clazz;325 &#125;326 &#125;327 &#125;328 if (dexElementsSuppressedExceptions !&#x3D; null) &#123;329 suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));330 &#125;331 return null;332 &#125; 跟着进入loadClassBinaryName,其中调用了native层实现defineClassNative 1234567891011121314151617181920214 public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) &#123;215 return defineClass(name, loader, mCookie, suppressed);216 &#125;217218 private static Class defineClass(String name, ClassLoader loader, int cookie,219 List&lt;Throwable&gt; suppressed) &#123;220 Class result &#x3D; null;221 try &#123;222 result &#x3D; defineClassNative(name, loader, cookie);223 &#125; catch (NoClassDefFoundError e) &#123;224 if (suppressed !&#x3D; null) &#123;225 suppressed.add(e);226 &#125;227 &#125; catch (ClassNotFoundException e) &#123;228 if (suppressed !&#x3D; null) &#123;229 suppressed.add(e);230 &#125;231 &#125;232 return result;233 &#125; dalvik下Full Search搜索defineClassNative，进入/dalvik/vm/native/dalvik_system_DexFile.cpp的Dalvik_dalvik_system_DexFile_defineClassNative方法，如注释中所说从一个dex文件中加载一个类 123456789101112131415161718192021222324252627282930349static void Dalvik_dalvik_system_DexFile_defineClassNative(const u4* args,350 JValue* pResult)351&#123;352 StringObject* nameObj &#x3D; (StringObject*) args[0]; &#x2F;&#x2F; 类名353 Object* loader &#x3D; (Object*) args[1]; &#x2F;&#x2F; classloader354 int cookie &#x3D; args[2]; &#x2F;&#x2F; java层cookie355 ClassObject* clazz &#x3D; NULL;356 DexOrJar* pDexOrJar &#x3D; (DexOrJar*) cookie; &#x2F;&#x2F; 将int型cookie转为DexOrJar指针357 DvmDex* pDvmDex;358 char* name;359 char* descriptor;360361 name &#x3D; dvmCreateCstrFromString(nameObj);362 descriptor &#x3D; dvmDotToDescriptor(name);363 ALOGV(&quot;--- Explicit class load &#39;%s&#39; l&#x3D;%p c&#x3D;0x%08x&quot;,364 descriptor, loader, cookie);365 free(name);366367 if (!validateCookie(cookie))368 RETURN_VOID();369370 if (pDexOrJar-&gt;isDex)371 pDvmDex &#x3D; dvmGetRawDexFileDex(pDexOrJar-&gt;pRawDexFile);372 else373 pDvmDex &#x3D; dvmGetJarFileDex(pDexOrJar-&gt;pJarFile);374375 &#x2F;* once we load something, we can&#39;t unmap the storage *&#x2F;376 pDexOrJar-&gt;okayToFree &#x3D; false;377378 clazz &#x3D; dvmDefineClass(pDvmDex, descriptor, loader); 进入dvmGetRawDexFileDex，只是取出指针中的pDvmDex 12362INLINE DvmDex* dvmGetRawDexFileDex(RawDexFile* pRawDexFile) &#123;63 return pRawDexFile-&gt;pDvmDex;64&#125; 进入dvmDefineClass 12345671413ClassObject* dvmDefineClass(DvmDex* pDvmDex, const char* descriptor,1414 Object* classLoader)1415&#123;1416 assert(pDvmDex !&#x3D; NULL);14171418 return findClassNoInit(descriptor, classLoader, pDvmDex);1419&#125; 进入findClassNoInit，首先调用了clazz = dvmLookupClass(descriptor, loader, true);对当前加载的类名进行计算查询，如没有则返回为空，对于第一次加载必然是没有的，接着进入pClassDef = dexFindClass(pDvmDex-&gt;pDexFile, descriptor);，即Android中实现「类方法指令抽取方式」加固方案原理解析中选择的时机点，并通过hook掉类被加载时的时机，对抽取函数的恢复，实现函数还原，因此必然需要早于函数执行的时机，保证app正常运行。由于有些函数符号没有导出，就不是很容易进行hook，而在libdvm.so中的dexFindClass在IDA中是被导出的，方便hook。以上就是Dalvik下函数抽取壳的简单原理。 ARTArt下实现难点：dex2oat编译流程，dex2oat是可以进行脱壳，对抽取的dex进行编译生成了oat文件，后续的函数运行中，从oat中取出函数编译生成的二进制代码来执行，自然从dex2oat后那么我们动态修改的dex中的smali指令流就不会生效。因此如果希望填充回去smali指令生效要么禁用dex2oat实现阻止编译，这样对加载到内存中的dex文件进行填充始终会保持生效，要么保持dex2oat编译，但是还原代码时机要早于dex2oat就ok了，保证dex2oat再次对dex编译的时候，dex已经是一个完整dex，不会影响我们填充的代码，但是肯定dex文件存在完整的时候，可以利用dex2oat编译的流程进行脱壳，一般都是牺牲掉app一部分的运行效率，干掉dex2oat的过程，因为google本身提倡dex2oat就是为了提升app运行效率。 禁用dex2oat编译回到ART下DexClassLoader动态加载dex的流程，在art下搜索GenerateOatFileNoChecks，该函数完成调用dex2oat进行编译 GenerateOatFileNoChecks中调用Dex2Oat函数 12616OatFileAssistant::ResultOfAttemptToUpdate OatFileAssistant::GenerateOatFileNoChecks(617 OatFileAssistant::OatFileInfo&amp; info, CompilerFilter::Filter filter, std::string* error_msg) &#123; Dex2Oat最终调用return Exec(argv, error_msg);，Exec中调用了int status = ExecAndReturnCode(arg_vector, error_msg);,其中ExecAndReturnCode通过pid_t pid = fork();进行fork一个子进程，在子进程中调用了execve(program, &amp;args[0], envp);完成对dex2oat这个二进制程序的调用。整个流程中任意一个环节被打断，dex2oat将会被干掉，无法继续运行。TurboDex就是干掉dex2oat为了让dex在第一次动态加载时快速加载完成，因为不干掉dex2oat，art虚拟机就会调用dex2oat对当前的dex进行编译，编译过程非常耗时，可以很大地提升dexclassloader加载dex 的效率，该项目就是通过hook了execv方法实现。 众所周知,Android中在Runtime加载一个 未优化的Dex文件 (尤其在 ART 模式)需要花费 很长的时间. 当你在App中使用 插件化框架 的时候, 首次加载插件就需要耗费很长的时间. TurboDex 就是为了解决这一问题而生, 就像是给AndroidVM开启了上帝模式, 在引入TurboDex后, 无论你加载了多大的Dex文件,都可以在毫秒级别内完成. 接下来通过hook execve实现干掉dex2oat，可以通过爱奇艺xhook的GOT进行表hook干掉dex2oat，也可以用inline库hook。 36：00","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"classloader","slug":"classloader","permalink":"http://onejane.github.io/tags/classloader/"}]},{"title":"加壳与脱壳之一代壳dex保护","slug":"加壳与脱壳之一代壳dex保护","date":"2021-03-16T12:27:25.000Z","updated":"2021-03-25T00:05:36.462Z","comments":true,"path":"2021/03/16/加壳与脱壳之一代壳dex保护/","link":"","permalink":"http://onejane.github.io/2021/03/16/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E4%B8%80%E4%BB%A3%E5%A3%B3dex%E4%BF%9D%E6%8A%A4/","excerpt":"","text":"Dalvik源码分析虽然加壳技术有所不同，第一步依然是dump内存中dex，虽然安卓4.4后Dalvik淡出视野，但是影响深远。Dalvik系统DexClassLoader加载dex具体流程： 搜索DexClassLoader源码只有一个构造函数 dexPath：需要加载的dex路径 optimizedDirectory：dex优化过程中产生的odex的存放路径 libraryPath：当前classloader需要加载so的路径 parent：双亲委派中的当前dexclassloader的父节点设置的classloader 1234public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), libraryPath, parent);&#125; 进入父类BaseDexClassLoader封装大量的函数，真正逻辑存在BaseDexClassLoader的构造函数中实现，调用了父类的构造函数，该类存在与/libcore/libart和/libcore/libdvm，说明在安卓4.4中已经开始引入art相关逻辑。 12345public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(parent); this.pathList &#x3D; new DexPathList(this, dexPath, libraryPath, optimizedDirectory);&#125; 进入Dalvik的ClassLoader的构造函数，将当前的ClassLoader的父节点作为传入的parent。 123456ClassLoader(ClassLoader parentLoader, boolean nullAllowed) &#123; if (parentLoader &#x3D;&#x3D; null &amp;&amp; !nullAllowed) &#123; throw new NullPointerException(&quot;parentLoader &#x3D;&#x3D; null &amp;&amp; !nullAllowed&quot;); &#125; parent &#x3D; parentLoader;&#125; new DexPathList再初始化pathList实例，进入DexPathList构造函数，前面对参数校验，真正起作用this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,suppressedExceptions);,makeDexElements方法调用了loadDexFile返回的dex添加到element数组并返回数组。 loadDexFile中再度调用了DexFile.loadDex(file.getPath(), optimizedPath, 0)，该方法新建了一个DexFile对象，return new DexFile(sourcePathName, outputPathName, flags);，在Dexfile中调用了openDexFile(sourceName, outputName, flags)完成了对dex的处理，openDexFile中调用了openDexFileNative，其中又调用openDexFileNative(new File(sourceName).getCanonicalPath(),(outputName == null) ? null : new File(outputName).getCanonicalPath(),flags);,跟进openDexFileNative发现是一个使用c/c++实现的native函数，native private static int openDexFileNative。该方法处理类/libcore/dalvik/src/main/java/dalvik/system/DexFile.java中，对应的实现文件就是dalvik_system_DexFile查看方法Dalvik_dalvik_system_DexFile_openDexFileNative，其中调用了dvmRawDexFileOpen实现对dex文件的打开。 123456789if (hasDexExtension(sourceName) &amp;&amp; dvmRawDexFileOpen(sourceName, outputName, &amp;pRawDexFile, false) &#x3D;&#x3D; 0) &#123; ALOGV(&quot;Opening DEX file &#39;%s&#39; (DEX)&quot;, sourceName); pDexOrJar &#x3D; (DexOrJar*) malloc(sizeof(DexOrJar)); pDexOrJar-&gt;isDex &#x3D; true; pDexOrJar-&gt;pRawDexFile &#x3D; pRawDexFile; pDexOrJar-&gt;pDexMemory &#x3D; NULL;&#125; 在dvmRawDexFileOpen中dexFd = open(fileName, O_RDONLY);打开dex文件，verifyMagicAndGetAdler32(dexFd, &amp;adler32) &lt; 0对dex魔术字校验，cachedName = dexOptGenerateCacheFileName(fileName, NULL);生成优化后的odex文件路径，dvmOptimizeDexFile(optFd, dexOffset, fileSize,fileName, modTime, adler32, isBootstrap);优化当前的dex，跟进发现存在于DexPrepare.cpp中的dvmOptimizeDexFile(int fd, off_t dexOffset, long dexLength,const char* fileName, u4 modWhen, u4 crc, bool isBootstrap),该方法中pid = fork();新建了子进程用于调用/bin/dexopt对当前dex文件进行优化，结果生成odex文件。bin/dexopt的main方法中传入的文件校验是dex时，调用static int fromDex(int argc, char* const argv[])首先调用dvmPrepForDexOpt对当前优化环境准备，再调用dvmContinueOptimization对当前的fd文件进行优化 123dexLength &lt; (int) sizeof(DexHeader) 字节长度判断mapAddr &#x3D; mmap(NULL, dexOffset + dexLength, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); mmap对当前dex文件的内容进行内存映射rewriteDex(((u1*) mapAddr) + dexOffset, dexLength, doVerify, doOpt, &amp;pClassLookup, NULL); 重写dex 查看static bool rewriteDex(u1* addr, int len, bool doVerify, bool doOpt,DexClassLookup** ppClassLookup, DvmDex** ppDvmDex)方法参数有加载到内存中dex的起始地址，字节数。该方法中暴露出在Dalvik中脱壳点的相关函数，dvmDexFileOpenPartial函数中出现dexFileParse，参数包含起始地址和字节数。 以上即是dexclassloader在动态加载dex时Dalvik实现的逻辑处理，很多时机点都出现了加载的dex的起始地址，就是最好的脱壳时机。很多脱壳方法都是对**dvmDexFileOpenPartial和dexFileParse进行下断点或者进行hook，取出第一个参数(起始地址)和第二个参数(dex长度)，其实在mmap对dex内存映射时包含dex文件，对当前映射区域进行dump也可以脱下从文件形式加载dex，在rewriteDex**时也出现了dex文件加载的起始地址和大小，自然也是可以进行dump等等。通过Cydia、xposed、frida都可以对实现对关键时机的hook，取出前两个参数，拿到起始地址和长度，dump下来内存区域即可实现脱壳。 定制源码脱壳对新的一些加壳厂商的产品依然有效，除非厂商对这些函数进行hook修改，或者参考Dalvik修改实现自己的逻辑。进入Ubuntu 1604x64_4.4的编译环境虚拟机，tom/admin，4.4的源码为hammerhead。通过编译源码的方式实现以下为部分脱壳点： dvmDexFileOpenPartial搜索 dvmDexFileOpenPartial 发现在/dalvik/vm/DvmDex.cpp文件中，使用Geany打开 ~/SourceCode/android-4.4.4_r1/dalvik/vm/DvmDex.cpp，找到dvmDexFileOpenPartial方法，只需要保存起始地址和大小即可。 修改int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex) 123456789101112131415#include &lt;sys&#x2F;stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;&#x2F;&#x2F;新建保存路径用于拼接脱壳app产生的dex路径，对每个脱壳的app的脱下的dex单独起名char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dvmDexFileOpenPartial.dex&quot;,len,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,addr,len); close(fd);&#125; dexFileParse搜索**dexFileParse**发现存在/dalvik/libdex/DexFile.cpp中，使用geany编辑器打开DexFile.cpp 修改DexFile* dexFileParse(const u1* data, size_t length, int flags) 123456789101112131415#include &lt;sys&#x2F;stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;&#x2F;&#x2F;新建保存路径用于拼接脱壳app产生的dex路径，对每个脱壳的app的脱下的dex单独起名char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dvmFileParse.dex&quot;,length,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,data,length); close(fd);&#125; mmap搜索 mmap 存在于/dalvik/vm/analysis/DexPrepare.cpp的中， 修改bool dvmContinueOptimization(int fd, off_t dexOffset, long dexLength, const char* fileName, u4 modWhen, u4 crc, bool isBootstrap) 1234567891011char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dvmContinueOptimization.dex&quot;,dexLength,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,mapAddr,dexOffset + dexLength); close(fd);&#125; 第一次映射到内存中需要将dex通过010Editor修正，删除64 65 78 0A前的字符。 rewriteDex搜索rewriteDex位于/dalvik/vm/analysis/DexPrepare.cpp， 修改static bool rewriteDex(u1* addr, int len, bool doVerify, bool doOpt, DexClassLookup** ppClassLookup, DvmDex** ppDvmDex) 1234567891011char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_rewriteDex.dex&quot;,len,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,addr,len); close(fd);&#125; dexSwapVerify搜索dexSwapVerify存在于/dalvik/libdex/DexSwapVerify.cpp 修改int dexSwapAndVerify(u1* addr, int len) 1234567891011char dexfilepath[100]&#x3D;&#123;0&#125;;&#x2F;&#x2F;当前进程的pidint pid&#x3D;getpid();&#x2F;&#x2F;文件路径拼接(文件大小，进程pid)sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_dexSwapAndVerify.dex&quot;,len,pid);&#x2F;&#x2F;写入sdcard保存的dex,很多壳对抗内存dump将fopen等方法hook，可以使用系统调用当中的写入，避免使用标准的文件写入函数导致dump不下来int fd &#x3D; open(dexfilepath,O_CREAT|O_RDWR,0666);if(fd&gt;0)&#123; write(fd,addr,len); close(fd);&#125; 编译1234~&#x2F;SourceCode&#x2F;android-4.4.4_r1$ source build&#x2F;envsetup.sh~&#x2F;SourceCode&#x2F;android-4.4.4_r1$ lunch7 选择aosp_hammerhead-userdebug~&#x2F;SourceCode&#x2F;android-4.4.4_r1$ time make -j4 如果报错直接make单线程编译 生成路径~/SourceCode/android/4.4.4_r1/out/target/product/hammerhead，将boot.img,cache.img,ramdisk.img,system.img,userdata.img拷出来 adb reboot bootloader fastboot flash system system.img 常用的img有boot,cache,ramdisk,system,userdata 安装LoadDex.apk，并把ClassLoaderTest生成的classes.dex放入/sdcard。在Activity启动的时候加载/sdcard的classes.dex的TestActivity并打印I&#39;m from TestActivity.onCreate，这就是一代壳的基本原理。 重启系统后/sdcard中已经出现一些系统中脱下的dex，启动LoadDex，grep -ril &quot;TestActivity&quot; ./*.dex 找到LoadDex中脱下的dex，gda可以看到优化后的odex的TestActivity中onCreate方法 真实案例a.apk 《百度》加固 启动后进入/sdcard , grep -ril “SplashActivity” ./*.dex b.apk 《爱加密》企业版本加固 启动后进入/sdcard , grep -ril “mvp/ui/SplashActivity” ./*.dex，内容都为null，说明用了函数抽取。 ARTInMemoryDexClassLoader源码分析加载内存中的解密字节流过程art的具体流程： 在Android 8.0中libcore搜索InMemoryDexClassLoader两个构造函数，分别加载一个或多个dex。进入父类BaseDexClassLoader.java的构造函数 123456789public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(parent); this.pathList &#x3D; new DexPathList(this, dexPath, librarySearchPath, null); if (reporter !&#x3D; null) &#123; reporter.report(this.pathList.getDexPaths()); &#125;&#125; 跟进public DexPathList(ClassLoader definingContext, ByteBuffer[] dexFiles)，前几步对传参判断，紧接着对传入的so库的处理 123456this.definingContext &#x3D; definingContext;&#x2F;&#x2F; TODO It might be useful to let in-memory dex-paths have native libraries.this.nativeLibraryDirectories &#x3D; Collections.emptyList();this.systemNativeLibraryDirectories &#x3D; splitPaths(System.getProperty(&quot;java.library.path&quot;), true);this.nativeLibraryPathElements &#x3D; makePathElements(this.systemNativeLibraryDirectories); 传入的dex只需要看this.dexElements = makeInMemoryDexElements(dexFiles, suppressedExceptions);摘除核心代码如下： 12345678910private static Element[] makeInMemoryDexElements(ByteBuffer[] dexFiles, List&lt;IOException&gt; suppressedExceptions) &#123; Element[] elements &#x3D; new Element[dexFiles.length]; int elementPos &#x3D; 0; for (ByteBuffer buf : dexFiles) &#123; DexFile dex &#x3D; new DexFile(buf); elements[elementPos++] &#x3D; new Element(dex); &#125; return elements;&#125; 进入DexFile(buf)的构造函数中，发现将buf在内存中打开 12345DexFile(ByteBuffer buf) throws IOException &#123; mCookie &#x3D; openInMemoryDexFile(buf); mInternalCookie &#x3D; mCookie; mFileName &#x3D; null;&#125; 查看openInMemoryDexFile方法，分别根据条件创建了两次cookie 1234567private static Object openInMemoryDexFile(ByteBuffer buf) throws IOException &#123; if (buf.isDirect()) &#123; return createCookieWithDirectBuffer(buf, buf.position(), buf.limit()); &#125; else &#123; return createCookieWithArray(buf.array(), buf.position(), buf.limit()); &#125;&#125; 分别查看createCookieWithDirectBuffer和createCookieWithArray两个方法，发现是两个native函数 12private static native Object createCookieWithDirectBuffer(ByteBuffer buf, int start, int end);private static native Object createCookieWithArray(byte[] buf, int start, int end); 在art模块中Full Search createCookieWithDirectBuffer,进入DexFile_createCookieWithDirectBuffer 12345678910111213141516171819202122static jobject DexFile_createCookieWithDirectBuffer(JNIEnv* env, jclass, &#x2F;&#x2F; 静态函数 第一个是jclass当前类 jobject buffer, &#x2F;&#x2F; 传入内存中的字节流 jint start, jint end) &#123; uint8_t* base_address &#x3D; reinterpret_cast&lt;uint8_t*&gt;(env-&gt;GetDirectBufferAddress(buffer)); if (base_address &#x3D;&#x3D; nullptr) &#123; ScopedObjectAccess soa(env); ThrowWrappedIOException(&quot;dexFileBuffer not direct&quot;); return 0; &#125; std::unique_ptr&lt;MemMap&gt; dex_mem_map(AllocateDexMemoryMap(env, start, end)); if (dex_mem_map &#x3D;&#x3D; nullptr) &#123; DCHECK(Thread::Current()-&gt;IsExceptionPending()); return 0; &#125; size_t length &#x3D; static_cast&lt;size_t&gt;(end - start); memcpy(dex_mem_map-&gt;Begin(), base_address, length); &#x2F;&#x2F; 对当前字节流进行内存拷贝memcpy，传入begin和length就是dex的起始地址，可以进行dump return CreateSingleDexFileCookie(env, std::move(dex_mem_map));&#125; createCookieWithDirectBuffer和createCookieWithArray都进行了CreateSingleDexFileCookie 12345678910static jobject CreateSingleDexFileCookie(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; data) &#123; std::unique_ptr&lt;const DexFile&gt; dex_file(CreateDexFile(env, std::move(data))); &#x2F;&#x2F; 根据传入dex文件在内存中信息创建了DexFile实例 if (dex_file.get() &#x3D;&#x3D; nullptr) &#123; DCHECK(env-&gt;ExceptionCheck()); return nullptr; &#125; std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files; dex_files.push_back(std::move(dex_file)); return ConvertDexFilesToJavaArray(env, nullptr, dex_files); &#x2F;&#x2F; 对该dex_files进行返回&#125; 通过CreateDexFile创建DexFile对象 12345678910111213141516171819202122232425static const DexFile* CreateDexFile(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; dex_mem_map) &#123; &#x2F;&#x2F; 返回dex文件在内存中映射的地址 std::string location &#x3D; StringPrintf(&quot;Anonymous-DexFile@%p-%p&quot;, dex_mem_map-&gt;Begin(), dex_mem_map-&gt;End()); std::string error_message; std::unique_ptr&lt;const DexFile&gt; dex_file(DexFile::Open(location, 0, std::move(dex_mem_map), &#x2F;* verify *&#x2F; true, &#x2F;* verify_location *&#x2F; true, &amp;error_message)); if (dex_file &#x3D;&#x3D; nullptr) &#123; ScopedObjectAccess soa(env); ThrowWrappedIOException(&quot;%s&quot;, error_message.c_str()); return nullptr; &#125; if (!dex_file-&gt;DisableWrite()) &#123; ScopedObjectAccess soa(env); ThrowWrappedIOException(&quot;Failed to make dex file read-only&quot;); return nullptr; &#125; return dex_file.release();&#125; 进入DexFile::Open，其中又调用了OpenCommon函数 1234567891011121314151617181920212223std::unique_ptr&lt;const DexFile&gt; DexFile::Open(const std::string&amp; location, uint32_t location_checksum, std::unique_ptr&lt;MemMap&gt; map, bool verify, bool verify_checksum, std::string* error_msg) &#123; ScopedTrace trace(std::string(&quot;Open dex file from mapped-memory &quot;) + location); CHECK(map.get() !&#x3D; nullptr); if (map-&gt;Size() &lt; sizeof(DexFile::Header)) &#123; *error_msg &#x3D; StringPrintf( &quot;DexFile: failed to open dex file &#39;%s&#39; that is too short to have a header&quot;, location.c_str()); return nullptr; &#125; std::unique_ptr&lt;DexFile&gt; dex_file &#x3D; OpenCommon(map-&gt;Begin(), map-&gt;Size(), location, location_checksum, kNoOatDexFile, verify, verify_checksum, error_msg); 进入OpenCommon函数 1234567891011121314151617std::unique_ptr&lt;DexFile&gt; DexFile::OpenCommon(const uint8_t* base, size_t size, const std::string&amp; location, uint32_t location_checksum, const OatDexFile* oat_dex_file, bool verify, bool verify_checksum, std::string* error_msg, VerifyResult* verify_result) &#123; if (verify_result !&#x3D; nullptr) &#123; *verify_result &#x3D; VerifyResult::kVerifyNotAttempted; &#125; std::unique_ptr&lt;DexFile&gt; dex_file(new DexFile(base, size, location, location_checksum, oat_dex_file)); &#x2F;&#x2F; 创建新的DexFile实例，构造函数也包含起始地址和大小 说明InMemoryDexClassLoader在对内存中bytebuffer的dex信息进行加载流程中涉及很多函数逻辑都包含dex信息的起始地址和大小。InMemoryDexClassLoader并没有对内存中dex信息进行编译生成相应的oat文件，这是与DexClassLoader的不同。 通用脱壳点： CreateSingleDexFileCookie的data参数可以获取起始地址 CreateDexFile DexFile::Open OpenCommon DexFile::DexFile DexClassLoader加载dex源码分析DexClassLoader只有一个构造函数 1234public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), librarySearchPath, parent);&#125; 进入父类BaseDexClassLoader.java的构造函数 123456789public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(parent); this.pathList &#x3D; new DexPathList(this, dexPath, librarySearchPath, null); if (reporter !&#x3D; null) &#123; reporter.report(this.pathList.getDexPaths()); &#125;&#125; 同样的进入DexPathList的核心逻辑this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,suppressedExceptions, definingContext);,调用了makeDexElements，其中加载dex文件loadDexFile(file, optimizedDirectory, loader, elements); 12345678910private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader, Element[] elements) throws IOException &#123; if (optimizedDirectory &#x3D;&#x3D; null) &#123; return new DexFile(file, loader, elements); &#125; else &#123; String optimizedPath &#x3D; optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements); &#125;&#125; DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements)调用了5个参数的loadDex,进入loadDex函数 1234static DexFile loadDex(String sourcePathName, String outputPathName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; return new DexFile(sourcePathName, outputPathName, flags, loader, elements); &#x2F;&#x2F; 创建DexFile实例&#125; 进入DexFile五参数构造函数 123456DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; mCookie &#x3D; openDexFile(fileName, null, 0, loader, elements); mInternalCookie &#x3D; mCookie; mFileName &#x3D; fileName; &#x2F;&#x2F;System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; fileName&#x3D;&quot; + fileName);&#125; 进入openDexFile中调用了native函数private static native Object openDexFileNative(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements); 1234567return openDexFileNative(new File(sourceName).getAbsolutePath(), (outputName &#x3D;&#x3D; null) ? null : new File(outputName).getAbsolutePath(), flags, loader, elements); Full Search搜索art目录下的openDexFileNative， 123456789101112131415161718192021222324252627282930313233343536373839static jobject DexFile_openDexFileNative(JNIEnv* env, jclass, &#x2F;&#x2F; 静态函数 jstring javaSourceName, &#x2F;&#x2F; 加载的dex路径 jstring javaOutputName ATTRIBUTE_UNUSED, jint flags ATTRIBUTE_UNUSED, jobject class_loader, jobjectArray dex_elements) &#123; ScopedUtfChars sourceName(env, javaSourceName); if (sourceName.c_str() &#x3D;&#x3D; nullptr) &#123; return 0; &#125; Runtime* const runtime &#x3D; Runtime::Current(); ClassLinker* linker &#x3D; runtime-&gt;GetClassLinker(); std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt; dex_files; std::vector&lt;std::string&gt; error_msgs; const OatFile* oat_file &#x3D; nullptr; &#x2F;&#x2F; 出现oat dex_files &#x3D; runtime-&gt;GetOatFileManager().OpenDexFilesFromOat(sourceName.c_str(), class_loader, dex_elements, &#x2F;*out*&#x2F; &amp;oat_file, &#x2F;*out*&#x2F; &amp;error_msgs); &#x2F;&#x2F; 调用OpenDexFilesFromOat编译生成oat流程 if (!dex_files.empty()) &#123; jlongArray array &#x3D; ConvertDexFilesToJavaArray(env, oat_file, dex_files); if (array &#x3D;&#x3D; nullptr) &#123; ScopedObjectAccess soa(env); for (auto&amp; dex_file : dex_files) &#123; if (linker-&gt;IsDexFileRegistered(soa.Self(), *dex_file)) &#123; dex_file.release(); &#125; &#125; &#125; return array; &#125; return nullptr; &#125;&#125; DexClassLoader第一次动态加载解密的dex时必然没有进行编译生成oat，查看OpenDexFilesFromOat,首先OatFileAssistant oat_file_assistant(dex_location,kRuntimeISA,!runtime-&gt;IsAotCompiler());新建了OatFileAssistant 对象，if (!oat_file_assistant.IsUpToDate())由于没有生成oat对象的，进入判断中的MakeUpToDate函数，其中调用了return GenerateOatFileNoChecks(info, target, error_msg);GenerateOatFileNoChecks最终进入调用dex2oat编译生成oat的流程 123456789if (!Dex2Oat(args, error_msg)) &#123; &#x2F;&#x2F; Manually delete the oat and vdex files. This ensures there is no garbage &#x2F;&#x2F; left over if the process unexpectedly died. vdex_file-&gt;Erase(); unlink(vdex_file_name.c_str()); oat_file-&gt;Erase(); unlink(oat_file_name.c_str()); return kUpdateFailed;&#125; 中准备相关二进制程序参数的相关信息，最终调用return Exec(argv, error_msg);实现dex2oat编译的过程，进入Exec中调用了ExecAndReturnCode，首次进行了进程fork，在子进程当中使用execve(program, &amp;args[0], envp);执行dex2oat实际执行流程。 说明我们在整个流程中其中某个函数进行修改或者hook都会导致dex2oat流程结束，强制结束dex2oat流程，可以让我们在DexClassLoader在加载dex时过程变的很有效率，减少dex2oat编译的流程，要想实现art下的函数抽取技术，也是要阻断dex2oat的流程。当我们阻断了dex2oat会导致openDexFileNative中 dex_files 文件无法生成，在调用runtime-&gt;GetOatFileManager().OpenDexFilesFromOat中进入尝试判断原始dex文件oat_file_assistant.HasOriginalDexFiles()并通过DexFile::Open进行加载dex 123456789101112131415161718if (dex_files.empty()) &#123; if (oat_file_assistant.HasOriginalDexFiles()) &#123; if (Runtime::Current()-&gt;IsDexFileFallbackEnabled()) &#123; static constexpr bool kVerifyChecksum &#x3D; true; if (!DexFile::Open( dex_location, dex_location, kVerifyChecksum, &#x2F;*out*&#x2F; &amp;error_msg, &amp;dex_files)) &#123; LOG(WARNING) &lt;&lt; error_msg; error_msgs-&gt;push_back(&quot;Failed to open dex files from &quot; + std::string(dex_location) + &quot; because: &quot; + error_msg); &#125; &#125; else &#123; error_msgs-&gt;push_back(&quot;Fallback mode disabled, skipping dex files.&quot;); &#125; &#125; else &#123; error_msgs-&gt;push_back(&quot;No original dex files found for dex location &quot; + std::string(dex_location)); &#125;&#125; 进入DexFile::Open中可看到File fd = OpenAndReadMagic(filename, &amp;magic, error_msg);到此出现了第一个脱壳点OpenAndReadMagic，此时dex还未加载到内存当中。紧接着开始判断dex魔术头，并进入DexFile::OpenFile函数 12345678910111213if (IsDexMagic(magic)) &#123; std::unique_ptr&lt;const DexFile&gt; dex_file(DexFile::OpenFile(fd.Release(), &#x2F;&#x2F; 文件描述符，可以作为脱壳点 location, &#x2F;* verify *&#x2F; true, verify_checksum, error_msg)); if (dex_file.get() !&#x3D; nullptr) &#123; dex_files-&gt;push_back(std::move(dex_file)); return true; &#125; else &#123; return false; &#125;&#125; 进入DexFile::OpenFile函数发现通过MemMap::MapFile将dex进行了内存映射 12345678map.reset(MemMap::MapFile(length, PROT_READ, MAP_PRIVATE, fd, 0, &#x2F;*low_4gb*&#x2F;false, location.c_str(), error_msg)); 再进入OpenCommon函数中，参数中也包含了dex文件的映射区域的起始地址，出现了第二个脱壳点。 12345678std::unique_ptr&lt;DexFile&gt; dex_file &#x3D; OpenCommon(map-&gt;Begin(), map-&gt;Size(), location, dex_header-&gt;checksum_, kNoOatDexFile, verify, verify_checksum, error_msg); 跟进DexFile::OpenCommon中，发现其中调用了DexFile的构造函数 12345std::unique_ptr&lt;DexFile&gt; dex_file(new DexFile(base, size, location, location_checksum, oat_dex_file)); 至此出现了第三个脱壳点DexFile::DexFile 12345DexFile::DexFile(const uint8_t* base, size_t size, const std::string&amp; location, uint32_t location_checksum, const OatDexFile* oat_dex_file) 通用脱壳点： OpenAndReadMagic OpenCommon DexFile::DexFile 通过对比：InMemoryDexClassLoader和DexClassLoader的脱壳点，发现OpenCommon是两者通用脱壳点。 定制源码脱壳DexFile::OpenCommon修改/art/runtime/dex_file.cc中DexFile::OpenCommon方法 12345678910 int pid&#x3D;getpid(); char dexfilepath[100]&#x3D;&#123;0&#125;; sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_OpenCommon.dex&quot;,(int)size,pid); int fd&#x3D;open(dexfilepath,O_CREAT|O_RDWR,666); if (fd&gt;0)&#123;int number&#x3D;write(fd,base,size);if(number&gt;0)&#123;&#125;close(fd); &#125; DexFile::DexFile修改/art/runtime/dex_file.cc中DexFile::DexFile方法 12345678910 int pid&#x3D;getpid(); char dexfilepath[100]&#x3D;&#123;0&#125;; sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%d_%d_DexFile.dex&quot;,(int)size,pid); int fd&#x3D;open(dexfilepath,O_CREAT|O_RDWR,666); if (fd&gt;0)&#123;int number&#x3D;write(fd,base,size);if(number&gt;0)&#123;&#125;close(fd); &#125; 编译1234~&#x2F;Android8.0&#x2F;android-8.0.0_r1$ source build&#x2F;envsetup.sh~&#x2F;Android8.0&#x2F;android-8.0.0_r1$ lunch23 选择aosp_sailfish-userdebug~&#x2F;Android8.0&#x2F;android-8.0.0_r1$ time make -j4 如果报错直接make单线程编译 生成路径~/Android8.0/android-8.0.0_r1/out/target/product/sailfish，将boot.img,ramdisk.img,system.img,system_other.img,userdata.img,vendor.img拷出来 安装LoadDex.apk，并把ClassLoaderTest生成的classes.dex放入/sdcard。并在设置中授予该app读写sdcard的权限。在Activity启动的时候加载/sdcard的classes.dex的TestActivity并打印I&#39;m from TestActivity.onCreate，这就是一代壳的基本原理。 重启系统后/sdcard中已经出现一些系统中脱下的dex，启动LoadDex，grep -ril &quot;TestActivity&quot; ./*.dex 找到LoadDex中脱下的dex，DexClassLoader加载的插件dex已经被dump下来，gda可以看到优化后的odex的TestActivity中onCreate方法。 真实案例a.apk 《百度》加固 启动后进入/sdcard , grep -ril “SplashActivity” ./*.dex b.apk 《爱加密》企业版本加固 启动后进入/sdcard , grep -ril “mvp/ui/SplashActivity” ./*.dex，内容都为null，说明用了函数抽取，这就是需要fart解决的问题。 ExecAndReturnCode中调用execve(program, &amp;args[0], envp);,dex2oat流程也可以脱壳,main函数中调用int result = static_cast&lt;int&gt;(art::Dex2oat(argc, argv));,跟进Setup()方法最后会出现对要编译dex文件的处理，CompileApp也出现了DexFile对象等等非常多的流程出现Dexfile对象，都可以成为脱壳点","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"Dalvik","slug":"Dalvik","permalink":"http://onejane.github.io/tags/Dalvik/"},{"name":"ART","slug":"ART","permalink":"http://onejane.github.io/tags/ART/"}]},{"title":"Socket&Websocket&Protobuf自吐通杀","slug":"Socket&Websocket&Protobuf自吐通杀","date":"2021-03-14T10:00:50.000Z","updated":"2021-03-27T03:42:32.300Z","comments":true,"path":"2021/03/14/Socket&Websocket&Protobuf自吐通杀/","link":"","permalink":"http://onejane.github.io/2021/03/14/Socket&Websocket&Protobuf%E8%87%AA%E5%90%90%E9%80%9A%E6%9D%80/","excerpt":"","text":"Socket所有的应用层都逃不掉底层用Socket来传输,只要掌握了Socket，对上层应用就是降维打击。 新建HttpSocket项目，并在AndroidManifest.xml配置网络权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true)&#123; newHttp(); try &#123; Thread.sleep(10*1000); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125; private static void newHttp()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; String url &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&quot;; URL urlConn &#x3D; new URL(url); HttpURLConnection connection &#x3D; (HttpURLConnection)urlConn.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.connect(); int responseCode &#x3D; connection.getResponseCode(); if (responseCode &#x3D;&#x3D; HttpURLConnection.HTTP_OK) &#123; InputStream inputStream &#x3D; connection.getInputStream(); String result &#x3D; is2String(inputStream); Log.d(&quot;onejane&quot;,&quot;result&#x3D;&#x3D;&#x3D;&#x3D;&quot;+result); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private static String is2String(InputStream inputStream) throws IOException &#123; byte[] buffer &#x3D; new byte[1024]; ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream(); for (int len &#x3D; 0; (len &#x3D; inputStream.read(buffer)) &gt; 0;) &#123; baos.write(buffer, 0, len); &#125; String result &#x3D; new String(baos.toByteArray(), &quot;utf-8&quot;); System.out.println(result); return result ; &#125;&#125; 关键类定位objection -g com.onejane.httpsocket explore android heap search instances java.net.Socket 查看堆内存中是否有该实例 android hooking search classes Socket 搜索与Socket相关的类 android hooking watch class java.net.Socket 默认hook类的所有方法没有构造函数 android hooking watch class_method java.net.Socket.$init –dump-args –dump-backtrace –dump-return 手动调用hook构造函数 vim ~/.pyenv/versions/3.8.0/lib/python3.8/site-packages/objection/agent.js 输入:9211跳转到9211行，加上.concat([“$init”])，会影响objection的稳定性 将与Socket相关的类添加前缀android hooking watch class存入socket.txt objection -g com.onejane.httpsocket explore -c ~/Desktop/socket.txt 批量hook，如果崩掉，需要将崩掉的类从文本中移除 okhttp底层走的socket android hooking watch class_method java.net.AbstractPlainSocketImpl.acquireFD --dump-args --dump-backtrace --dump-return 根据hook的结果拿到java.net.SocketOutputStream.write方法就是socket写入时调用的方法，针对该方法进行hook android hooking watch class_method java.net.SocketOutputStream.write --dump-args --dump-backtrace --dump-return SocketInputStream.read的hook结果复制到010Editor，搜索1f8b,删除前面所有字符，保存为gzip,解压查看结果就是百度网页结果 socket自吐实现http与https的socket自吐，修改url地址http://www.baidu.com/为https://www.baidu.com/, 有这两个自吐，可以通杀所有协议层的收发包内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function hook_socket()&#123; Java.perform(function()&#123; console.log(&quot;hook_socket;&quot;) Java.use(&quot;java.net.SocketOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTP write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; Java.use(&quot;java.net.SocketInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTP read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; &#125;)&#125;function hook_SSLsocketandroid8()&#123; Java.perform(function()&#123; console.log(&quot;hook_SSLsocket&quot;) Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.write(bytearry,int1,int2); console.log(&quot;HTTPS write result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; Java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;, &#39;int&#39;, &#39;int&#39;).implementation &#x3D; function(bytearry,int1,int2)&#123; var result &#x3D; this.read(bytearry,int1,int2); console.log(&quot;HTTPS read result,bytearry,int1,int2&#x3D;&gt;&quot;,result,bytearry,int1,int2) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); console.log(&quot;bytearray contents&#x3D;&gt;&quot;, ByteString.of(bytearry).hex()) return result; &#125; &#125;)&#125;function hook_SSLsocket2android10()&#123; Java.perform(function()&#123; console.log(&quot; hook_SSLsocket2&quot;) var ByteString &#x3D; Java.use(&quot;com.android.okhttp.okio.ByteString&quot;); Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_write.implementation &#x3D; function(long,NS,fd,NC,bytearray,int1,int2,int3)&#123; var result &#x3D; this .SSL_write(long,NS,fd,NC,bytearray,int1,int2,int3); console.log(&quot;SSL_write(long,NS,fd,NC,bytearray,int1,int2,int3),result&#x3D;&gt;&quot;,long,NS,fd,NC,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex()); return result; &#125; Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_read.implementation &#x3D; function(long,NS,fd,NC,bytearray,int1,int2,int3)&#123; var result &#x3D; this .SSL_read(long,NS,fd,NC,bytearray,int1,int2,int3); console.log(&quot;SSL_read(long,NS,fd,NC,bytearray,int1,int2,int3),result&#x3D;&gt;&quot;,long,NS,fd,NC,bytearray,int1,int2,int3,result) console.log(ByteString.of(bytearray).hex()); return result; &#125; &#125;)&#125;function main()&#123; console.log(&quot;Main&quot;) hook_socket(); hook_SSLsocketandroid8(); &#x2F;&#x2F;hook_SSLsocket2android10();&#125;setImmediate(main) frida -UF -l hookSocket.js 使用git clone https://github.com/peiniwan/Ganhuo.git 编译源码编译安装GanHuo.apk查看代码家栏,通过010Editor获取转换后的Unicode码，即为抓包结果 Websocket虚拟机网卡切换为桥接模式:192.168.0.104 server wget https://github.com/gotify/server/releases/download/v2.0.20/gotify-linux-amd64.zip unzip gotify-linux-amd64.zip chmod +x gotify-linux-amd64 ./gotify-linux-amd64 client adb install Gotify.apk 输入server地址http://192.168.0.104 admin/admin cli wget -O gotify https://github.com/gotify/cli/releases/download/v1.2.0/gotify-cli-linux-amd64 chmod +x gotify mv gotify /usr/bin/gotify gotify init gotify push -t “my title” -p 10 “my message” 服务器向手机发送消息 hook_okhttp3_logging添加十六进制转换，在控制台中以字符串显示 123456function jhexdump(array) &#123; var ptr &#x3D; Memory.alloc(array.length); for(var i &#x3D; 0; i &lt; array.length; ++i) Memory.writeS8(ptr.add(i), array[i]); console.log(hexdump(ptr, &#123; offset: 0, length: array.length, header: false, ansi: false &#125;));&#125; 使用console.log(jhexdump(bytearry))替换console.log(“bytearray contents=&gt;”, ByteString.of(bytearry).hex()) frida -UF -l hookSocket.js 使用socket自吐依旧可以通杀抓包 pm list packages|grep -i gotify 获取包名 frida -U -f com.github.gotify -l hookSocket.js –no-pause -o gotify.log objection -g com.github.gotify explore android hooking search classes websocket 查找内存中和websocket相关的类很少，可以通过android hooking watch class * ,存入websocket.txt文件批量hook 123objection -g com.github.gotify explore -c ~&#x2F;Desktop&#x2F;gotify&#x2F;websocket.txtplugin wallbreaker objectsearch com.github.gotify.client.model.Message 获取内存中的Message对象pluginwallbreaker objectdump --fullname 0x2576 获取该对象中字段在内存中的内容 android hooking search classes websocket 发现okhttp3.WebSocket,通过hook_okhttp3_logging脚本进行hook抓包frida -U -f com.github.gotify -l hookOkhttp3.js --no-pause，logcat|grep okhttpGET 查看可以抓到ok3的websocket包 android hooking search classes com.xabber.xmpp.smack 基于xmpp协议聊天软件xabber搜索包名并批量hook android hooking watch class_method java.lang.String.toString –dump-args -dump-backtrace –dump-return hookWebSocketvim hookWebSocket.js 综合基于hook和枚举的方式抓包websocket 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384function hook_okhttp3() &#123; &#x2F;&#x2F; 1. frida Hook java层的代码必须包裹在Java.perform中，Java.perform会将Hook Java相关API准备就绪。 Java.perform(function () &#123; Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;okhttp3logging.dex.dex&quot;).load(); &#x2F;&#x2F; 只修改了这一句，换句话说，只是使用不同的拦截器对象。 var MyInterceptor &#x3D; Java.use(&quot;com.roysue.octolesson2ok3.okhttp3Logging&quot;); var MyInterceptorObj &#x3D; MyInterceptor.$new(); var Builder &#x3D; Java.use(&quot;okhttp3.OkHttpClient$Builder&quot;); console.log(Builder); Builder.build.implementation &#x3D; function () &#123; this.networkInterceptors().add(MyInterceptorObj); console.log(&quot;hook Build.build successfully !&quot;) return this.build(); &#125;; console.log(&quot;hooking_okhttp3...&quot;); &#125;);&#125;function EnumerateClient()&#123; Java.perform(function()&#123; &#x2F;&#x2F;Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;r0gson.dex&quot;).load(); &#x2F;&#x2F;const gson &#x3D; Java.use(&#39;com.r0ysue.gson.Gson&#39;); var gson2 &#x3D; Java.use(&#39;com.google.gson.Gson&#39;); &#x2F;&#x2F; 加载包含CurlInterceptor拦截器的DEX Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;myok2curl.dex&quot;).load(); console.log(&quot;loading dex successful!&quot;) const curlInterceptor &#x3D; Java.use(&quot;com.moczul.ok2curl.CurlInterceptor&quot;); const loggable &#x3D; Java.use(&quot;com.moczul.ok2curl.logger.Loggable&quot;); var Log &#x3D; Java.use(&quot;android.util.Log&quot;); var TAG &#x3D; &quot;okhttpGETcurl&quot;; &#x2F;&#x2F;注册类————一个实现了所需接口的类 var MyLogClass &#x3D; Java.registerClass(&#123; name: &quot;okhttp3.MyLogClass&quot;, implements: [loggable], methods: &#123; log: function (MyMessage) &#123; Log.v(TAG, MyMessage); &#125;&#125; &#125;); const mylog &#x3D; MyLogClass.$new(); &#x2F;&#x2F; 得到所需拦截器对象 var curlInter &#x3D; curlInterceptor.$new(mylog); &#x2F;&#x2F; 加载包含logging-interceptor拦截器的DEX Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;okhttplogging.dex&quot;).load(); var MyInterceptor &#x3D; Java.use(&quot;com.r0ysue.learnokhttp.okhttp3Logging&quot;); var MyInterceptorObj &#x3D; MyInterceptor.$new(); Java.choose(&quot;okhttp3.OkHttpClient&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;1. found instance:&quot;,instance) console.log(&quot;2. instance.interceptors():&quot;,instance.interceptors().$className) console.log(&quot;3. instance._interceptors:&quot;,instance._interceptors.value.$className) &#x2F;&#x2F;console.log(&quot;4. interceptors:&quot;,gson2.$new().toJson(instance.interceptors())) console.log(&quot;5. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(instance.interceptors().toArray())) var newInter &#x3D; Java.use(&quot;java.util.ArrayList&quot;).$new(); newInter.addAll(instance.interceptors()); console.log(&quot;6. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(newInter.toArray())); console.log(&quot;7. interceptors:&quot;,newInter.$className); newInter.add(MyInterceptorObj); newInter.add(curlInter); instance._interceptors.value &#x3D; newInter; &#125;,onComplete:function()&#123; console.log(&quot;Search complete!&quot;) &#125; &#125;) &#125;)&#125;function main()&#123; hook_okhttp3(); EnumerateClient(); &#125;setImmediate(main) OkHttpLogger-Fridafrida -UF -l OkHttpLogger-Frida/okhttp_poker.js 抓包websocket Protobuf直播/弹幕协议Protobuf逆向分析，手把手教你使用ProtoBuf，通过gRPC服务在Android上进行网络请求 服务端192.168.0.102 官方教程 123456789101112131415161718192021systemctl stop firewalld.service systemctl disable firewalld.servicesetenforce 0/etc/selinux/config 修改为SELINUX=disabledtar -zxvf jdk-8u60-linux-x64.tar.gzmv jdk1.8.0_60/ /usr/local/tar -zxf apache-maven-3.6.3-bin.tar.gz -C /usr/local/vim /etc/profileJAVA_HOME=/usr/local/jdk1.8.0_60JRE_HOME=$JAVA_HOME/jreMAVEN_HOME=/usr/local/apache-maven-3.6.3PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin::$MAVEN_HOME/binCLASSPATH=:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/dt.jarexport JAVA_HOME JRE_HOME PATH CLASSPATH MAVEN_HOMEsource /etc/profilegit clone -b v1.36.1 https://github.com/grpc/grpc-javagit checkout -b v1.32.1 避免无法连接国外仓库ggcd grpc-java/examples./gradlew installDist./build/install/examples/bin/hello-world-server 启动server端口在50051./build/install/examples/bin/hello-world-client 通过HelloRequest发送Hello World 客户端192.168.0.104 git clone https://github.com/xuexiangjys/Protobuf-gRPC-Android.git ，其中helloworld.proto通过protoc编译生成HelloReply.java 手动编译，idea中安装GenProtobuf将binary进行encode和decode wget https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-linux-x86_64.zip unzip protoc-3.13.0-linux-x86_64.zip as-Tools-Configure GenProtobuf 右键hellooworld.proto点击quick gen protobuf here 实现手动编译，生成的编译代码使用了大量的google的protobuf基础库 安装启动Protobuf-gRPC-Android，保证服务端和客户端互相ping通，可以通过nc 192.168.0.102 50052 给服务端发送数据，服务端使用nc -l 50052接收，如果互通消息就可以收到，否则使用NPS将服务端的50051端口服务映射到指定服务器ip的指定端口(需要在服务端安装nps客户端，在nps服务端配置该nps客户端)。 如果没有响应，ps -ef|grep protobuf 获取到进程id后，logcat|grep -i 22916 查看log，退出重进gRPC-普通请求按钮，输入服务端ip，端口及内容发送请求。 1234567adb shellps -ef|grep protobuf 获取包名.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64 启动frida serverpyenv local 3.8.0objection -g com.xuexiang.protobufdemo exploreandroid hooking search classes protobuf 将打印出的类前面加上android hooking watch class,存入hook_list.txtobjection -g com.xuexiang.protobufdemo explore -c &#x2F;root&#x2F;Desktop&#x2F;hook_list.txt 实现批量hook，点击发送请求，从请求找寻找调用到的protobuf类相关方法 关注打印出来的几个函数： com.google.protobuf.WireFormat.makeTagcom.google.protobuf.CodedOutputStream$OutputStreamEncoder.write([B, int, int)com.google.protobuf.CodedInputStream.readTag()com.google.protobuf.WireFormat.getTagFieldNumber(int)com.google.protobuf.Utf8.encode(java.lang.CharSequence, [B, int, int)com.google.protobuf.CodedInputStream.newInstance([B, int, int, boolean) 1android hooking watch class_method com.google.protobuf.Utf8.encode --dump-args --dump-backtrace --dump-return 同理，makeTag的调用栈也是从用户代码中的writeTo调用而来。 frida -UF -l hookSocket.js -o protobuf.txt 通杀自吐打印出protubuf的包数据 12plugin wallbreaker objectsearch com.xuexiang.protobufdemo.HelloReplyplugin wallbreaker objectdump --fullname 0x22ea 内存漫游的源码 Protobuf协议逆向和仿真&amp;举个栗子 抓包+逆向app分析protobuf -Protobuf协议解析文档-某音弹幕","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"Socket","slug":"Socket","permalink":"http://onejane.github.io/tags/Socket/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://onejane.github.io/tags/WebSocket/"},{"name":"Protobuf","slug":"Protobuf","permalink":"http://onejane.github.io/tags/Protobuf/"},{"name":"XMPP","slug":"XMPP","permalink":"http://onejane.github.io/tags/XMPP/"}]},{"title":"Spring-Cloud-Alibaba","slug":"Spring-Cloud-Alibaba","date":"2021-03-11T08:03:07.000Z","updated":"2021-03-16T13:56:30.893Z","comments":true,"path":"2021/03/11/Spring-Cloud-Alibaba/","link":"","permalink":"http://onejane.github.io/2021/03/11/Spring-Cloud-Alibaba/","excerpt":"","text":"SpringCloudAlibabaSpring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。 依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。 Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。 Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。 Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。 Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。 Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 虚拟机安装virtualbox 6 vagrant安装好后进入镜像仓库搜索需要安装的镜像 mkdir centos7 &amp;&amp; vagrant init centos/7 &amp;&amp; vagrant up &amp;&amp; vagrant ssh 创建并开启镜像，修改网络桥接 如果太慢，进入centos/7仓库下载，手动加载vagrant box add centos/7 CentOS-7-x86_64-Vagrant-2004_01.VirtualBox.box vim Vagrantfile 修改配置并重启vagrant reload，保存虚拟机与主机可ping通，sudo passwd root 设置root权限 12# config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot; host-onlyconfig.vm.network &quot;public_network&quot; 桥接 安装nodejs并配置淘宝源npm config set registry http://registry.npm.taobao.org/ 安装docker 1234567891011121314151617sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-enginesudo yum install -y yum-utilssudo yum-config-manager \\ --add-repo \\ https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.reposudo yum install -y docker-ce docker-ce-cli containerd.ioyum list docker-ce --showduplicates | sort -rsudo systemctl start dockersudo docker imagessudo systemctl enable docker 镜像加速器 12345678sudo mkdir -p &#x2F;etc&#x2F;dockersudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;3gki6pei.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker mysql 12345678910docker run -p 3306:3306 --name mysql \\-v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysal \\-v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql \\-e MYSQL_ROOT_PASSWORD&#x3D;root \\-d mysql:5.7docker exec -it mysql &#x2F;bin&#x2F;bashmysql -uroot -prootuse mysql;alter user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;root&#39;;flush privileges; vi /mydata/mysql/conf/my.cnf 修改编码配置 1234567891011[client]default-character-set&#x3D;utf8[mysql]default-character-set&#x3D;utf8[mysqld]init_connect&#x3D;&#39;SET collation_connection &#x3D; utf8_unicode_ci&#39;init_connect&#x3D;&#39;SET NAMES utf8&#39;character-set-server&#x3D;utf8collation-server&#x3D;utf8_unicode_ciskip-character-set-client-handshakeskip-name-resolve docker restart mysql &amp;&amp; cat /etc/mysql/my.cnf &amp;&amp; docker update mysql –restart=always redis vi /mydata/redis/conf/redis.conf 配置appendonly yes持久化硬盘 12345docker run -p 6379:6379 --name redis -v &#x2F;mydata&#x2F;redis&#x2F;data:&#x2F;data \\-v &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf \\-d redis:3.2 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf --appendonly yesdocker exec -it redis redis-clidocker update redis --restart&#x3D;always maven 123456789101112131415161718&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt; &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt;&lt;&#x2F;mirror&gt; &lt;profile&gt; &lt;id&gt;jdk18&lt;&#x2F;id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt; &lt;jdk&gt;1.8&lt;&#x2F;jdk&gt; &lt;&#x2F;activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;&#x2F;maven.compiler.compilerVersion&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;profile&gt; idea安装lombok，mybatisX插件 vscode安装Auto Close Tag,Auto Rename Tag,Chinese,Eslint,HTML CSS Support,HTML Snippets,JavaScript(ES6),Live Server,open in browser,Vetur,Vue 2 Snippets插件 git配置 12345git config --global user.name &quot;username&quot; &#x2F;&#x2F;（名字） # 配置邮箱git config --global user.email &quot;username@email.com&quot; &#x2F;&#x2F;(注册账号时用的邮箱)ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; 进入git bash生成公私钥cat ~&#x2F;.ssh&#x2F;id_rsa.pubssh -T git@gitee.com 测试是否成功即可 Nacos注册中心新建Spring Initializr作为provider项目jdk1.8并导入Web中的Spring Web和Spring Cloud Routing的OpenFeign组件，设置-Xmx100m 启动Application使用最大内存 启动nacos-server-1.3.1.zip访问nacos 修改依赖如下 123456789101112131415161718192021222324252627282930313233343536373839&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;&#x2F;spring-cloud.version&gt; &lt;spring-cloud-alibaba.version&gt;2.1.0.RELEASE&lt;&#x2F;spring-cloud-alibaba.version&gt;&lt;&#x2F;properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt; 添加application.yml配置 123456789spring: application: name: provider cloud: nacos: discovery: server-addr: 127.0.0.1:8848server: port: 8000 ProviderApplication启动类添加@EnableDiscoveryClient,启动后在nacos控制台查看已经上线的服务 Nacos配置中心默认配置读取application.properties添加配置 12user.name&#x3D;onejaneuser.age&#x3D;20 Controller实现读取 123456789101112@RestController@RequestMapping(&quot;test&quot;)public class UserController &#123; @Value(&quot;$&#123;user.name&#125;&quot;) private String name; @Value(&quot;$&#123;user.age&#125;&quot;) private Integer age; @RequestMapping(&quot;&#x2F;user&quot;) public void test()&#123; System.out.println(name+&quot;:&quot;+age); &#125;&#125; Nacos配置项目添加config依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; Provider项目创建bootstrap.properties 12spring.application.name&#x3D;providerspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848 Nacos中配置provider.properties，默认规则，取public命名空间的应用名.properties，类型为Properties，相同与application.properties时优先使用配置中心的配置。 12user.name&#x3D;onejane1user.age&#x3D;23 多环境配置配置命名空间provider，命名空间ID为f7d49148-09a8-4ca1-8a40-c52e9cb627b5，在该命名空间下配置provider.properties，Group为prod 12user.name&#x3D;onejane2user.age&#x3D;23 配置bootstrap.properties 1234spring.application.name&#x3D;providerspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848spring.cloud.nacos.config.namespace&#x3D;f7d49148-09a8-4ca1-8a40-c52e9cb627b5spring.cloud.nacos.config.group&#x3D;prod 命名空间，用于配置隔离，默认新增的所有配置都在public空间。 1、开发，测试，生产：利用命名空间来做环境隔离。在bootstrap.properties；配置spring.cloud.nacos.config.namespace需要使用哪个命名空间下的配置 2、每一个微服务之间互相隔离配置，每一个微服务都创建自己的命名空间，只加载自己命名空间下的所有配置 每个微服务创建自己的命名空间，使用配置分组区分环境，dev，test，prod 多文件配置在Nacos中provider微服务命名空间配置datasource.yml 123456spring: datasource: username: root password: root url: jdbc:mysql:&#x2F;&#x2F;172.20.1.185:3306&#x2F;user driver-class-name: com.mysql.jdbc.Driver 配置mybatis.yml 12345mybatis-plus: mapper-locations: classpath:&#x2F;mapper&#x2F;**&#x2F;*.xml global-config: db-config: id-type: auto 配置service.yml 123456789spring: application: name: provider cloud: nacos: discovery: server-addr: 127.0.0.1:8848 server: port: 7000 注释application.yml中所有配置并在bootstrap.properties中实现多文件配置 1234567891011121314151617spring.application.name&#x3D;providerspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848spring.cloud.nacos.config.namespace&#x3D;f7d49148-09a8-4ca1-8a40-c52e9cb627b5spring.cloud.nacos.config.group&#x3D;prodspring.cloud.nacos.config.ext-config[0].data-id&#x3D;datasource.ymlspring.cloud.nacos.config.ext-config[0].group&#x3D;devspring.cloud.nacos.config.ext-config[0].refresh&#x3D;truespring.cloud.nacos.config.ext-config[1].data-id&#x3D;mybatis.ymlspring.cloud.nacos.config.ext-config[1].group&#x3D;devspring.cloud.nacos.config.ext-config[1].refresh&#x3D;truespring.cloud.nacos.config.ext-config[2].data-id&#x3D;other.ymlspring.cloud.nacos.config.ext-config[2].group&#x3D;devspring.cloud.nacos.config.ext-config[2].refresh&#x3D;true Mybatis-Plus持久化引入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;3.2.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.17&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;version&gt;1.18.8&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 配置数据源 123456789101112131415spring: datasource: username: root password: root url: jdbc:mysql:&#x2F;&#x2F;172.20.1.185:3306&#x2F;user driver-class-name: com.mysql.jdbc.Driver jackson: date-format: yyyy-MM-dd HH:mm:ss # 输出日期自动转换mybatis-plus: mapper-locations: classpath:&#x2F;mapper&#x2F;**&#x2F;*.xml global-config: db-config: id-type: auto logic-delete-value: 1 # 逻辑删除 logic-not-delete-value: 0 配置扫描包 1@MapperScan(&quot;com.onejane.demo.provider.dao&quot;) 添加实体类 123456789101112131415@Data@TableName(&quot;user_info&quot;)public class UserInfoEntity implements Serializable &#123; private static final long serialVersionUID &#x3D; 1L; @TableId private Long id; private String name; private Long age; &#x2F;** * 是否显示[0-不显示，1显示] 用于逻辑删除 *&#x2F; @TableLogic(value &#x3D; &quot;1&quot;,delval &#x3D; &quot;0&quot;) private Integer status;&#125; 逻辑删除实现 1234567@AutowiredUserInfoSerivce userInfoSerivce;@RequestMapping(&quot;&#x2F;delete&quot;)public R delete(Long[] ids)&#123; userInfoSerivce.removeByIds(Arrays.asList(ids)); return R.ok();&#125; 分页查询实现 1234567891011121314151617181920public interface UserInfoSerivce extends IService&lt;UserInfoEntity&gt; &#123; PageUtils queryPage(Map&lt;String, Object&gt; params);&#125;@Service(&quot;userInfoService&quot;)public class UserInfoServiceImpl extends ServiceImpl&lt;UserInfoDao, UserInfoEntity&gt; implements UserInfoSerivce &#123; @Override public PageUtils queryPage(Map&lt;String, Object&gt; params) &#123; IPage&lt;UserInfoEntity&gt; page &#x3D; this.page( new Query&lt;UserInfoEntity&gt;().getPage(params), new QueryWrapper&lt;UserInfoEntity&gt;() ); return new PageUtils(page); &#125;&#125;@RequestMapping(&quot;&#x2F;list&quot;)public R list(@RequestParam Map&lt;String, Object&gt; params)&#123; PageUtils page &#x3D; userInfoSerivce.queryPage(params); return R.ok().put(&quot;page&quot;, page);&#125; 分页配置 12345678910111213141516@Configuration@EnableTransactionManagement &#x2F;&#x2F;开启事务@MapperScan(&quot;com.onejane.demo.provider.dao&quot;)public class MyBatisConfig &#123; &#x2F;&#x2F;引入分页插件 @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor paginationInterceptor &#x3D; new PaginationInterceptor(); &#x2F;&#x2F; 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false paginationInterceptor.setOverflow(true); &#x2F;&#x2F; 设置最大单页限制数量，默认 500 条，-1 不受限制 paginationInterceptor.setLimit(1000); return paginationInterceptor; &#125;&#125; Feign远程调用新建Spring Initializr作为consumer项目jdk1.8并导入Web中的Spring Web和Spring Cloud Routing的OpenFeign组件，设置-Xmx100m 启动Application使用最大内存 provider提供api，启动类配置@EnableDiscoveryClient后启动应用 consumer中引入nacos依赖 123456789101112131415161718192021222324252627282930313233&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;&#x2F;spring-cloud.version&gt; &lt;spring-cloud-alibaba.version&gt;2.1.0.RELEASE&lt;&#x2F;spring-cloud-alibaba.version&gt;&lt;&#x2F;properties&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt; Member作为consumer获取feign调用，定义feign方法 1234567@FeignClient(&quot;provider&quot;)public interface ProviderFeignService &#123; @RequestMapping(&quot;&#x2F;test&#x2F;list&quot;) public void test();&#125; consumer在控制器中申请远程调用，并在启动类中开启feign调用@EnableFeignClients(basePackages = &quot;com.onejane.demo.consumer.feign&quot;)并将consumer加入nacos注册中心@EnableDiscoveryClient 12345@FeignClient(&quot;provider&quot;)public interface ProviderFeignService &#123; @RequestMapping(&quot;&#x2F;test&#x2F;user&quot;) public void test();&#125; 在application.yml中配置nacos 123456789spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 application: name: consumerserver: port: 7000 开启feign远程调用 12345678910@RestController@RequestMapping(&quot;test&quot;)public class UserInfoController &#123; @Autowired ProviderFeignService providerFeignService; @RequestMapping(&quot;&#x2F;user&quot;) public void test()&#123; providerFeignService.test(); &#125;&#125; Gateway网关修改provider项目新增server.servlet.context-path: /provider 新建Spring Initializr作为网关项目项目jdk1.8并导入Spring Cloud Routing的Gateway组件 pom依赖修改 12345678910&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;&#x2F;spring-cloud.version&gt;&lt;&#x2F;properties&gt; application.properties添加配置 123spring.cloud.nacos.discovery.server-addr&#x3D;127.0.0.1:8848spring.application.name&#x3D;gatewayserver.port&#x3D;88 在nacos中配置微服务命名空间gateway,ID为7601cb5a-a9dd-43d8-a1b9-a37952674df2，添加配置文件gateway.yml 123spring: application: name: gateway bootstrap.properties配置命名空间 123spring.application.name&#x3D;gatewayspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848spring.cloud.nacos.config.namespace&#x3D;7601cb5a-a9dd-43d8-a1b9-a37952674df2 application.yml中添加网关配置，访问http://localhost:88/?url=qq 则跳转到https://www.qq.com?url=qq， 访问http://localhost:88/?url=baidu 则跳转到https://www.baidu.com?url=baidu 123456789101112131415161718192021222324spring: cloud: gateway: routes: - id: test_route uri: https:&#x2F;&#x2F;www.baidu.com predicates: - Query&#x3D;url,baidu - id: qq_route uri: https:&#x2F;&#x2F;www.qq.com predicates: - Query&#x3D;url,qq - id: provider_route uri: lb:&#x2F;&#x2F;provider predicates: - Path&#x3D;&#x2F;api&#x2F;provider&#x2F;** filters: - RewritePath&#x3D;&#x2F;api&#x2F;(?&lt;segment&gt;.*),&#x2F;$\\&#123;segment&#125; application: name: gateway# http:&#x2F;&#x2F;localhost:88&#x2F;api&#x2F;provider&#x2F;test&#x2F;user &#x3D;&#x3D;&gt; http:&#x2F;&#x2F;localhost:8000&#x2F;provider&#x2F;test&#x2F;user 在启动类中配置@EnableDiscoveryClient，并过滤掉数据库配置@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) 跨域12345678910111213141516171819@Configurationpublic class GulimallCorsConfiguration &#123; @Bean public CorsWebFilter corsWebFilter()&#123; UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource(); CorsConfiguration corsConfiguration &#x3D; new CorsConfiguration(); &#x2F;&#x2F;1、配置跨域 corsConfiguration.addAllowedHeader(&quot;*&quot;); corsConfiguration.addAllowedMethod(&quot;*&quot;); corsConfiguration.addAllowedOrigin(&quot;*&quot;); corsConfiguration.setAllowCredentials(true); source.registerCorsConfiguration(&quot;&#x2F;**&quot;,corsConfiguration); return new CorsWebFilter(source); &#125;&#125; 阿里云oss引入阿里云oss依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alicloud-oss&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; application.yml配置阿里云AccessKey 12345678spring: cloud: alicloud: access-key: *** secret-key: *** oss: endpoint: oss-cn-beijing.aliyuncs.com bucket: onejane-opencv 上传图片一般先通过服务端签名后前端直传 JSR303通过自定义校验，分组校验及全局校验实现对Spring MVC入参的参数校验。 加入validation依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;&#x2F;groupId&gt; &lt;artifactId&gt;validation-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0.1.Final&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 加入校验注解 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;** * 品牌id *&#x2F;@NotNull(message &#x3D; &quot;修改必须指定品牌id&quot;,groups &#x3D; &#123;UpdateGroup.class&#125;)@Null(message &#x3D; &quot;新增不能指定id&quot;,groups &#x3D; &#123;AddGroup.class&#125;)@TableIdprivate Long brandId;&#x2F;** * 品牌名 *&#x2F;@NotBlank(message &#x3D; &quot;品牌名必须提交&quot;,groups &#x3D; &#123;AddGroup.class,UpdateGroup.class&#125;)private String name;&#x2F;** * 品牌logo地址 *&#x2F;@NotBlank(groups &#x3D; &#123;AddGroup.class&#125;)@URL(message &#x3D; &quot;logo必须是一个合法的url地址&quot;,groups&#x3D;&#123;AddGroup.class,UpdateGroup.class&#125;)private String logo;&#x2F;** * 介绍 *&#x2F;private String descript;&#x2F;** * 显示状态[0-不显示；1-显示] *&#x2F;@NotNull(groups &#x3D; &#123;AddGroup.class, UpdateStatusGroup.class&#125;)@ListValue(vals&#x3D;&#123;0,1&#125;,groups &#x3D; &#123;AddGroup.class, UpdateStatusGroup.class&#125;)private Integer showStatus;&#x2F;** * 检索首字母 *&#x2F;@NotEmpty(groups&#x3D;&#123;AddGroup.class&#125;)@Pattern(regexp&#x3D;&quot;^[a-zA-Z]$&quot;,message &#x3D; &quot;检索首字母必须是一个字母&quot;,groups&#x3D;&#123;AddGroup.class, UpdateGroup.class&#125;)private String firstLetter;&#x2F;** * 排序 *&#x2F;@NotNull(groups&#x3D;&#123;AddGroup.class&#125;)@Min(value &#x3D; 0,message &#x3D; &quot;排序必须大于等于0&quot;,groups&#x3D;&#123;AddGroup.class,UpdateGroup.class&#125;)private Integer sort; 建立分组校验类 123public interface AddGroup &#123;&#125;public interface UpdateGroup &#123;&#125;public interface UpdateStatusGroup &#123;&#125; 自定义异常注解 12345678910111213@Documented@Constraint(validatedBy &#x3D; &#123; ListValueConstraintValidator.class &#125;)@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)@Retention(RUNTIME)public @interface ListValue &#123; String message() default &quot;&#123;com.onejane.demo.provider.valid.ListValue.message&#125;&quot;; Class&lt;?&gt;[] groups() default &#123; &#125;; Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;; int[] vals() default &#123; &#125;;&#125; 自定义异常实现 12345678910111213141516171819202122232425262728public class ListValueConstraintValidator implements ConstraintValidator&lt;ListValue,Integer&gt; &#123; private Set&lt;Integer&gt; set &#x3D; new HashSet&lt;&gt;(); &#x2F;&#x2F;初始化方法 @Override public void initialize(ListValue constraintAnnotation) &#123; int[] vals &#x3D; constraintAnnotation.vals(); for (int val : vals) &#123; set.add(val); &#125; &#125; &#x2F;&#x2F;判断是否校验成功 &#x2F;** * * @param value 需要校验的值 * @param context * @return *&#x2F; @Override public boolean isValid(Integer value, ConstraintValidatorContext context) &#123; return set.contains(value); &#125;&#125; 控制器层加入字段校验配置 12345678910111213141516171819202122232425262728293031323334353637@RequestMapping(&quot;&#x2F;save&quot;)public R save(@Validated(&#123;AddGroup.class&#125;) @RequestBody BrandEntity brand&#x2F;*,BindingResult result*&#x2F;)&#123;&#x2F;&#x2F; if(result.hasErrors())&#123;&#x2F;&#x2F; Map&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F; &#x2F;&#x2F;1、获取校验的错误结果&#x2F;&#x2F; result.getFieldErrors().forEach((item)-&gt;&#123;&#x2F;&#x2F; &#x2F;&#x2F;FieldError 获取到错误提示&#x2F;&#x2F; String message &#x3D; item.getDefaultMessage();&#x2F;&#x2F; &#x2F;&#x2F;获取错误的属性的名字&#x2F;&#x2F; String field &#x3D; item.getField();&#x2F;&#x2F; map.put(field,message);&#x2F;&#x2F; &#125;);&#x2F;&#x2F;&#x2F;&#x2F; return R.error(400,&quot;提交的数据不合法&quot;).put(&quot;data&quot;,map);&#x2F;&#x2F; &#125;else &#123;&#x2F;&#x2F; 为避免每次请求都判断异常输出，通过ExceptionControllerAdvice实现全局异常控制 brandService.save(brand); return R.ok();&#125;&#x2F;** * 修改 *&#x2F;@RequestMapping(&quot;&#x2F;update&quot;)public R update(@Validated(UpdateGroup.class) @RequestBody BrandEntity brand)&#123; brandService.updateById(brand); return R.ok();&#125;&#x2F;** * 修改状态 *&#x2F;@RequestMapping(&quot;&#x2F;update&#x2F;status&quot;)public R updateStatus(@Validated(UpdateStatusGroup.class) @RequestBody BrandEntity brand)&#123; brandService.updateById(brand); return R.ok();&#125; 全局异常控制配置 123456789101112131415161718192021222324252627@Slf4j&#x2F;&#x2F;@ResponseBody&#x2F;&#x2F;@ControllerAdvice(basePackages &#x3D; &quot;com.onejane.demo.provider.controller&quot;)@RestControllerAdvice(basePackages &#x3D; &quot;com.onejane.demo.provider.controller&quot;)public class ExceptionControllerAdvice &#123; @ExceptionHandler(value&#x3D; MethodArgumentNotValidException.class) public R handleVaildException(MethodArgumentNotValidException e)&#123; log.error(&quot;数据校验出现问题&#123;&#125;，异常类型：&#123;&#125;&quot;,e.getMessage(),e.getClass()); BindingResult bindingResult &#x3D; e.getBindingResult(); Map&lt;String,String&gt; errorMap &#x3D; new HashMap&lt;&gt;(); bindingResult.getFieldErrors().forEach((fieldError)-&gt;&#123; errorMap.put(fieldError.getField(),fieldError.getDefaultMessage()); &#125;); return R.error(BizCodeEnume.VAILD_EXCEPTION.getCode(),BizCodeEnume.VAILD_EXCEPTION.getMsg()).put(&quot;data&quot;,errorMap); &#125; @ExceptionHandler(value &#x3D; Throwable.class) public R handleException(Throwable throwable)&#123; log.error(&quot;错误：&quot;,throwable); return R.error(BizCodeEnume.UNKNOW_EXCEPTION.getCode(),BizCodeEnume.UNKNOW_EXCEPTION.getMsg()); &#125;&#125;","categories":[{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"nacos","slug":"nacos","permalink":"http://onejane.github.io/tags/nacos/"},{"name":"feign","slug":"feign","permalink":"http://onejane.github.io/tags/feign/"},{"name":"gateway","slug":"gateway","permalink":"http://onejane.github.io/tags/gateway/"},{"name":"sentinel","slug":"sentinel","permalink":"http://onejane.github.io/tags/sentinel/"}]},{"title":"HttpURLConnection&OK3&Retrofit自吐通杀","slug":"HttpURLConnection&OK3&Retrofit自吐通杀","date":"2021-03-01T17:28:26.000Z","updated":"2021-03-14T06:36:19.311Z","comments":true,"path":"2021/03/02/HttpURLConnection&OK3&Retrofit自吐通杀/","link":"","permalink":"http://onejane.github.io/2021/03/02/HttpURLConnection&OK3&Retrofit%E8%87%AA%E5%90%90%E9%80%9A%E6%9D%80/","excerpt":"","text":"HttpURLConnectionadb install -r -t network-debug.apk 启动frida 12adb shell .&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64 内存漫游 123456pyenv local 3.8.0objection -g com.example.network explore -P ~&#x2F;.objection&#x2F;pluginsandroid hooking list classes 查看所有可hook的类android hooking search classes URLandroid hooking watch class java.net.URL 由于hookURL类遗漏构造函数需要手动hook $initandroid hooking watch class_method java.net.URL.$init --dump-args --dump-backtrace --dump-return hook构造函数并打印 点击HTTP图片获取按钮，实现自吐第一步，并拿到上层实现类HttpURLConnectionImpl 123android hooking search classes HttpURLConnectionImplandroid hooking watch class com.android.okhttp.internal.huc.HttpURLConnectionImpl hook类所有方法并打印方法android hooking watch class_method com.android.okhttp.internal.huc.HttpURLConnectionImpl.setRequestProperty --dump-args --dump-backtrace --dump-return hook类指定方法并打印出入参及调用栈 点击HTTP图片获取按钮，实现自吐第二步 plugin wallbreaker objectsearch com.android.okhttp.internal.huc.HttpURLConnectionImpl 存在多个实例说明每次点击生成新的对象且不释放 plugin wallbreaker objectdump –fullname 0x2972 打印其中一个对象在内存中的结构 android heap search instances com.android.okhttp.internal.huc.HttpURLConnectionImpl 获取内存中的实例地址 android heap execute 0x21e6 defaultUserAgent 手动调用defaultUserAgent 自吐frida -U -f com.cz.babySister -l hook_HttpUrlConnection.js --no-pause 12345678910111213141516171819202122232425262728function hook_HttpUrlConnection()&#123; Java.perform(function()&#123; &#x2F;&#x2F; java.net.URL.URL ($init) (得到URL) Java.use(&quot;java.net.URL&quot;).$init.overload(&#39;java.lang.String&#39;).implementation &#x3D; function (str)&#123; var result &#x3D; this.$init(str) console.log(&quot;result , str &#x3D;&gt; &quot;,result,str); return result; &#125; &#x2F;&#x2F;HttpURLConnection setRequestProperty 得到各种请求头、属性等，不能hook抽象类HttpURLConnection，只能hook抽象类的实现类HttpURLConnectionImpl Java.use(&quot;com.android.okhttp.internal.huc.HttpURLConnectionImpl&quot;).setRequestProperty.implementation &#x3D; function(str1,str2)&#123; var result &#x3D; this.setRequestProperty(str1,str2); console.log(&quot;.setRequestProperty result,str1,str2-&gt;&quot;,result,str1,str2); return result; &#125; Java.use(&quot;com.android.okhttp.internal.huc.HttpURLConnectionImpl&quot;).setRequestMethod.implementation &#x3D; function(str1)&#123; var result &#x3D; this.setRequestMethod(str1); console.log(&quot;.setRequestMethod result,str1,str2-&gt;&quot;,result,str1); return result; &#125; &#125;)&#125;setImmediate(hook_HttpUrlConnection) OkHttp3搭建抓包环境默认创建Okhttp框架帮我们默认所有配置，因此无法自定义添加用户拦截器。 as新建Ok3Demo项目，创建页面button布局 12345678910111213141516171819&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot; android:gravity&#x3D;&quot;center|center_horizontal|center_vertical&quot; tools:context&#x3D;&quot;.MainActivity&quot;&gt; &lt;Button android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:gravity&#x3D;&quot;center|center_horizontal|center_vertical&quot; android:id&#x3D;&quot;@+id&#x2F;mybtn&quot; android:text&#x3D;&quot;发送请求&quot; android:textSize&#x3D;&quot;45sp&quot;&gt; &lt;&#x2F;Button&gt;&lt;&#x2F;LinearLayout&gt; build.gradle引入ok3依赖 12&#x2F;&#x2F; 增加对Okhttp3的依赖implementation(&quot;com.squareup.okhttp3:okhttp:3.12.0&quot;) AndroidManifest.xml配置网络权限 12&lt;!-- 申请网络请求权限 --&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt; 创建异步请求线程，在RealCall.newRealCall()中，创建了一个新的RealCall对象，RealCall对象是Okhttp3.Call接口的一个实现，也是Okhttp3中Call的唯一实现。它表示一个等待执行的请求，它只能被执行一次，但实际上，到这一步，请求依然可以被取消。因此只有Hook 了execute()和enqueue(new Callback())才能真正保证每个从Okhttp出去的请求都能被Hook到 1234567891011121314151617181920212223242526272829303132public class example &#123; &#x2F;&#x2F; TAG即为日志打印时的标签 private static String TAG &#x3D; &quot;learnokhttp&quot;; &#x2F;&#x2F; 新建一个Okhttp客户端 OkHttpClient client &#x3D; new OkHttpClient(); void run(String url) throws IOException &#123; &#x2F;&#x2F; 构造request Request request &#x3D; new Request.Builder() .url(url) .build(); &#x2F;&#x2F; 发起异步请求 client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; call.cancel(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#x2F;&#x2F;打印输出 Log.d(TAG, response.body().string()); &#125; &#125; ); &#125;&#125; MainActivity中调用网络请求线程 12345678910111213141516171819202122232425262728public class MainActivity extends AppCompatActivity &#123; private static String TAG &#x3D; &quot;learnokhttp&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#x2F;&#x2F; 定位发送请求按钮 Button btn &#x3D; findViewById(R.id.mybtn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#x2F;&#x2F; 访问百度首页 String requestUrl &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;; example myexample &#x3D; new example(); try &#123; myexample.run(requestUrl); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 建造者(Builder)模式新建LoggingInterceptor类，实现Interceptor接口，这代表它是一个拦截器，接下来实现intercept方法，我们的拦截器会打印URL和请求headers 123456789101112131415class LoggingInterceptor implements Interceptor &#123; &#x2F;&#x2F; TAG即为日志打印时的标签 private static String TAG &#x3D; &quot;learnokhttp&quot;; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Request request &#x3D; chain.request(); Log.i(TAG, &quot;请求URL：&quot;+String.valueOf(request.url())+&quot;\\n&quot;); Log.i(TAG, &quot;请求headers：&quot;+&quot;\\n&quot;+String.valueOf(request.headers())+&quot;\\n&quot;); Response response &#x3D; chain.proceed(request); return response; &#125;&#125; 拦截器是Okhttp中重要的一个概念，Okhttp通过Interceptor来完成监控管理、重写和重试请求。Okhttp本身存在五大拦截器，每个网络请求，不管是GET还是PUT/POST或者其他，都必须经过这五大拦截器。拦截器可以对request做出一定修改，同时对返回的Response做出一定修改，因此Interceptor是一个绝佳的Hook点，可以同时打印输出请求和相应。 自定义配置所有参数 1234567&#x2F;&#x2F; 此为原先的clientOkHttpClient client &#x3D; new OkHttpClient();&#x2F;&#x2F; 基于原先的client创建新的clientOkHttpClient newClient &#x3D; client.newBuilder() .addNetworkInterceptor(new LoggingInterceptor()) .build(); 将example中代码转移到MainActivity中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MainActivity extends AppCompatActivity &#123; private static String TAG &#x3D; &quot;learnokhttp&quot;; public static final String requestUrl &#x3D; &quot;http:&#x2F;&#x2F;www.kuaidi100.com&#x2F;query?type&#x3D;yuantong&amp;postid&#x3D;11111111111&quot;; &#x2F;&#x2F; 全局只使用这一个拦截器 public static final OkHttpClient client &#x3D; new OkHttpClient.Builder() .addNetworkInterceptor(new LoggingInterceptor()) .build(); Request request &#x3D; new Request.Builder() .url(requestUrl) .build(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#x2F;&#x2F; 定位发送请求按钮 Button btn &#x3D; findViewById(R.id.mybtn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#x2F;&#x2F; 发起异步请求 client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; call.cancel(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#x2F;&#x2F;打印输出 Log.d(TAG, response.body().string()); &#125; &#125; ); &#125; &#125;); &#125;&#125; hookadb shell &amp;&amp; ./data/local/tmp/fs128arm64 启动frida pyenv local 3.8.0 切换python环境 objection -g com.onejane.ok3demo explore -P ~/.objection/plugins 加载所有插件，点击发送请求并开启内存漫游 12345plugin wallbreaker classsearch OkHttpClient 内存搜索OkHttpClient类plugin wallbreaker classdump --fullname okhttp3.OkHttpClient 打印该类结构plugin wallbreaker objectsearch okhttp3.OkHttpClient 获取该类的内存地址plugin wallbreaker objectdump --fullname 0x2592 打印内存中该地址的类结构plugin wallbreaker objectsearch okhttp3.OkHttpClient 内存中存在多个OkHttpClient,默认不回收对象实例 okhttp3Logging新增okhttp3Logging类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171public final class okhttp3Logging implements Interceptor &#123; private static final String TAG &#x3D; &quot;okhttpGET&quot;; private static final Charset UTF8 &#x3D; Charset.forName(&quot;UTF-8&quot;); @Override public Response intercept(Chain chain) throws IOException &#123; Request request &#x3D; chain.request(); RequestBody requestBody &#x3D; request.body(); boolean hasRequestBody &#x3D; requestBody !&#x3D; null; Connection connection &#x3D; chain.connection(); String requestStartMessage &#x3D; &quot;--&gt; &quot; + request.method() + &#39; &#39; + request.url(); Log.e(TAG, requestStartMessage); if (hasRequestBody) &#123; &#x2F;&#x2F; Request body headers are only present when installed as a network interceptor. Force &#x2F;&#x2F; them to be included (when available) so there values are known. if (requestBody.contentType() !&#x3D; null) &#123; Log.e(TAG, &quot;Content-Type: &quot; + requestBody.contentType()); &#125; if (requestBody.contentLength() !&#x3D; -1) &#123; Log.e(TAG, &quot;Content-Length: &quot; + requestBody.contentLength()); &#125; &#125; Headers headers &#x3D; request.headers(); for (int i &#x3D; 0, count &#x3D; headers.size(); i &lt; count; i++) &#123; String name &#x3D; headers.name(i); &#x2F;&#x2F; Skip headers from the request body as they are explicitly logged above. if (!&quot;Content-Type&quot;.equalsIgnoreCase(name) &amp;&amp; !&quot;Content-Length&quot;.equalsIgnoreCase(name)) &#123; Log.e(TAG, name + &quot;: &quot; + headers.value(i)); &#125; &#125; if (!hasRequestBody) &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method()); &#125; else if (bodyHasUnknownEncoding(request.headers())) &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (encoded body omitted)&quot;); &#125; else &#123; Buffer buffer &#x3D; new Buffer(); requestBody.writeTo(buffer); Charset charset &#x3D; UTF8; MediaType contentType &#x3D; requestBody.contentType(); if (contentType !&#x3D; null) &#123; charset &#x3D; contentType.charset(UTF8); &#125; Log.e(TAG, &quot;&quot;); if (isPlaintext(buffer)) &#123; Log.e(TAG, buffer.readString(charset)); Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (&quot; + requestBody.contentLength() + &quot;-byte body)&quot;); &#125; else &#123; Log.e(TAG, &quot;--&gt; END &quot; + request.method() + &quot; (binary &quot; + requestBody.contentLength() + &quot;-byte body omitted)&quot;); &#125; &#125; long startNs &#x3D; System.nanoTime(); Response response; try &#123; response &#x3D; chain.proceed(request); &#125; catch (Exception e) &#123; Log.e(TAG, &quot;&lt;-- HTTP FAILED: &quot; + e); throw e; &#125; long tookMs &#x3D; TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs); ResponseBody responseBody &#x3D; response.body(); long contentLength &#x3D; responseBody.contentLength(); String bodySize &#x3D; contentLength !&#x3D; -1 ? contentLength + &quot;-byte&quot; : &quot;unknown-length&quot;; Log.e(TAG, &quot;&lt;-- &quot; + response.code() + (response.message().isEmpty() ? &quot;&quot; : &#39; &#39; + response.message()) + &#39; &#39; + response.request().url() + &quot; (&quot; + tookMs + &quot;ms&quot; + (&quot;, &quot; + bodySize + &quot; body:&quot; + &quot;&quot;) + &#39;)&#39;); Headers myheaders &#x3D; response.headers(); for (int i &#x3D; 0, count &#x3D; myheaders.size(); i &lt; count; i++) &#123; Log.e(TAG, myheaders.name(i) + &quot;: &quot; + myheaders.value(i)); &#125; if (!HttpHeaders.hasBody(response)) &#123; Log.e(TAG, &quot;&lt;-- END HTTP&quot;); &#125; else if (bodyHasUnknownEncoding(response.headers())) &#123; Log.e(TAG, &quot;&lt;-- END HTTP (encoded body omitted)&quot;); &#125; else &#123; BufferedSource source &#x3D; responseBody.source(); source.request(Long.MAX_VALUE); &#x2F;&#x2F; Buffer the entire body. Buffer buffer &#x3D; source.buffer(); Long gzippedLength &#x3D; null; if (&quot;gzip&quot;.equalsIgnoreCase(myheaders.get(&quot;Content-Encoding&quot;))) &#123; gzippedLength &#x3D; buffer.size(); GzipSource gzippedResponseBody &#x3D; null; try &#123; gzippedResponseBody &#x3D; new GzipSource(buffer.clone()); buffer &#x3D; new Buffer(); buffer.writeAll(gzippedResponseBody); &#125; finally &#123; if (gzippedResponseBody !&#x3D; null) &#123; gzippedResponseBody.close(); &#125; &#125; &#125; Charset charset &#x3D; UTF8; MediaType contentType &#x3D; responseBody.contentType(); if (contentType !&#x3D; null) &#123; charset &#x3D; contentType.charset(UTF8); &#125; if (!isPlaintext(buffer)) &#123; Log.e(TAG, &quot;&quot;); Log.e(TAG, &quot;&lt;-- END HTTP (binary &quot; + buffer.size() + &quot;-byte body omitted)&quot;); return response; &#125; if (contentLength !&#x3D; 0) &#123; Log.e(TAG, &quot;&quot;); Log.e(TAG, buffer.clone().readString(charset)); &#125; if (gzippedLength !&#x3D; null) &#123; Log.e(TAG, &quot;&lt;-- END HTTP (&quot; + buffer.size() + &quot;-byte, &quot; + gzippedLength + &quot;-gzipped-byte body)&quot;); &#125; else &#123; Log.e(TAG, &quot;&lt;-- END HTTP (&quot; + buffer.size() + &quot;-byte body)&quot;); &#125; &#125; return response; &#125; &#x2F;** * Returns true if the body in question probably contains human readable text. Uses a small sample * of code points to detect unicode control characters commonly used in binary file signatures. *&#x2F; static boolean isPlaintext(Buffer buffer) &#123; try &#123; Buffer prefix &#x3D; new Buffer(); long byteCount &#x3D; buffer.size() &lt; 64 ? buffer.size() : 64; buffer.copyTo(prefix, 0, byteCount); for (int i &#x3D; 0; i &lt; 16; i++) &#123; if (prefix.exhausted()) &#123; break; &#125; int codePoint &#x3D; prefix.readUtf8CodePoint(); if (Character.isISOControl(codePoint) &amp;&amp; !Character.isWhitespace(codePoint)) &#123; return false; &#125; &#125; return true; &#125; catch (EOFException e) &#123; return false; &#x2F;&#x2F; Truncated UTF-8 sequence. &#125; &#125; private boolean bodyHasUnknownEncoding(Headers myheaders) &#123; String contentEncoding &#x3D; myheaders.get(&quot;Content-Encoding&quot;); return contentEncoding !&#x3D; null &amp;&amp; !contentEncoding.equalsIgnoreCase(&quot;identity&quot;) &amp;&amp; !contentEncoding.equalsIgnoreCase(&quot;gzip&quot;); &#125;&#125; 打包编译后取出dex改名为okhttp3logging.dex，push到/data/locol/tmp目录下 编写frida进行hook,frida -U -f com.onejane.ok3demo -l hookOkhttp3.js --no-pause并通过adb logcat 查看系统log 123456789101112131415161718function hook_okhttp3_logging() &#123; &#x2F;&#x2F; 1. frida Hook java层的代码必须包裹在Java.perform中，Java.perform会将Hook Java相关API准备就绪。 Java.perform(function () &#123; Java.openClassFile(&quot;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;okhttp3logging.dex&quot;).load(); &#x2F;&#x2F; 只修改了这一句，换句话说，只是使用不同的拦截器对象。 var MyInterceptor &#x3D; Java.use(&quot;com.onejane.ok3demo.okhttp3Logging&quot;); var MyInterceptorObj &#x3D; MyInterceptor.$new(); var Builder &#x3D; Java.use(&quot;okhttp3.OkHttpClient$Builder&quot;); console.log(Builder); Builder.build.implementation &#x3D; function () &#123; this.networkInterceptors().add(MyInterceptorObj); return this.build(); &#125;; console.log(&quot;hook_okhttp3...&quot;); &#125;);&#125; Retrofitgit clone https://github.com/peiniwan/Ganhuo.git 编译源码编译安装apk 修改build.gradle,buildscript.repositories和allprojects.repositories添加google() 1classpath &#39;com.android.tools.build:gradle:3.5.3&#39; frida -U -f ganhuo.ly.com.ganhuo -l hookOkhttp3.js --no-pause 调用hook_okhttp3_logging()通过adb logcat查看后台log git clone https://github.com/siyujie/OkHttpLogger-Frida.git 获取Frida 实现拦截okhttp的脚本，首先将 okhttpfind.dex 拷贝到 /data/local/tmp/ 目录下，执行命令启动frida -UF -l okhttp_poker.js -f ganhuo.ly.com.ganhuo --no-pause 可追加 -o [output filepath]保存到文件 原理： 由于所有使用的okhttp框架的App发出的请求都是通过RealCall.java发出的，那么我们可以hook此类拿到request和response, 也可以缓存下来每一个请求的call对象，进行再次请求，所以选择了此处进行hook。 find前新增check，根据特征类寻找是否使用了okhttp3库，如果没有特征类，则说明没有使用okhttp; 找到特征类，说明使用了okhttp的库，并打印出是否被混淆。 12345&#96;find()&#96; 要等完全启动并执行过网络请求后再进行调用,检查是否使用了Okhttp &amp; 是否可能被混淆 &amp; 寻找okhttp3关键类及函数 &#96;switchLoader(\\&quot;okhttp3.OkHttpClient\\&quot;)&#96; 参数：静态分析到的okhttpclient类名&#96;hold()&#96; 要等完全启动再进行调用,开启HOOK拦截&#96;history()&#96; 打印可重新发送的请求&#96;resend(index)&#96; 重新发送请求 baseUrl自吐 Hook RetrofitUtils 中的new Retrofit.Builder().baseUrl(baseurl)的baseUrl 12345objection -g ganhuo.ly.com.ganhuo exploreandroid hooking search classes retrofitandroid hooking list class_methods retrofit2.Retrofitandroid hooking list class_methods retrofit2.Retrofit$Builder 发现只有baseUrl()无参构造，可能在app启动时就执行了baseUrl(baseurl)objection -g ganhuo.ly.com.ganhuo explore --startup-command &quot;android hooking list class_methods retrofit2.Retrofit$Builder&quot; 没有反应 通过编写frida脚本实现hook有参构造baseUrl 12345678910111213141516function hookbaseurl()&#123; Java.perform(function()&#123; Java.use(&quot;retrofit2.Retrofit$Builder&quot;).baseUrl.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(str)&#123; var result &#x3D; this.baseUrl(str) console.log(&quot;result1,str&#x3D;&gt;&quot;,result,str) return result &#125; Java.use(&quot;retrofit2.Retrofit$Builder&quot;).baseUrl.overload(&#39;okhttp3.HttpUrl&#39;).implementation &#x3D; function(str)&#123; var result &#x3D; this.baseUrl(str) console.log(&quot;result2,str&#x3D;&gt;&quot;,result,str) return result &#125; &#125;)&#125;setImmediate(hookbaseurl)","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"okhttp3","slug":"okhttp3","permalink":"http://onejane.github.io/tags/okhttp3/"},{"name":"HttpURLConnection","slug":"HttpURLConnection","permalink":"http://onejane.github.io/tags/HttpURLConnection/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://onejane.github.io/tags/Retrofit/"}]},{"title":"强大的脚本","slug":"强大的脚本","date":"2021-02-22T07:48:20.000Z","updated":"2021-04-10T00:23:00.638Z","comments":true,"path":"2021/02/22/强大的脚本/","link":"","permalink":"http://onejane.github.io/2021/02/22/%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%84%9A%E6%9C%AC/","excerpt":"","text":"Python合并多dex1234567891011121314151617181920import os, sys# python3.7 merge_dex.py .&#x2F;file&#x2F; livedexif __name__ &#x3D;&#x3D; &quot;__main__&quot;: if len(sys.argv) &lt; 3 : print(&quot;start error&quot;) sys.exit() print(sys.argv[1], sys.argv[2]) path &#x3D; sys.argv[1] #文件夹目录files&#x3D; os.listdir(path) #得到文件夹下的所有文件名称s &#x3D; []for file in files: #遍历文件夹 if file.find(&quot;dex&quot;) &gt; 0: ## 查找dex 文件 sh &#x3D; &#39;jadx -j 1 -r -d &#39; + sys.argv[2] + &quot; &quot; + path + file print(sh) os.system(sh) 集合排列组合12345678910111213141516171819productType = [1, 2, 3]goodType = [4, 5]energyType = [6, 7]productGoodEnergyType = [[1,2,3],[4,5],[6, 7]]# 多个集合随机有序排列,同itertools.product(*productGoodEnergyType)for newValue in itertools.product(productType,goodType,energyType): print(newValue)# 按组合个数进行无序组合print(list(itertools.permutations(productType))) for productTypeIndex in range(1, len(productType) + 1): # 单个集合按指定个数随机有序排列 productTypeTter1 = itertools.combinations(productType, productTypeIndex) print(list(productTypeTter1)) # 单个集合按指定个数随机无序组合 productTypeTter2 = itertools.permutations(productType, productTypeIndex) print(list(productTypeTter2)) 多集合组合 拿到集合的组合 根据这些组合进行分组笛卡尔积 1234567891011121314151617181920212223242526272829def combine(big_dict): # Cn1+Cn2+...+Cnn # Cmn&#x3D;m!&#x2F;n!*(m-n)! keys &#x3D; list(big_dict.keys()) # 获取keyList combine_key_list &#x3D; [] # key值 排列组合 valueList &#x3D; [] # 将key替换为值 for i in range(1, len(keys) + 1): iter &#x3D; itertools.combinations(keys, i) # [(&#39;a&#39;,), (&#39;b&#39;,), (&#39;c&#39;,), (&#39;a&#39;, &#39;b&#39;), (&#39;a&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)] combine_key_list.extend(list(iter)) # key的所有组合 以list形式加入列表 for m in combine_key_list: # [[[1, 2, 3]], [[4, 5]], [[6, 7, 8, 9]], [[1, 2, 3], [4, 5]], [[1, 2, 3], [6, 7, 8, 9]], [[4, 5], [6, 7, 8, 9]], [[1, 2, 3], [4, 5], [6, 7, 8, 9]]] valueList.append([big_dict.get(n) for n in m if n in keys]) # key所有组合转value组合 以object形式加入列表 param_list &#x3D; [] for index, value in enumerate(valueList): # list转为索引序列 search_type_key &#x3D; list(combine_key_list[index]) # 根据当前值对应key for item in itertools.product(*value): # 集合中n个集合n组笛卡尔积 params &#x3D; dict(zip(search_type_key, list(item))) param_list.append(urlencode(params)) print(param_list)d &#x3D; &#123; &#39;a&#39;: [1,2,3], &#39;b&#39;: [4,5], &#39;c&#39;: [6,7,8,9],&#125;combine(d) 格式转换转str 1234t &#x3D; (1,2)l &#x3D; [3,4]print(&#39;,&#39;.join(map(str, t)) if isinstance(t,tuple) else t)print(&#39;,&#39;.join(map(str, l)) if isinstance(l,list) else l) 转dict 1print(dict(zip(productType,goodType))) 转list 12def flatten(li): return sum(([x] if not isinstance(x, list) else flatten(x) for x in li), []) 字典key替换 1param_dict[&#39;area&#39;] &#x3D; param_dict.pop(&#39;ownerProvince&#39;)+&#39;-&#39;+param_dict.pop(&#39;ownerCity&#39;) Mongo123456import pymongoclient &#x3D; pymongo.MongoClient(settings.get(&#39;MONGO_URI&#39;))[settings.get(&#39;MONGO_DB&#39;)]client[&#39;MUsedCar&#39;].create_index([(&quot;url&quot;, 1)], unique&#x3D;True)client[&#39;MUsedCar&#39;].insert(dict(&#123;&#39;url&#39;:used_car_url+urlencode(param_dict)&#125;))for doc in client[&#39;MUsedCarParams&#39;].find(): print(doc[&#39;params&#39;]) 爬虫url12param_dict &#x3D; dict(parse.parse_qsl(parse.unquote(doc[&#39;params&#39;]))) url解码并转为字典urlencode(param_dict) 字典转url编码 Javaidea生成注释文档File =&gt; setting =&gt; editor =&gt; File and Code Templates 12345&quot;&quot;&quot;@author: onejane@time: $&#123;DATE&#125; $&#123;TIME&#125;@desc:&quot;&quot;&quot; File =&gt; Setting=&gt; Editor=&gt; Live Templates 输入onejane代码提示直接回车即可 Tools-Generate JavaDoc 12zh_CN-tag ProjectDetails:a:&quot;项目详情:&quot; -tag update:a:&quot;项目更改:&quot; -tag CreateDate:a:&quot;创建时间:&quot; -encoding UTF-8 -charset UTF-8 Git多仓库12git remote set-url --add origin git@github.com:OneJane&#x2F;CrawlerBase.gitgit push origin --all 版本回退12git refloggit reset --hard 版本号 Mongo更新批量将字段更新成字符串 1234db.getCollection(&#39;alimama&#39;).find(&#123;&#125;).forEach(function(x)&#123; db.getCollection(&#39;alimama&#39;).updateOne( &#123;_id: x._id&#125;, &#123;$set:&#123;income_rate: String(x.income_rate)&#125;&#125;)&#125;) 批量新增字段 1db.getCollection(&#39;taobao&#39;).update(&#123;&#125;, &#123;$set: &#123;&#39;name&#39;:&quot;taobao&quot;&#125;&#125;, &#123;multi: true&#125;); 批量修改字段名 1db.getCollection(&#39;long_link&#39;).update(&#123;&#125;, &#123;&quot;$rename&quot;:&#123;&quot;long_link&quot;:&quot;orientPlanLinkUrl&quot;&#125;&#125;, false, true) 查询返回指定字段id 1db.getCollection(&#39;alimama&#39;).find(&#123;&#125;,&#123;_id:0,id:1&#125;) 按照url分组查询并倒序 1db.getCollection(&#39;conditions&#39;).aggregate([&#123;$group : &#123;_id : &quot;$url&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;,&#123; $sort : &#123; num_tutorial: -1 &#125; &#125;]) 模糊查询 1db.getCollection(&#39;conditions&#39;).find(&#123;&#39;url&#39;:&#123;&#39;$regex&#39;:&#39;https:*&#39;&#125;&#125;).count() 导出 sublime 中ctrl+h 进行 {“_id”:.:”(.)”}\\n 替换为 $1\\n 1mongoexport -h 172.20.0.186:27017 -d jddmoto -c mbrand -o mbrand.json --type json -f url Mysqllocate1SELECT GROUP_CONCAT(a.n_id), COUNT(a.&#96;n_id&#96;) FROM &#96;motor_business_essay&#96; a, &#96;motor_business_essay_ext&#96; b where locate(&#39;&quot;img&quot;:&quot;&quot;&#39;,a.c_short_vod_info) Linux删除大文件123df -hlsof | grep deleted 查询内存中持续删除的进程kill -9 id windows新增复制文件路径.regUTF-8-BOM编码 1234567891011121314151617181920Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\*\\shell\\copypath]@&#x3D;&quot;复制文件路径到剪贴板&quot;[HKEY_CLASSES_ROOT\\*\\shell\\copypath\\command]@&#x3D;&quot;cmd &#x2F;c echo %1 | clip&quot;[HKEY_CLASSES_ROOT\\*\\shell\\copypathwithquote]@&#x3D;&quot;复制文件路径到剪贴板(带引号)&quot;[HKEY_CLASSES_ROOT\\*\\shell\\copypathwithquote\\command]@&#x3D;&quot;cmd &#x2F;c echo \\&quot;%1\\&quot; | clip&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypath]@&#x3D;&quot;复制文件夹路径到剪贴板&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypath\\command]@&#x3D;&quot;cmd &#x2F;c echo %1 | clip&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypathwithquote]@&#x3D;&quot;复制文件夹路径到剪贴板(带引号)&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\copypathwithquote\\command]@&#x3D;&quot;cmd &#x2F;c echo \\&quot;%1\\&quot; | clip&quot;","categories":[{"name":"脚本","slug":"脚本","permalink":"http://onejane.github.io/categories/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"python","slug":"python","permalink":"http://onejane.github.io/tags/python/"}]},{"title":"加壳与脱壳之分类技术","slug":"加壳与脱壳之分类技术","date":"2021-02-21T09:16:27.000Z","updated":"2021-03-25T00:09:11.473Z","comments":true,"path":"2021/02/21/加壳与脱壳之分类技术/","link":"","permalink":"http://onejane.github.io/2021/02/21/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%88%86%E7%B1%BB%E6%8A%80%E6%9C%AF/","excerpt":"","text":"历代加壳技术分类动态加载是用到的时候再去加载，也叫懒加载，是dex加壳，插件化，热更新的基础，避免发布新版本需要用户全量更新app，快速迭代，提升用户体验。比如阿里的AndFix和HotFix，腾讯的tinker，美团的Robust等热修复框架的基础。动态加载的dex不具有生命周期特征，APP中的Activity，Service等组件无法正常工作，只能完成一般函数的调用。需要对ClassLoader进行修正，APP才能够正常运行，有反射替换和反射插入两种修正手段，这是加壳app必然要做的一步。 第一代壳:dex加密 Dex字符串加密 资源加密 对抗反编译 反调试 自定义 DexClass Loader 由于是dex整体保护，在内存中映射是整体连续的，通过定位起始地址将app完整脱下来 第二代壳:dex抽取与加固 对抗第一代壳常见的脱壳法 Dex method代码抽取到外部(通常企业版) Dex动态加载 So加密 首先dex整体保护，其次对关键函数进行抽取(dump内存区域中dex关键类为空)进行so加密，对抗第一代壳常用脱壳法(从关键hook点dump dex) 第三代壳:dex动态解密与混淆 Dex method代码动态解密 So代码膨胀混淆 对抗之前出现的所有脱壳法 对抗第二代壳的一个通用脱壳工具DexHunter(通过遍历dex所有类进行加载初始化，将内存中dex完整恢复),dex中method动态解密，指定函数只有被调用时才执行，dex在内存中始终不是完整的状态 第四代壳:vmp壳目前仍然是smali指令级别的vmp，未来将出现arm指令级别vmp 加壳技术分析dex加固 dex整体加固:文件加载（监控app访问文件的记录）和内存加载（对内存dex的解密直接动态加载） 函数抽取:在函数粒度完成代码的保护：dump下dex的关键函数体置空 VMP和Dex2C:JAVA函数 Native化。vmp-&gt;逆向分析解释器找到取址译码 dex整体加固dex整体加壳是基础防护，所有加壳的app必然都有，关键在于怎么区分函数抽取，vmp以及dex2c甚至多种技术混合的混合型壳。 文件加载:定位解密文件是关键 内存加载:加载时机和内存起始地址是关键 通用方案:dex打开和优化的流程以及产出的odex、dex2oat编译的流程和生成的oat文件等等 函数抽取获取到保护的dex后,函数体的内容是无效的,注意这里说的是无效,而不是无意义,有的app壳后函数依然是有意义的,但不是我们想要的。f5查看函数体全部为空，则表现为函数抽取。 VMP获取到保护的dex后,函数的属性由java属性变为 Native,典型的有数字的 onCreate函数 Native化JNI函数。vmp壳的核心就是dalvik虚拟机的解释器原理。 若所有vmp保护的函数都有自己的解释器则so必然很大，所以必然共享一个解释器，vmp化的函数注册地址一致或者函数逻辑相似。 MainActivity动态注册地址在d3dec3f1,TestActivity地址一致，说明vmp保护。 参考vmp加壳方案之ADVMP，vmp对每一种smali指令处理，保护了函数后函数属性发生改变，因为解释器一般是用JNI实现，java易被反编译，故没用java实现，基本由c实现，防止快速定位到解释器的取址译码和执行的流程会加ollvm混淆保护之类。 Dex2c获取到保护的dex后保护的函数属性有java变成native，dcc保护后所有java属性的函数变成jni函数，只能看到类名和参数。核心原理与编译原理相关，传统编译原理是编译器经过词法分析语法分析生成二进制代码，dex2c中生成结果是c、c++文件，经过ndk编译器最终编译为so,每一个函数基本编译成一个c/c++文件，ubuntu中编译最终生成一个so。 dex2c核心对指定java函数进行语义分析生成各个不同的c/c++代码编译为相应so，自然dex2c保护的函数逻辑不一致，自然注册地址不同。 MainActivity的地址在7ba61b17c0，TestActivity地址在7ba61ac604，说明dex2c保护。 dcc_out.apk在lib下编译生成了so文件中,jni函数静态注册都存放于so文件中，使用IDA v7打开libnc.so，搜索java就可以找到所有jni函数。 dcc_out编译于项目LoadDex,新增FirstActivity，SecondActivity MainActivity.java 12345678910111213141516171819202122static&#123; try &#123; System.loadLibrary(&quot;nc&quot;); &#125; catch (UnsatisfiedLinkError e) &#123; e.printStackTrace(); &#125;&#125;setContentView(R.layout.activity_main);Button mybutton01&#x3D;findViewById(R.id.button01);mybutton01.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; context.startActivity(new Intent(context,FirstActivity.class)); &#125;&#125;);Button mybutton02&#x3D;findViewById(R.id.button02);mybutton02.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; context.startActivity(new Intent(context,SecondActivity.class)); &#125;&#125;); AndroidManifest.xml 12&lt;activity android:name&#x3D;&quot;.FirstActivity&quot;&gt;&lt;&#x2F;activity&gt;&lt;activity android:name&#x3D;&quot;.SecondActivity&quot;&gt;&lt;&#x2F;activity&gt; activity_main.xml 12345678910111213141516171819202122232425&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot; android:id&#x3D;&quot;@+id&#x2F;LinearLayout1&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;button01&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center_horizontal&quot; android:text&#x3D;&quot;FirstActivity&quot; &#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;button02&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center_horizontal&quot; android:text&#x3D;&quot;SecondActivity&quot; &#x2F;&gt;&lt;&#x2F;LinearLayout&gt; dcc_ollvm.apk 在dex2c过程中加入了ollvm，在ida中打开so，jni找不到。 参考dex2c加壳方案之dcc 1234git clone https:&#x2F;&#x2F;github.com&#x2F;amimo&#x2F;dcc.gitpyenv local 3.8.5 &amp;&amp; cd dcc &amp;&amp; pip install -r requirements.txtvim filter.txt 添加.*onejane*. 编译函数名含有onejane的函数python dcc.py dcc.apk -o dcc_out.apk 加固app VMP和dex2c是高级防护 VMP:定位解释器是关键,找到映射关系便可恢复 dex2c:基础是编译原理,进行了等价语义转换,彻底还原难度巨大: 通用分类技术:关注JNI相关的ap调用是关键,也是分析VMP和dex2c保护的函数的逻辑的关键。 混合型壳多种加固技术混合使用,比如先将原有smal指令流使用VMP或dex2c保护,构建object数组传递给jni函数进行调用，然后再经过函数抽取进一步保护 区分apk保护技术 是否Native化 函数体无效 函数抽取类壳 否 是 vmp壳 是 native化 Dex2c壳 是 native化 so加固 基于init、 init_array以及JNI_Onload函数的加壳 基于自定义linker的加壳 IDA快捷键 空格键 反汇编窗口切换文本跟图形 ESC 退到上一个操作地址 F5 C伪代码 alt+t 搜索文本","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"fart","slug":"fart","permalink":"http://onejane.github.io/tags/fart/"},{"name":"vmp","slug":"vmp","permalink":"http://onejane.github.io/tags/vmp/"},{"name":"dex2c","slug":"dex2c","permalink":"http://onejane.github.io/tags/dex2c/"}]},{"title":"主动调用java及native层","slug":"主动调用java及native层","date":"2021-02-16T15:27:08.000Z","updated":"2021-04-19T13:16:02.747Z","comments":true,"path":"2021/02/16/主动调用java及native层/","link":"","permalink":"http://onejane.github.io/2021/02/16/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8java%E5%8F%8Anative%E5%B1%82/","excerpt":"","text":"examplefrida-server-linuxfrida-python修改examples中rpc.py 12345678910111213141516171819# -*- coding: utf-8 -*-from __future__ import print_functionimport fridaimport timesession &#x3D; frida.attach(&quot;mousepad&quot;)script &#x3D; session.create_script(&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; hello: function () &#123; return &#39;Hello&#39;; &#125;, failPlease: function () &#123; return &#39;oops&#39;; &#125;&#125;;&quot;&quot;&quot;)script.load()api &#x3D; script.exportsprint(&quot;api.hello() &#x3D;&gt;&quot;, api.hello())print(&quot;api.fail_please() &#x3D;&gt;&quot;,api.fail_please()) 7z x frida-server-14.2.12-linux-x86_64.xz &amp;&amp; chmod 777 frida-server-14.2.12-linux-x86_64 &amp;&amp; ./frida-server-14.2.12-linux-x86_64 启动linux的frida server 通过netstat -tuulp可以查询被frida-server listen的27042端口 echo 123&gt;1.txt &amp;&amp; mousepad 1.txt 记事本打开1.txt,ps aux|grep -i mousepad查看该进程 python rpc.py 查看rpc attach mousepad引用打印结果 python-binding里连接frida-server的非标准端口: ./fs1428arm64 -l 0.0.0.0:6666import fridadevice = frida.get_device_manager().add_remote_device(‘192.168.1.101:6666’)print(device.name,devie.type,device.id) frida-python修改examples中bytecode.py 1234567891011121314system_session &#x3D; frida.attach(0)bytecode &#x3D; system_session.compile_script(name&#x3D;&quot;bytecode-example&quot;, source&#x3D;&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; listThreads: function () &#123; return Process.enumerateThreadsSync(); &#125;&#125;;&quot;&quot;&quot;)session &#x3D; frida.attach(&quot;mousepad&quot;)script &#x3D; session.create_script_from_bytes(bytecode)script.load()api &#x3D; script.exportsprint(&quot;api.list_threads() &#x3D;&gt;&quot;, api.list_threads()) python bytecode.py 查看rpc 编译生成的thread列表 frida-server-androidfrida-python修改examples中rpc.py 1234567891011121314151617181920device &#x3D; frida.get_usb_device()#device &#x3D; frida.get_device_manager.add_remote_device(&quot;192.168.0.2:8888&quot;) # 基于远程ip的集群pid &#x3D; device.spawn([&quot;com.android.settings&quot;])device.resume(pid)time.sleep(1)session &#x3D; device.attach(pid)script &#x3D; session.create_script(&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; hello: function () &#123; return &#39;Hello&#39;; &#125;, failPlease: function () &#123; return &#39;oops&#39;; &#125;&#125;;&quot;&quot;&quot;)script.load()api &#x3D; script.exportsprint(&quot;api.hello() &#x3D;&gt;&quot;, api.hello())print(&quot;api.fail_please() &#x3D;&gt;&quot;,api.fail_please()) ./fs1428arm64 pyenv local 3.8.5 &amp;&amp; python rpc.py 自启动进程查看rpc attach pid引用打印结果 frida-python修改examples中detached.py 1234567891011121314151617181920def on_detached(): print(&quot;on_detached&quot;)def on_detached_with_reason(reason): print(&quot;on_detached_with_reason:&quot;, reason)def on_detached_with_varargs(*args): print(&quot;on_detached_with_varargs:&quot;, args)device &#x3D; frida.get_usb_device()#device &#x3D; frida.get_device_manager.add_remote_device(&quot;192.168.0.2:8888&quot;) # 基于远程ip的集群pid &#x3D; device.spawn([&quot;com.android.settings&quot;])device.resume(pid)time.sleep(1)session &#x3D; device.attach(pid)print(&quot;attached&quot;)session.on(&#39;detached&#39;, on_detached)session.on(&#39;detached&#39;, on_detached_with_reason)session.on(&#39;detached&#39;, on_detached_with_varargs)sys.stdin.read() ./fs1428arm64 pyenv local 3.8.5 &amp;&amp; python detached.py 自启动进程detach进程后捕获进程退出打印log frida-python修改examples中crash_reporting.py 123456789101112131415def on_process_crashed(crash): print(&quot;on_process_crashed&quot;) print(&quot;\\tcrash:&quot;, crash)def on_detached(reason, crash): print(&quot;on_detached()&quot;) print(&quot;\\treason:&quot;, reason) print(&quot;\\tcrash:&quot;, crash)device &#x3D; frida.get_usb_device()device.on(&#39;process-crashed&#39;, on_process_crashed)session &#x3D; device.attach(&quot;com.android.settings&quot;)session.on(&#39;detached&#39;, on_detached)print(&quot;[*] Ready&quot;)sys.stdin.read() ./fs1428arm64 pyenv local 3.8.5 &amp;&amp; python crash_reporting.py 进程运行中detach进程后捕获进程退出打印log 当需要hook一个app的子进程时，调用child_gating.py在子进程创建时创建脚本打印内容。 argv = [“/bin/sh”, “-c”, “cat /etc/hosts”] # 在bullhead中/system/bin/sh frida-python修改examples中bytecode.py 1234567891011121314151617181920device &#x3D; frida.get_usb_device()#device &#x3D; frida.get_device_manager.add_remote_device(&quot;192.168.0.2:8888&quot;) # 基于远程ip的集群pid &#x3D; device.spawn([&quot;com.hd.zhibo&quot;])device.resume(pid)time.sleep(1)system_session &#x3D; device.attach(0)bytecode &#x3D; system_session.compile_script(name&#x3D;&quot;bytecode-example&quot;, source&#x3D;&quot;&quot;&quot;\\rpc.exports &#x3D; &#123; listThreads: function () &#123; return Process.enumerateThreadsSync(); &#125;&#125;;&quot;&quot;&quot;)session &#x3D; device.attach(pid)script &#x3D; session.create_script_from_bytes(bytecode)script.load()api &#x3D; script.exportsprint(&quot;api.list_threads() &#x3D;&gt;&quot;, api.list_threads()) python bytecode.py 查看rpc 编译生成的thread列表 DEXDump:js暴露3个export api(memorydump,switchmode,scandex)，在py层调用三个api进行交互 Zentracer:使用替换js中字符串(MATCHREGEX,BLACKREGEX)将黑白名单传输给js文件，将js文件直接加载通过send将信息传输给py端 java层主动调用pyenv 升级123456789pyenv versionsgit clone https:&#x2F;&#x2F;github.com&#x2F;pyenv&#x2F;pyenv-update.git $(pyenv root)&#x2F;plugins&#x2F;pyenv-updatepyenv updatepyenv install 3.8.6pip install objection 安装最新版objection和fridafrida -UF Frida 查看版本Frida.heapSizeScript 查看运行环境使用的是QJS 项目 demoso1pyenv 3.8.0 123456objection -g com.example.demoso1 exploreandroid hooking search classes com.example.demoso1 打印包名下所有的类android hooking list class_methods com.example.demoso1.MainActivity 打印类下所有方法android hooking watch class com.example.demoso1.MainActivityandroid hooking watch class_method com.example.demoso1.MainActivity.method02 --dump-args --dump-backtrace --dump-return objection -N -h 192.168.0.105 -p 8888 -g com.example.demoso1 explore method01在native层的静态方法，method02是native层的动态方法 12345678910111213141516171819202122232425262728293031323334var MainActivityHandle &#x3D; null; &#x2F;&#x2F; 实例调用的性能优化(将instance缓存起来反复调用)Java.perform(function()&#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) Java.choose(&quot;com.example.demoso1.MainActivity&quot;,&#123; onMatch:function(instance)&#123; MainActivityHandle &#x3D; instance; &#125;,onComplete()&#123;&#125; &#125;) console.log(&quot;MainActivityHandle is &#x3D;&gt; &quot;,MainActivityHandle)&#125;) function fridamethod01(plaintext)&#123; var result; Java.perform(function()&#123; var MainActivity &#x3D; Java.use(&quot;com.example.demoso1.MainActivity&quot;); var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) result &#x3D; MainActivity.method01(javaString.$new(plaintext)) &#125;) return result;&#125;function fridamethod02(ciphertext)&#123; var result; Java.perform(function()&#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) &#x2F;&#x2F; Java.choose(&quot;com.example.demoso1.MainActivity&quot;,&#123; &#x2F;&#x2F; onMatch:function(instance)&#123; &#x2F;&#x2F; MainActivityHandle &#x3D; instance.method02(javaString.$new(ciphertext)); &#x2F;&#x2F; &#125;,onComplete()&#123;&#125; &#x2F;&#x2F; &#125;) result &#x3D; MainActivityHandle.method02(javaString.$new(ciphertext)) &#125;) return result;&#125; hook主机中 ./fs128arm64 -l 0.0.0.0:8888frida -H 192.168.0.105:8888 -F -l hookandinvoke.js 手机ipobjection -N -h 192.168.0.105 -p 8888 -g com.example.demoso1 explore 远程objection连接 123456HTTP 每次都是新连接 速度慢RPC 是 TCP流，速度快rpc.exports&#x3D;&#123; fridamethod01:fridamethod01, fridamethod02:fridamethod02,&#125; rpc调用curl -s -X POST “http://127.0.0.1:5000/encrypt&quot; -H “Content-Type: application/json” -d ‘{“data”: “roysue”}’ curl -s -X POST “http://127.0.0.1:5000/decrypt&quot; -H “Content-Type: application/json” -d ‘{“data”: “47fcda3822cd10a8e2f667fa49da783f”}’ 123456789101112131415device &#x3D; frida.get_device_manager().add_remote_device(&quot;192.168.0.105:8888&quot;)# 启动&#96;demo01&#96;这个apppid &#x3D; device.spawn([&quot;com.example.demoso1&quot;])device.resume(pid)time.sleep(1)session &#x3D; device.attach(pid)# 加载脚本with open(&quot;hookandinvoke.js&quot;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot; , my_message_handler) #调用错误处理script.load()print(script.exports.fridamethod01(&quot;roysue&quot;))print(script.exports.fridamethod02(&quot;47fcda3822cd10a8e2f667fa49da783f&quot;)) python hookandinvoke.py 压测http并发性能https://github.com/JoeDog/siege 压测 apt install siege https://www.jianshu.com/p/74c465ff136f 1siege -c5 -r10 \"http://127.0.0.1:5000/encrypt POST &lt;./iloveroysue.json \" nps 内网穿透客户端：linux_arm64_client.tar.gz 因为n5x是kali nethunter系统，chmod 777 * &amp;&amp; ./npc，启动npc 服务端：https://ehang-io.github.io/nps/#/run 添加隧道，端口映射 add_remote_device 修改远程地址，将手机ip和kali主机ip暴露公网调用，通过siege压测 device = frida.get_device_manager().add_remote_device(“192.168.0.105:8888”) 手机ip linux_arm64_client.tar.gz device = frida.get_device_manager().add_remote_device(“118.126.66.193:58888”) npc和frida都在手机上，新增客户端，启动npc，手机ip公网映射添加隧道58888目标8888 siege -c5 -r10 “http://127.0.0.1:5000/encrypt POST &lt;./iloveroysue.json “ 启动py脚本 linux_amd64_client.tar.gz device = frida.get_device_manager().add_remote_device(“118.126.66.193:48888”) npc在kali上，新增客户端，启动npc，配置隧道服务端口55000目标5000端口，手机ip公网映射48888目标192.168.0.105:8888 siege -c5 -r10 “http://118.126.66.193:55000/encrypt POST &lt;./iloveroysue.json “ 启动py脚本 Native层主动调用demoso1基于https://www.jianshu.com/p/0390f598c34c 12objection -g com.example.demoso1 explorememory list exports libnative-lib.so 查看导出函数，静态函数直接搜索 _Z8method01P7_JNIEnvP7_jclassP8_jstring 通过搜索http://demangler.com/ 拿到原函数名 或者通过https://github.com/lasting-yang/frida_hook_libart.git frida -U -f com.example.demoso1 -l hook_RegisterNatives.js –no-pause 查看原始方法名 修改hook_RegisterNatives，添加hookMethod01和invokemethod02 123456789101112131415161718192021222324252627282930313233343536373839在hook_RegisterNatives方法中添加 if(name.indexOf(&quot;method01&quot;)&gt;&#x3D;0)&#123; &#x2F;&#x2F;hookmethod(fnPtr_ptr); &#x2F;&#x2F;replacehook(fnPtr_ptr); method01addr &#x3D; fnPtr_ptr; &#125;else if (name.indexOf(&quot;method02&quot;)&gt;&#x3D;0)&#123; method02addr &#x3D; fnPtr_ptr; method02 &#x3D; new NativeFunction(method02addr,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;pointer&#39;,&#39;pointer&#39;]); &#125;else&#123; continue; &#125;新增invokemethod01function invokemethod01(contents)&#123; console.log(&quot;ENV&#x3D;&gt;&quot;,ENV) console.log(&quot;JCLZ&#x3D;&gt;&quot;,JCLZ); console.log(&quot;method01_addr is &#x3D;&gt;&quot;,method01addr) var method01 &#x3D; new NativeFunction(method01addr,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;pointer&#39;,&#39;pointer&#39;]); var NewStringUTF &#x3D; new NativeFunction(addrNewStringUTF,&#39;pointer&#39;,[&#39;pointer&#39;,&#39;pointer&#39;]) var result &#x3D; null; Java.perform(function()&#123; console.log(&quot;Java.vm.getEnv()&quot;,Java.vm.getEnv()) var JSTRING &#x3D; NewStringUTF(Java.vm.getEnv(),Memory.allocUtf8String(contents)) result &#x3D; method01(Java.vm.getEnv(),JSTRING,JSTRING); console.log(&quot;result is &#x3D;&gt;&quot;,result) console.log(&quot;result is &quot;,Java.vm.getEnv().getStringUtfChars(result, null).readCString()) result &#x3D; Java.vm.getEnv().getStringUtfChars(result, null).readCString(); &#125;) return result;&#125;新增invokemethod02function invokemethod02(contents)&#123; var result &#x3D; null; Java.perform(function()&#123; var JSTRING &#x3D; NewStringUTF(Java.vm.getEnv(),Memory.allocUtf8String(contents)) result &#x3D; method02(Java.vm.getEnv(),JSTRING,JSTRING); result &#x3D; Java.vm.getEnv().getStringUtfChars(result, null).readCString(); &#125;) return result;&#125; jni 获取类(jclass)的方式 1.需要new 一个对象时需要jclass.2.需要调用这个对象的方法或者属性时需要jclass.3.jclass 不需要释放. 12345获取对象类jclass GetObjectClass_(JNIEnv* jni, jobject object) &#123; jclass c = jni-&gt;GetObjectClass(object); return c;&#125; 12直接找到类名jclass long_cls &#x3D; env-&gt;FindClass(&quot;java&#x2F;lang&#x2F;Long&quot;); rpc1234rpc.exports &#x3D; &#123; invoke1:invokemethod01, &#x2F;&#x2F; 导出名不可以有大写字母或者下划线 invoke2:invokemethod02&#125;; init.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import timeimport fridafrom flask import Flask, jsonify, requestimport jsondef my_message_handler(message , payload): #定义错误处理 print(message) print(payload)# 连接安卓机上的frida-server#device &#x3D; frida.get_device_manager().add_remote_device(&quot;192.168.0.3:8888&quot;)#device &#x3D; frida.get_device_manager().add_remote_device(&quot;118.126.66.193:58888&quot;)device &#x3D; frida.get_device_manager().add_remote_device(&quot;192.168.0.105:8888&quot;)#device &#x3D; frida.get_usb_device()# 启动&#96;demo01&#96;这个apppid &#x3D; device.spawn([&quot;com.example.demoso1&quot;])session &#x3D; device.attach(pid)# 加载脚本with open(&quot;hook_RegisterNatives.js&quot;) as f: script &#x3D; session.create_script(f.read())script.on(&quot;message&quot; , my_message_handler) #调用错误处理script.load()time.sleep(3)device.resume(pid)time.sleep(3)print(script.exports.invoke1(&quot;onejane&quot;))print(script.exports.invoke2(&quot;c6138f96658ce0cb845bdab0f9616273&quot;))# 脚本会持续运行等待输入#input()app &#x3D; Flask(__name__)@app.route(&#39;&#x2F;encrypt&#39;, methods&#x3D;[&#39;POST&#39;])#url加密def encrypt_class(): data &#x3D; request.get_data() json_data &#x3D; json.loads(data.decode(&quot;utf-8&quot;)) postdata &#x3D; json_data.get(&quot;data&quot;) #print(postdata) res &#x3D; script.exports.invoke1(postdata) return res @app.route(&#39;&#x2F;decrypt&#39;, methods&#x3D;[&#39;POST&#39;])#data解密def decrypt_class(): data &#x3D; request.get_data() json_data &#x3D; json.loads(data.decode(&quot;utf-8&quot;)) postdata &#x3D; json_data.get(&quot;data&quot;) res &#x3D; script.exports.invoke2(postdata) return res if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.run() 端口usb连接，主机连接adb, ./fs128arm64 -l 0.0.0.0:8888 启动frida server 脱离apk7z x demoso1/app/build/outputs/apk/debug/app-debug.apk cp lib/arm64-v8a/libnative-lib.so 到 /data/app/libnative-lib.so 并赋予最高权限 adb push libnative-lib.so /data/app 12345678910frida -U -f com.android.settings -l hook_RegisterNatives.js --no-pauseobjection -g com.android.settings explore memory list modules 可以看到libnative-lib.so已经被加载memory list exports libnative-lib.so 找到两个函数名_Z8method01P7_JNIEnvP7_jclassP8_jstring，_Z8method02P7_JNIEnvP8_jobjectP8_jstringvar modulelibnative &#x3D; Module.load(&quot;&#x2F;data&#x2F;app&#x2F;libnative-lib.so&quot;) &#x2F;&#x2F; 加载somethod01addr &#x3D; modulelibnative.findExportByName(&quot;_Z8method01P7_JNIEnvP7_jclassP8_jstring&quot;)method02addr &#x3D; modulelibnative.findExportByName(&quot;_Z8method02P7_JNIEnvP8_jobjectP8_jstring&quot;)修改init.py中pid &#x3D; device.spawn([&quot;com.android.settings&quot;]) RPC（TCP） 远快于 HTTP,手机暴露frida-server，它是一个TCP，效率很高 IDA从入门到理解 某加固系统运行信息获取frida 脚本 unidbg学习笔记 浅谈渗透江湖之细水柔情 领悟Frida的精髓_0512newCodeAndProject.zip","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"rpc","slug":"rpc","permalink":"http://onejane.github.io/tags/rpc/"}]},{"title":"基于内存漫游定位分析","slug":"基于内存漫游定位分析","date":"2021-02-12T13:54:40.000Z","updated":"2021-03-01T17:12:15.236Z","comments":true,"path":"2021/02/12/基于内存漫游定位分析/","link":"","permalink":"http://onejane.github.io/2021/02/12/%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E6%BC%AB%E6%B8%B8%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90/","excerpt":"","text":"三板斧： 先hook、看参数和返回值，利用命令行定位 再利用命令行/写代码构造参数、主动调用 最后规模化利用PYTHON配RPC导出结果 基于内存漫游定位案例一adb install -r -t movetv.apk 移动tv onejane/123456,-r强制升级，-t允许装debug版本 jadx打开发现com.tecent.StubShell加壳，找不到MainActivity 123456pyenv local 3.8.0adb shell.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fs128arm64objection -g com.cz.babySister exploreandroid hooking search classes com.wrapper.proxyapplicationandroid hooking watch class com.wrapper.proxyapplication.WrapperProxyApplication 该类在启动则被调用，attach将无法hook Frida附加app的两种模式： SPAWN：创建进程时就hook，有壳的话就不行 ATTACH：应用运行过程中hook，有壳也是ok 分析123android hooking list activitiesandroid intent launch_activity com.cz.babySister.activity.LoginActivity 指定启动Activityps -ef|grep baby 进程一直自动启动 objection -d -g com.cz.babySister explore --startup-command &quot;android hooking watch class com.wrapper.proxyapplication.WrapperProxyApplication&quot; 开启debug -d 由于该app会自动后台启动 需要在前台启动时立即使用objection漫游 批量hookandroid hooking search classes com.wrapper.proxyapplication 枚举包中所有类 12345com.wrapper.proxyapplication.CustomerClassLoadercom.wrapper.proxyapplication.MultiDexcom.wrapper.proxyapplication.MultiDex$V19com.wrapper.proxyapplication.Utilcom.wrapper.proxyapplication.WrapperProxyApplication 如何使用objection去批量hook和trace？ 把~/.objection/objection.log删掉； 到objection界面中运行android hooking list classes，列出所有的类； 对新生成的~/.objection/objection.log文件进行过滤，比如只关心http相关的。cat objection.log|grep -i http 将输出结果保存到一个excel列中，前面补全android hooking watch class xxxxx，另存为文本文件 加载这个文件：objection -g com.android.settings explore -c “2.txt” ，这样一下子就hook上了几千个相关类的所有方法及其所有重载。 如果trace感兴趣的方法也是同理，android hooking search methods * ，会打印出所有的方法。 vim hooklist.txt 12345android hooking watch class com.wrapper.proxyapplication.CustomerClassLoaderandroid hooking watch class com.wrapper.proxyapplication.MultiDexandroid hooking watch class com.wrapper.proxyapplication.MultiDex$V19android hooking watch class com.wrapper.proxyapplication.Utilandroid hooking watch class com.wrapper.proxyapplication.WrapperProxyApplication objection -g com.cz.babySister explore -c “hooklist.txt” 批量hook android hooking list class_methods com.wrapper.proxyapplication.Util 枚举类中所有方法 Zentraceradb shell &amp;&amp; top 根据负载查看包名 java.net.HttpUrlConnection 1234objection -g com.cz.babySister explore --startup-command &quot;android hooking watch class java.net.HttpURLConnection&quot;jobs listjobs kill idandroid hooking watch class_method java.net.HttpURLConnection.getFollowRedirects --dump-args 登录发现堆栈来自于com.cz.babySister.c.a.a 通过jadx搜索com.cz.babySister.c.a.a所在类，通过android hooking watch class com.cz.babySister.c.a进行trace类 通过android hooking watch class_method com.cz.babySister.c.a.a --dump-args --dump-backtrace --dump-return 进行trace方法 什么叫trace？hook多了就成了trace 系统框架是不可能被混淆的，基于枚举的内存漫游定位思路的含义是：怀疑你使用了什么框架API、怀疑你经过了哪个包哪处地方、就去那里埋伏起来，等待经过。 针对混淆后的okhttp3,通过Frida实现的拦截okhttp脚本 ./data/local/tmp/fs1428arm64 cd ZenTracer &amp;&amp; proxychains pip install PyQt5 &amp;&amp; python ZenTracer.py 报错：Could not load the Qt platform plugin “xcb” in “” even though it was found 1export QT_DEBUG_PLUGINS&#x3D;1 python ZenTracer.py ldd libqxcb.so 查看具体哪个so文件为not found apt install libxcb-util1 libxcb-xinerama0 Action-Match RegEx Action-Start 启动trace,登录trace保存为json thunar . 打开当前目录 查看babySister查看json 极端情况：Match RegEx 填写com.cz.babySister主包名，trace所有的方法 1234objection -g com.cz.babySister exploreandroid hooking search classes com.cz.babySistercat ~&#x2F;.objection&#x2F;objection.log|grep com.cz.babySister 拿到所有的类 在前面添加命令 android hooking watch class保存到classes.txt中objection -g com.cz.babySister explore -c classes.txt 实现批量hook 案例二adb install xes.apk 123456objection -g com.xes.jazhanghui.activity explore -P ~&#x2F;.objection&#x2F;plugins 启动objection加载所有插件android hooking search classes okhttp3android hooking list class_methods okhttp3.OkHttpClientandroid heap search instances okhttp3.OkHttpClient 找到对象实例plugin wallbreaker objectsearch okhttp3.OkHttpClient 拿到ok3对象的地址，如混淆在jadx中找到ok3的类注释中的renameplugin wallbreaker objectdump --fullname 0x37d2 分析adb push okhttplogging.dex /data/local/tmp adb push myok2curl.dex /data/local/tmp cd ~/Desktop/frida-agent-example &amp;&amp; npm run watch frida -UF -l hookOkhttp3.js 通过adb logcat | grep “okhttpGet”查看log 原生：离解释器更近：安卓原生就是dex被libart.so来解释、linux原生就是CPU直接解释的机器码 123ps -e |grep -i chromeobjection -g com.android.chrome explorememory list modules 发现dex被libart.so加载解析执行 脱壳frida_fart 12cd frida_fart &amp;&amp; adb push lib&#x2F;* &#x2F;data&#x2F;local&#x2F;tmpcd &#x2F;data&#x2F;local&#x2F;tmp&#x2F; &amp;&amp; cp fart* &#x2F;data&#x2F;app &amp;&amp; cd &#x2F;data&#x2F;app &amp;&amp; chmod 777 fart* 加权限 修改源码dex保存路径：var savepath = “/sdcard/com.cz.babySister.activity/“; 1234mkdir &#x2F;sdcard&#x2F;com.cz.babySister.activity&#x2F; frida -U -f com.cz.babySister -l frida_fart_reflection.js --no-pausefrida -UF -l frida_fart_reflection.jsfrida -U -f com.cz.babySister -l frida_fart_hook.js --no-pause 基于安卓8，生成dex frida-dexdump 核心原理：进程级别的内存漫游 cd ~/.objection/plugins/dexdump &amp;&amp; python main.py 自动脱壳(前台运行的学而思app) cd com.xes.jazhanghui.activity &amp;&amp; grep -ril “okhttp3.OkHttpClient” * du -h * 查看文件最大的dex使用jadx打开 objection -g com.xes.jazhanghui.activity explore -P ~/.objection/plugins android hooking list activities 在jadx中查找到dex包含com.xes.jazhanghui.activity.mvp.live.activity.LiveMainActivity 同理：脱壳移动TV，grep -ril “MainActivity” *,grep -ril “LoginActivity” *,找到唯一入口dex 案例三adb install 免费电影院v2.1.0_210.apk 分析静态：通过jadx搜索OkHttpClient,或者apktool d 免费电影院v2.1.0_210.apk &amp;&amp; grep -ril &quot;OkHttpClient&quot; * 动态： 12345cat smali&#x2F;فمضﺝ&#x2F;ﻙﺫتك$ﺯﺵتﻝ.smali拿到.class public Lفمضﺝ&#x2F;ﻙﺫتك;类名objection -g com.singleman.freevideo explore -P &#x2F;root&#x2F;.objection&#x2F;plugins 点击登录调用ok3plugin wallbreaker objectsearch فمضﺝ.ﻙﺫتكplugin wallbreaker objectdump --fullname 0x2452 查看该类是否ok3Client，获取其中List&lt;Interceptor&gt;地址，用wallbreaker dump下来class为Collections$UnmodifiableRandomAccessList 即为OkHttpClient类 在hookOkhttp3.js中实现hook 12345678910111213141516171819202122Java.choose(&quot;فمضﺝ.ﻙﺫتك&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;1. found instance:&quot;,instance) &#x2F;&#x2F;console.log(&quot;2. instance.interceptors():&quot;,instance.interceptors().$className) console.log(&quot;3. instance._interceptors:&quot;,instance.ﻭﻍﺫﻉ.value.$className) &#x2F;&#x2F;console.log(&quot;4. interceptors:&quot;,gson2.$new().toJson(instance.interceptors())) console.log(&quot;5. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(instance.ﻭﻍﺫﻉ.value.toArray())) &#x2F;* var newInter &#x3D; Java.use(&quot;java.util.ArrayList&quot;).$new(); newInter.addAll(instance.interceptors()); console.log(&quot;6. interceptors:&quot;,Java.use(&quot;java.util.Arrays&quot;).toString(newInter.toArray())); console.log(&quot;7. interceptors:&quot;,newInter.$className); newInter.add(MyInterceptorObj); newInter.add(curlInter); instance._interceptors.value &#x3D; newInter; *&#x2F; &#125;,onComplete:function()&#123; console.log(&quot;Search complete!&quot;) &#125;&#125;) 基于Frida的Hook案例一adb install -r -t junior.apk 开启远程调用frida -UF -l demo.js 像素显示dip2px123456789101112131415161718objection -g com.example.junior explore -P ~&#x2F;.objection&#x2F;plugins 加载所有插件android hooking list activities 查看用于展示的界面android intent launch_activity com.example.junior.CalculatorActivity 启动计算器界面cat objection.log | grep com.example.junior.util.Utilsandroid hooking list class_methods com.example.junior.util.Utils 打印来中所有可hook的函数android hooking watch class_method com.example.junior.util.Utils.dip2px --dump-args --dump-return --dump-backtrace hook方法并打印像素显示出入参与调用栈function main() &#123; Java.perform(function () &#123;&#x2F;&#x2F;只要是java的代码都要跑在Java.perform里面 console.log(&quot;Entering Hook!&quot;) Java.use(&quot;com.example.junior.util.Utils&quot;).dip2px.implementation &#x3D; function (context, float) &#123; &#x2F;&#x2F;return null; var result &#x3D; this.dip2px(context, 100) console.log(&quot;context,float,result &#x3D;&#x3D;&gt; &quot;, context, float, result); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return 26; &#125; &#125;)&#125; 分辨率显示setTexthook用不上Java.choose的，hook函数时不分动静态 123456789101112131415161718192021222324252627282930android intent launch_activity com.example.junior.ScreenActivity cat objection.log|grep -i android.widget.TextViewandroid hooking list class_methods android.widget.TextView 打印来中所有可hook的函数android hooking watch class_method android.widget.TextView.setText --dump-args --dump-backtrace --dump-return hook公共方法setTextandroid heap search instances com.example.junior.ScreenActivity 搜索activity类内存地址android heap execute 0x6f72 showScreenInfo 主动调用该类的指定方法，frida端hook自动执行function Screen() &#123; Java.perform(function () &#123; &#x2F;&#x2F; 重载 Java.use(&quot;android.widget.TextView&quot;).setText.overload(&#39;java.lang.CharSequence&#39;).implementation &#x3D; function (text) &#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;); var newString &#x3D; javaString.$new(&quot;onejane&quot;) var result &#x3D; null; var realText &#x3D; String(text); console.log(&quot;real text is &#x3D;&#x3D;&gt; &quot;,realText); if (realText.indexOf(&quot;junior&quot;) &gt;&#x3D; 0) &#123; var result &#x3D; this.setText(newString); console.log(&quot;text,result &#x3D;&#x3D;&gt; &quot;, newString, result); &#125; else &#123; var result &#x3D; this.setText(text); console.log(&quot;text,result &#x3D;&#x3D;&gt; &quot;, text, result); &#125; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new())); return result; &#125; &#125;)&#125; 计算器123456789101112131415161718192021222324cat objection.log|grep -i com.example.junior.util.Arithandroid hooking list class_methods com.example.junior.util.Arith 查看Arith类有哪些hook的方法android hooking watch class_method com.example.junior.util.Arith.sub --dump-args --dump-backtrace --dump-return hook静态方法subfunction Equals()&#123; Java.perform(function()&#123; Java.use(&quot;java.lang.String&quot;).equals.implementation &#x3D; function(obj)&#123; var result &#x3D; this.equals(obj); console.log(&quot;obj,result &#x3D;&#x3D;&gt; &quot;,obj,result); return result; &#125; &#125;)&#125;function sub()&#123; Java.perform(function()&#123; Java.use(&quot;com.example.junior.util.Arith&quot;).sub.overload(&#39;java.lang.String&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function(str1,str2)&#123; var javaString &#x3D; Java.use(&quot;java.lang.String&quot;) var result &#x3D; this.sub(str1,javaString.$new(&quot;2&quot;)); &#x2F;&#x2F; 本质上属于主动调用构造函数 console.log(&quot;str1,str2,result&#x3D;&#x3D;&gt;&quot;,str1,str2,result) return javaString.$new(&quot;10&quot;); &#125; &#125;)&#125; 静态变量运行junior的计算器 12plugin wallbreaker classsearch Arith 内存漫游搜索Arith类plugin wallbreaker classdump --fullname com.example.junior.util.Arith 将Arith类dump发现有静态变量 通过frida获取静态变量DEF_DIV_SCALE并修改值为20，内存中的静态变量DEF_DIV_SCALE即变为20 123456789function staticField()&#123; Java.perform(function()&#123; var divscale &#x3D; Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value; console.log(&quot;divscale1 is &#x3D;&gt;&quot;,divscale); Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value&#x3D;20; divscale &#x3D; Java.use(&quot;com.example.junior.util.Arith&quot;).DEF_DIV_SCALE.value; console.log(&quot;divscale2 is &#x3D;&gt;&quot;,divscale); &#125;)&#125; 静态主动调用frida -UF -l demo.js主动调用Arith.add方法 123456function operate()&#123; Java.perform(function()&#123; var Arith &#x3D; Java.use(&quot;com.example.junior.util.Arith&quot;); console.log(&quot;addResult is &#x3D;&gt;&quot;,Arith.add(&quot;1&quot;,&quot;1&quot;)); &#125;)&#125; plugin wallbreaker classsearch Build 搜索含有Build的类 plugin wallbreaker classdump --fullname android.os.Build 将Build类dump下来 123456789function fingerPrint()&#123; Java.perform(function()&#123; var Build &#x3D; Java.use(&quot;android.os.Build&quot;); console.log(Build.DEVICE.value,Build.ID.value,Build.MODEL.value,Build.SERIAL.value); Build.SERIAL.value &#x3D; &#39;F123456&#39;; console.log(Build.SERIAL.value,Build.getSerial()); &#x2F;&#x2F; 若app无权限getSerial()，换设置重新主动调用 console.log(&#39;sdk is &#39;,Build.getString(&quot;ro.build.version.sdk&quot;)); &#125;)&#125; 动态变量plugin wallbreaker objectsearch com.example.junior.CalculatorActivity 获取该类地址 plugin wallbreaker objectdump 0x1eea 计算1+2=3后查看该类的动态变量 寻找CalculatorActivity实例，通过frida动态hook，通过修改showText值时内存中变量变为123 12345678910111213function dynamicField()&#123; Java.perform(function()&#123; Java.choose(&quot;com.example.junior.CalculatorActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance &#x3D;&gt;&quot;,instance); console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.showText.value) instance.showText.value &#x3D; &quot;123&quot; &#125;,onComplete:function()&#123; console.log(&#39;Search complete&#39;) &#125; &#125;) &#125;)&#125; 动态主动调用动态调用有参函数，计算机显示666，打印666 12345678910111213function dynamic()&#123; Java.perform(function()&#123; Java.choose(&quot;com.example.junior.CalculatorActivity&quot;,&#123; onMatch:function(instance)&#123; console.log(&quot;found instance &#x3D;&gt;&quot;,instance); console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.clear(&quot;666&quot;)) console.log(&quot;instance showText is &#x3D;&gt;&quot;,instance.showText.value) &#125;,onComplete:function()&#123; console.log(&#39;Search complete&#39;) &#125; &#125;) &#125;)&#125; RPC调用12345678910111213141516171819import frida# device&#x3D;frida.get_device_manager().add_remote_device(&#39;192.168.0.100:5555&#39;) 远程连接.&#x2F;fs128arm64 -l 0.0.0.0:5555,可定义多个device实现批量自动化群控device &#x3D; frida.get_usb_device()### attachpid&#x3D;device.get_frontmost_application().pid # 若双进程保护，指定pid进行hooksession &#x3D; device.attach(pid)### spawn #pid &#x3D; device.spawn([&quot;com.example.junior&quot;])#device.resume(pid)#time.sleep(1)#session &#x3D; device.attach(pid)with open(&quot;demo.js&quot;) as f: script &#x3D; session.create_script(f.read())script.load()input() 键盘操作input keyevent 4 表示后退 1234567function subcommand()&#123; Java.perform(function()&#123; &#x2F;&#x2F; adb input api var process &#x3D; Java.use(&#39;java.lang.Runtime&#39;).getRuntime().exec(&#39;input keyevent 4&#39;); console.log(&#39;subcommand success process is &#39;, process) &#125;)&#125; 循环调用 demo.js中导出指定方法 123rpc.exports &#x3D; &#123; subcommand: subcommand&#125; demo.py中开启循环 1234567command &#x3D; &quot;&quot;while 1 &#x3D;&#x3D; 1: command &#x3D; input(&quot;Enter command:\\n1: Exit\\n2: Call secret function\\nchoice:&quot;) if command &#x3D;&#x3D; &quot;1&quot;: break elif command &#x3D;&#x3D; &quot;2&quot;: # 在这里调用，可以设置多个条件判断 script.exports.subcommand() 输入2对当前进程持续后退 案例二利用nps实现启动了frida-server和nps-client的device的内网穿透，真正意义上实现批量自动化群控 案例三利用ssr通过nps内网穿透实现4G作为出口ip代理供request/scrapy调用 objection和frida不可同时hook一个函数, hook Non-ASCII 对于有些混淆后不可见或乱码的函数名，可以先编码打印出来, 再用编码后的字符串去 hook. 123456789101112131415161718192021Java.perform( function x() &#123; var targetClass &#x3D; &quot;com.example.hooktest.MainActivity&quot;; var hookCls &#x3D; Java.use(targetClass); var methods &#x3D; hookCls.class.getDeclaredMethods(); for (var i in methods) &#123; console.log(methods[i].toString()); console.log(encodeURIComponent(methods[i].toString().replace(&#x2F;^.*?\\.([^\\s\\.\\(\\)]+)\\(.*?$&#x2F;, &quot;$1&quot;))); &#125; hookCls[decodeURIComponent(&quot;%D6%8F&quot;)] .implementation &#x3D; function (x) &#123; console.log(&quot;original call: fun(&quot; + x + &quot;)&quot;); var result &#x3D; this[decodeURIComponent(&quot;%D6%8F&quot;)](900); return result; &#125; &#125;) hook Intent MainActivity中Intent intent2 = new Intent(this, Class.forName(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;));我们通过frida打印Intent 参考资料： Android App 保护那些事儿 （一） Android App 保护那些事儿 (二) frida dexclassloader 从三道题目入手入门frida Frida 入门小练习 举杯邀Frida，对影成三题 Null混淆 Android 字符串及字典混淆开源实现 资源压缩 Android微信逆向–实现发朋友圈动态 微信朋友圈分析 实用FRIDA进阶：脱壳、自动化、高频问题","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"}]},{"title":"加壳与脱壳之基本原理","slug":"加壳与脱壳之基本原理","date":"2021-02-04T02:39:05.000Z","updated":"2021-03-25T00:06:03.316Z","comments":true,"path":"2021/02/04/加壳与脱壳之基本原理/","link":"","permalink":"http://onejane.github.io/2021/02/04/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","excerpt":"","text":"逆向基本流程 使用自动化检测工具检测apk是否加壳，或者借助一些反编译工具依靠经验推断是否加壳 GDA3.85 或者 常见so文件 《娜迦》企业版本加固 libedog.so 《娜迦》免费版本加固 libddog.so 《梆梆》企业版本加固 libDexHelper.so 《梆梆》免费版本加固 libsecexe.so 《爱加密》企业版本加固 ijiami.ajm 《爱加密》免费版本加固 libexec.so 《通付盾》加固 libegis.so 《360》加固 libprotectClass.so，libjiagu.so 《百度》加固 libbaiduprotect.so 《阿里》加固 libmobisec.so 《腾讯》加固 libtup.so 《盛大》加固 libapssec.so 《瑞星》加固 librsprotect.so 《网秦》加固 nqdata 《国信灵通》加固 libnqshield.so 《apkprotect》加固 apkprotect 《几维安全》加固 libkwscmm.so，libkwscr.so，libkwslinker.so 《UU安全》加固 libuusafe.jar.so，libuusafe.so，libuusafeempty.so 几维安全 lib/armeabi-v7a/libkwscmm.so，lib/armeabi-v7a/libkwscr.so，lib/armeabi-v7a/libkwslinker.so UU安全 assets/libuusafe.jar.so，assets/libuusafe.so，lib/armeabi/libuusafeempty.so 如果apk加壳，则需要首先对apk进行脱壳 使用jeb，jadx，apktool等反编译工具对apk进行反编译 如果反编译工具打不开，使用010Editor把文件魔术字修复前8个字节 64 65 78 0A 30 33 35 00 dex.035. 再使用jadx反编译 grep -ril “MainAcitvity” ./*.txt 找到对应dex前缀名 先依据静态分析中得到的关键字字符串，关键api调用等方法快速定位需要分析的关键函数和流程 如果依据简单的字符串，关键api无法快速定位，则apk可能使用了字符串加密，反射调用等手段，此时可以结合hook，动态调试等 定位到关键函数后，再根据是java实现还是jni实现进一步分析 类加载基本原理JVM类加载器 Bootstrap ClassLoader（引导类加载器） C/C++代码实现的加载器,用于加载指定的JDK的核心类库,比如java. lang、java.utI等这些系统类。Java虚拟机的启动就是通过 Bootstrap,该 Classloader在java里无法获取,负责加载/lib下的类。 Extensions Classloader(拓展类加载器) Java中的实现类为 Extclassloader,提供了除了系统类之外的额外功能,可以在java里获取,负责加载/lib/ext下的类 Application ClassLoader(应用程序类加载器) Java中的实现类为 AppClassLoader,是与我们接触对多的类加载器,开发人员写的代码默认就是由它来加载, ClassLoader.getSystemClassLoader返回的就是它。 可以自定义类加载器，只需要通过java.lang.ClassLoader来实现自己的类加载器。 加载顺序：Bootstrap ClassLoader-&gt;Extensions Classloader-&gt;Application ClassLoader 双亲委派 如果一个类加载器收到了类加载请求,它并不会自己先去加载,而是把这个请求委托给父类的加载器去执行,如果父类加载器还存在其父类加载器,则进一步向上委托,依次递归,请求最终将到达顶层的启动类加载器,如果父类加载器可以完成类加载任务,就成功返回,倘若父类加载器无法完成此加载任务,子加载器才会尝试自己去加载。 1)避免重复加载,如果已经加载过一次class,可以直接读取已经加载的class 2)更加安全,无法自定义类来替代系统的类,可以防止核心API库被随意篡改 Android类加载器加载时机： 隐式加载：创建类的实例，访问类的静态变量，或者为静态变量赋值，调用类的静态方法，使用反射方式来强制创建某个类或接口对应的java.lang.Class对象，初始化某个类的子类 显式加载：使用LoadClass()加载，使用forName()加载 加载过程： 装载：查找和导入Class文件 链接：其中解析步骤是可以选择的（a）检查：检查载入的class文件数据的正确性（b）准备：给类的静态变量分配存储空间（c）解析：将符号引用转成直接引用 初始化：即调用&lt;clinit&gt;函数，对静态变量，静态代码块执行初始化工作 ClassLoader继承关系 ClassLoader:抽象类；BootClassLoader:预加载常用类，单例模式。与Java中的BootClassLoader不同，它并不是由C/C++代码实现，而是由Java实现的；BaseDexClassLoader是PathClassLoader、DexClassLoader、InMemoryDexClassLoader的父类，类加载的主要逻辑都是在BaseDexClassLoader完成的。SecureClassLoader继承了抽象类ClassLoader，拓展了ClassLoader类加入了权限方面的功能，加强了安全性，其子类URLClassLoader是用URL路径从jar文件中加载类和资源。其中重点关注的是PathClassLoader和DexClassLoader。PathClassLoader是Android默认使用的类加载器，一个apk中的Activity等类便是在其中加载。DexClassLoader可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更灵活，是实现插件化、热修复以及dex加壳的重点。 DexClassLoader方法参数 dexPath:目标所在的apk或者jar文件的路径，装载器将从路径中寻找指定的目标类。dexOutputDir:由于dex 文件在APK或者 jar文件中，所以在装载前面前先要从里面解压出dex文件，这个路径就是dex文件存放的路径，在 android系统中，一个应用程序对应一个linux用户id ,应用程序只对自己的数据目录有写的权限，所以我们存放在这个路径中。libPath :目标类中使用的C/C++库。parent：该装载器的父装载器，一般为当前执行类的装载器。 Android8.0新引入InMemoryDexClassLoader，用于直接从内存中加载dex。 http://androidxref.com/8.0.0_r4/ 搜索位于libcore中的Definition的DexClassLoader 、PathClassLoader、 InmemoryDexClassLoader查看源码。 ClassLoaderTest新建项目ClassLoaderTest验证类加载器的加载顺序 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); testClassLoader(); &#125; /** * I/kanxue: thisClassLoader:dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/base.apk\"],nativeLibraryDirectories=[/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/lib/x86, /system/lib, /system/product/lib]]] * I/kanxue: this:dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/base.apk\"],nativeLibraryDirectories=[/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/lib/x86, /system/lib, /system/product/lib]]]===java.lang.BootClassLoader@232d58a * I/kanxue: root:java.lang.BootClassLoader@232d58a * */ public void testClassLoader()&#123; ClassLoader thisClassLoader=MainActivity.class.getClassLoader(); Log.i(\"kanxue\",\"thisClassLoader:\"+thisClassLoader); ClassLoader tmpClassLoader = null; ClassLoader parentClassLoader=thisClassLoader.getParent(); while (parentClassLoader!=null)&#123; Log.i(\"kanxue\",\"this:\"+thisClassLoader+\"===\"+parentClassLoader); tmpClassLoader=parentClassLoader.getParent(); thisClassLoader=parentClassLoader; parentClassLoader=tmpClassLoader; &#125; Log.i(\"kanxue\",\"root:\"+thisClassLoader); &#125;&#125; LoadDex通过DexClassLoader实现一个动态加载的dex插件 在ClassLoaderTest项目中打印log 12345public class TestDexClass &#123; public void testFunc()&#123; Log.i(\"kanxue\",\"I'm from com.onejane.classloadertest.TestDexClass.testFunc\"); &#125;&#125; 通过build生成ClassLoaderTest\\app\\build\\outputs\\apk\\debug\\app-debug.apk, apktool d -s app-debug.apk保留并抽取出classes.dex adb push classes.dex /sdcard 创建LoadDex空白Android项目，加载调用位于dex下com.onejane.classloadertest.TestDexClass 在AndroidManifest.xml中添加读写权限 12&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt; 新增application配置android:requestLegacyExternalStorage=”true” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context = this.getApplicationContext(); /** * Android 10 sdk30 无法获取sdcard权限，通过获取当前app的cache目录 * if(!getExternalCacheDir().exists()) getExternalCacheDir().mkdirs(); * testDexClassLoader(context,getExternalCacheDir().getAbsolutePath()+\"/classes.dex\"); * 再将TestDexClass所在的adb push classes.dex /sdcard/Android/data/com.onejane.loaddex/cache/ */ // 若sdk30需要sdcard，通过requestMyPermissions动态获取读写权限 testDexClassLoader(context,\"/sdcard/classes.dex\"); &#125; private void requestMyPermissions() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; //没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(\"kanxue\", \"requestMyPermissions: 有写SD权限\"); &#125; if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; //没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(\"kanxue\", \"requestMyPermissions: 有读SD权限\"); &#125; &#125; // 可应对app热更新bug修复 public void testDexClassLoader(Context context, String dexfilepath)&#123; // 存放dex文件 File optFile = context.getDir(\"opt_dex\",0); // 存放依赖的so文件 File libFile = context.getDir(\"lib_path\",0); ClassLoader parentClassLoader=MainActivity.class.getClassLoader(); Log.i(\"kanxue\",parentClassLoader.toString()); //PathClassLoader ClassLoader tmpClassLoader=context.getClassLoader(); Log.i(\"kanxue\",tmpClassLoader.toString()); // PathClassLoader requestMyPermissions(); DexClassLoader dexClassLoader = new DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity.class.getClassLoader()); Class&lt;?&gt; clazz=null; try&#123; clazz=dexClassLoader.loadClass(\"com.onejane.classloadertest.TestDexClass\"); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; if(clazz!=null)&#123; try &#123; Method testFuncMethod=clazz.getDeclaredMethod(\"testFunc\"); Object obj = clazz.newInstance(); testFuncMethod.invoke(obj); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 利用外部dex下发热修复bug，用户无感知更新。 APP启动流程由发起进程通过binder进程间通信告知system_server进程启动指定的app，system_server通过socket方式与安卓孵化器进程进行通信，告诉孵化器进程启动指定app，由进程fork产生新的进程真正进入ActivityThread.main()，在此之前一直处于安卓的framework中。 ActivityThread是单例模式，在app整个进程的生命周期中，只存在一个实例，http://androidxref.com/8.0.0_r4/ 搜索位于frameworks中的ActivityThread 调用静态函数currentActivityThread获取当前进程中的ActivityThread实例，进而可以获取ActivityThread的重要变量,如mPackages 1234public static ActivityThread currentActivityThread() &#123; return sCurrentActivityThread;&#125;final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages &#x3D; new ArrayMap&lt;&gt;(); 其中LoadedApk中有加载app组件的PathClassLoader,即mClassLoader 通过反射获取app进程中单例ActivityThread，其中的sCurrentActivityThread静态变量用于全局保存创建的ActivityThread实例，同时还提供了currentActivityThread()静态函数用于获取当前虚拟机创建的ActivityThread实例。 反射拿到ActivityThread中的 mPackages的ArrayMap，通过当前app包名获取LoadedApk。 最后通过LoadedApk获取mClassLoader-&gt;PathClassLoader。 PathClassLoader: app运行过程中用于加载四大组件类的ClassLoader **ActivityThread.main()**函数是java中的入口main函数,这里会启动主消息循环，并创建ActivityThread实例，之后调用thread.attach(false)完成一系列初始化准备工作，并完成全局静态变量sCurrentActivityThread的初始化。之后主线程进入消息循环，等待接收来自系统的消息。当收到系统发送来的bindapplication的进程间调用时，调用函数handleBindApplication来处理该请求。 12345678910111213141516171819202122private void handleBindApplication(AppBindData data) &#123; &#x2F;&#x2F;step 1: 创建LoadedApk对象 data.info &#x3D; getPackageInfoNoCheck(data.appInfo, data.compatInfo); ... &#x2F;&#x2F;step 2: 创建ContextImpl对象; final ContextImpl appContext &#x3D; ContextImpl.createAppContext(this, data.info); &#x2F;&#x2F;step 3: 创建Instrumentation mInstrumentation &#x3D; new Instrumentation(); &#x2F;&#x2F;step 4: 创建Application对象;在makeApplication函数中调用了newApplication，真正执行app代码。在该函数中又调用了app.attach(context)，在attach函数中调用了Application.attachBaseContext函数 Application app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication &#x3D; app; &#x2F;&#x2F;step 5: 安装providers List&lt;ProviderInfo&gt; providers &#x3D; data.providers; installContentProviders(app, providers); &#x2F;&#x2F;step 6: 执行Application.Create回调 mInstrumentation.callApplicationOnCreate(app); ...&#125; 在 handleBindApplication函数中第一次进入了app的代码世界，该函数功能是启动一个application，并把系统收集的apk组件等相关信息绑定到application里，在创建完application对象后，接着调用了application的attachBaseContext方法，之后调用了application的onCreate函数。由此可以发现，app的Application类中的attachBaseContext和onCreate这两个函数是最先获取执行权进行代码执行的。这也是为什么各家的加固工具的主要逻辑都是通过替换app入口Application，并自实现这两个函数，在这两个函数中进行加密dex释放以及执行权交付的原因。 APP运行流程 无壳：PathClassLoader加载自身app自身dex，包括app声明的Application及所有其他类信息 加壳：PathClassLoader只加载壳自身代码，不包含app自身真正代码。首先进入壳的application的attachBaseContext，解密原始dex，再完成执行权的交付。 DexClassLoader加载的类是没有组件生命周期的，也就是说即使DexClassLoader通过对APK的动态加载完成了对组件类的加载，当系统启动该组件时，依然会出现加载类失败的异常，因为插件没有组件相关的类，如一些activity或service，若只用DexClassLoader进行动态加载，系统PathClassLoader无法找到相关组件信息，app将直接崩溃。所以如何解决动态加载dex中的生命周期成为加壳厂商首先需要解决的问题！！！ 在项目ClassLoaderTest中新建TestActivity ，并将build的apk中的classes.dex取出，adb push classes.dex /sdcard 12345678public class TestActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#x2F;&#x2F; adb push classes.dex &#x2F;sdcard Log.i(&quot;kanxue&quot;,&quot;I&#39;m from TestActivity.onCreate&quot;); &#125;&#125; 在项目LoadDex中，配置AndroidManifest.xml&lt;activity android:name=&quot;com.onejane.classloadertest.TestActivity&quot;&gt;&lt;/activity&gt;,在MainActivity中新增方法，并启动运行 123456789101112131415161718192021222324252627protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context &#x3D; this.getApplicationContext(); startTestActivity(context,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;);&#125;public void startTestActivity(Context context,String dexfilepath)&#123; &#x2F;&#x2F; 存放dex文件 File optFile &#x3D; context.getDir(&quot;opt_dex&quot;,0); &#x2F;&#x2F; 存放依赖的so文件 File libFile &#x3D; context.getDir(&quot;lib_path&quot;,0); ClassLoader parentClassLoader&#x3D;MainActivity.class.getClassLoader(); Log.i(&quot;kanxue&quot;,parentClassLoader.toString()); &#x2F;&#x2F;PathClassLoader ClassLoader tmpClassLoader&#x3D;context.getClassLoader(); Log.i(&quot;kanxue&quot;,tmpClassLoader.toString()); &#x2F;&#x2F; PathClassLoader requestMyPermissions(); DexClassLoader dexClassLoader &#x3D; new DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity.class.getClassLoader()); Class&lt;?&gt; clazz&#x3D;null; try&#123; clazz&#x3D;dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; if(clazz!&#x3D;null)&#123; context.startActivity(new Intent(context,clazz)); &#125;&#125; 启动app将报错ClassNotFoundException: Didn’t find class “com.onejane.classloadertest.TestActivity” 说明组件相关的Activity由mClassLoader-&gt;PathClassLoader加载了，虽然获取到非空TestActivity，却无法找到启动的目标Activity。 方案一反射替换，替换系统组件类加载器mClassLoader为我们的DexClassLoader，同时设置DexClassLoader的parent为系统组件类加载器PathClassLoader； 修改LoadDex项目的MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context &#x3D; this.getApplicationContext(); startTestActivityReplaceMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;); &#125; private void requestMyPermissions() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有写SD权限&quot;); &#125; if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有读SD权限&quot;); &#125; &#125; public void replaceClassloader(ClassLoader classloader)&#123; try &#123; Class&lt;?&gt; ActivityThreadClazz&#x3D;classloader.loadClass(&quot;android.app.ActivityThread&quot;); &#x2F;&#x2F; 获取静态函数currentActivityThread Method currentActivityThreadMethod&#x3D; ActivityThreadClazz.getDeclaredMethod(&quot;currentActivityThread&quot;); currentActivityThreadMethod.setAccessible(true); Object activityThreadObj&#x3D;currentActivityThreadMethod.invoke(null); &#x2F;&#x2F; 获取ActivityThread对象 &#x2F;&#x2F;final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages &#x3D; new ArrayMap&lt;&gt;(); Field mPackagesField&#x3D;ActivityThreadClazz.getDeclaredField(&quot;mPackages&quot;); &#x2F;&#x2F; 获取ActivityThread对象的ArrayMap的Field mPackagesField.setAccessible(true); ArrayMap mPackagesObj&#x3D; (ArrayMap) mPackagesField.get(activityThreadObj); &#x2F;&#x2F; 通过Field获取mPackages实例 WeakReference wr&#x3D; (WeakReference) mPackagesObj.get(this.getPackageName()); &#x2F;&#x2F; 从ArrayMap中获取LoadApk Object loadedApkObj&#x3D;wr.get(); Class LoadedApkClazz&#x3D;classloader.loadClass(&quot;android.app.LoadedApk&quot;); &#x2F;&#x2F;private ClassLoader mClassLoader; Field mClassLoaderField&#x3D;LoadedApkClazz.getDeclaredField(&quot;mClassLoader&quot;); mClassLoaderField.setAccessible(true); mClassLoaderField.set(loadedApkObj,classloader); &#x2F;&#x2F; 将LoadApk(mClassLoader)替换为我们的DexClassLoader &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; &#125; public void startTestActivityReplaceMethod(Context context,String dexfilepath)&#123; &#x2F;&#x2F; 存放dex文件 File optFile &#x3D; context.getDir(&quot;opt_dex&quot;,0); &#x2F;&#x2F; 存放依赖的so文件 File libFile &#x3D; context.getDir(&quot;lib_path&quot;,0); requestMyPermissions(); DexClassLoader dexClassLoader &#x3D; new DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity.class.getClassLoader()); replaceClassloader(dexClassLoader); Class&lt;?&gt; clazz&#x3D;null; try&#123; clazz&#x3D;dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; if(clazz!&#x3D;null)&#123; context.startActivity(new Intent(context,clazz)); &#125; &#125;&#125; 方案二打破原有的双亲关系，在系统组件类加载器和BootClassLoader的中间插入我们自己的DexClassLoader即可 修改ClassLoaderTest中的TestActivity类继承自Activity 123456789public class TestActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState);&#x2F;&#x2F; setContentView(R.layout.activity_main); &#x2F;&#x2F; adb push classes.dex &#x2F;sdcard Log.i(&quot;kanxue&quot;,&quot;I&#39;m from TestActivity.onCreate&quot;); &#125;&#125; 修改LoadDex中的MainActivity继承Activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context context &#x3D; this.getApplicationContext(); &#x2F;&#x2F; 若sdk30需要sdcard，通过requestMyPermissions动态获取读写权限&#x2F;&#x2F; testDexClassLoader(context,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;);&#x2F;&#x2F; startTestActivityReplaceMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;); startTestActivityInsertMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;); &#125; private void requestMyPermissions() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有写SD权限&quot;); &#125; if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) &#123; &#x2F;&#x2F;没有授权，编写申请权限代码 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100); &#125; else &#123; Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有读SD权限&quot;); &#125; &#125; public void startTestActivityInsertMethod(Context context,String dexfilepath)&#123; File optfile&#x3D;context.getDir(&quot;opt_dex&quot;,0); File libfile&#x3D;context.getDir(&quot;lib_path&quot;,0); requestMyPermissions(); ClassLoader pathClassloader&#x3D;MainActivity.class.getClassLoader(); ClassLoader bootClassloader&#x3D;MainActivity.class.getClassLoader().getParent(); &#x2F;&#x2F; 设置自定义dexClassLoader父ClassLoader为bootClassloader DexClassLoader dexClassLoader&#x3D;new DexClassLoader(dexfilepath,optfile.getAbsolutePath(),libfile.getAbsolutePath(),bootClassloader); try &#123; Field parentField&#x3D;ClassLoader.class.getDeclaredField(&quot;parent&quot;); parentField.setAccessible(true); &#x2F;&#x2F; 设置pathClassLoader父ClassLoader为自定义dexClassLoader parentField.set(pathClassloader,dexClassLoader); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; ClassLoader tmpClassloader&#x3D;pathClassloader; ClassLoader parentClassloader&#x3D;pathClassloader.getParent(); while(parentClassloader!&#x3D;null)&#123; Log.i(&quot;kanxue&quot;,&quot;this:&quot;+tmpClassloader+&quot;--parent:&quot;+parentClassloader); tmpClassloader&#x3D;parentClassloader; parentClassloader&#x3D;parentClassloader.getParent(); &#125; Log.i(&quot;kanxue&quot;,&quot;root:&quot;+tmpClassloader); Class&lt;?&gt; clazz&#x3D;null; try &#123; clazz &#x3D; dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; context.startActivity(new Intent(context,clazz)); &#125;&#125; 以上都是基于文件形式的外部加载，Android 8.0引入InMemoryDexClassLoader实现从内存中直接加载字节流，更加安全，不能通过文件监控形式达到脱壳目的，需要从进程内存中扣出这块完整的dex实现脱壳。 部分app在AndroidManifest.xml中没有声明application，加固厂商只需要添加一个application，在自己的application中完成classloader的替换。 部分app在AndroidManifest.xml中已经声明application，加固需要一个代理的application，壳的application不仅需要完成解密dex以及classloader相关修复，还需要完成解密dex后原app的application的attachBaseContext和onCreate函数调用。","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"}],"tags":[{"name":"classloader","slug":"classloader","permalink":"http://onejane.github.io/tags/classloader/"}]},{"title":"猿人学之访问逻辑罗生门","slug":"猿人学之访问逻辑罗生门","date":"2021-02-03T05:25:34.000Z","updated":"2021-02-10T01:52:51.716Z","comments":true,"path":"2021/02/03/猿人学之访问逻辑罗生门/","link":"","permalink":"http://onejane.github.io/2021/02/03/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8B%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91%E7%BD%97%E7%94%9F%E9%97%A8/","excerpt":"","text":"题目http://match.yuanrenxue.com/match/3 抓取下列5页商标的数据，并将出现频率最高的申请号填入答案中 抓包 分析http://match.yuanrenxue.com/match/3 请求原始网页后请求一堆js/css,并没有携带cookie和特殊的返回 http://match.yuanrenxue.com/logo 每次请求页数的时候都会先请求logo并set了一个cookie，说明cookie是从服务器返回的 http://match.yuanrenxue.com/api/match/3 请求返回页面json数据，携带logo返回的cookie 没有带cookie不能访问http://match.yuanrenxue.com/api/match/3 使用请求头加引号.py 将fiddler的请求头包上 请求头加引号.py 123456789101112131415161718import reold_headers ='''Connection: keep-aliveAccept: application/json, text/javascript, */*; q=0.01X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36Referer: http://match.yuanrenxue.com/match/3Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: sessionid=7ly07o9fclh1llfsposkhh9jqvujxkth'''pattern = '^(.*?):[\\s]*(.*?)$'headers = \"\"for line in old_headers.splitlines(): headers += (re.sub(pattern,'\\'\\\\1\\': \\'\\\\2\\',',line)) + '\\n'print(headers[:-2]) 加上cookie使用python请求抓取返回一堆js代码，因为cookie是由服务器生成的，所以这一段返回的js没有意义 12345678910111213headers = &#123; 'Connection': 'keep-alive', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'X-Requested-With': 'XMLHttpRequest', 'User-Agent': 'yuanrenxue.project', 'Referer': 'http://match.yuanrenxue.com/match/3', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Cookie': 'sessionid=7ly07o9fclh1llfsposkhh9jqvujxkth'&#125;url = 'http://match.yuanrenxue.com/api/match/3'res = requests.get(url=url, headers=headers)print(res.text) 爬虫规律：请求完logo后再请求api则正常返回，同理请求第二页 1234567891011121314151617session = requests.session()headers = &#123; 'Connection': 'keep-alive', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'X-Requested-With': 'XMLHttpRequest', 'User-Agent': 'yuanrenxue.project', 'Referer': 'http://match.yuanrenxue.com/match/3', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9'&#125;session.headers = headersurl_logo = 'http://match.yuanrenxue.com/logo'res = session.post(url_logo)print(res, res.cookies)url = 'http://match.yuanrenxue.com/api/match/3?page=1'res = session.get(url=url)print(res.text)","categories":[{"name":"js逆向","slug":"js逆向","permalink":"http://onejane.github.io/categories/js%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"猿人学之js混淆动态cookie","slug":"猿人学之js混淆动态cookie","date":"2021-02-03T02:19:32.000Z","updated":"2021-02-10T01:51:48.856Z","comments":true,"path":"2021/02/03/猿人学之js混淆动态cookie/","link":"","permalink":"http://onejane.github.io/2021/02/03/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8Bjs%E6%B7%B7%E6%B7%86%E5%8A%A8%E6%80%81cookie/","excerpt":"","text":"题目http://match.yuanrenxue.com/match/2 提取全部5页发布日热度的值，计算所有值的加和,并提交答案 抓包chrome无痕模式通过抓包获取所有请求 第一个match/2不携带cookie并返回一串js代码 第二个match/2最早携带cookie并返回html页面，且并没有在请求头set-cookie,说明cookie是本地生成，而非服务器生成带到前端的，那么第一个match/2返回的js很可能就会生成cookie 1Cookie m&#x3D;dd5572e825610043a17c791d1eadc601|1607590427000 第三个api/match/2携带cookie返回页面请求json数据 分析使用ob混淆专解测试版V0.1反混淆第一个match/2返回的js代码去掉script标签 将解析完的js放到notepad++中进行js format，查找eval，setInterval，document等函数或者cookie等关键字符串。 123456789101112131415161718function V(Y, Z, a0) &#123; // 空参数 M(); return Z ? a0 ? H(Z, Y) : y(Z, Y) : a0 ? T(Y) : U(Y); &#125; // Y=X()时间戳，Z无用 function W(Y, Z) &#123; // 获取cookie document[\"cookie\"] = \"m\" + M() + \"=\" + V(Y) + \"|\" + Y + \"; path=/\"; // 带上cookie重新刷新页面返回真实网页并发送ajax请求获取json数据 location[\"reload\"](); &#125; // 时间戳 function X(Y, Z) &#123; return Date[\"parse\"](new Date()); &#125; // 最先执行js W(X()); 查看W和V中的M(),都没有传参数 1234567891011121314151617181920212223242526272829303132333435function M(Y, Z) &#123; // 只定义函数并无更新值 var a2 = B(this, function () &#123; var a5 = &#123; \"JLTiy\": \"return /\\\" + this + \\\"/\", \"uynWF\": \"^([^ ]+( +[^ ]+)+)+[^ ]&#125;\" &#125;; var a7 = function () &#123; var a8 = a7[\"constructor\"](a5[\"JLTiy\"])()[\"compile\"](a5[\"uynWF\"]); return !a8[\"test\"](a2); &#125;; return a7(); &#125;); // 未传参 未改变全局变量 无返回 a2(); // 未传参 未改变全局变量 无返回 K(); qz = [10, 99, 111, 110, 115, 111, 108, 101, 32, 61, 32, 110, 101, 119, 32, 79, 98, 106, 101, 99, 116, 40, 41, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 115, 41, 32, 123, 10, 32, 32, 32, 32, 119, 104, 105, 108, 101, 32, 40, 49, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 40, 105, 61, 48, 59, 105, 60, 49, 49, 48, 48, 48, 48, 48, 59, 105, 43, 43, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 104, 105, 115, 116, 111, 114, 121, 46, 112, 117, 115, 104, 83, 116, 97, 116, 101, 40, 48, 44, 48, 44, 105, 41, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 10, 125, 10, 99, 111, 110, 115, 111, 108, 101, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 91, 111, 98, 106, 101, 99, 116, 32, 79, 98, 106, 101, 99, 116, 93, 39, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 402, 32, 116, 111, 83, 116, 114, 105, 110, 103, 40, 41, 32, 123, 32, 91, 110, 97, 116, 105, 118, 101, 32, 99, 111, 100, 101, 93, 32, 125, 39, 10]; eval(L(qz)); try &#123; if (global) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); &#125; else &#123; while (1) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); debugger; &#125; &#125; &#125; catch (a5) &#123; return navigator[\"vendorSub\"]; &#125; &#125; 通过WT-JS查看L(qz)，并没有对cookie进行影响 1234567function L(Y, Z) &#123; let a0 = \"\"; for (let a1 = 0; a1 &lt; Y[\"length\"]; a1++) &#123; a0 += String[\"fromCharCode\"](Y[a1]); &#125; return a0;&#125; navigator[“vendorSub”]放到console返回””,得出M()结论不返回或者返回””,也没修改变量参数 去除无用首行(function $c(k) {和尾行})(); 去除最先执行W(X()); 去除W内的location“reload”; 将document[“cookie”] =改为return 去除无用setInterval(M(), 500); 去除W函数无用Z,M()为null也可以去除 删除无返回js，因为会报test未定义 12345678910111213141516// 无返回 var a2 = B(this, function () &#123; var a5 = &#123; \"JLTiy\": \"return /\\\" + this + \\\"/\", \"uynWF\": \"^([^ ]+( +[^ ]+)+)+[^ ]&#125;\" &#125;; var a7 = function () &#123; var a8 = a7[\"constructor\"](a5[\"JLTiy\"])()[\"compile\"](a5[\"uynWF\"]); return !a8[\"test\"](a2); &#125;; return a7();&#125;);// 未传参 未改变全局变量 无返回a2(); 新增var navigator = {}; 使用鬼鬼调试工具，执行W(X()); 核心js如下2.js 1234567891011121314151617181920212223242526272829303132333435363738var navigator = &#123;&#125;;function M(Y, Z) &#123; // 未传参 未改变全局变量 无返回 K(); qz = [10, 99, 111, 110, 115, 111, 108, 101, 32, 61, 32, 110, 101, 119, 32, 79, 98, 106, 101, 99, 116, 40, 41, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 115, 41, 32, 123, 10, 32, 32, 32, 32, 119, 104, 105, 108, 101, 32, 40, 49, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 40, 105, 61, 48, 59, 105, 60, 49, 49, 48, 48, 48, 48, 48, 59, 105, 43, 43, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 104, 105, 115, 116, 111, 114, 121, 46, 112, 117, 115, 104, 83, 116, 97, 116, 101, 40, 48, 44, 48, 44, 105, 41, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 10, 125, 10, 99, 111, 110, 115, 111, 108, 101, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 91, 111, 98, 106, 101, 99, 116, 32, 79, 98, 106, 101, 99, 116, 93, 39, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 402, 32, 116, 111, 83, 116, 114, 105, 110, 103, 40, 41, 32, 123, 32, 91, 110, 97, 116, 105, 118, 101, 32, 99, 111, 100, 101, 93, 32, 125, 39, 10]; eval(L(qz)); try &#123; if (global) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); &#125; else &#123; while (1) &#123; console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); debugger; &#125; &#125; &#125; catch (a5) &#123; return navigator[\"vendorSub\"]; &#125;&#125;function V(Y, Z, a0) &#123; // 空参数 M(); return Z ? a0 ? H(Z, Y) : y(Z, Y) : a0 ? T(Y) : U(Y);&#125;// Y=X()时间戳，Z无用function W(Y) &#123; return \"m\" + \"=\" + V(Y) + \"|\" + Y;&#125;function X(Y, Z) &#123; return Date[\"parse\"](new Date());&#125;function request() &#123; return W(X());&#125; 爬虫123456789101112131415161718192021222324252627282930313233import requestsimport execjsimport timedef get_page(page_num,param): url = \"http://match.yuanrenxue.com/api/match/2?page=&#123;&#125;\".format(page_num) headers = &#123; 'Host': 'match.yuanrenxue.com', 'Referer':'http://match.yuanrenxue.com/match/2', 'User-Agent':'yuanrenxue.project', 'X-Requested-With':'XMLHttpRequest', 'Cookie': param &#125; resonse = requests.get(url=url,headers=headers) return resonse.json()def calculate_m_value(): with open(r'2.js',encoding='utf-8',mode='r') as f: JsData = f.read() psd = execjs.compile(JsData).call('request') psd = psd.replace('丨','%E4%B8%A8') print('this request parameters is :',psd) return psdif __name__ == '__main__': sum_num = 0 for page_num in range(1,6): res = get_page(page_num,calculate_m_value()) data = [__['value'] for __ in res['data']] print(data) sum_num+=sum(data) time.sleep(1) print('the answer is :',sum_num)","categories":[{"name":"js逆向","slug":"js逆向","permalink":"http://onejane.github.io/categories/js%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"猿人学之js混淆源码乱码","slug":"猿人学之js混淆源码乱码","date":"2021-02-01T03:18:17.000Z","updated":"2021-02-10T01:52:29.653Z","comments":true,"path":"2021/02/01/猿人学之js混淆源码乱码/","link":"","permalink":"http://onejane.github.io/2021/02/01/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8Bjs%E6%B7%B7%E6%B7%86%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/","excerpt":"","text":"题目http://match.yuanrenxue.com/match/1抓取所有（5页）机票的价格，并计算所有机票价格的平均值，填入答案。 抓包打开控制台开始抓包，出现无限debugger循环,可以通过Never pause here或Fiddler过掉。 方案一：在第2行选中右键Never pause here 方案二：通过查看该debug的js名为uzt.js，本地创建uzt.js并修改其中的jsFiddler的AutoResponder下，选中Enable automatic reaponses 和Unmatched requests passthrough 通过翻页获取请求参数得其中1607516709为秒时间戳，即time.time() 12page: 2m: 3ddf4f4e72bd84562a0e0104d425a791丨1607657864 分析查看网页源码，搜索丨中文竖线，抠出js 通过notepad++插件进行js格式化后得到核心代码 修改得m的计算方式 12345request = function () &#123; var timestamp = Date.parse(new Date()) + 100000000; var m = oo0O0(timestamp.toString()) + window.f; m = m + '丨' + timestamp / 1000 &#125;; 扣出oo0O0方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function oo0O0(mw) &#123; window.b = ''; for (var i = 0, len = window.a.length; i &lt; len; i++) &#123; console.log(window.a[i]); window.b += String[document.e + document.g](window.a[i][document.f + document.h]() - i - window.c) &#125; var U = ['W5r5W6VdIHZcT8kU', 'WQ8CWRaxWQirAW==']; var J = function (o, E) &#123; o = o - 0x0; var N = U[o]; if (J['bSSGte'] === undefined) &#123; var Y = function (w) &#123; var m = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=', T = String(w)['replace'](/=+$/, ''); var A = ''; for (var C = 0x0, b, W, l = 0x0; W = T['charAt'](l++); ~W &amp;&amp; (b = C % 0x4 ? b * 0x40 + W : W, C++ % 0x4) ? A += String['fromCharCode'](0xff &amp; b &gt;&gt; (-0x2 * C &amp; 0x6)) : 0x0) &#123; W = m['indexOf'](W) &#125; return A &#125;; var t = function (w, m) &#123; var T = [], A = 0x0, C, b = '', W = ''; w = Y(w); for (var R = 0x0, v = w['length']; R &lt; v; R++) &#123; W += '%' + ('00' + w['charCodeAt'](R)['toString'](0x10))['slice'](-0x2) &#125; w = decodeURIComponent(W); var l; for (l = 0x0; l &lt; 0x100; l++) &#123; T[l] = l &#125; for (l = 0x0; l &lt; 0x100; l++) &#123; A = (A + T[l] + m['charCodeAt'](l % m['length'])) % 0x100, C = T[l], T[l] = T[A], T[A] = C &#125; l = 0x0, A = 0x0; for (var L = 0x0; L &lt; w['length']; L++) &#123; l = (l + 0x1) % 0x100, A = (A + T[l]) % 0x100, C = T[l], T[l] = T[A], T[A] = C, b += String['fromCharCode'](w['charCodeAt'](L) ^ T[(T[l] + T[A]) % 0x100]) &#125; return b &#125;; J['luAabU'] = t, J['qlVPZg'] = &#123;&#125;, J['bSSGte'] = !![] &#125; var H = J['qlVPZg'][o]; return H === undefined ? (J['TUDBIJ'] === undefined &amp;&amp; (J['TUDBIJ'] = !![]), N = J['luAabU'](N, E), J['qlVPZg'][o] = N) : N = H, N &#125;; eval(atob(window['b'])[J('0x0', ']dQW')](J('0x1', 'GTu!'), '\\x27' + mw + '\\x27')); return ''&#125; 由于返回是个空字符串，则oo0O0(timestamp.toString())=‘’，m=window.f，查看源码得知window.f只有一个，那么f作为全局变量可能在oo0O0中被修改 1eval(atob(window[&#39;b&#39;])[J(&#39;0x0&#39;, &#39;]dQW&#39;)](J(&#39;0x1&#39;, &#39;GTu!&#39;), &#39;\\x27&#39; + mw + &#39;\\x27&#39;)); atob是解码使用 base-64 编码的字符串的函数，通过console中获取atob(window[‘b’]) 通过WT-JS加载计算f=hex_md5(mwqqppz) 报错未定义，mwqqppz可能是被其他地方替换或者加密来的 查看J(‘0x0’, ‘]dQW’)方法返回值，在console中执行J方法 1234var U = ['W5r5W6VdIHZcT8kU', 'WQ8CWRaxWQirAW=='];var J = function (o, E) &#123; ...&#125; 拼接得到eval(atob(window[&#39;b&#39;])[replace](&#39;mwqqppz&#39;, &#39;\\x27&#39; + mw + &#39;\\x27&#39;)); 搜索\\bmw\\b,发现mw为function oo0O0的参数，即时间戳 所以f=hex_md5(timestamp),在WT-JS中添加js，atob(window[‘b’])获取window.f 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210var hexcase = 0;var b64pad = \"\";var chrsz = 16;function hex_md5(a) &#123; return binl2hex(core_md5(str2binl(a), a.length * chrsz))&#125;function b64_md5(a) &#123; return binl2b64(core_md5(str2binl(a), a.length * chrsz))&#125;function str_md5(a) &#123; return binl2str(core_md5(str2binl(a), a.length * chrsz))&#125;function hex_hmac_md5(a, b) &#123; return binl2hex(core_hmac_md5(a, b))&#125;function b64_hmac_md5(a, b) &#123; return binl2b64(core_hmac_md5(a, b))&#125;function str_hmac_md5(a, b) &#123; return binl2str(core_hmac_md5(a, b))&#125;function md5_vm_test() &#123; return hex_md5(\"abc\") == \"900150983cd24fb0d6963f7d28e17f72\"&#125;function core_md5(p, k) &#123; p[k &gt;&gt; 5] |= 128 &lt;&lt; ((k) % 32); p[(((k + 64) &gt;&gt;&gt; 9) &lt;&lt; 4) + 14] = k; var o = 1732584193; var n = -271733879; var m = -1732584194; var l = 271733878; for (var g = 0; g &lt; p.length; g += 16) &#123; var j = o; var h = n; var f = m; var e = l; o = md5_ff(o, n, m, l, p[g + 0], 7, -680976936); l = md5_ff(l, o, n, m, p[g + 1], 12, -389564586); m = md5_ff(m, l, o, n, p[g + 2], 17, 606105819); n = md5_ff(n, m, l, o, p[g + 3], 22, -1044525330); o = md5_ff(o, n, m, l, p[g + 4], 7, -176418897); l = md5_ff(l, o, n, m, p[g + 5], 12, 1200080426); m = md5_ff(m, l, o, n, p[g + 6], 17, -1473231341); n = md5_ff(n, m, l, o, p[g + 7], 22, -45705983); o = md5_ff(o, n, m, l, p[g + 8], 7, 1770035416); l = md5_ff(l, o, n, m, p[g + 9], 12, -1958414417); m = md5_ff(m, l, o, n, p[g + 10], 17, -42063); n = md5_ff(n, m, l, o, p[g + 11], 22, -1990404162); o = md5_ff(o, n, m, l, p[g + 12], 7, 1804660682); l = md5_ff(l, o, n, m, p[g + 13], 12, -40341101); m = md5_ff(m, l, o, n, p[g + 14], 17, -1502002290); n = md5_ff(n, m, l, o, p[g + 15], 22, 1236535329); o = md5_gg(o, n, m, l, p[g + 1], 5, -165796510); l = md5_gg(l, o, n, m, p[g + 6], 9, -1069501632); m = md5_gg(m, l, o, n, p[g + 11], 14, 643717713); n = md5_gg(n, m, l, o, p[g + 0], 20, -373897302); o = md5_gg(o, n, m, l, p[g + 5], 5, -701558691); l = md5_gg(l, o, n, m, p[g + 10], 9, 38016083); m = md5_gg(m, l, o, n, p[g + 15], 14, -660478335); n = md5_gg(n, m, l, o, p[g + 4], 20, -405537848); o = md5_gg(o, n, m, l, p[g + 9], 5, 568446438); l = md5_gg(l, o, n, m, p[g + 14], 9, -1019803690); m = md5_gg(m, l, o, n, p[g + 3], 14, -187363961); n = md5_gg(n, m, l, o, p[g + 8], 20, 1163531501); o = md5_gg(o, n, m, l, p[g + 13], 5, -1444681467); l = md5_gg(l, o, n, m, p[g + 2], 9, -51403784); m = md5_gg(m, l, o, n, p[g + 7], 14, 1735328473); n = md5_gg(n, m, l, o, p[g + 12], 20, -1921207734); o = md5_hh(o, n, m, l, p[g + 5], 4, -378558); l = md5_hh(l, o, n, m, p[g + 8], 11, -2022574463); m = md5_hh(m, l, o, n, p[g + 11], 16, 1839030562); n = md5_hh(n, m, l, o, p[g + 14], 23, -35309556); o = md5_hh(o, n, m, l, p[g + 1], 4, -1530992060); l = md5_hh(l, o, n, m, p[g + 4], 11, 1272893353); m = md5_hh(m, l, o, n, p[g + 7], 16, -155497632); n = md5_hh(n, m, l, o, p[g + 10], 23, -1094730640); o = md5_hh(o, n, m, l, p[g + 13], 4, 681279174); l = md5_hh(l, o, n, m, p[g + 0], 11, -358537222); m = md5_hh(m, l, o, n, p[g + 3], 16, -722881979); n = md5_hh(n, m, l, o, p[g + 6], 23, 76029189); o = md5_hh(o, n, m, l, p[g + 9], 4, -640364487); l = md5_hh(l, o, n, m, p[g + 12], 11, -421815835); m = md5_hh(m, l, o, n, p[g + 15], 16, 530742520); n = md5_hh(n, m, l, o, p[g + 2], 23, -995338651); o = md5_ii(o, n, m, l, p[g + 0], 6, -198630844); l = md5_ii(l, o, n, m, p[g + 7], 10, 11261161415); m = md5_ii(m, l, o, n, p[g + 14], 15, -1416354905); n = md5_ii(n, m, l, o, p[g + 5], 21, -57434055); o = md5_ii(o, n, m, l, p[g + 12], 6, 1700485571); l = md5_ii(l, o, n, m, p[g + 3], 10, -1894446606); m = md5_ii(m, l, o, n, p[g + 10], 15, -1051523); n = md5_ii(n, m, l, o, p[g + 1], 21, -2054922799); o = md5_ii(o, n, m, l, p[g + 8], 6, 1873313359); l = md5_ii(l, o, n, m, p[g + 15], 10, -30611744); m = md5_ii(m, l, o, n, p[g + 6], 15, -1560198380); n = md5_ii(n, m, l, o, p[g + 13], 21, 1309151649); o = md5_ii(o, n, m, l, p[g + 4], 6, -145523070); l = md5_ii(l, o, n, m, p[g + 11], 10, -1120210379); m = md5_ii(m, l, o, n, p[g + 2], 15, 718787259); n = md5_ii(n, m, l, o, p[g + 9], 21, -343485551); o = safe_add(o, j); n = safe_add(n, h); m = safe_add(m, f); l = safe_add(l, e) &#125; return Array(o, n, m, l)&#125;function md5_cmn(h, e, d, c, g, f) &#123; return safe_add(bit_rol(safe_add(safe_add(e, h), safe_add(c, f)), g), d)&#125;function md5_ff(g, f, k, j, e, i, h) &#123; return md5_cmn((f &amp; k) | ((~f) &amp; j), g, f, e, i, h)&#125;function md5_gg(g, f, k, j, e, i, h) &#123; return md5_cmn((f &amp; j) | (k &amp; (~j)), g, f, e, i, h)&#125;function md5_hh(g, f, k, j, e, i, h) &#123; return md5_cmn(f ^ k ^ j, g, f, e, i, h)&#125;function md5_ii(g, f, k, j, e, i, h) &#123; return md5_cmn(k ^ (f | (~j)), g, f, e, i, h)&#125;function core_hmac_md5(c, f) &#123; var e = str2binl(c); if (e.length &gt; 16) &#123; e = core_md5(e, c.length * chrsz) &#125; var a = Array(16), d = Array(16); for (var b = 0; b &lt; 16; b++) &#123; a[b] = e[b] ^ 909522486; d[b] = e[b] ^ 1549556828 &#125; var g = core_md5(a.concat(str2binl(f)), 512 + f.length * chrsz); return core_md5(d.concat(g), 512 + 128)&#125;function safe_add(a, d) &#123; var c = (a &amp; 65535) + (d &amp; 65535); var b = (a &gt;&gt; 16) + (d &gt;&gt; 16) + (c &gt;&gt; 16); return (b &lt;&lt; 16) | (c &amp; 65535)&#125;function bit_rol(a, b) &#123; return (a &lt;&lt; b) | (a &gt;&gt;&gt; (32 - b))&#125;function str2binl(d) &#123; var c = Array(); var a = (1 &lt;&lt; chrsz) - 1; for (var b = 0; b &lt; d.length * chrsz; b += chrsz) &#123; c[b &gt;&gt; 5] |= (d.charCodeAt(b / chrsz) &amp; a) &lt;&lt; (b % 32) &#125; return c&#125;function binl2str(c) &#123; var d = \"\"; var a = (1 &lt;&lt; chrsz) - 1; for (var b = 0; b &lt; c.length * 32; b += chrsz) &#123; d += String.fromCharCode((c[b &gt;&gt; 5] &gt;&gt;&gt; (b % 32)) &amp; a) &#125; return d&#125;function binl2hex(c) &#123; var b = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\"; var d = \"\"; for (var a = 0; a &lt; c.length * 4; a++) &#123; d += b.charAt((c[a &gt;&gt; 2] &gt;&gt; ((a % 4) * 8 + 4)) &amp; 15) + b.charAt((c[a &gt;&gt; 2] &gt;&gt; ((a % 4) * 8)) &amp; 15) &#125; return d&#125;function binl2b64(d) &#123; var c = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; var f = \"\"; for (var b = 0; b &lt; d.length * 4; b += 3) &#123; var e = (((d[b &gt;&gt; 2] &gt;&gt; 8 * (b % 4)) &amp; 255) &lt;&lt; 16) | (((d[b + 1 &gt;&gt; 2] &gt;&gt; 8 * ((b + 1) % 4)) &amp; 255) &lt;&lt; 8) | ((d[b + 2 &gt;&gt; 2] &gt;&gt; 8 * ((b + 2) % 4)) &amp; 255); for (var a = 0; a &lt; 4; a++) &#123; if (b * 8 + a * 6 &gt; d.length * 32) &#123; f += b64pad &#125; else &#123; f += c.charAt((e &gt;&gt; 6 * (3 - a)) &amp; 63) &#125; &#125; &#125; return f&#125;;function get_m_value() &#123; //var timestamp = Date.parse(new Date()) + 100000000; timestamp = '1607657864000' f = hex_md5(timestamp) return f;&#125; 以上获取m=window.f的值 爬虫pip3 install PyExecJS 123456789101112131415161718192021222324252627282930313233343536import timeimport execjsimport requestsdef get_page(page_num,parameters): url = 'http://match.yuanrenxue.com/api/match/1?page=&#123;&#125;&amp;m=&#123;&#125;'.format(page_num,parameters) headers = &#123; 'Host': 'match.yuanrenxue.com', 'Referer': 'http://match.yuanrenxue.com/match/1', 'User-Agent': 'yuanrenxue.project', 'X-Requested-With': 'XMLHttpRequest', 'Cookie': 'qpfccr=true; Hm_lvt_c99546cf032aaa5a679230de9a95c7db=1607556997,1607557857; Hm_lpvt_c99546cf032aaa5a679230de9a95c7db=1607557857; no-alert=true' &#125; response = requests.get(url=url,headers=headers) return response.json()def calculate_m_value(): with open(r'1.js',encoding='utf-8',mode='r') as f: JsData = f.read() psd = execjs.compile(JsData).call('request') psd = psd.replace('丨','%E4%B8%A8') print('this request parameters is :',psd) return psdif __name__ == '__main__': sum_num = 0 index_num = 0 for page_num in range(1,6): res = get_page(page_num,calculate_m_value()) data = [__['value'] for __ in res['data']] print(data) sum_num+=sum(data) index_num += len(data) time.sleep(1) average = sum_num/index_num print('the answer is :',average) 1.js中获取param的函数如下 12345678function request() &#123; var timestamp = Date.parse(new Date()) + 100000000; // timestamp = '1607657864000' f = hex_md5(timestamp+'') var m = f; m = m + '丨' + timestamp / 1000 return m;&#125;","categories":[{"name":"js逆向","slug":"js逆向","permalink":"http://onejane.github.io/categories/js%E9%80%86%E5%90%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"}]},{"title":"博客搭建","slug":"博客搭建","date":"2021-01-31T14:51:49.000Z","updated":"2021-02-23T14:55:51.689Z","comments":true,"path":"2021/01/31/博客搭建/","link":"","permalink":"http://onejane.github.io/2021/01/31/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Hexo12345678https://nodejs.org/download/release/v10.15.3/ 安装nodenpm install -g cnpm --registry=https://registry.npm.taobao.orgnpm config set registry https://registry.npm.taobao.org npm install -g hexo@4.1.1npm install -g hexo-cli@1.3.0 hexo init blog cd blog npm install Melody12345678910111213set http_proxy=http://127.0.0.1:1080set https_proxy=https://127.0.0.1:1080git clone -b master https://github.com/Molunerfinn/hexo-theme-melody themes/melodynpm install hexo-renderer-pug hexo-renderer-styluscp themes\\melody\\_config.yml themes\\melody\\melody.yml 通过git pull 即可更新melodynpm i --save hexo-wordcountnpm i hexo-deployer-git --save 使用git bashnpm install --save-dev gulp@3.9.1npm install -g gulp@3.9.1npm install gulp-imagemin@3.1.1 --savenpm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify --save blog\\package.json 12345\"scripts\": &#123; \"build\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d &amp; git add * &amp; git commit -m 'deploy' &amp; git push origin master\", \"test\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo s\", \"dev\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\" &#125; 通过npm run build 即可自动打包上传发布http://onejane.gitee.io/ 新建Onajane公开项目，hexo d后启用服务的Gitee Pages 新建picture公开项目，上传图片后启动服务的Gitee Pages图床服务，http://onejane.gitee.io/picture/avatar.jpg blog_config.yml 1234567891011121314151617title: Jsubtitle: '朝花夕拾'description: '逆向,爬虫'keywords:author: Jlanguage: zh-Hanstimezone: 'Hongkong'url: https://gitee.com/OneJanetheme: melodypost_asset_folder: true # npm install https://github.com/CodeFalling/hexo-asset-image --save 上传图片到博客deploy: type: git repo: gitee: https://gitee.com/OneJane/OneJane.git github: git@github.com:OneJane/OneJane.github.io.git branch: master message: gitee 评论https://leancloud.cn/dashboard/applist.html#/apps 新建应用获取AppID,AppKey 123456789101112valine: enable: true # if you want use valine,please set this value is true appId: cWLsquGr5PNi33OWXNhzerep-gzGzoHsz # leancloud application app id appKey: S35phfCSbm8dAG9LpOc5rjm3 # leancloud application app key notify: false # valine mail notify (true/false) https://github.com/xCss/Valine/wiki verify: false # valine verify code (true/false) recordip: false # whether record commentor's ip (true/false) pageSize: 10 # comment list page size avatar: mm # gravatar style https://valine.js.org/#/avatar lang: zh-cn # i18n: zh-cn/en placeholder: 一起来吹牛逼好吗！ # valine comment input placeholder(like: Please leave your footprints ) guest_info: nick,mail,link #valine comment header inf 分享123sharejs: enable: true disabled_sites: google,facebook 搜索本地 npm install hexo-generator-search –save 12345local_search: enable: true # or false labels: input_placeholder: Search for Posts hits_empty: \"We didn't find any results for the search: $&#123;query&#125;\" # if there are no result 头像1avatar: http://onejane.gitee.io/picture/avatar.jpg # 网站 Logo 导航菜单1234567891011121314151617181920hexo new page tags修改source/tags/index.md---title: 标签date: 2018-01-05 00:00:00type: \"tags\"---hexo new page categories修改source/categories/index.md---title: 分类date: 2018-01-05 00:00:00type: \"categories\"---修改_config.ymlmenu: 主页: / 归档: /archives 标签: /tags 分类: /categories 自动节选123auto_excerpt: enable: true length: 150 顶部图12top_img_height: 80 top_img: http://onejane.gitee.io/picture/hacker.jpg 在_config.yml和文章中使用 打赏1234567QR_code: - itemlist: img: http://onejane.gitee.io/picture/alipay.png text: 支付宝打赏 - itemlist: img: http://onejane.gitee.io/picture/wx.png text: 微信打赏 广告/音乐播放器123adv: enable: true info: &lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"center\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=572547816&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt; Follow1234follow: enable: true url: 'https://gitee.com/OneJane/' text: 'Follow Me' 友链123links_title: 友链 # 配置友链的标题文字links: OneJane: http://onejane.gitee.io/ 目录1234toc: enable: true # or false number: true # or false. 版本v1.5.6新增 在文章头部加入toc_number: true 页脚1footer_custom_text: Hi, welcome to my &lt;a href=http://onejane.gitee.io/\"&gt;blog&lt;/a&gt;! 配置成hitokoto则是随机的谚语 点击特效1fireworks: true 彩带123456canvas_ribbon: enable: true size: 150 alpha: 0.6 zIndex: -1 click_to_change: false 阅读密码npm install –save hexo-blog-encrypt 123文中标题填入password: blogJmessage: 请联系微信：codewj，获取本文密码","categories":[{"name":"生活","slug":"生活","permalink":"http://onejane.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://onejane.github.io/tags/hexo/"}]},{"title":"逆向环境搭建","slug":"逆向环境搭建","date":"2021-01-31T03:20:05.000Z","updated":"2021-03-01T14:56:12.020Z","comments":true,"path":"2021/01/31/逆向环境搭建/","link":"","permalink":"http://onejane.github.io/2021/01/31/%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Pixel玩逆向必备一台真机，那么非谷歌亲儿子莫属，模拟器缺失native/so层，属于精简版系统，故还是真机香呀。 官网下载pixel 8.1.0镜像，建议刷OPM1.171019.011版本安卓8.1.0 12adb reboot bootloader 或 按住音量向下键和开机键 进入fastboot状态cd sailfish-opm4.171019.021.p1-factory-0bcf4315/sailfish-opm4.171019.021.p1 &amp;&amp; flash-all.sh 开始刷机 设置-关于手机-版本号8下点击-进入开发者模式，进入系统-高级-打开开发者选项-USB调试 123456adb push Magisk-v20.4.zip /sdcard adb push magisk-riru-v21.3.zip /sdcard/Download 使用magisk模块安装并重启adb push magisk-EdXposed-SandHook-v0.4.5.1_beta.4463.-release.zip /sdcard/Download 使用magisk模块安装并重启adb install EdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apk 安装xposedadb push MagiskHidePropsConf-v5.3.4.zip /sdcard/Download adb install JustTrustMePlus-debug.apk 用于结合xposed突破SSL Pinning抓包限制 twrp作为第三方刷机工具，刷入Magisk，nethunter等魔改系统。 fastboot flash recovery twrp-3.3.0-0-angler.img 12345678adb reboot bootloaderfastboot boot twrp-3.4.0-0-sailfish.img 进入recovery modeinstall Magisk-v20.4.zipadb install MagiskManager-v7.5.1.apksettings put global captive_portal_http_url https://www.google.cn/generate_204 去除wifi上的×settings put global captive_portal_https_url https://www.google.cn/generate_204settings put global ntp_server 1.hk.pool.ntp.org 修改时区reboot linux下载最新的platform-tools刷机的时候，fastboot会报各种unknow command或接近的错误，把fastboot文件替换成随着aosp一起编译出来的即可,使用自行编译的fastboot即可。 123rm ~&#x2F;Android&#x2F;Sdk&#x2F;platform-tools&#x2F;fastbootcp fastboot810r1 fastbootfastboot --version 通过wifi连接adb可实现群控adb -s 192.168.0.104:5555 install com.ttxapps.wifiadb_2.1.3-810031745_minAPI15(nodpi)_apkmirror.com.apk 安装apk adb connect 192.168.0.104:5555 使用adb连接手机 termux adb -s 192.168.0.104:5555 install com.termux_92.apk adb被禁时在app端使用命令行操作 pkg update &amp;&amp; pkg install htop 在app端安装管理进程的包 xdebuggable &amp;&amp; XAppDebug启动EdXposed,搜索xdebuggable 和XAppDebug模块并安装开启debug apk(需要借助ssr科学上网) ro.debuggable adb push MagiskHidePropsConf-v5.3.4.zip /sdcard/Download 并通过Magisk Manager-模块-下载-安装MagiskHidePropsConf-v5.3.4.zip reboot-adb shell-props 123456789101112131415161718192021222324252627282930313233343536373839404142434445461 - Edit device fingerprint2 - Force BASIC key attestation3 - Device simulation (disabled)4 - Edit MagiskHide props5 - Add&#x2F;edit custom props6 - Delete prop values7 - Script settings8 - Collect logsu - Perform module update checkr - Reset all options&#x2F;settingsb - Reboot devicee - ExitSee the module readme or thesupport thread @ XDA for details.Enter your desired option: 41 - ro.debuggable2 - ro.secure3 - ro.build.type4 - ro.build.tags5 - ro.bootmode6 - ro.boot.modea - Change all propsb - Go back to main menue - ExitPick several options at once byseparating inputs with a comma.Example: 1,3,4See the module readme or thesupport thread @ XDA for details.Enter your desired option: 1You currently have the safe value set.Are you sure you want to change it to 1?Enter y(es), n(o) or e(xit): yDo you want to reboot now (y&#x2F;n)?Enter y(es), n(o) or e(xit): y getprop ro.debuggable 即可查看1,开启全局可调式 Genymotion安装全程开全局代理，安装nexus 5x 8.0network mode选择Bridge或者在virtualbox中修改网络为桥接，如virtualbox网络连接里没有桥接网卡选择修改D:\\VirtualBox\\drivers\\network\\netlwf\\VBoxNetLwf.infsettings-system-Languages&amp;input-Languages-Add a language-简体中文 adb 无法连接genymotion怎么办？ 修改genymotion的settings，Use custom Android SDK tools为本地android sdk路径adb kill-server + adb start-server 重启adb安装wifiadb后即可，默认可以连接192网段，配置桥接，可adb connect 192.168.0.104:5555 arm桥接 uname -a i686 查看cpu架构为x86 32位 不支持arm，需要安装arm桥，直接将 Genymotion-ARM-Translation_for_8.0.zip拖入nexus 5x 8.0, 进行安装adb reboot 即可安装带有arm的so的apk Kali别用Windows了，鲁迅曾经说过，他在逆向生涯中超过一半的苦难均由Windows赐予。 vmware安装文件 秘钥：YC34H-6WWDK-085MQ-JYPNX-NZRA2 kali-linux-2020.4-vmware-amd64.7z种子，使用vmware打开vmx文件，配置6g内存，80g磁盘存储，网络适配选择桥接到本地网卡(虚拟网络编辑器)，默认账密：kali/kali，sudo passwd root 修改密码123456 重启后使用root登录，android-studio-ide-201.7042882-linux.tar.gz安装包~/.cache/vmware/drag_and_drop 定期删除拷贝的文件缓存 基本配置12345apt update;apt install htop jnettop tmux iotopdpkg-reconfigure tzdata 选择Asia-Shanghai apt update 更新自动同步时间apt install xfonts-intl-chinese 装中文字体apt-get install ttf-wqy-microhei 常用软件1234567tar zxf android-studio-ide-201.7042882-linux.tar.gzcd ~/Desktop/android-studio/bin &amp;&amp; ./studio.sh 启动android studioctrl+shift+t 当前窗口新建终端vim ~/.zshrcexport PATH=\"/root/Android/Sdk/platform-tools:$PATH\" 加入环境变量exec \"$SHELL\"dpkg -i code_1.52.1-1608136922_amd64.deb 安装vscode as若报错To build this project, accept the SDK license agreements and install the missing components？ 执行/root/Android/Sdk/tools/bin/sdkmanager –licenses Android设备投屏 NodeJs 123curl -fsSL https://deb.nodesource.com/setup_14.x | bash -apt-get install -y nodejsnpm install --save @types/frida-gum frida代码提示 jeb-pro-3.19.1.202005071620_pwd_ilbtcdnwiuypbzeo_.7z 运行./jeb_linux.sh，输入密码：ilbtcdnwiuypbzeo，进入界面点击Manual Key Generation中间按钮获取LICENSE DATA，运行jebKeygen.py 获取license key后输入到界面的key中，continue Kali Linux里的as4的DDMS启动失败，原因是要用as自带的jre来启动，直接./monitor用的是Kali系统的jdk，版本太高了ln -s /root/Desktop/android-studio/jre/ /root/Android/Sdk/tools/lib/monitor-x86_64/,然后通过~/Android/Sdk/tools/monitor打开ddms vim ~/.bashrc &amp;&amp; source ~/.bashrc export PATH=$PATH:/root/Android/Sdk/platform-tools jdk1.8 123456789101112apt-get remove openjdk-11-jre-headless:amd64apt-get remove openjdk-11-jre:amd64tar zxf jdk-8u191-linux-x64.tar.gz -C &#x2F;opt&#x2F;jdkvim ~&#x2F;.zshrcexport JAVA_HOME&#x3D;&#x2F;opt&#x2F;jdkexport CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;libexport PATH&#x3D;&quot;&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;ndk-bundle:&#x2F;root&#x2F;Android&#x2F;Sdk&#x2F;platform-tools:$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH&quot;source ~&#x2F;.zshrcupdate-alternatives --install &#x2F;usr&#x2F;bin&#x2F;java java &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;java 1update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;javac javac &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;javac 1update-alternatives --set java &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;javaupdate-alternatives --set javac &#x2F;opt&#x2F;jdk&#x2F;bin&#x2F;javac nexus 5x 安装流程 twrp-&gt;SuperSu-&gt; nethunter kali nethunter下载nexus 5x nethunter，使用投屏可变成一个迷你的linux渗透系统，通过twrp进行install ，sh userinit.sh 同步时间 tab smali与java代码转换 ctrl+b 下断点（注意这个必须在smali代码界面才有用） esc 回退上一级引用 activity_main.xml中配置的view组件：jeb中以十六进制存在于代码中，利用计算器的程序员模式转为十进制，jadx将该十进制存入resources.arsc，gda有APK入口直接进入MainActivity，同样以十六进制存入代码中。 科学上网dpkg -i electron-ssr-0.2.6.deb 卸载使用-r，查询使用-l ,失败缺少包，经过https://pkgs.org/ 查找所缺的包并安装 123456apt --fix-broken installapt-get install gconf2dpkg -i libdbusmenu-gtk4_18.10.20180917_bzr492+repack1-2_amd64.deb dpkg -i libindicator7_0.5.0-4_amd64.deb dpkg -i libappindicator1_0.4.92-8_amd64.debdpkg -i electron-ssr-0.2.6.deb 启动electron-ssr的pac模式即可vim /etc/proxychains4.conf 通过右键复制SSR服务器订阅代理设置 1http 127.0.0.1 12333 基本命令 getprop ro.product.cpu.abi 判断系统cpu版本 虚拟机一般都是x86 dumpsys meminfo pid 查看进程占用内存映射的信息 cat /proc/pid/maps 进程加载的so cat /proc/pid/maps | grep -i libart.so 所有java代码通过libart.so解析，脱壳机的关键 dumpsys activity top 显示当前的Activity，显示View Hierarchy，看view的类信息 dumpsys package com.soviet.hook4crawler 查看运行包信息 pm list packages 查看所有安装的包 pyenv环境对python不同包(frida,objection…)多版本管理 3.8.512345678910111213ctrl+alt+t 新建终端git clone https://github.com/pyenv/pyenv.git ~/.pyenv 安装pyenv，python全版本随意切echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' &gt;&gt; ~/.zshrcecho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' &gt;&gt; ~/.zshrcecho -e 'if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\\n eval \"$(pyenv init -)\"\\nfi' &gt;&gt; ~/.zshrcexec \"$SHELL\"apt-get update; apt-get install --no-install-recommends make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-devPYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pyenv install 3.8.5 使用代理访问，不然会报错you can specify \"--disable-ipv6\".pyenv local 3.8.5python -Vpyenv local system 切换原系统pyenvpip install frida-toolsproxychains4 pip install objection==1.9.5 针对指定frida版本的objection，通过pypi中查找frida release日期稍后一点版本的objection即可7x x frida-server-14.2.8-android-arm64.xz 123456adb push frida-server-14.2.8-android-arm64 /data/local/tmpmv frida-server-14.2.8-android-arm64 fs1428arm64 改名fs1428arm64,防止反调试chmod 777 fs1428arm64 加权./fs1428arm64frida-ps -Uandroid hooking list classes 3.8.0123456PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pyenv install 3.8.0 pyenv local 3.8.0 PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pip install frida==12.8.0PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pip install frida-tools==5.3.0PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains4 pip install objection==1.8.4objection -g com.android.settings explore 7z x frida-server-12.8.0-android-arm64 12345adb push frida-server-12.8.0-android-arm64 /data/local/tmpmv frida-server-12.8.0-android-arm64 fs128arm64 改名防止反调试chmod 777 frida-server-12.8.0-android-arm64objection -g com.android.settings exploreandroid hooking list classes 特定版本frida 按照这个顺序，在装objection的时候，就会直接Requirement already satisfied，不会再去下载新的frida来安装了。 123pip install frida&#x3D;&#x3D;12.8.0 pip install frida-tools&#x3D;&#x3D;5.3.0 pip install objection&#x3D;&#x3D;1.8.4 frida开发环境 pyenv local 3.8.0 &amp;&amp; ./fs128arm64 git clone https://github.com/oleavr/frida-agent-example.git cd frida-agent-example/ npm install 使用VSCode等IDE打开此工程，在agent下编写typescript，会有智能提示。 npm run watch会监控代码修改自动编译生成js文件 frida -UF -l demo.js usb连接手机保存将自动调用demo.js 进行hook Java.perform(function(){console.log(&quot;frida hook&quot;)}) frida -UF -l demo.js –runtime=v8 使用v8引擎 Java.perform(()=&gt;{console.log(&quot;Hello World&quot;)}) frida-ps -U 查看所有进程 frida -H 192.168.0.100:5555 -f com.ttxapps.wifiadb -l demo.js –runtime=v8 远程hook,-l指定脚本 frida -Uf com.android.settings -l demo.js –runtime=v8 –no-pause 经过usb主动启动应用调用demo.js,-f是spawn模式,–no-pause直接加载应用，没有的话需要%resume启动主线程 frida -UF –runtime=v8 -e “Java.perform(()=&gt;{console.log(‘Hello World’)})” -o /root/log.txt 直接执行脚本写入文件 远程连接 ./fs128arm64 -v -l 0.0.0.0:8888 指定端口启动frida，默认端口27042 frida-ps -H 192.168.0.8:8888 指定-U表示usb,-H表示主机ip frida -H 192.168.0.8:8888 -F 指定-H表示主机ip，-F表示前台应用，输入frida即可查看Frida信息 cd frida-agent-example/ &amp;&amp; npm install &amp;&amp; npm run watch &amp;&amp; frida -H 192.168.0.8:8888 -F -l agent/demo.js 远程调用js脚本 1234567Java.perform(()&#x3D;&gt;&#123;console.log(&quot;Hello World&quot;)&#125;) function main()&#123; Java.perform(function()&#123; console.log(&quot;hello&quot;) &#125;)&#125;setImmediate(main) 远程调用 12345678910111213import fridadevice &#x3D; frida.get_usb_device() print(device.get_frontmost_application())#pid &#x3D; device.spawn([&quot;com.onejane.demo02&quot;])pid&#x3D;device.get_frontmost_application().pid # 若双进程保护，指定pid进行hook print(device.enumerate_processes()) # 枚举所有进程print(device.enumerate_applications()) # 枚举所有包名# device.resume(pid)# time.sleep(1)session &#x3D; device.attach(pid) with open(&quot;demo.js&quot;) as f: script &#x3D; session.create_script(f.read())script.load() plugins 1234proxychains git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;FRIDA-DEXDump ~&#x2F;Downloads&#x2F;FRIDA-DEXDump 脱壳mv ~&#x2F;Downloads&#x2F;FRIDA-DEXDump&#x2F;frida_dexdump ~&#x2F;.objection&#x2F;plugins&#x2F;dexdump 在plugins子目录插件下必须有__init__.pyproxychains git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;Wallbreaker ~&#x2F;.objection&#x2F;plugins&#x2F;Wallbreaker 内存漫游objection -N -h 192.168.0.8 -p 8888 -g com.android.settings explore -P ~&#x2F;.objection&#x2F;plugins 远程连接批量加载插件","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"tags":[{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"kali","slug":"kali","permalink":"http://onejane.github.io/tags/kali/"},{"name":"xposed","slug":"xposed","permalink":"http://onejane.github.io/tags/xposed/"}]}],"categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"爬虫基础","slug":"爬虫基础","permalink":"http://onejane.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"},{"name":"JS逆向","slug":"JS逆向","permalink":"http://onejane.github.io/categories/JS%E9%80%86%E5%90%91/"},{"name":"加壳与脱壳","slug":"安卓逆向/加壳与脱壳","permalink":"http://onejane.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"},{"name":"架构","slug":"架构","permalink":"http://onejane.github.io/categories/%E6%9E%B6%E6%9E%84/"},{"name":"脚本","slug":"脚本","permalink":"http://onejane.github.io/categories/%E8%84%9A%E6%9C%AC/"},{"name":"js逆向","slug":"js逆向","permalink":"http://onejane.github.io/categories/js%E9%80%86%E5%90%91/"},{"name":"生活","slug":"生活","permalink":"http://onejane.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"postern","slug":"postern","permalink":"http://onejane.github.io/tags/postern/"},{"name":"selenium","slug":"selenium","permalink":"http://onejane.github.io/tags/selenium/"},{"name":"js","slug":"js","permalink":"http://onejane.github.io/tags/js/"},{"name":"frida","slug":"frida","permalink":"http://onejane.github.io/tags/frida/"},{"name":"scrapy","slug":"scrapy","permalink":"http://onejane.github.io/tags/scrapy/"},{"name":"scrapy_redis","slug":"scrapy-redis","permalink":"http://onejane.github.io/tags/scrapy-redis/"},{"name":"mongo","slug":"mongo","permalink":"http://onejane.github.io/tags/mongo/"},{"name":"asyncore","slug":"asyncore","permalink":"http://onejane.github.io/tags/asyncore/"},{"name":"socket","slug":"socket","permalink":"http://onejane.github.io/tags/socket/"},{"name":"asyncio","slug":"asyncio","permalink":"http://onejane.github.io/tags/asyncio/"},{"name":"websocket","slug":"websocket","permalink":"http://onejane.github.io/tags/websocket/"},{"name":"requests","slug":"requests","permalink":"http://onejane.github.io/tags/requests/"},{"name":"pymongo","slug":"pymongo","permalink":"http://onejane.github.io/tags/pymongo/"},{"name":"flask","slug":"flask","permalink":"http://onejane.github.io/tags/flask/"},{"name":"xpath","slug":"xpath","permalink":"http://onejane.github.io/tags/xpath/"},{"name":"css","slug":"css","permalink":"http://onejane.github.io/tags/css/"},{"name":"json","slug":"json","permalink":"http://onejane.github.io/tags/json/"},{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","permalink":"http://onejane.github.io/tags/ThreadPoolExecutor/"},{"name":"BoundedSemaphore","slug":"BoundedSemaphore","permalink":"http://onejane.github.io/tags/BoundedSemaphore/"},{"name":"parsel","slug":"parsel","permalink":"http://onejane.github.io/tags/parsel/"},{"name":"classloader","slug":"classloader","permalink":"http://onejane.github.io/tags/classloader/"},{"name":"Dalvik","slug":"Dalvik","permalink":"http://onejane.github.io/tags/Dalvik/"},{"name":"ART","slug":"ART","permalink":"http://onejane.github.io/tags/ART/"},{"name":"Socket","slug":"Socket","permalink":"http://onejane.github.io/tags/Socket/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://onejane.github.io/tags/WebSocket/"},{"name":"Protobuf","slug":"Protobuf","permalink":"http://onejane.github.io/tags/Protobuf/"},{"name":"XMPP","slug":"XMPP","permalink":"http://onejane.github.io/tags/XMPP/"},{"name":"nacos","slug":"nacos","permalink":"http://onejane.github.io/tags/nacos/"},{"name":"feign","slug":"feign","permalink":"http://onejane.github.io/tags/feign/"},{"name":"gateway","slug":"gateway","permalink":"http://onejane.github.io/tags/gateway/"},{"name":"sentinel","slug":"sentinel","permalink":"http://onejane.github.io/tags/sentinel/"},{"name":"okhttp3","slug":"okhttp3","permalink":"http://onejane.github.io/tags/okhttp3/"},{"name":"HttpURLConnection","slug":"HttpURLConnection","permalink":"http://onejane.github.io/tags/HttpURLConnection/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://onejane.github.io/tags/Retrofit/"},{"name":"python","slug":"python","permalink":"http://onejane.github.io/tags/python/"},{"name":"fart","slug":"fart","permalink":"http://onejane.github.io/tags/fart/"},{"name":"vmp","slug":"vmp","permalink":"http://onejane.github.io/tags/vmp/"},{"name":"dex2c","slug":"dex2c","permalink":"http://onejane.github.io/tags/dex2c/"},{"name":"rpc","slug":"rpc","permalink":"http://onejane.github.io/tags/rpc/"},{"name":"objection","slug":"objection","permalink":"http://onejane.github.io/tags/objection/"},{"name":"hexo","slug":"hexo","permalink":"http://onejane.github.io/tags/hexo/"},{"name":"kali","slug":"kali","permalink":"http://onejane.github.io/tags/kali/"},{"name":"xposed","slug":"xposed","permalink":"http://onejane.github.io/tags/xposed/"}]}