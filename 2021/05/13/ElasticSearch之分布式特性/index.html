<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="ElasticSearch之分布式特性"><meta name="keywords" content="elasticsearch"><meta name="author" content="J"><meta name="copyright" content="J"><title>ElasticSearch之分布式特性 | J</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?a345f534c85363668f09d4d5c6a9ee81";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-111479568-4","auto"),ga("send","pageview")</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer="defer"></script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},hexoVersion:"4.1.1"}</script><meta name="generator" content="Hexo 4.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#shard-amp-replica机制"><span class="toc-number">1.</span> <span class="toc-text">shard&amp;replica机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单node创建index"><span class="toc-number">2.</span> <span class="toc-text">单node创建index</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双node分配shard"><span class="toc-number">3.</span> <span class="toc-text">双node分配shard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#横向扩容"><span class="toc-number">4.</span> <span class="toc-text">横向扩容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容错机制"><span class="toc-number">5.</span> <span class="toc-text">容错机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#元数据"><span class="toc-number">6.</span> <span class="toc-text">元数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#document-id"><span class="toc-number">7.</span> <span class="toc-text">document_id</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#source"><span class="toc-number">8.</span> <span class="toc-text">_source</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#批量查询"><span class="toc-number">9.</span> <span class="toc-text">批量查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bulk批量增删改"><span class="toc-number">10.</span> <span class="toc-text">bulk批量增删改</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bulk-api奇特的json格式"><span class="toc-number">10.1.</span> <span class="toc-text">bulk api奇特的json格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更新"><span class="toc-number">11.</span> <span class="toc-text">更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全量替换"><span class="toc-number">11.1.</span> <span class="toc-text">全量替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部更新"><span class="toc-number">11.2.</span> <span class="toc-text">局部更新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原理"><span class="toc-number">11.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实战partial-update"><span class="toc-number">11.2.2.</span> <span class="toc-text">实战partial update</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#groovy实现partial-update"><span class="toc-number">11.2.3.</span> <span class="toc-text">groovy实现partial update</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强制创建"><span class="toc-number">11.3.</span> <span class="toc-text">强制创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除"><span class="toc-number">11.4.</span> <span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发冲突"><span class="toc-number">12.</span> <span class="toc-text">并发冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#悲观锁与乐观锁方案"><span class="toc-number">12.1.</span> <span class="toc-text">悲观锁与乐观锁方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#version乐观锁实战"><span class="toc-number">12.2.</span> <span class="toc-text">_version乐观锁实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#external-version乐观锁实战"><span class="toc-number">12.3.</span> <span class="toc-text">external version乐观锁实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#partial-update内置乐观锁并发控制"><span class="toc-number">12.4.</span> <span class="toc-text">partial update内置乐观锁并发控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#document原理"><span class="toc-number">13.</span> <span class="toc-text">document原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#路由"><span class="toc-number">13.1.</span> <span class="toc-text">路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增删改"><span class="toc-number">13.2.</span> <span class="toc-text">增删改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查"><span class="toc-number">13.3.</span> <span class="toc-text">查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#quorum"><span class="toc-number">14.</span> <span class="toc-text">quorum</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://onejane.gitee.io/picture/avatar.jpg"></div><div class="author-info__name text-center">J</div><div class="author-info__description text-center">逆向,爬虫</div><div class="follow-button"><a href="https://github.com/OneJane/" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">55</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">55</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://blog.csdn.net/welggy" target="_blank" rel="noopener">OneJane</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(http://onejane.gitee.io/picture/kali.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">J</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i> <span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a></span></div><div id="post-info"><div id="post-title">ElasticSearch之分布式特性</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">7.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 28 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote><p>Elasticsearch是一套分布式的系统，分布式是为了应对大数据量，隐藏了复杂的分布式机制，实现了分片机制(数据插入分配不同的shard中)，集群发现机制(启动多个es进程自动发现集群并加入且接受部分数据当做副本)，shard负载均衡机制(增减节点时，多节点条件下es自动进行均匀分配，保持每个节点均衡读写负载请求)，shard副本机制(请求路由，集群扩容，shard重分配)。master节点实现创建或删除索引，增加或删除节点。节点对等，每个节点都能接收所有的请求，自动请求路由，响应收集。</p></blockquote><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210525152751946.png" alt="image-20210525152751946"></p><p>ES就是一个分布式的文档数据存储系统。</p><ul><li>文档数据：es可以存储和操作json文档类型的数据，而且这也是es的核心数据结构。</li><li>存储系统：es可以对json文档类型的数据进行存储，查询，创建，更新，删除，等等操作。其实ES满足了这些功能，就可以说已经是一个NoSQL的存储系统了。</li></ul><p>场景：</p><ul><li>数据量较大，es的分布式本质，可以帮助你快速进行扩容，承载大量数据</li><li>数据结构灵活多变，随时可能会变化，而且数据结构之间的关系，非常复杂，如果我们用传统数据库，那是不是很坑，因为要面临大量的表</li><li>对数据的相关操作，较为简单，比如就是一些简单的增删改查，用我们之前讲解的那些document操作就可以搞定</li><li>NoSQL数据库，适用的也是类似于上面的这种场景</li></ul><h2 id="shard-amp-replica机制"><a href="#shard-amp-replica机制" class="headerlink" title="shard&amp;replica机制"></a>shard&amp;replica机制</h2><ol><li>index包含多个shard</li><li>每个shard都是一个最小工作单元，承载部分数据，lucene实例，完整的建立索引和处理请求的能力</li><li>增减节点时，shard会自动在nodes中负载均衡,6个节点，7个shard，其中一个节点2个shard,进入新节点时，自动将shard负载均匀分配到所有节点。</li><li>primary shard和replica shard，每个document肯定只存在于某一个primary shard以及其对应的replica shard中，不可能存在于多个primary shard</li><li>replica shard是primary shard的副本，负责容错，以及承担读请求负载</li><li>primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改</li><li>primary shard的默认数量是5，replica默认是1，默认有10个shard，5个primary shard，5个replica shard</li><li>primary shard不能和自己的replica shard放在同一个节点上（否则节点宕机，primary shard和副本都丢失，起不到容错的作用），但是可以和其他primary shard的replica shard放在同一个节点上</li></ol><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/shard&replica%E6%9C%BA%E5%88%B6%E5%86%8D%E6%AC%A1%E6%A2%B3%E7%90%86.png" alt="shard&amp;replica机制再次梳理"></p><h2 id="单node创建index"><a href="#单node创建index" class="headerlink" title="单node创建index"></a>单node创建index</h2><ol><li>单node环境下，创建一个index，有3个primary shard，3个replica shard</li><li>集群status是yellow</li><li>这个时候，只会将3个primary shard分配到仅有的一个node上去，另外3个replica shard是无法分配的</li><li>集群可以正常工作，但是一旦出现节点宕机，数据全部丢失，而且集群不可用，无法承接任何请求</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;test_index</span><br><span class="line">&#123;</span><br><span class="line">   &quot;settings&quot; : &#123;</span><br><span class="line">      &quot;number_of_shards&quot; : 3,</span><br><span class="line">      &quot;number_of_replicas&quot; : 1</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双node分配shard"><a href="#双node分配shard" class="headerlink" title="双node分配shard"></a>双node分配shard</h2><ol><li>replica shard分配：master(3个primary shard)，slave(3个replica shard)，新增1个node</li><li>primary ---&gt; replica同步</li><li>读请求：primary/replica</li></ol><h2 id="横向扩容"><a href="#横向扩容" class="headerlink" title="横向扩容"></a>横向扩容</h2><ol><li>primary&amp;replica自动负载均衡，6个shard，3 primary，3 replica</li><li>每个node有更少的shard，IO/CPU/Memory资源给每个shard分配更多，每个shard性能更好</li><li>扩容的极限，6个shard（3 primary，3 replica），最多扩容到6台机器，每个shard可以占用单台服务器的所有资源，性能最好</li><li>超出扩容极限，动态修改replica数量，9个shard（3primary，6 replica），扩容到9台机器，比3台机器时，拥有3倍的读吞吐量</li><li>3台机器下，9个shard（3 primary，6 replica），资源更少，但是容错性更好，最多容纳2台机器宕机，6个shard只能容纳0台机器宕机</li></ol><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210514171113961.png" alt="image-20210514171113961"></p><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="扩容过程分析"></p><h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><ol><li>9 shard，3 node</li><li>master node宕机，自动master选举，red</li><li>replica容错：新master将replica提升为primary shard，yellow</li><li>重启宕机node，master copy replica到该node，使用原有的shard并同步宕机后的修改，green</li></ol><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210514192317121.png" alt="image-20210514192317121"></p><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;test_indx&#x2F;test_type&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;test_content&quot;: &quot;test test&quot;</span><br><span class="line">&#125;</span><br><span class="line">GET  &#x2F;test_indx&#x2F;test_type&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;test_index&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;test_type&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot;: 1,</span><br><span class="line">  &quot;found&quot;: true,</span><br><span class="line">  &quot;_source&quot;: &#123;</span><br><span class="line">    &quot;test_content&quot;: &quot;test test&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>_index元数据</li></ol><p>（1）代表一个document存放在哪个index中<br>（2）类似的数据放在一个索引，非类似的数据放不同索引：product index（包含了所有的商品），sales index（包含了所有的商品销售数据），inventory index（包含了所有库存相关的数据）。如果你把比如product，sales，human resource（employee），全都放在一个大的index里面，比如说company index，不合适的。<br>（3）index中包含了很多类似的document：类似是什么意思，其实指的就是说，这些document的fields很大一部分是相同的，你说你放了3个document，每个document的fields都完全不一样，这就不是类似了，就不太适合放到一个index里面去了。<br>（4）索引名称必须是小写的，不能用下划线开头，不能包含逗号：product，website，blog</p><ol start="2"><li>_type元数据</li></ol><p>（1）代表document属于index中的哪个类别（type）<br>（2）一个索引通常会划分为多个type，逻辑上对index中有些许不同的几类数据进行分类：因为一批相同的数据，可能有很多相同的fields，但是还是可能会有一些轻微的不同，可能会有少数fields是不一样的，举个例子，就比如说，商品，可能划分为电子商品，生鲜商品，日化商品，等等。<br>（3）type名称可以是大写或者小写，但是同时不能用下划线开头，不能包含逗号</p><ol start="3"><li>_id元数据</li></ol><p>（1）代表document的唯一标识，与index和type一起，可以唯一标识和定位一个document<br>（2）我们可以手动指定document的id（put /index/type/id），也可以不指定，由es自动为我们创建一个id</p><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210514193728892.png" alt="image-20210514193728892"></p><h2 id="document-id"><a href="#document-id" class="headerlink" title="document_id"></a>document_id</h2><ol><li>手动指定document id</li></ol><p>一般来说，是从某些其他的系统中，导入一些数据到es时，会采取这种方式，就是使用系统中已有数据的唯一标识，作为es中document的id。举个例子，比如说，我们现在在开发一个电商网站，做搜索功能，或者是OA系统，做员工检索功能。这个时候，数据首先会在网站系统或者IT系统内部的数据库中，会先有一份，此时就肯定会有一个数据库的primary key（自增长，UUID，或者是业务编号）。如果将数据导入到es中，此时就比较适合采用数据在数据库中已有的primary key。</p><p>如果说，我们是在做一个系统，这个系统主要的数据存储就是es一种，也就是说，数据产生出来以后，可能就没有id，直接就放es一个存储，那么这个时候，可能就不太适合说手动指定document id的形式了，因为你也不知道id应该是什么，此时可以采取下面要讲解的让es自动生成id的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;test_index&#x2F;test_type&#x2F;2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;test_content&quot;: &quot;my test&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>自动生成document id</li></ol><p>（1）post /index/type</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;test_index&#x2F;test_type</span><br><span class="line">&#123;</span><br><span class="line">  &quot;test_content&quot;: &quot;my test&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;test_index&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;test_type&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;AVp4RN0bhjxldOOnBxaE&quot;,</span><br><span class="line">  &quot;_version&quot;: 1,</span><br><span class="line">  &quot;result&quot;: &quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 2,</span><br><span class="line">    &quot;successful&quot;: 1,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;created&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）自动生成的id，长度为20个字符，URL安全，base64编码，GUID，分布式系统并行生成时不可能会发生冲突</p><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210514194511913.png" alt="image-20210514194511913"></p><h2 id="source"><a href="#source" class="headerlink" title="_source"></a>_source</h2><p>_source元数据：就是说，我们在创建一个document的时候，使用的那个放在request body中的json串，默认情况下，在get的时候，会原封不动的给我们返回回来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">put &#x2F;test_index&#x2F;test_type&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;test_field1&quot;: &quot;test field1&quot;,</span><br><span class="line">  &quot;test_field2&quot;: &quot;test field2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get &#x2F;test_index&#x2F;test_type&#x2F;1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;test_index&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;test_type&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot;: 2,</span><br><span class="line">  &quot;found&quot;: true,</span><br><span class="line">  &quot;_source&quot;: &#123;</span><br><span class="line">    &quot;test_field1&quot;: &quot;test field1&quot;,</span><br><span class="line">    &quot;test_field2&quot;: &quot;test field2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定制返回的结果，指定_source中，返回哪些field,<code>GET /test_index/test_type/1?_source=test_field1,test_field2</code></p><h2 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h2><p>就是一条一条的查询，比如说要查询100条数据，那么就要发送100次网络请求，这个开销还是很大的<br>如果进行批量查询的话，查询100条数据，就只要发送1次网络请求，网络请求的性能开销缩减100倍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;test_index&#x2F;test_type&#x2F;1</span><br><span class="line">GET &#x2F;test_index&#x2F;test_type&#x2F;2</span><br><span class="line">GET &#x2F;_mget            mget批量查询</span><br><span class="line">&#123;</span><br><span class="line">   &quot;docs&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_index&quot; : &quot;test_index&quot;,</span><br><span class="line">         &quot;_type&quot; :  &quot;test_type&quot;,</span><br><span class="line">         &quot;_id&quot; :    1</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_index&quot; : &quot;test_index&quot;,</span><br><span class="line">         &quot;_type&quot; :  &quot;test_type&quot;,</span><br><span class="line">         &quot;_id&quot; :    2</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line">GET &#x2F;test_index&#x2F;_mget      查询的document是一个index下的不同type</span><br><span class="line">&#123;</span><br><span class="line">   &quot;docs&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_type&quot; :  &quot;test_type&quot;,</span><br><span class="line">         &quot;_id&quot; :    1</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_type&quot; :  &quot;test_type&quot;,</span><br><span class="line">         &quot;_id&quot; :    2</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line">GET &#x2F;test_index&#x2F;test_type&#x2F;_mget  查询的数据都在同一个index下的同一个type</span><br><span class="line">&#123;</span><br><span class="line">   &quot;ids&quot;: [1, 2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以说mget是很重要的，一般来说，在进行查询的时候，如果一次性要查询多条数据的话，那么一定要用batch批量操作的api，尽可能减少网络开销次数，可能可以将性能提升数倍，甚至数十倍。</p><h2 id="bulk批量增删改"><a href="#bulk批量增删改" class="headerlink" title="bulk批量增删改"></a>bulk批量增删改</h2><p>bulk api对json的语法，有严格的要求，每个json串不能换行，只能放一行，同时一个json串和一个json串之间，必须有一个换行</p><ol><li>delete：删除一个文档，只要1个json串就可以了</li><li>create：PUT /index/type/id/_create，强制创建</li><li>index：普通的put操作，可以是创建文档，也可以是全量替换文档</li><li>update：执行的partial update操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;_bulk</span><br><span class="line">&#123; &quot;delete&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;3&quot; &#125;&#125; </span><br><span class="line">&#123; &quot;create&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;12&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;test_field&quot;:    &quot;test12&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;:  &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;2&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;test_field&quot;:    &quot;replaced test2&quot; &#125;</span><br><span class="line">&#123; &quot;update&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_retry_on_conflict&quot; : 3&#125; &#125;</span><br><span class="line">&#123; &quot;doc&quot; : &#123;&quot;test_field2&quot; : &quot;bulk test1&quot;&#125; &#125;</span><br></pre></td></tr></table></figure><p>bulk操作中，任意一个操作失败，是不会影响其他的操作的，但是在返回结果里，会告诉你异常日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;test_index&#x2F;_bulk</span><br><span class="line">&#123; &quot;delete&quot;: &#123; &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;3&quot; &#125;&#125; </span><br><span class="line">&#123; &quot;create&quot;: &#123; &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;12&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;test_field&quot;:    &quot;test12&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;:  &#123; &quot;_type&quot;: &quot;test_type&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;test_field&quot;:    &quot;auto-generate id test&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;:  &#123; &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;2&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;test_field&quot;:    &quot;replaced test2&quot; &#125;</span><br><span class="line">&#123; &quot;update&quot;: &#123; &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_retry_on_conflict&quot; : 3&#125; &#125;</span><br><span class="line">&#123; &quot;doc&quot; : &#123;&quot;test_field2&quot; : &quot;bulk test1&quot;&#125; &#125;</span><br><span class="line"></span><br><span class="line">POST &#x2F;test_index&#x2F;test_type&#x2F;_bulk</span><br><span class="line">&#123; &quot;delete&quot;: &#123; &quot;_id&quot;: &quot;3&quot; &#125;&#125; </span><br><span class="line">&#123; &quot;create&quot;: &#123; &quot;_id&quot;: &quot;12&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;test_field&quot;:    &quot;test12&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;:  &#123; &#125;&#125;</span><br><span class="line">&#123; &quot;test_field&quot;:    &quot;auto-generate id test&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;:  &#123; &quot;_id&quot;: &quot;2&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;test_field&quot;:    &quot;replaced test2&quot; &#125;</span><br><span class="line">&#123; &quot;update&quot;: &#123; &quot;_id&quot;: &quot;1&quot;, &quot;_retry_on_conflict&quot; : 3&#125; &#125;</span><br><span class="line">&#123; &quot;doc&quot; : &#123;&quot;test_field2&quot; : &quot;bulk test1&quot;&#125; &#125;</span><br></pre></td></tr></table></figure><p>bulk request会加载到内存里，如果太大的话，性能反而会下降，因此需要反复尝试一个最佳的bulk size。一般从1000~5000条数据开始，尝试逐渐增加。另外，如果看大小的话，最好是在5~15MB之间。</p><h3 id="bulk-api奇特的json格式"><a href="#bulk-api奇特的json格式" class="headerlink" title="bulk api奇特的json格式"></a>bulk api奇特的json格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;action&quot;: &#123;&quot;meta&quot;&#125;&#125;\n</span><br><span class="line">&#123;&quot;data&quot;&#125;\n</span><br><span class="line">&#123;&quot;action&quot;: &#123;&quot;meta&quot;&#125;&#125;\n</span><br><span class="line">&#123;&quot;data&quot;&#125;\n</span><br></pre></td></tr></table></figure><ol><li>不用将其转换为json对象，不会出现内存中的相同数据的拷贝，直接按照换行符切割json</li><li>对每两个一组的json，读取meta，进行document路由</li><li>直接将对应的json发送到node上去</li><li>最大的优势在于，不需要将json数组解析为一个JSONArray对象，形成一份大数据的拷贝，浪费内存空间，尽可能地保证性能</li></ol><p>如果采用比较良好的json数组格式,允许任意的换行，整个可读性非常棒，读起来很爽，es拿到那种标准格式的json串以后，要按照下述流程去进行处理</p><ul><li>将json数组解析为JSONArray对象，这个时候，整个数据，就会在内存中出现一份一模一样的拷贝，一份数据是json文本，一份数据是JSONArray对象</li><li>解析json数组里的每个json，对每个请求中的document进行路由</li><li>为路由到同一个shard上的多个请求，创建一个请求数组</li><li>将这个请求数组序列化</li><li>将序列化后的请求数组发送到对应的节点上去</li></ul><p>耗费更多内存，更多的jvm gc开销，我们之前提到过bulk size最佳大小的那个问题，一般建议说在几千条那样，然后大小在10MB左右，所以说，可怕的事情来了。假设说现在100个bulk请求发送到了一个节点上去，然后每个请求是10MB，100个请求，就是1000MB = 1GB，然后每个请求的json都copy一份为jsonarray对象，此时内存中的占用就会翻倍，就会占用2GB的内存，甚至还不止。因为弄成jsonarray之后，还可能会多搞一些其他的数据结构，2GB+的内存占用。占用更多的内存可能就会积压其他请求的内存使用量，比如说最重要的搜索请求，分析请求，等等，此时就可能会导致其他请求的性能急速下降。占用内存更多，就会导致java虚拟机的垃圾回收次数更多，跟频繁，每次要回收的垃圾对象更多，耗费的时间更多，导致es的java虚拟机停止工作线程的时间更多</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="全量替换"><a href="#全量替换" class="headerlink" title="全量替换"></a>全量替换</h3><ol><li>语法与创建文档是一样的，如果document id不存在，那么就是创建；如果document id已经存在，那么就是全量替换操作，替换document的json串内容，更新_version的值</li></ol><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210514195424111.png" alt="image-20210514195424111"></p><ol start="2"><li>document是不可变的，如果要修改document的内容，第一种方式就是全量替换，直接对document重新建立索引，替换里面所有的内容</li><li>es会将老的document标记为deleted，然后新增我们给定的一个document，当我们创建越来越多的document的时候，es会在适当的时机在后台自动删除标记为deleted的document</li></ol><h3 id="局部更新"><a href="#局部更新" class="headerlink" title="局部更新"></a>局部更新</h3><p>PUT /index/type/id，创建文档&amp;替换文档，就是一样的语法</p><ol><li>应用程序先发起一个get请求，获取到document，展示到前台界面，供用户查看和修改</li><li>用户在前台界面修改数据，发送到后台</li><li>后台代码，会将用户修改的数据在内存中进行执行，然后封装好修改后的全量数据</li><li>然后发送PUT请求，到es中，进行全量替换</li><li>es将老的document标记为deleted，然后重新创建一个新的document</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">post &#x2F;index&#x2F;type&#x2F;id&#x2F;_update </span><br><span class="line">&#123;</span><br><span class="line">   &quot;doc&quot;: &#123;</span><br><span class="line">      &quot;要修改的少数几个field即可，不需要全量的数据&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210517194617604.png" alt="image-20210517194617604"></p><h4 id="实战partial-update"><a href="#实战partial-update" class="headerlink" title="实战partial update"></a>实战partial update</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;test_index&#x2F;test_type&#x2F;10</span><br><span class="line">&#123;</span><br><span class="line">  &quot;test_field1&quot;: &quot;test1&quot;,</span><br><span class="line">  &quot;test_field2&quot;: &quot;test2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST &#x2F;test_index&#x2F;test_type&#x2F;10&#x2F;_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;test_field2&quot;: &quot;updated test2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="groovy实现partial-update"><a href="#groovy实现partial-update" class="headerlink" title="groovy实现partial update"></a>groovy实现partial update</h4><p>es，其实是有个内置的脚本支持的，可以基于groovy脚本实现各种各样的复杂操作</p><p><strong>准备数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;test_index&#x2F;test_type&#x2F;11</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 0,</span><br><span class="line">  &quot;tags&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>更新数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update</span><br><span class="line">&#123;</span><br><span class="line">   &quot;script&quot; : &quot;ctx._source.num+&#x3D;1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>外部脚本</strong></p><p>vim elasticsearch-5.2.0\config\scripts\test-add-tags.groovy<br><code>ctx._source.tags+=new_tag</code> 为tags字段添加tag1,test-add-tags.groovy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;lang&quot;: &quot;groovy&quot;, </span><br><span class="line">    &quot;file&quot;: &quot;test-add-tags&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">      &quot;new_tag&quot;: &quot;tag1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ctx.op = ctx._source.num == count ? &#39;delete&#39; : &#39;none&#39;</code> 删除文档test-delete-document.groovy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;lang&quot;: &quot;groovy&quot;,</span><br><span class="line">    &quot;file&quot;: &quot;test-delete-document&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">      &quot;count&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>upsert操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;num&quot;: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始_update会直接报错404.</p><p>如果指定的document不存在，就执行upsert中的初始化操作；如果指定的document存在，就执行doc或者script指定的partial update操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;test_index&#x2F;test_type&#x2F;11&#x2F;_update</span><br><span class="line">&#123;</span><br><span class="line">   &quot;script&quot; : &quot;ctx._source.num+&#x3D;1&quot;,</span><br><span class="line">   &quot;upsert&quot;: &#123;</span><br><span class="line">       &quot;num&quot;: 0,</span><br><span class="line">       &quot;tags&quot;: []</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强制创建"><a href="#强制创建" class="headerlink" title="强制创建"></a>强制创建</h3><p><code>PUT /index/type/id?op_type=create，PUT /index/type/id/_create</code></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>DELETE /index/type/id</code></p><p>不会理解物理删除，只会将其标记为deleted，当数据越来越多的时候，在后台自动删除</p><h2 id="并发冲突"><a href="#并发冲突" class="headerlink" title="并发冲突"></a>并发冲突</h2><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210514195747886.png" alt="image-20210514195747886"></p><h3 id="悲观锁与乐观锁方案"><a href="#悲观锁与乐观锁方案" class="headerlink" title="悲观锁与乐观锁方案"></a>悲观锁与乐观锁方案</h3><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210514201338263.png" alt="image-20210514201338263"></p><p>第一次创建一个document的时候，它的_version内部版本号就是1；以后，每次对这个document执行修改或者删除操作，都会对这个_version版本号自动加1；哪怕是删除，也会对这条数据的版本号加1。</p><p>在删除一个document之后，可以从一个侧面证明，它不是立即物理删除掉的，因为它的一些版本号等信息还是保留着的。先删除一条document，再重新创建这条document，其实会在delete version基础之上，再把version号加1</p><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210514202012003.png" alt="image-20210514202012003"></p><h3 id="version乐观锁实战"><a href="#version乐观锁实战" class="headerlink" title="_version乐观锁实战"></a>_version乐观锁实战</h3><ol><li>构造一条数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;test_index&#x2F;test_type&#x2F;7</span><br><span class="line">&#123;</span><br><span class="line">  &quot;test_field&quot;: &quot;test test&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>模拟两个客户端，都获取到了同一条数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET test_index&#x2F;test_type&#x2F;7</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;test_index&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;test_type&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;7&quot;,</span><br><span class="line">  &quot;_version&quot;: 1,</span><br><span class="line">  &quot;found&quot;: true,</span><br><span class="line">  &quot;_source&quot;: &#123;</span><br><span class="line">    &quot;test_field&quot;: &quot;test test&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>其中一个客户端，先更新了一下这个数据，同时带上数据的版本号，确保说，es中的数据的版本号，跟客户端中的数据的版本号是相同的，才能修改<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;test_index&#x2F;test_type&#x2F;7?version&#x3D;1 </span><br><span class="line">&#123;</span><br><span class="line">  &quot;test_field&quot;: &quot;test client 1&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;test_index&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;test_type&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;7&quot;,</span><br><span class="line">  &quot;_version&quot;: 2,</span><br><span class="line">  &quot;result&quot;: &quot;updated&quot;,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 2,</span><br><span class="line">    &quot;successful&quot;: 1,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;created&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>另外一个客户端，尝试基于version=1的数据去进行修改，同样带上version版本号，进行乐观锁的并发控制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;test_index&#x2F;test_type&#x2F;7?version&#x3D;1 </span><br><span class="line">&#123;</span><br><span class="line">  &quot;test_field&quot;: &quot;test client 2&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &#123;</span><br><span class="line">    &quot;root_cause&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,</span><br><span class="line">        &quot;reason&quot;: &quot;[test_type][7]: version conflict, current version [2] is different than the one provided [1]&quot;,</span><br><span class="line">        &quot;index_uuid&quot;: &quot;6m0G7yx7R1KECWWGnfH1sw&quot;,</span><br><span class="line">        &quot;shard&quot;: &quot;3&quot;,</span><br><span class="line">        &quot;index&quot;: &quot;test_index&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,</span><br><span class="line">    &quot;reason&quot;: &quot;[test_type][7]: version conflict, current version [2] is different than the one provided [1]&quot;,</span><br><span class="line">    &quot;index_uuid&quot;: &quot;6m0G7yx7R1KECWWGnfH1sw&quot;,</span><br><span class="line">    &quot;shard&quot;: &quot;3&quot;,</span><br><span class="line">    &quot;index&quot;: &quot;test_index&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot;: 409</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在乐观锁成功阻止并发问题之后，尝试正确的完成更新</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;test_index&#x2F;test_type&#x2F;7</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;test_index&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;test_type&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;7&quot;,</span><br><span class="line">  &quot;_version&quot;: 2,</span><br><span class="line">  &quot;found&quot;: true,</span><br><span class="line">  &quot;_source&quot;: &#123;</span><br><span class="line">    &quot;test_field&quot;: &quot;test client 1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>基于最新的数据和版本号，去进行修改，修改后，带上最新的版本号，可能这个步骤会需要反复执行好几次，才能成功，特别是在多线程并发更新同一条数据很频繁的情况下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;test_index&#x2F;test_type&#x2F;7?version&#x3D;2 </span><br><span class="line">&#123;</span><br><span class="line">  &quot;test_field&quot;: &quot;test client 2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="external-version乐观锁实战"><a href="#external-version乐观锁实战" class="headerlink" title="external version乐观锁实战"></a>external version乐观锁实战</h3><p>es提供了一个feature，就是说，你可以不用它提供的内部_version版本号来进行并发控制，可以基于你自己维护的一个版本号来进行并发控制。比如，加入你的数据在mysql里也有一份，然后你的应用系统本身就维护了一个版本号，无论是什么自己生成的，程序控制的。这个时候，你进行乐观锁并发控制的时候，可能并不是想要用es内部的_version来进行控制，而是用你自己维护的那个version来进行控制。</p><blockquote><p>_version=1，?version=1，才能更新成功<br>_version=1，?version&gt;1&amp;version_type=external，才能成功，比如说?version=2&amp;version_type=external</p><p>version_type=external，唯一的区别在于，_version，只有当你提供的version与es中的_version一模一样的时候，才可以进行修改，只要不一样，就报错；当version_type=external的时候，只有当你提供的version比es中的_version大的时候，才能完成修改。</p></blockquote><ol><li>先构造一条数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;test_index&#x2F;test_type&#x2F;8</span><br><span class="line">&#123;</span><br><span class="line">  &quot;test_field&quot;: &quot;test&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;test_index&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;test_type&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;8&quot;,</span><br><span class="line">  &quot;_version&quot;: 1,</span><br><span class="line">  &quot;result&quot;: &quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 2,</span><br><span class="line">    &quot;successful&quot;: 1,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;created&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>模拟两个客户端同时查询到这条数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;test_index&#x2F;test_type&#x2F;8</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;test_index&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;test_type&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;8&quot;,</span><br><span class="line">  &quot;_version&quot;: 1,</span><br><span class="line">  &quot;found&quot;: true,</span><br><span class="line">  &quot;_source&quot;: &#123;</span><br><span class="line">    &quot;test_field&quot;: &quot;test&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>第一个客户端先进行修改，此时客户端程序是在自己的数据库中获取到了这条数据的最新版本号，比如说是2</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;test_index&#x2F;test_type&#x2F;8?version&#x3D;2&amp;version_type&#x3D;external</span><br><span class="line">&#123;</span><br><span class="line">  &quot;test_field&quot;: &quot;test client 1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;test_index&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;test_type&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;8&quot;,</span><br><span class="line">  &quot;_version&quot;: 2,</span><br><span class="line">  &quot;result&quot;: &quot;updated&quot;,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 2,</span><br><span class="line">    &quot;successful&quot;: 1,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;created&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>模拟第二个客户端，同时拿到了自己数据库中维护的那个版本号，也是2，同时基于version=2发起了修改</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;test_index&#x2F;test_type&#x2F;8?version&#x3D;2&amp;version_type&#x3D;external</span><br><span class="line">&#123;</span><br><span class="line">  &quot;test_field&quot;: &quot;test client 2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &#123;</span><br><span class="line">    &quot;root_cause&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,</span><br><span class="line">        &quot;reason&quot;: &quot;[test_type][8]: version conflict, current version [2] is higher or equal to the one provided [2]&quot;,</span><br><span class="line">        &quot;index_uuid&quot;: &quot;6m0G7yx7R1KECWWGnfH1sw&quot;,</span><br><span class="line">        &quot;shard&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;index&quot;: &quot;test_index&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,</span><br><span class="line">    &quot;reason&quot;: &quot;[test_type][8]: version conflict, current version [2] is higher or equal to the one provided [2]&quot;,</span><br><span class="line">    &quot;index_uuid&quot;: &quot;6m0G7yx7R1KECWWGnfH1sw&quot;,</span><br><span class="line">    &quot;shard&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;index&quot;: &quot;test_index&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot;: 409</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>在并发控制成功后，重新基于最新的版本号发起更新<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;test_index&#x2F;test_type&#x2F;8</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;test_index&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;test_type&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;8&quot;,</span><br><span class="line">  &quot;_version&quot;: 2,</span><br><span class="line">  &quot;found&quot;: true,</span><br><span class="line">  &quot;_source&quot;: &#123;</span><br><span class="line">    &quot;test_field&quot;: &quot;test client 1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT &#x2F;test_index&#x2F;test_type&#x2F;8?version&#x3D;3&amp;version_type&#x3D;external</span><br><span class="line">&#123;</span><br><span class="line">  &quot;test_field&quot;: &quot;test client 2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;test_index&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;test_type&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;8&quot;,</span><br><span class="line">  &quot;_version&quot;: 3,</span><br><span class="line">  &quot;result&quot;: &quot;updated&quot;,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 2,</span><br><span class="line">    &quot;successful&quot;: 1,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;created&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="partial-update内置乐观锁并发控制"><a href="#partial-update内置乐观锁并发控制" class="headerlink" title="partial update内置乐观锁并发控制"></a>partial update内置乐观锁并发控制</h3><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210525150841434.png" alt="image-20210525150841434"></p><p><code>post /index/type/id/_update?retry_on_conflict=5&amp;version=6</code></p><h2 id="document原理"><a href="#document原理" class="headerlink" title="document原理"></a>document原理</h2><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210525153053021.png" alt="image-20210525153053021"></p><p>document路由到shard上的路由算法：<code>shard = hash(routing) % number_of_primary_shards</code></p><p>举个例子，一个index有3个primary shard，P0，P1，P2，每次增删改查一个document的时候，都会带过来一个routing number，默认就是这个document的_id（可能是手动指定，也可能是自动生成）,routing = _id，假设_id=1,会将这个routing值，传入一个hash函数中，产出一个routing值的hash值，hash(routing) = 21，然后将hash函数产出的值对这个index的primary shard的数量求余数，21 % 3 = 0，就决定了，这个document就放在P0上。</p><p>决定一个document在哪个shard上，最重要的一个值就是routing值，默认是_id，也可以手动指定，相同的routing值，每次过来，从hash函数中，产出的hash值一定是相同的。无论hash值是几，无论是什么数字，对number_of_primary_shards求余数，结果一定是在0~number_of_primary_shards-1之间这个范围内的。0,1,2。</p><p>默认的routing就是_id，也可以在发送请求的时候，手动指定一个routing value，比如说put /index/type/id?routing=user_id。手动指定routing value是很有用的，可以保证说，某一类document一定被路由到一个shard上去，那么在后续进行应用级别的负载均衡，以及提升批量读取的性能。</p><h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><ul><li>客户端选择一个node发送请求过去，这个node就是coordinating node（协调节点）</li><li>coordinating node，对document进行路由，将请求转发给对应的node（有primary shard）</li><li>实际的node上的primary shard处理请求，然后将数据同步到replica node</li><li>coordinating node，如果发现primary node和所有replica node都搞定之后，就返回响应结果给客户端</li></ul><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210525154434211.png" alt="image-20210525154434211"></p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ol><li>客户端发送请求到任意一个node，成为coordinate node</li><li>coordinate node对document进行路由，将请求转发到对应的node，此时会使用round-robin随机轮询算法，在primary shard以及其所有replica中随机选择一个，让读请求负载均衡</li><li>接收请求的node返回document给coordinate node</li><li>coordinate node返回document给客户端</li><li>特殊情况：document如果还在建立索引过程中，可能只有primary shard有，任何一个replica shard都没有，此时可能会导致无法读取到document，但是document完成索引建立之后，primary shard和replica shard就都有了</li></ol><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210525165721839.png" alt="image-20210525165721839"></p><h2 id="quorum"><a href="#quorum" class="headerlink" title="quorum"></a>quorum</h2><p>我们在发送任何一个增删改操作的时候，比如说put /index/type/id，都可以带上一个consistency参数，指明我们想要的写一致性<br>put /index/type/id?consistency=quorum</p><p>one：要求我们这个写操作，只要有一个primary shard是active活跃可用的，就可以执行<br>all：要求我们这个写操作，必须所有的primary shard和replica shard都是活跃的，才可以执行这个写操作<br>quorum：默认的值，要求所有的shard中，必须是大部分的shard都是活跃的，可用的，才可以执行这个写操作</p><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210525164457823.png" alt="image-20210525164457823"></p><p>quorum机制，写之前必须确保大多数shard都可用，int( (primary + number_of_replicas) / 2 ) + 1，当number_of_replicas&gt;1时才生效</p><p>quroum = int( (primary + number_of_replicas) / 2 ) + 1<br>举个例子，3个primary shard，number_of_replicas=1，总共有3 + 3 * 1 = 6个shard<br>quorum = int( (3 + 1) / 2 ) + 1 = 3<br>所以，要求6个shard中至少有3个shard是active状态的，才可以执行这个写操作</p><p>如果节点数少于quorum数量，可能导致quorum不齐全，进而导致无法执行任何写操作。3个primary shard，replica=1，要求至少3个shard是active，3个shard按照之前学习的shard&amp;replica机制，必须在不同的节点上，如果说只有2台机器的话，是不是有可能出现说，3个shard都没法分配齐全，此时就可能会出现写操作无法执行的情况。</p><p>1个primary shard，replica=3，quorum=((1 + 3) / 2) + 1 = 3，要求1个primary shard + 3个replica shard = 4个shard，其中必须有3个shard是要处于active状态的。如果这个时候只有2台机器的话，es提供了一种特殊的处理场景，就是说当number_of_replicas&gt;1时才生效，因为假如说，你就一个primary shard，replica=1，此时就2个shard，(1 + 1 / 2) + 1 = 2，要求必须有2个shard是活跃的，但是可能就1个node，此时就1个shard是活跃的，如果你不特殊处理的话，导致我们的单节点集群就无法工作</p><p>quorum不齐全时，wait，默认1分钟，timeout，100，30s，等待期间，期望活跃的shard数量可以增加，最后实在不行，就会timeout，我们其实可以在写操作的时候，加一个timeout参数，比如说put /index/type/id?timeout=30，这个就是说自己去设定quorum不齐全的时候，es的timeout时长，可以缩短，也可以增长</p><p><img src="/2021/05/13/ElasticSearch%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/image-20210525165432451.png" alt="image-20210525165432451"></p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">J</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="http://onejane.github.io/2021/05/13/ElasticSearch之分布式特性/">http://onejane.github.io/2021/05/13/ElasticSearch之分布式特性/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://onejane.github.io">J</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/elasticsearch/">elasticsearch</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://onejane.gitee.io/picture/alipay.png"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://onejane.gitee.io/picture/wx.png"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/05/14/%E8%AF%86%E8%B4%A7%E8%B7%B3%E8%BD%AC%E6%B7%98%E5%AE%9D%E6%97%B6%E6%90%BA%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/"><i class="fa fa-chevron-left"></i> <span>识货跳转淘宝时携带参数的实现</span></a></div><div class="next-post pull-right"><a href="/2021/05/10/ElasticSearch%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"><span>ElasticSearch之基础介绍</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify=!1,verify=!1,record_ip=!1,GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)});guest_info=0==guest_info.length?GUEST_INFO:guest_info,window.valine=new Valine({el:"#vcomment",notify:notify,verify:verify,recordIP:record_ip,appId:"cWLsquGr5PNi33OWXNhzerep-gzGzoHsz",appKey:"S35phfCSbm8dAG9LpOc5rjm3",placeholder:"一起来吹牛逼好吗！",avatar:"mm",guest_info:guest_info,pageSize:"10",lang:"zh-cn"})</script></div></div><footer class="footer-bg" style="background-image:url(http://onejane.gitee.io/picture/kali.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 By J</div><div class="framework-info"><span>驱动 -</span> <a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"),$("#top-container").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>