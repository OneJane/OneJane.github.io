<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="加壳与脱壳之基本原理"><meta name="keywords" content="classloader"><meta name="author" content="J"><meta name="copyright" content="J"><title>加壳与脱壳之基本原理 | J</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?a345f534c85363668f09d4d5c6a9ee81";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-111479568-4","auto"),ga("send","pageview")</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer="defer"></script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},hexoVersion:"4.1.1"}</script><meta name="generator" content="Hexo 4.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#逆向基本流程"><span class="toc-number">1.</span> <span class="toc-text">逆向基本流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类加载基本原理"><span class="toc-number">2.</span> <span class="toc-text">类加载基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM类加载器"><span class="toc-number">2.1.</span> <span class="toc-text">JVM类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android类加载器"><span class="toc-number">2.2.</span> <span class="toc-text">Android类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassLoaderTest"><span class="toc-number">2.2.1.</span> <span class="toc-text">ClassLoaderTest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LoadDex"><span class="toc-number">2.2.2.</span> <span class="toc-text">LoadDex</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#APP启动流程"><span class="toc-number">3.</span> <span class="toc-text">APP启动流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#APP运行流程"><span class="toc-number">4.</span> <span class="toc-text">APP运行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#方案一"><span class="toc-number">4.1.</span> <span class="toc-text">方案一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方案二"><span class="toc-number">4.2.</span> <span class="toc-text">方案二</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://onejane.gitee.io/picture/avatar.jpg"></div><div class="author-info__name text-center">J</div><div class="author-info__description text-center">逆向,爬虫</div><div class="follow-button"><a href="https://github.com/OneJane/" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">58</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://blog.csdn.net/welggy" target="_blank" rel="noopener">OneJane</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(http://onejane.gitee.io/picture/kali.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">J</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i> <span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a></span></div><div id="post-info"><div id="post-title">加壳与脱壳之基本原理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/">安卓逆向</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/">加壳与脱壳</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">4.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 18 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="逆向基本流程"><a href="#逆向基本流程" class="headerlink" title="逆向基本流程"></a>逆向基本流程</h1><ol><li>使用自动化检测工具检测apk是否加壳，或者借助一些反编译工具依靠经验推断是否加壳</li></ol><p>GDA3.85 或者 常见so文件</p><table><thead><tr><th>《娜迦》企业版本加固</th><th>libedog.so</th></tr></thead><tbody><tr><td>《娜迦》免费版本加固</td><td>libddog.so</td></tr><tr><td>《梆梆》企业版本加固</td><td>libDexHelper.so</td></tr><tr><td>《梆梆》免费版本加固</td><td>libsecexe.so</td></tr><tr><td>《爱加密》企业版本加固</td><td>ijiami.ajm</td></tr><tr><td>《爱加密》免费版本加固</td><td>libexec.so</td></tr><tr><td>《通付盾》加固</td><td>libegis.so</td></tr><tr><td>《360》加固</td><td>libprotectClass.so，libjiagu.so</td></tr><tr><td>《百度》加固</td><td>libbaiduprotect.so</td></tr><tr><td>《阿里》加固</td><td>libmobisec.so</td></tr><tr><td>《腾讯》加固</td><td>libtup.so</td></tr><tr><td>《盛大》加固</td><td>libapssec.so</td></tr><tr><td>《瑞星》加固</td><td>librsprotect.so</td></tr><tr><td>《网秦》加固</td><td>nqdata</td></tr><tr><td>《国信灵通》加固</td><td>libnqshield.so</td></tr><tr><td>《apkprotect》加固</td><td>apkprotect</td></tr><tr><td>《几维安全》加固</td><td>libkwscmm.so，libkwscr.so，libkwslinker.so</td></tr><tr><td>《UU安全》加固</td><td>libuusafe.jar.so，libuusafe.so，libuusafeempty.so</td></tr><tr><td>几维安全</td><td>lib/armeabi-v7a/libkwscmm.so，lib/armeabi-v7a/libkwscr.so，lib/armeabi-v7a/libkwslinker.so</td></tr><tr><td>UU安全</td><td>assets/libuusafe.jar.so，assets/libuusafe.so，lib/armeabi/libuusafeempty.so</td></tr></tbody></table><ol start="2"><li><p>如果apk加壳，则需要首先对apk进行脱壳</p></li><li><p>使用jeb，jadx，apktool等反编译工具对apk进行反编译</p><blockquote><p>如果反编译工具打不开，使用010Editor把文件魔术字修复前8个字节</p><p>64 65 78 0A 30 33 35 00 dex.035. 再使用jadx反编译</p><p>grep -ril “MainAcitvity” ./*.txt 找到对应dex前缀名</p></blockquote></li><li><p>先依据静态分析中得到的关键字字符串，关键api调用等方法快速定位需要分析的关键函数和流程</p></li><li><p>如果依据简单的字符串，关键api无法快速定位，则apk可能使用了字符串加密，反射调用等手段，此时可以结合hook，动态调试等</p></li><li><p>定位到关键函数后，再根据是java实现还是jni实现进一步分析</p></li></ol><h1 id="类加载基本原理"><a href="#类加载基本原理" class="headerlink" title="类加载基本原理"></a>类加载基本原理</h1><h2 id="JVM类加载器"><a href="#JVM类加载器" class="headerlink" title="JVM类加载器"></a>JVM类加载器</h2><ol><li><p>Bootstrap ClassLoader（引导类加载器）</p><blockquote><p>C/C++代码实现的加载器,用于加载指定的JDK的核心类库,比如java. lang、java.utI等这些系统类。Java虚拟机的启动就是通过 Bootstrap,该 Classloader在java里无法获取,负责加载/lib下的类。</p></blockquote></li><li><p>Extensions Classloader(拓展类加载器)</p><blockquote><p>Java中的实现类为 Extclassloader,提供了除了系统类之外的额外功能,可以在java里获取,负责加载/lib/ext下的类</p></blockquote></li><li><p>Application ClassLoader(应用程序类加载器)</p><blockquote><p>Java中的实现类为 AppClassLoader,是与我们接触对多的类加载器,开发人员写的代码默认就是由它来加载, ClassLoader.getSystemClassLoader返回的就是它。</p></blockquote></li></ol><p>可以自定义类加载器，只需要通过java.lang.ClassLoader来实现自己的类加载器。</p><p>加载顺序：Bootstrap ClassLoader-&gt;Extensions Classloader-&gt;Application ClassLoader</p><p><strong>双亲委派</strong></p> <img src="/2021/02/04/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/类加载器.png" alt="类加载流程" style="zoom:80%"><p>如果一个类加载器收到了类加载请求,它并不会自己先去加载,而是把这个请求委托给父类的加载器去执行,如果父类加载器还存在其父类加载器,则进一步向上委托,依次递归,请求最终将到达顶层的启动类加载器,如果父类加载器可以完成类加载任务,就成功返回,倘若父类加载器无法完成此加载任务,子加载器才会尝试自己去加载。</p><p>1)避免重复加载,如果已经加载过一次class,可以直接读取已经加载的class</p><p>2)更加安全,无法自定义类来替代系统的类,可以防止核心API库被随意篡改</p><h2 id="Android类加载器"><a href="#Android类加载器" class="headerlink" title="Android类加载器"></a>Android类加载器</h2><p><strong>加载时机</strong>：</p><ul><li>隐式加载：创建类的实例，访问类的静态变量，或者为静态变量赋值，调用类的静态方法，使用反射方式来强制创建某个类或接口对应的java.lang.Class对象，初始化某个类的子类</li><li>显式加载：使用LoadClass()加载，使用forName()加载</li></ul><p><strong>加载过程</strong>：</p> <img src="/2021/02/04/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/类加载过程.png" alt="类加载过程" style="zoom:50%"><ol><li>装载：查找和导入Class文件</li><li>链接：其中解析步骤是可以选择的<br>（a）检查：检查载入的class文件数据的正确性<br>（b）准备：给类的静态变量分配存储空间<br>（c）解析：将符号引用转成直接引用</li><li>初始化：即调用&lt;clinit&gt;函数，对静态变量，静态代码块执行初始化工作</li></ol><p><strong>ClassLoader继承关系</strong></p> <img src="/2021/02/04/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/classloader继承关系.png" alt="classloader继承关系" style="zoom:67%"><p><strong>ClassLoader</strong>:抽象类；<br><strong>BootClassLoader</strong>:预加载常用类，单例模式。与Java中的BootClassLoader不同，它并不是由C/C++代码实现，而是由Java实现的；<br><strong>BaseDexClassLoader</strong>是PathClassLoader、DexClassLoader、InMemoryDexClassLoader的父类，类加载的主要逻辑都是在BaseDexClassLoader完成的。<br><strong>SecureClassLoader</strong>继承了抽象类ClassLoader，拓展了ClassLoader类加入了权限方面的功能，加强了安全性，其子类URLClassLoader是用URL路径从jar文件中加载类和资源。<br>其中重点关注的是<strong>PathClassLoader</strong>和<strong>DexClassLoader</strong>。<br><strong>PathClassLoader是Android默认使用的类加载器，一个apk中的Activity等类便是在其中加载。</strong><br><strong>DexClassLoader可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更灵活，是实现插件化、热修复以及dex加壳的重点。</strong></p><blockquote><p>DexClassLoader方法参数</p><p>dexPath:目标所在的apk或者jar文件的路径，装载器将从路径中寻找指定的目标类。<br>dexOutputDir:由于dex 文件在APK或者 jar文件中，所以在装载前面前先要从里面解压出dex文件，这个路径就是dex文件存放的路径，在 android系统中，一个应用程序对应一个linux用户id ,应用程序只对自己的数据目录有写的权限，所以我们存放在这个路径中。<br>libPath :目标类中使用的C/C++库。<br>parent：该装载器的父装载器，一般为当前执行类的装载器。</p></blockquote><p>Android8.0新引入InMemoryDexClassLoader，用于直接从内存中加载dex。</p><p><a href="http://androidxref.com/8.0.0_r4/" target="_blank" rel="noopener">http://androidxref.com/8.0.0_r4/</a> 搜索位于libcore中的Definition的DexClassLoader 、PathClassLoader、 InmemoryDexClassLoader查看源码。</p><h3 id="ClassLoaderTest"><a href="#ClassLoaderTest" class="headerlink" title="ClassLoaderTest"></a>ClassLoaderTest</h3><p>新建项目ClassLoaderTest验证类加载器的加载顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        testClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  I/kanxue: thisClassLoader:dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/base.apk"],nativeLibraryDirectories=[/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/lib/x86, /system/lib, /system/product/lib]]]</span></span><br><span class="line"><span class="comment">     *  I/kanxue: this:dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/base.apk"],nativeLibraryDirectories=[/data/app/com.onejane.classloadertest-8BzVJE0RmCd4VMY0V2ZBAQ==/lib/x86, /system/lib, /system/product/lib]]]===java.lang.BootClassLoader@232d58a</span></span><br><span class="line"><span class="comment">     *  I/kanxue: root:java.lang.BootClassLoader@232d58a</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassLoader thisClassLoader=MainActivity<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        Log.i(<span class="string">"kanxue"</span>,<span class="string">"thisClassLoader:"</span>+thisClassLoader);</span><br><span class="line">        ClassLoader tmpClassLoader = <span class="keyword">null</span>;</span><br><span class="line">        ClassLoader parentClassLoader=thisClassLoader.getParent();</span><br><span class="line">        <span class="keyword">while</span> (parentClassLoader!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Log.i(<span class="string">"kanxue"</span>,<span class="string">"this:"</span>+thisClassLoader+<span class="string">"==="</span>+parentClassLoader);</span><br><span class="line">            tmpClassLoader=parentClassLoader.getParent();</span><br><span class="line">            thisClassLoader=parentClassLoader;</span><br><span class="line">            parentClassLoader=tmpClassLoader;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(<span class="string">"kanxue"</span>,<span class="string">"root:"</span>+thisClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LoadDex"><a href="#LoadDex" class="headerlink" title="LoadDex"></a>LoadDex</h3><p>通过DexClassLoader实现一个<strong>动态加载</strong>的dex插件</p><p>在ClassLoaderTest项目中打印log</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDexClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.i(<span class="string">"kanxue"</span>,<span class="string">"I'm from com.onejane.classloadertest.TestDexClass.testFunc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过build生成ClassLoaderTest\app\build\outputs\apk\debug\app-debug.apk, <code>apktool d -s app-debug.apk</code>保留并抽取出classes.dex</p><p>adb push classes.dex /sdcard</p><p>创建LoadDex空白Android项目，加载调用位于dex下com.onejane.classloadertest.TestDexClass</p><p>在AndroidManifest.xml中添加读写权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新增application配置android:requestLegacyExternalStorage=”true”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Context context = <span class="keyword">this</span>.getApplicationContext();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Android 10 sdk30 无法获取sdcard权限，通过获取当前app的cache目录</span></span><br><span class="line"><span class="comment">         * if(!getExternalCacheDir().exists()) getExternalCacheDir().mkdirs();</span></span><br><span class="line"><span class="comment">         * testDexClassLoader(context,getExternalCacheDir().getAbsolutePath()+"/classes.dex");</span></span><br><span class="line"><span class="comment">         * 再将TestDexClass所在的adb push classes.dex /sdcard/Android/data/com.onejane.loaddex/cache/</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 若sdk30需要sdcard，通过requestMyPermissions动态获取读写权限</span></span><br><span class="line">        testDexClassLoader(context,<span class="string">"/sdcard/classes.dex"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestMyPermissions</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>,</span><br><span class="line">                Manifest.permission.WRITE_EXTERNAL_STORAGE)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            <span class="comment">//没有授权，编写申请权限代码</span></span><br><span class="line">            ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, <span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.d(<span class="string">"kanxue"</span>, <span class="string">"requestMyPermissions: 有写SD权限"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>,</span><br><span class="line">                Manifest.permission.READ_EXTERNAL_STORAGE)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            <span class="comment">//没有授权，编写申请权限代码</span></span><br><span class="line">            ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, <span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.d(<span class="string">"kanxue"</span>, <span class="string">"requestMyPermissions: 有读SD权限"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可应对app热更新bug修复</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDexClassLoader</span><span class="params">(Context context, String dexfilepath)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 存放dex文件</span></span><br><span class="line">        File optFile = context.getDir(<span class="string">"opt_dex"</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 存放依赖的so文件</span></span><br><span class="line">        File libFile = context.getDir(<span class="string">"lib_path"</span>,<span class="number">0</span>);</span><br><span class="line">        ClassLoader parentClassLoader=MainActivity<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        Log.i(<span class="string">"kanxue"</span>,parentClassLoader.toString()); <span class="comment">//PathClassLoader</span></span><br><span class="line">        ClassLoader tmpClassLoader=context.getClassLoader();</span><br><span class="line">        Log.i(<span class="string">"kanxue"</span>,tmpClassLoader.toString()); <span class="comment">// PathClassLoader</span></span><br><span class="line">        requestMyPermissions();</span><br><span class="line">        DexClassLoader dexClassLoader = <span class="keyword">new</span> DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        Class&lt;?&gt; clazz=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            clazz=dexClassLoader.loadClass(<span class="string">"com.onejane.classloadertest.TestDexClass"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(clazz!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method testFuncMethod=clazz.getDeclaredMethod(<span class="string">"testFunc"</span>);</span><br><span class="line">                Object obj = clazz.newInstance();</span><br><span class="line">                testFuncMethod.invoke(obj);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用外部dex下发热修复bug，用户无感知更新。</p><h1 id="APP启动流程"><a href="#APP启动流程" class="headerlink" title="APP启动流程"></a>APP启动流程</h1><p>由发起进程通过binder进程间通信告知system_server进程启动指定的app，system_server通过socket方式与安卓孵化器进程进行通信，告诉孵化器进程启动指定app，由进程fork产生新的进程真正进入ActivityThread.main()，在此之前一直处于安卓的framework中。</p><p><img src="/2021/02/04/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="APP启动流程"></p><p>ActivityThread是单例模式，在app整个进程的生命周期中，只存在一个实例，<a href="http://androidxref.com/8.0.0_r4/" target="_blank" rel="noopener">http://androidxref.com/8.0.0_r4/</a> 搜索位于frameworks中的ActivityThread</p><p>调用静态函数currentActivityThread获取当前进程中的ActivityThread实例，进而可以获取ActivityThread的重要变量,如mPackages</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static ActivityThread currentActivityThread() &#123;</span><br><span class="line">    return sCurrentActivityThread;</span><br><span class="line">&#125;</span><br><span class="line">final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages &#x3D; new ArrayMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>其中LoadedApk中有加载app组件的PathClassLoader,即mClassLoader</strong></p><ol><li><p>通过反射获取app进程中单例<strong>ActivityThread</strong>，其中的<strong>sCurrentActivityThread静态变量</strong>用于全局保存创建的ActivityThread实例，同时还提供了<strong>currentActivityThread()静态函数</strong>用于获取当前虚拟机创建的ActivityThread实例。</p></li><li><p>反射拿到ActivityThread中的 <strong>mPackages</strong>的ArrayMap，通过当前app包名<strong>获取LoadedApk</strong>。</p></li><li><p>最后通过LoadedApk获取<strong>mClassLoader-&gt;PathClassLoader</strong>。</p></li></ol><blockquote><p>PathClassLoader: app运行过程中用于加载四大组件类的ClassLoader</p></blockquote><p>**ActivityThread.main()**函数是java中的入口main函数,这里会启动主消息循环，并创建ActivityThread实例，之后调用thread.attach(false)完成一系列初始化准备工作，并完成全局静态变量sCurrentActivityThread的初始化。之后主线程进入消息循环，等待接收来自系统的消息。当收到系统发送来的bindapplication的进程间调用时，调用函数handleBindApplication来处理该请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    &#x2F;&#x2F;step 1: 创建LoadedApk对象</span><br><span class="line">    data.info &#x3D; getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;step 2: 创建ContextImpl对象;</span><br><span class="line">    final ContextImpl appContext &#x3D; ContextImpl.createAppContext(this, data.info);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;step 3: 创建Instrumentation</span><br><span class="line">    mInstrumentation &#x3D; new Instrumentation();</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;step 4: 创建Application对象;在makeApplication函数中调用了newApplication，真正执行app代码。在该函数中又调用了app.attach(context)，在attach函数中调用了Application.attachBaseContext函数</span><br><span class="line">    Application app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">    mInitialApplication &#x3D; app;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;step 5: 安装providers</span><br><span class="line">    List&lt;ProviderInfo&gt; providers &#x3D; data.providers;</span><br><span class="line">    installContentProviders(app, providers);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;step 6: 执行Application.Create回调</span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>handleBindApplication</strong>函数中第一次进入了app的代码世界，该函数功能是<strong>启动一个application</strong>，并把系统收集的apk组件等相关信息绑定到application里，在创建完application对象后，接着<strong>调用了application的attachBaseContext</strong>方法，之后<strong>调用了application的onCreate</strong>函数。由此可以发现，app的Application类中的<strong>attachBaseContext</strong>和<strong>onCreate</strong>这两个函数是最先获取执行权进行代码执行的。这也是为什么各家的加固工具的主要逻辑都是通过替换app入口Application，并自实现这两个函数，在这两个函数中进行加密dex释放以及执行权交付的原因。</p><h1 id="APP运行流程"><a href="#APP运行流程" class="headerlink" title="APP运行流程"></a>APP运行流程</h1><img src="/2021/02/04/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/app运行流程.png" alt="app运行流程" style="zoom:67%"><p>无壳：PathClassLoader加载自身app自身dex，包括app声明的Application及所有其他类信息</p><p>加壳：PathClassLoader只加载壳自身代码，不包含app自身真正代码。首先进入壳的application的attachBaseContext，解密原始dex，再完成执行权的交付。</p><p><img src="/2021/02/04/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E5%8A%A0%E5%A3%B3app%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="加壳app启动流程"></p><p><strong>DexClassLoader加载的类是没有组件生命周期的</strong>，也就是说即使DexClassLoader通过对APK的动态加载完成了对组件类的加载，当系统启动该组件时，依然会出现加载类失败的异常，因为插件没有组件相关的类，如一些activity或service，若只用DexClassLoader进行动态加载，系统PathClassLoader无法找到相关组件信息，app将直接崩溃。所以如何解决动态加载dex中的生命周期成为加壳厂商首先需要解决的问题！！！</p><p>在项目<strong>ClassLoaderTest</strong>中新建TestActivity ，并将build的apk中的classes.dex取出，adb push classes.dex /sdcard</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TestActivity extends AppCompatActivity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        &#x2F;&#x2F; adb push classes.dex &#x2F;sdcard</span><br><span class="line">        Log.i(&quot;kanxue&quot;,&quot;I&#39;m from TestActivity.onCreate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目<strong>LoadDex</strong>中，配置AndroidManifest.xml<code>&lt;activity android:name=&quot;com.onejane.classloadertest.TestActivity&quot;&gt;&lt;/activity&gt;</code>,在MainActivity中新增方法，并启动运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    Context context &#x3D; this.getApplicationContext();</span><br><span class="line">    startTestActivity(context,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void startTestActivity(Context context,String dexfilepath)&#123;</span><br><span class="line">    &#x2F;&#x2F; 存放dex文件</span><br><span class="line">    File optFile &#x3D; context.getDir(&quot;opt_dex&quot;,0);</span><br><span class="line">    &#x2F;&#x2F; 存放依赖的so文件</span><br><span class="line">    File libFile &#x3D; context.getDir(&quot;lib_path&quot;,0);</span><br><span class="line">    ClassLoader parentClassLoader&#x3D;MainActivity.class.getClassLoader();</span><br><span class="line">    Log.i(&quot;kanxue&quot;,parentClassLoader.toString()); &#x2F;&#x2F;PathClassLoader</span><br><span class="line">    ClassLoader tmpClassLoader&#x3D;context.getClassLoader();</span><br><span class="line">    Log.i(&quot;kanxue&quot;,tmpClassLoader.toString()); &#x2F;&#x2F; PathClassLoader</span><br><span class="line">    requestMyPermissions();</span><br><span class="line">    DexClassLoader dexClassLoader &#x3D; new DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity.class.getClassLoader());</span><br><span class="line">    Class&lt;?&gt; clazz&#x3D;null;</span><br><span class="line">    try&#123;</span><br><span class="line">        clazz&#x3D;dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;);</span><br><span class="line">    &#125;catch (ClassNotFoundException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    if(clazz!&#x3D;null)&#123;</span><br><span class="line">        context.startActivity(new Intent(context,clazz));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动app将报错ClassNotFoundException: Didn’t find class “com.onejane.classloadertest.TestActivity”</p><p>说明组件相关的Activity由mClassLoader-&gt;PathClassLoader加载了，<strong>虽然获取到非空TestActivity，却无法找到启动的目标Activity</strong>。</p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>反射替换，替换系统组件类加载器mClassLoader为我们的DexClassLoader，同时设置DexClassLoader的parent为系统组件类加载器PathClassLoader；</p> <img src="/2021/02/04/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/反射替换.png" alt="反射替换" style="zoom:67%"><p>修改LoadDex项目的MainActivity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Context context &#x3D; this.getApplicationContext();</span><br><span class="line">        startTestActivityReplaceMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void requestMyPermissions() &#123;</span><br><span class="line"></span><br><span class="line">        if (ContextCompat.checkSelfPermission(this,</span><br><span class="line">                Manifest.permission.WRITE_EXTERNAL_STORAGE)</span><br><span class="line">                !&#x3D; PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            &#x2F;&#x2F;没有授权，编写申请权限代码</span><br><span class="line">            ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有写SD权限&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ContextCompat.checkSelfPermission(this,</span><br><span class="line">                Manifest.permission.READ_EXTERNAL_STORAGE)</span><br><span class="line">                !&#x3D; PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            &#x2F;&#x2F;没有授权，编写申请权限代码</span><br><span class="line">            ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有读SD权限&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void replaceClassloader(ClassLoader classloader)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class&lt;?&gt; ActivityThreadClazz&#x3D;classloader.loadClass(&quot;android.app.ActivityThread&quot;);</span><br><span class="line">            &#x2F;&#x2F; 获取静态函数currentActivityThread</span><br><span class="line">            Method currentActivityThreadMethod&#x3D; ActivityThreadClazz.getDeclaredMethod(&quot;currentActivityThread&quot;);</span><br><span class="line">            currentActivityThreadMethod.setAccessible(true);</span><br><span class="line">            Object activityThreadObj&#x3D;currentActivityThreadMethod.invoke(null); &#x2F;&#x2F; 获取ActivityThread对象</span><br><span class="line">            &#x2F;&#x2F;final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages &#x3D; new ArrayMap&lt;&gt;();  </span><br><span class="line">            Field mPackagesField&#x3D;ActivityThreadClazz.getDeclaredField(&quot;mPackages&quot;);  &#x2F;&#x2F; 获取ActivityThread对象的ArrayMap的Field</span><br><span class="line">            mPackagesField.setAccessible(true);</span><br><span class="line">            ArrayMap mPackagesObj&#x3D; (ArrayMap) mPackagesField.get(activityThreadObj); &#x2F;&#x2F; 通过Field获取mPackages实例</span><br><span class="line">            WeakReference wr&#x3D; (WeakReference) mPackagesObj.get(this.getPackageName()); &#x2F;&#x2F; 从ArrayMap中获取LoadApk</span><br><span class="line">            Object loadedApkObj&#x3D;wr.get();</span><br><span class="line"></span><br><span class="line">            Class LoadedApkClazz&#x3D;classloader.loadClass(&quot;android.app.LoadedApk&quot;);</span><br><span class="line">            &#x2F;&#x2F;private ClassLoader mClassLoader;</span><br><span class="line">            Field mClassLoaderField&#x3D;LoadedApkClazz.getDeclaredField(&quot;mClassLoader&quot;);</span><br><span class="line">            mClassLoaderField.setAccessible(true);</span><br><span class="line">            mClassLoaderField.set(loadedApkObj,classloader); &#x2F;&#x2F; 将LoadApk(mClassLoader)替换为我们的DexClassLoader</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void startTestActivityReplaceMethod(Context context,String dexfilepath)&#123;</span><br><span class="line">        &#x2F;&#x2F; 存放dex文件</span><br><span class="line">        File optFile &#x3D; context.getDir(&quot;opt_dex&quot;,0);</span><br><span class="line">        &#x2F;&#x2F; 存放依赖的so文件</span><br><span class="line">        File libFile &#x3D; context.getDir(&quot;lib_path&quot;,0);</span><br><span class="line">        requestMyPermissions();</span><br><span class="line">        DexClassLoader dexClassLoader &#x3D; new DexClassLoader(dexfilepath,optFile.getAbsolutePath(),libFile.getAbsolutePath(),MainActivity.class.getClassLoader());</span><br><span class="line">        replaceClassloader(dexClassLoader);</span><br><span class="line">        Class&lt;?&gt; clazz&#x3D;null;</span><br><span class="line">        try&#123;</span><br><span class="line">            clazz&#x3D;dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;);</span><br><span class="line">        &#125;catch (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if(clazz!&#x3D;null)&#123;</span><br><span class="line">            context.startActivity(new Intent(context,clazz));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>打破原有的双亲关系，在系统组件类加载器和BootClassLoader的中间插入我们自己的DexClassLoader即可</p> <img src="/2021/02/04/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/反射插入.png" alt="反射插入" style="zoom:67%"><p>修改ClassLoaderTest中的TestActivity类继承自Activity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TestActivity extends Activity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">&#x2F;&#x2F;        setContentView(R.layout.activity_main);</span><br><span class="line">        &#x2F;&#x2F; adb push classes.dex &#x2F;sdcard</span><br><span class="line">        Log.i(&quot;kanxue&quot;,&quot;I&#39;m from TestActivity.onCreate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改LoadDex中的MainActivity继承Activity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Context context &#x3D; this.getApplicationContext();</span><br><span class="line">        &#x2F;&#x2F; 若sdk30需要sdcard，通过requestMyPermissions动态获取读写权限</span><br><span class="line">&#x2F;&#x2F;        testDexClassLoader(context,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;);</span><br><span class="line">&#x2F;&#x2F;        startTestActivityReplaceMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;);</span><br><span class="line">        startTestActivityInsertMethod(this,&quot;&#x2F;sdcard&#x2F;classes.dex&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void requestMyPermissions() &#123;</span><br><span class="line"></span><br><span class="line">        if (ContextCompat.checkSelfPermission(this,</span><br><span class="line">                Manifest.permission.WRITE_EXTERNAL_STORAGE)</span><br><span class="line">                !&#x3D; PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            &#x2F;&#x2F;没有授权，编写申请权限代码</span><br><span class="line">            ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 100);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有写SD权限&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ContextCompat.checkSelfPermission(this,</span><br><span class="line">                Manifest.permission.READ_EXTERNAL_STORAGE)</span><br><span class="line">                !&#x3D; PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            &#x2F;&#x2F;没有授权，编写申请权限代码</span><br><span class="line">            ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 100);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Log.d(&quot;kanxue&quot;, &quot;requestMyPermissions: 有读SD权限&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void startTestActivityInsertMethod(Context context,String dexfilepath)&#123;</span><br><span class="line">        File optfile&#x3D;context.getDir(&quot;opt_dex&quot;,0);</span><br><span class="line">        File libfile&#x3D;context.getDir(&quot;lib_path&quot;,0);</span><br><span class="line">        requestMyPermissions();</span><br><span class="line">        ClassLoader pathClassloader&#x3D;MainActivity.class.getClassLoader();</span><br><span class="line">        ClassLoader bootClassloader&#x3D;MainActivity.class.getClassLoader().getParent();</span><br><span class="line">        &#x2F;&#x2F; 设置自定义dexClassLoader父ClassLoader为bootClassloader</span><br><span class="line">        DexClassLoader dexClassLoader&#x3D;new DexClassLoader(dexfilepath,optfile.getAbsolutePath(),libfile.getAbsolutePath(),bootClassloader);</span><br><span class="line">        try &#123;</span><br><span class="line">            Field parentField&#x3D;ClassLoader.class.getDeclaredField(&quot;parent&quot;);</span><br><span class="line">            parentField.setAccessible(true);</span><br><span class="line">            &#x2F;&#x2F; 设置pathClassLoader父ClassLoader为自定义dexClassLoader</span><br><span class="line">            parentField.set(pathClassloader,dexClassLoader);</span><br><span class="line">        &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ClassLoader tmpClassloader&#x3D;pathClassloader;</span><br><span class="line">        ClassLoader parentClassloader&#x3D;pathClassloader.getParent();</span><br><span class="line">        while(parentClassloader!&#x3D;null)&#123;</span><br><span class="line">            Log.i(&quot;kanxue&quot;,&quot;this:&quot;+tmpClassloader+&quot;--parent:&quot;+parentClassloader);</span><br><span class="line">            tmpClassloader&#x3D;parentClassloader;</span><br><span class="line">            parentClassloader&#x3D;parentClassloader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(&quot;kanxue&quot;,&quot;root:&quot;+tmpClassloader);</span><br><span class="line">        Class&lt;?&gt; clazz&#x3D;null;</span><br><span class="line">        try &#123;</span><br><span class="line">            clazz &#x3D; dexClassLoader.loadClass(&quot;com.onejane.classloadertest.TestActivity&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        context.startActivity(new Intent(context,clazz));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上都是基于文件形式的外部加载，Android 8.0引入InMemoryDexClassLoader实现从内存中直接加载字节流，更加安全，不能通过文件监控形式达到脱壳目的，需要从进程内存中扣出这块完整的dex实现脱壳。</p></blockquote><ul><li>部分app在AndroidManifest.xml中没有声明application，加固厂商只需要添加一个application，在自己的application中完成classloader的替换。</li><li>部分app在AndroidManifest.xml中已经声明application，加固需要一个代理的application，壳的application不仅需要完成解密dex以及classloader相关修复，还需要完成解密dex后原app的application的attachBaseContext和onCreate函数调用。</li></ul><hr><ul><li>逆向分析和脱壳的意义</li><li>ClassLoader和动态加载</li><li>加壳APP运行流程和ClassLoader修正</li></ul></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">J</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="http://onejane.github.io/2021/02/04/加壳与脱壳之基本原理/">http://onejane.github.io/2021/02/04/加壳与脱壳之基本原理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://onejane.github.io">J</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/classloader/">classloader</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://onejane.gitee.io/picture/alipay.png"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://onejane.gitee.io/picture/wx.png"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/02/05/%E5%8A%A8%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E4%B9%8B%E9%94%81%E6%9C%BA%E7%97%85%E6%AF%92/"><i class="fa fa-chevron-left"></i> <span>动静态分析之锁机病毒</span></a></div><div class="next-post pull-right"><a href="/2021/02/03/%E7%8C%BF%E4%BA%BA%E5%AD%A6%E4%B9%8B%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91%E7%BD%97%E7%94%9F%E9%97%A8/"><span>猿人学之访问逻辑罗生门</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify=!1,verify=!1,record_ip=!1,GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)});guest_info=0==guest_info.length?GUEST_INFO:guest_info,window.valine=new Valine({el:"#vcomment",notify:notify,verify:verify,recordIP:record_ip,appId:"cWLsquGr5PNi33OWXNhzerep-gzGzoHsz",appKey:"S35phfCSbm8dAG9LpOc5rjm3",placeholder:"一起来吹牛逼好吗！",avatar:"mm",guest_info:guest_info,pageSize:"10",lang:"zh-cn"})</script></div></div><footer class="footer-bg" style="background-image:url(http://onejane.gitee.io/picture/kali.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 By J</div><div class="framework-info"><span>驱动 -</span> <a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"),$("#top-container").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>